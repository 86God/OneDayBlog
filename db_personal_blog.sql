/*
 Navicat Premium Data Transfer

 Source Server         : MySql
 Source Server Type    : MySQL
 Source Server Version : 80017
 Source Host           : localhost:3306
 Source Schema         : db_personal_blog

 Target Server Type    : MySQL
 Target Server Version : 80017
 File Encoding         : 65001

 Date: 09/08/2020 13:07:07
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_art_type
-- ----------------------------
DROP TABLE IF EXISTS `t_art_type`;
CREATE TABLE `t_art_type`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `type_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '文章类型',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_art_type
-- ----------------------------
INSERT INTO `t_art_type` VALUES (1, 'JavaSE');
INSERT INTO `t_art_type` VALUES (2, 'JavaEE');
INSERT INTO `t_art_type` VALUES (3, 'Web前端');
INSERT INTO `t_art_type` VALUES (4, 'Spring全家桶');
INSERT INTO `t_art_type` VALUES (5, '数据库');
INSERT INTO `t_art_type` VALUES (6, 'LeetCode刷题');
INSERT INTO `t_art_type` VALUES (7, 'C语言');
INSERT INTO `t_art_type` VALUES (8, 'Git的使用');
INSERT INTO `t_art_type` VALUES (9, 'Linux笔记');
INSERT INTO `t_art_type` VALUES (10, '面试');
INSERT INTO `t_art_type` VALUES (11, '数据结构');
INSERT INTO `t_art_type` VALUES (12, '算法');
INSERT INTO `t_art_type` VALUES (13, '每日心得');
INSERT INTO `t_art_type` VALUES (14, '生活小点滴');

-- ----------------------------
-- Table structure for t_art_type_rel
-- ----------------------------
DROP TABLE IF EXISTS `t_art_type_rel`;
CREATE TABLE `t_art_type_rel`  (
  `id` int(255) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `art_id` int(11) NOT NULL COMMENT '文章ID',
  `art_type` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NOT NULL COMMENT '文章类型',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 473 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_art_type_rel
-- ----------------------------
INSERT INTO `t_art_type_rel` VALUES (115, 27, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (116, 28, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (117, 30, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (118, 31, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (119, 32, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (120, 33, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (121, 34, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (122, 35, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (123, 36, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (124, 37, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (125, 38, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (126, 39, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (127, 40, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (128, 41, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (129, 42, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (130, 43, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (131, 44, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (132, 45, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (133, 46, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (134, 47, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (135, 48, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (136, 49, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (137, 50, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (138, 51, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (139, 52, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (140, 53, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (141, 54, 'JavaSE');
INSERT INTO `t_art_type_rel` VALUES (142, 55, 'C语言笔记');
INSERT INTO `t_art_type_rel` VALUES (143, 56, 'Git的使用');
INSERT INTO `t_art_type_rel` VALUES (147, 58, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (148, 59, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (149, 60, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (151, 61, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (152, 63, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (153, 64, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (154, 65, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (155, 66, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (156, 67, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (157, 68, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (158, 69, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (159, 70, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (160, 71, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (161, 72, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (162, 73, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (163, 74, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (164, 75, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (166, 76, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (167, 77, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (168, 78, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (169, 79, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (170, 80, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (171, 81, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (172, 82, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (173, 83, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (174, 84, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (175, 85, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (176, 86, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (177, 87, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (178, 88, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (179, 89, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (180, 90, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (181, 91, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (182, 92, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (183, 93, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (184, 94, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (185, 95, 'LeetCode刷题');
INSERT INTO `t_art_type_rel` VALUES (187, 96, 'Linux笔记');
INSERT INTO `t_art_type_rel` VALUES (188, 97, 'Linux笔记');
INSERT INTO `t_art_type_rel` VALUES (189, 98, 'Linux笔记');
INSERT INTO `t_art_type_rel` VALUES (190, 99, 'Linux笔记');
INSERT INTO `t_art_type_rel` VALUES (191, 100, 'Linux笔记');
INSERT INTO `t_art_type_rel` VALUES (192, 101, 'Linux笔记');
INSERT INTO `t_art_type_rel` VALUES (194, 102, 'Linux笔记');
INSERT INTO `t_art_type_rel` VALUES (195, 103, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (196, 103, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (197, 103, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (198, 103, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (199, 103, 'Spring Boot');
INSERT INTO `t_art_type_rel` VALUES (200, 104, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (201, 104, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (202, 105, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (203, 105, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (204, 106, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (205, 106, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (206, 107, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (207, 107, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (208, 108, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (209, 108, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (210, 109, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (211, 109, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (212, 110, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (213, 110, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (214, 111, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (215, 111, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (216, 112, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (217, 112, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (218, 113, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (219, 113, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (220, 114, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (221, 114, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (222, 115, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (223, 115, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (224, 116, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (225, 116, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (226, 117, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (227, 117, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (228, 118, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (229, 118, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (230, 119, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (231, 119, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (232, 119, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (233, 119, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (234, 119, 'Spring Boot');
INSERT INTO `t_art_type_rel` VALUES (235, 120, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (236, 120, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (237, 120, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (238, 121, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (239, 121, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (240, 121, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (241, 121, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (242, 122, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (243, 122, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (244, 122, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (245, 122, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (250, 123, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (251, 123, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (252, 123, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (253, 123, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (254, 124, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (255, 124, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (256, 124, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (257, 124, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (258, 125, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (259, 125, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (260, 125, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (261, 125, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (262, 126, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (263, 126, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (264, 126, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (265, 126, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (266, 127, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (267, 127, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (268, 127, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (269, 127, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (270, 128, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (271, 128, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (272, 128, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (273, 128, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (274, 129, 'Spring全家桶');
INSERT INTO `t_art_type_rel` VALUES (275, 129, 'Spring');
INSERT INTO `t_art_type_rel` VALUES (276, 129, 'Spring MVC');
INSERT INTO `t_art_type_rel` VALUES (277, 129, 'MyBatis');
INSERT INTO `t_art_type_rel` VALUES (278, 129, 'Spring Boot');
INSERT INTO `t_art_type_rel` VALUES (279, 130, '数据结构');
INSERT INTO `t_art_type_rel` VALUES (280, 131, '数据结构');
INSERT INTO `t_art_type_rel` VALUES (281, 132, '数据结构');
INSERT INTO `t_art_type_rel` VALUES (282, 133, '数据结构');
INSERT INTO `t_art_type_rel` VALUES (283, 134, '数据结构');
INSERT INTO `t_art_type_rel` VALUES (284, 135, '数据结构');
INSERT INTO `t_art_type_rel` VALUES (285, 136, '数据结构');
INSERT INTO `t_art_type_rel` VALUES (286, 137, '算法');
INSERT INTO `t_art_type_rel` VALUES (287, 138, '数据库');
INSERT INTO `t_art_type_rel` VALUES (288, 138, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (289, 139, '数据库');
INSERT INTO `t_art_type_rel` VALUES (290, 139, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (291, 140, '数据库');
INSERT INTO `t_art_type_rel` VALUES (292, 140, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (293, 141, '数据库');
INSERT INTO `t_art_type_rel` VALUES (294, 141, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (295, 142, '数据库');
INSERT INTO `t_art_type_rel` VALUES (296, 142, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (297, 143, '数据库');
INSERT INTO `t_art_type_rel` VALUES (298, 143, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (299, 144, '数据库');
INSERT INTO `t_art_type_rel` VALUES (300, 144, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (301, 145, '数据库');
INSERT INTO `t_art_type_rel` VALUES (302, 145, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (303, 146, '数据库');
INSERT INTO `t_art_type_rel` VALUES (304, 146, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (305, 147, '数据库');
INSERT INTO `t_art_type_rel` VALUES (306, 147, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (307, 148, '数据库');
INSERT INTO `t_art_type_rel` VALUES (308, 148, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (309, 149, '数据库');
INSERT INTO `t_art_type_rel` VALUES (310, 149, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (311, 150, '数据库');
INSERT INTO `t_art_type_rel` VALUES (312, 150, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (313, 151, '数据库');
INSERT INTO `t_art_type_rel` VALUES (314, 151, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (315, 152, '数据库');
INSERT INTO `t_art_type_rel` VALUES (316, 152, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (317, 153, '数据库');
INSERT INTO `t_art_type_rel` VALUES (318, 153, 'MySql');
INSERT INTO `t_art_type_rel` VALUES (319, 154, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (320, 155, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (321, 156, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (322, 157, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (323, 158, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (324, 159, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (325, 160, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (326, 161, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (327, 162, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (328, 163, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (329, 164, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (330, 165, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (331, 166, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (332, 167, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (333, 168, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (334, 169, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (335, 170, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (336, 171, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (337, 172, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (338, 173, 'JavaEE');
INSERT INTO `t_art_type_rel` VALUES (339, 174, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (340, 174, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (341, 174, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (342, 174, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (343, 174, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (345, 176, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (346, 176, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (347, 176, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (348, 176, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (349, 176, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (350, 175, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (351, 175, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (352, 175, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (353, 175, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (354, 175, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (355, 177, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (356, 177, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (357, 177, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (358, 177, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (359, 178, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (360, 178, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (361, 178, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (362, 178, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (363, 178, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (364, 179, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (365, 179, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (366, 179, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (367, 179, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (368, 179, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (369, 180, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (370, 180, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (371, 180, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (372, 180, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (373, 180, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (374, 181, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (375, 181, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (376, 181, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (377, 181, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (378, 181, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (379, 182, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (380, 182, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (381, 182, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (382, 182, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (383, 182, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (384, 183, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (385, 183, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (386, 183, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (387, 183, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (388, 183, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (389, 184, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (390, 184, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (391, 184, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (392, 184, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (393, 184, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (394, 185, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (395, 185, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (396, 185, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (397, 185, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (398, 185, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (399, 186, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (400, 186, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (401, 186, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (402, 186, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (403, 186, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (404, 187, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (405, 187, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (406, 187, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (407, 187, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (408, 187, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (409, 188, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (410, 188, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (411, 188, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (412, 188, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (413, 188, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (414, 189, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (415, 189, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (416, 189, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (417, 189, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (418, 189, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (419, 190, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (420, 190, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (421, 190, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (422, 190, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (423, 190, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (424, 191, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (425, 191, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (426, 191, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (427, 191, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (428, 191, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (429, 192, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (430, 192, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (431, 192, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (432, 192, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (433, 192, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (434, 193, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (435, 193, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (436, 193, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (437, 193, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (438, 193, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (439, 194, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (440, 194, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (441, 194, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (442, 194, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (443, 194, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (444, 195, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (445, 195, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (446, 195, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (447, 195, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (448, 195, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (449, 196, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (450, 196, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (451, 196, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (452, 196, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (453, 196, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (454, 197, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (455, 197, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (456, 197, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (457, 197, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (458, 197, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (459, 198, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (460, 198, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (461, 198, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (462, 198, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (463, 198, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (464, 199, 'Web前端');
INSERT INTO `t_art_type_rel` VALUES (465, 199, 'jQuery');
INSERT INTO `t_art_type_rel` VALUES (466, 199, 'HTML');
INSERT INTO `t_art_type_rel` VALUES (467, 199, 'CSS');
INSERT INTO `t_art_type_rel` VALUES (468, 199, 'JavaScript');
INSERT INTO `t_art_type_rel` VALUES (469, 200, '算法');
INSERT INTO `t_art_type_rel` VALUES (471, 201, '算法');
INSERT INTO `t_art_type_rel` VALUES (472, 202, '算法');
INSERT INTO `t_art_type_rel` VALUES (473, 203, '生活小点滴');

-- ----------------------------
-- Table structure for t_article
-- ----------------------------
DROP TABLE IF EXISTS `t_article`;
CREATE TABLE `t_article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NOT NULL COMMENT '标题',
  `user_id` int(11) NOT NULL COMMENT '发帖人/作者',
  `content` text CHARACTER SET utf8 COLLATE utf8_croatian_ci NOT NULL COMMENT '内容',
  `likes` int(255) NOT NULL DEFAULT 0 COMMENT '点赞',
  `collect` int(255) NOT NULL DEFAULT 0 COMMENT '收藏',
  `release_time` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '发布时间',
  `page_view` int(255) NOT NULL DEFAULT 0 COMMENT '浏览量',
  `comment_num` int(10) NOT NULL DEFAULT 0 COMMENT '评论量',
  `perm_type` int(11) NULL DEFAULT NULL COMMENT '文章权限类型,1是公开，2是私密，0是粉丝可见',
  `text` text CHARACTER SET utf8 COLLATE utf8_croatian_ci NOT NULL COMMENT 'txt内容，无html标签',
  `editor_type` int(255) NOT NULL COMMENT '编译器类型，0是markdown，1是富文本，2是layEdit',
  `isreg` int(255) NOT NULL COMMENT '0是草稿，1是正式发布的文章',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 203 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_article
-- ----------------------------
INSERT INTO `t_article` VALUES (27, '01. Java简介', 8, '## **1、 Java发展史**\n\n![img](https://pic1.zhimg.com/v2-31769750f059ecee92f42f06e625b4b8_b.png)\n\n**发展历史：**\n\n1.1992年，Sun公司詹姆斯·高斯林开发Oak语言，用于嵌入式开发。 \n\n2.1995年，推出Applet，将Oak更名Java。 \n\n3.1996年，Java第一个开发工具JDK1.0和第一个即时JIT编译器发布。 \n\n4.1999年，Java第二代平台发布，JZME，JZSE和JZEE。 \n\n5.2005年，JavaSE6发布，更名为JavaME，JavaSE和 JavaEE。 \n\n6.2009年，Sun公司被Oracle公司收购，次年高斯林从Oracle辞职。\n\n\n\n![img](https://pic1.zhimg.com/v2-3ff44becfd2db25e8fe1621faf2adfcc_b.png)\n\n## 2、 Java应用：            \n\n- JavaME ：洗衣机，诺基亚，冰箱等嵌入式开发。            \n- JavaSE ：命令行和窗口，网络程序（聊天室）。            \n- JavaEE ：Web服务，组建模型，管理和通信API。             \n- 接口：通用的插口。\n\n\n\n## 3、Java语言特点         \n\n- ①简单性  \n- ②面向对象  \n- ③跨平台（可移植性）\n- ④健壮性   \n- ⑤安全性            \n- ⑥高性能  \n- ⑦解释执行  \n- ⑧自动垃圾回收   \n- ⑨多线程\n\n', 0, 0, '2020-08-06 21:35:14', 0, 0, 1, '1、 Java发展史\n发展历史：\n1.1992年，Sun公司詹姆斯·高斯林开发Oak语言，用于嵌入式开发。 \n2.1995年，推出Applet，将Oak更名Java。 \n3.1996年，Java第一个开发工具JDK1.0和第一个即时JIT编译器发布。 \n4.1999年，Java第二代平台发布，JZME，JZSE和JZEE。 \n5.2005年，JavaSE6发布，更名为JavaME，JavaSE和 JavaEE。 \n6.2009年，Sun公司被Oracle公司收购，次年高斯林从Oracle辞职。\n\n2、 Java应用：\nJavaME ：洗衣机，诺基亚，冰箱等嵌入式开发。            JavaSE ：命令行和窗口，网络程序（聊天室）。            JavaEE ：Web服务，组建模型，管理和通信API。             接口：通用的插口。\n3、Java语言特点\n①简单性  ②面向对象  ③跨平台（可移植性）④健壮性   ⑤安全性            ⑥高性能  ⑦解释执行  ⑧自动垃圾回收   ⑨多线程\n', 0, 1);
INSERT INTO `t_article` VALUES (28, '02. JDK简介及环境配置', 8, '\n## 1、JDK简介：\n\n- JDK：Java开发工具包         \n- JRE：Java运行环境         \n- JVM:  Java 虚拟机        \n- Java开发工具包： \n  - 编译工具（javac.exe）                                       \n  - 运行工具（java.exe）                                      \n  - 打包工具（jar.exe）                                      \n  - 文档工具（javadoc.exe）    \n\n\n\n### Java 可以跨平台的原因：\n\nJava源文件在通过编译器之(javac.exe)后被编译成相应的.Class文件（字节码文件），.Class文件再被JVM中的解释器(java.exe)编译成机器码在不同的操作系统 ( Windows、Linus、Mac )上面运行。不同操作系统上面的JVM是不同的，解释器是不同的，他们可以把.Class文件编译为当前操作系统可读的机器码，然后机器码执行去调用操作系统类库实现功能。\n\n\n\n##  2、JDK环境配置     \n\n（1）下载解压安装JDK。     \n\n（2）右击此电脑，点击属性->高级系统设置->环境变量     \n\n（3）在系统变量中新建变量，变量名：JAVA_HOME，变量值：JDK安装根目录              \n\n如：C:\\Program Files\\Java\\jdk1.8.0_181     \n\n（4）编辑Path变量，新建一条变量值JDK中的bin目录              \n\n如：C:\\Program Files\\Java\\jdk1.8.0_181\\bin   或  %JAVA_HOME%\\bin        \n\n（5） 在系统变量中新建变量，变量名：CLASSPATH，变量值：.;JDK中lib目录               \n\n其中 .  代表当前类所在目录，这块一定不能忘记了              \n\n如：.;C:\\Program Files\\Java\\jdk1.8.0_181\\lib              lib：系统内库 \n\n\n\n## 3、Java运行原理\n\n- 编写源代码(xxx.java文件）\n- 编译生成.Class文件(编译工具javac.exe)\n- 解释成机器码(解释器java.exe)\n- 机器码在操作系统上面运行\n\n\n\n## 4、测试JDK环境是否配置完整    \n\n（1）进入cmd，输入java，输入javac，输入\"java -version\"，查看是否正常    \n\n（2）先在一个d盘下创建一个文本，名叫HelloWorld，后缀名为.java。    \n\n```java\npublic class HelloWorld{                   \n	public static void main(String[] args){            \n		System.out.println(\"Hello World \");                   \n	}              \n}  \n```\n\n\n\n（3）win+R，打开cmd。    \n\n（4）先进入文件所在盘符，如D盘下输入   d:    ，回车。    \n\n（5）输入  javac HelloWorld.java    回车，其中HelloWorld指的是Java文件名，会生成一个HelloWorld.class  的字符码文件。    \n\n（6）输入 java HelloWorld   回车，  其中HelloWorld指的是类会打印出结果  Hello World  证明我们的环境已经没有问题了。\n\n![img](https://pic3.zhimg.com/v2-9c9b3eeec3f4ea7638c0d20dfa558f4e_b.png)', 0, 0, '2020-08-06 21:40:30', 0, 0, 1, '1、JDK简介：\nJDK：Java开发工具包         JRE：Java运行环境         JVM:  Java 虚拟机        Java开发工具包： \n编译工具（javac.exe）                                       运行工具（java.exe）                                      打包工具（jar.exe）                                      文档工具（javadoc.exe）    \n\nJava 可以跨平台的原因：Java源文件在通过编译器之(javac.exe)后被编译成相应的.Class文件（字节码文件），.Class文件再被JVM中的解释器(java.exe)编译成机器码在不同的操作系统 ( Windows、Linus、Mac )上面运行。不同操作系统上面的JVM是不同的，解释器是不同的，他们可以把.Class文件编译为当前操作系统可读的机器码，然后机器码执行去调用操作系统类库实现功能。\n2、JDK环境配置（1）下载解压安装JDK。     \n（2）右击此电脑，点击属性->高级系统设置->环境变量     \n（3）在系统变量中新建变量，变量名：JAVA_HOME，变量值：JDK安装根目录              \n如：C:\\Program Files\\Java\\jdk1.8.0_181     \n（4）编辑Path变量，新建一条变量值JDK中的bin目录              \n如：C:\\Program Files\\Java\\jdk1.8.0_181\\bin   或  %JAVA_HOME%\\bin        \n（5） 在系统变量中新建变量，变量名：CLASSPATH，变量值：.;JDK中lib目录               \n其中 .  代表当前类所在目录，这块一定不能忘记了              \n如：.;C:\\Program Files\\Java\\jdk1.8.0_181\\lib              lib：系统内库 \n3、Java运行原理\n编写源代码(xxx.java文件）编译生成.Class文件(编译工具javac.exe)解释成机器码(解释器java.exe)机器码在操作系统上面运行\n4、测试JDK环境是否配置完整（1）进入cmd，输入java，输入javac，输入”java -version”，查看是否正常    \n（2）先在一个d盘下创建一个文本，名叫HelloWorld，后缀名为.java。    \npublic class HelloWorld{                       public static void main(String[] args){                    System.out.println(\"Hello World \");                       }              }\n（3）win+R，打开cmd。    \n（4）先进入文件所在盘符，如D盘下输入   d:    ，回车。    \n（5）输入  javac HelloWorld.java    回车，其中HelloWorld指的是Java文件名，会生成一个HelloWorld.class  的字符码文件。    \n（6）输入 java HelloWorld   回车，  其中HelloWorld指的是类会打印出结果  Hello World  证明我们的环境已经没有问题了。\n\n', 0, 1);
INSERT INTO `t_article` VALUES (30, '03. 面向对象分析', 8, '\n\n## 1、面向对象\n\n**（1）OOA**(Object-oriented Analysis) \n			面向对象分析——事物的分类、命名、描述。\n**（2）OOD**(Object-oriented Design) \n			面向对象设计——建模\n**（3）OOP**(Object-oriented Programming) \n			面向对象编程——实现\n\n## 2、面向对象分析的特点\n\n（1）特征：事物的特征/性状、结构和状态\n\n（2）行为：能力、效果/功效、职责\n\n（3）事物：具体/泛指，物理/逻辑\n\n（4）要义：\n\n- 万物皆可分类、命名\n- 万物皆对象\n- 万物皆有特征、行为和初始状态\n- 万物间皆有联系\n- 万物皆是层次结构\n\n\n\n## 3、**五大成员：**\n\n**（1）属性 \n（2）构造方法：** \n\n```java\n[访问修饰符] 类名 （形参列表） {\n方法体\n}\n```\n\n**（3）方法：**\n\n```java\n[访问修饰符] [修饰符] 返回值类型 方法名 （形参列表） {\n方法体\n}\n```\n\n**（4）块：**\n1）实例块 ：\n\n```java\n{\n}\n```\n\n每次创建对象时，都会自动执行，且在构造方法之前执行，由于版本原因，可以说是之前版本的构造类。\n2）静态块：\n\n```java\nstatic{\n}\n```\n\n在类第一次被实例化时会被调用执行一次（仅一次），且在实例化之前执行。\n**（5）内部类** \n\n```java\nclass demo{\n		\n}\n```\n\n\n\n## 4、Java命名规范\n\n（1）大驼峰：类名，构造方法\n（2）小驼峰：方法名，变量名\n（3）全大写：常量名\n（4）全小写：包名\n\n\n\n## 5、Java权限修饰符＋特征修饰\n\n**（1）权限修饰符**\n\n- public － 共有的－可以在本项目中任意位置使用\n- protected－保护的－可以在本类、同包、子类中使用\n- 默认－默认的－可以在本类、同包中使用\n- private－私有的－可以在本类中使用\n\njava语言的严谨性和安全性，我们在以后使用这4种修饰符时创建一个类，这个类的权限尽量要小，这样才能减少漏洞和提高安全性，从而体现java面向对象的封装性。\n\n**（2） 特征修饰符**\n\n**final：**\n\n修饰变量－－只有一次赋值机会，不能再发生改变\n修饰属性－－必须赋初始值，不能再次发生改变\n修饰方法－－该方法不能被重写\n修饰类 －－该类不能被子类继承\n\n**static：**\n修饰属性／修饰方法／修饰块／修饰内部类\n静态元素在类加载时即被初始化\n静态元素存储在静态区中，每个类有单独的区域不冲突\n静态元素不能被GC（垃圾回收机制）管理\n静态元素与对象无关，属于类\n静态元素只能加载一次，与所有类对象以及类本身共享\n静态元素加载时没有对象所以可以直接通过类名访问\n静态元素与静态元素之间可以直接访问\n非静态元素可以直接访问静态元素，静态元素不可以访问非静态元素\n静态元素中不可以使用this和super\n\n**abstract**\n用来创建抽象类和抽象方法。\n\n**synchronized 和 volatile**\n主要用于线程的编程。\n\n**native**\n用来调用本地的（C/C++）语言\n\n## **6、方法重载：**\n\n（1） 同一个类中的多个方法可以有相同的方法名称，但是有不同的参数列表，这就称为方法重载（method overloading）。\n\n参数列表又叫参数签名，包括参数的类型、参数的个数、参数的顺序，只要有一个不同就叫做参数列表不同。\n\n重载是面向对象的一个基本特性。\n\n（2）方法的重载的规则：\n\n- 方法名称必须相同。\n- 参数列表必须不同。\n- 方法的返回类型可以相同也可以不相同。\n- 仅仅返回类型不同不足以称为方法的重载。\n\n（3）方法重载的实现：\n\n方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错，这叫做重载分辨。\n\n\n\n## 7、创建一个对象的过程\n\n（1）把类的字节码加载到内存。\n\n（2）根据类的声明，把属性集初始化到内存堆并赋初值。\n\n（3）根据代码，调用参数的构造方法，并赋值。\n\n（4）在栈中创建一个变量，用来引用堆中对象的具体属性。', 0, 0, '2020-08-06 21:47:32', 0, 0, 1, '1、面向对象（1）OOA(Object-oriented Analysis)            面向对象分析——事物的分类、命名、描述。（2）OOD(Object-oriented Design)            面向对象设计——建模（3）OOP(Object-oriented Programming)            面向对象编程——实现\n2、面向对象分析的特点（1）特征：事物的特征/性状、结构和状态\n（2）行为：能力、效果/功效、职责\n（3）事物：具体/泛指，物理/逻辑\n（4）要义：\n\n万物皆可分类、命名万物皆对象万物皆有特征、行为和初始状态万物间皆有联系万物皆是层次结构\n3、五大成员：（1）属性（2）构造方法： \n[访问修饰符] 类名 （形参列表） {方法体}\n（3）方法：\n[访问修饰符] [修饰符] 返回值类型 方法名 （形参列表） {方法体}\n（4）块：1）实例块 ：\n{}\n每次创建对象时，都会自动执行，且在构造方法之前执行，由于版本原因，可以说是之前版本的构造类。2）静态块：\nstatic{}\n在类第一次被实例化时会被调用执行一次（仅一次），且在实例化之前执行。（5）内部类 \nclass demo{}\n4、Java命名规范（1）大驼峰：类名，构造方法（2）小驼峰：方法名，变量名（3）全大写：常量名（4）全小写：包名\n5、Java权限修饰符＋特征修饰（1）权限修饰符\n\npublic － 共有的－可以在本项目中任意位置使用protected－保护的－可以在本类、同包、子类中使用默认－默认的－可以在本类、同包中使用private－私有的－可以在本类中使用\njava语言的严谨性和安全性，我们在以后使用这4种修饰符时创建一个类，这个类的权限尽量要小，这样才能减少漏洞和提高安全性，从而体现java面向对象的封装性。\n（2） 特征修饰符\nfinal：\n修饰变量－－只有一次赋值机会，不能再发生改变修饰属性－－必须赋初始值，不能再次发生改变修饰方法－－该方法不能被重写修饰类 －－该类不能被子类继承\nstatic：修饰属性／修饰方法／修饰块／修饰内部类静态元素在类加载时即被初始化静态元素存储在静态区中，每个类有单独的区域不冲突静态元素不能被GC（垃圾回收机制）管理静态元素与对象无关，属于类静态元素只能加载一次，与所有类对象以及类本身共享静态元素加载时没有对象所以可以直接通过类名访问静态元素与静态元素之间可以直接访问非静态元素可以直接访问静态元素，静态元素不可以访问非静态元素静态元素中不可以使用this和super\nabstract用来创建抽象类和抽象方法。\nsynchronized 和 volatile主要用于线程的编程。\nnative用来调用本地的（C/C++）语言\n6、方法重载：（1） 同一个类中的多个方法可以有相同的方法名称，但是有不同的参数列表，这就称为方法重载（method overloading）。\n参数列表又叫参数签名，包括参数的类型、参数的个数、参数的顺序，只要有一个不同就叫做参数列表不同。\n重载是面向对象的一个基本特性。\n（2）方法的重载的规则：\n\n方法名称必须相同。参数列表必须不同。方法的返回类型可以相同也可以不相同。仅仅返回类型不同不足以称为方法的重载。\n（3）方法重载的实现：\n方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错，这叫做重载分辨。\n7、创建一个对象的过程（1）把类的字节码加载到内存。\n（2）根据类的声明，把属性集初始化到内存堆并赋初值。\n（3）根据代码，调用参数的构造方法，并赋值。\n（4）在栈中创建一个变量，用来引用堆中对象的具体属性。\n', 0, 1);
INSERT INTO `t_article` VALUES (31, '04. 内部类', 8, '## 1、类的五大成员\n\n属性、构造方法、一般方法、块、内部类\n\n这篇主要描写内部类。\n\n下面代码演示类的结构：\n\n```java\npackage com.company.project.test.t41;\n\nimport java.sql.Struct;\n\nimport org.omg.CORBA.PUBLIC_MEMBER;\n\npublic class Demo {\n//1属性\n	String name;\n//2.构造方法\n	public Demo() {\n		\n	}\n	\n//3.方法\n	public void funOuter1() {\n		System.out.println(\"外部类方法\");\n	}\n	\n//4.块\n	{\n		\n	}\n	\n//5.内部类	\n  //5.1成员内部类\n	class Inner{\n		public void fun1() {\n		name = \"\";	\n		funOuter1();\n		}\n	}\n	\n   //5.2静态内部类\n	static class StaticClass{\n		\n	}\n	\n   //5.3匿名内部类\n		//通过接口创建匿名内部类\n	Runnable runnable = new Runnable() {\n		\n		@Override\n		public void run() {\n			// TODO Auto-generated method stub\n			\n		}\n	};\n	\n		//通过类创建匿名内部类\n	Thread thread = new Thread() {\n		public void run() {\n			\n		}\n	};\n	\n   //5.4局部内部类\n	public void funOuter2() {\n		//作用范围仅限于所属方法，\n		class A{\n			\n		}\n		\n		A a = new A();\n	}\n}\n```\n\n## 2、内部类\n\n内部类分为4种：成员内部类、静态内部类、匿名内部类、局部内部类。\n\n特点：可以共享外部类的成员（属性，方法）\n\n### 2.1 成员内部类\n\n```java\npublic class Demo {\n//1属性\n	String name;\n//3.方法\n	public void funOuter1() {\n		System.out.println(\"外部类方法\");\n	}\n//5.内部类\n//5.1 成员内部类\n	class Inner{\n		public void fun1() {\n		name = \"\";	\n		funOuter1();\n		}\n	}\n}\n```\n\n特点：要使用成员内部类的对象，外部类的对象必须存在。\n\n实例化：\n\n```java\npackage com.company.project.test.t41;\n\n\npublic class Client {\n	public static void main(String[] args) {\n	//内部类的实例化\n	//5.1成员内部类\n		Demo.Inner inner = new Demo().new Inner();\n}\n```\n\n### 2.2 静态内部类\n\n```java\npublic class Demo {\n//1属性\n	String name;\n//3.方法\n	public void funOuter1() {\n		System.out.println(\"外部类方法\");\n	}\n//5.内部类\n//5.2静态内部类\n	static class StaticClass{\n		\n	}\n}\n```\n\n特点：静态内部类，把外部类当作特殊的包使用，所以实例化时new 后面的Demo不需要小括号（和成员内部类区别）。\n\n实例化：\n\n```java\npackage com.company.project.test.t41;\n\n\npublic class Client {\n	public static void main(String[] args) {\n	//内部类的实例化\n	//5.2静态内部类的实例化\n		//静态内部类，把外部类当作特殊的包使用\n		Demo.StaticClass staticClass = new Demo.StaticClass();\n	}\n}\n```\n\n### 2.3 匿名内部类\n\n分为两种：通过接口创建和类创建。\n\n特点：简化了一些临时使用的类，小，方便，属于临时变量类。\n\n​          创建和实例化在一起。\n\n```java\npublic class Demo {\n//1属性\n	String name;\n//3.方法\n	public void funOuter1() {\n		System.out.println(\"外部类方法\");\n	}\n//5.内部类\n //5.3匿名内部类\n		//通过接口创建匿名内部类\n	Runnable runnable = new Runnable() {\n		\n		@Override\n		public void run() {\n			// TODO Auto-generated method stub\n			\n		}\n	};\n	\n		//通过类创建匿名内部类\n	Thread thread = new Thread() {\n		public void run() {\n			\n		}\n	};\n}\n```\n\n### 2.4 局部内部类\n\n特点：可以在方法中定义，并实例化，但使用地方仅局限在此方法中。\n\n```java\npublic class Demo {\n//1属性\n	String name;\n//3.方法\n	public void funOuter1() {\n		System.out.println(\"外部类方法\");\n	}\n//5.内部类\n//5.4局部内部类\npublic void funOuter2() {\n		//作用范围仅限于所属方法，\n		class A{\n			\n		}\n		\n		A a = new A();\n	}\n}\n```', 0, 0, '2020-08-06 21:50:45', 0, 0, 1, '1、类的五大成员属性、构造方法、一般方法、块、内部类\n这篇主要描写内部类。\n下面代码演示类的结构：\npackage com.company.project.test.t41;import java.sql.Struct;import org.omg.CORBA.PUBLIC_MEMBER;public class Demo {//1属性    String name;//2.构造方法    public Demo() {    }//3.方法    public void funOuter1() {        System.out.println(\"外部类方法\");    }//4.块    {    }//5.内部类      //5.1成员内部类    class Inner{        public void fun1() {        name = \"\";            funOuter1();        }    }   //5.2静态内部类    static class StaticClass{    }   //5.3匿名内部类        //通过接口创建匿名内部类    Runnable runnable = new Runnable() {        @Override        public void run() {            // TODO Auto-generated method stub        }    };        //通过类创建匿名内部类    Thread thread = new Thread() {        public void run() {        }    };   //5.4局部内部类    public void funOuter2() {        //作用范围仅限于所属方法，        class A{        }        A a = new A();    }}\n2、内部类内部类分为4种：成员内部类、静态内部类、匿名内部类、局部内部类。\n特点：可以共享外部类的成员（属性，方法）\n2.1 成员内部类public class Demo {//1属性    String name;//3.方法    public void funOuter1() {        System.out.println(\"外部类方法\");    }//5.内部类//5.1 成员内部类    class Inner{        public void fun1() {        name = \"\";            funOuter1();        }    }}\n特点：要使用成员内部类的对象，外部类的对象必须存在。\n实例化：\npackage com.company.project.test.t41;public class Client {    public static void main(String[] args) {    //内部类的实例化    //5.1成员内部类        Demo.Inner inner = new Demo().new Inner();}\n2.2 静态内部类public class Demo {//1属性    String name;//3.方法    public void funOuter1() {        System.out.println(\"外部类方法\");    }//5.内部类//5.2静态内部类    static class StaticClass{    }}\n特点：静态内部类，把外部类当作特殊的包使用，所以实例化时new 后面的Demo不需要小括号（和成员内部类区别）。\n实例化：\npackage com.company.project.test.t41;public class Client {    public static void main(String[] args) {    //内部类的实例化    //5.2静态内部类的实例化        //静态内部类，把外部类当作特殊的包使用        Demo.StaticClass staticClass = new Demo.StaticClass();    }}\n2.3 匿名内部类分为两种：通过接口创建和类创建。\n特点：简化了一些临时使用的类，小，方便，属于临时变量类。\n​          创建和实例化在一起。\npublic class Demo {//1属性    String name;//3.方法    public void funOuter1() {        System.out.println(\"外部类方法\");    }//5.内部类 //5.3匿名内部类        //通过接口创建匿名内部类    Runnable runnable = new Runnable() {        @Override        public void run() {            // TODO Auto-generated method stub        }    };        //通过类创建匿名内部类    Thread thread = new Thread() {        public void run() {        }    };}\n2.4 局部内部类特点：可以在方法中定义，并实例化，但使用地方仅局限在此方法中。\npublic class Demo {//1属性    String name;//3.方法    public void funOuter1() {        System.out.println(\"外部类方法\");    }//5.内部类//5.4局部内部类public void funOuter2() {        //作用范围仅限于所属方法，        class A{        }        A a = new A();    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (32, '05. 四种权限修饰符', 8, '\n## **权限修饰符**\n\n**（1）public :** 公共权限\n\n​             修饰对象： 修饰类、方法、属性\n\n​             继承：       被public所修饰的成员能被该类的所有子类继承下来。\n\n​             作用域：    可以被任意类访问\n\n​      public能用来修饰类，在一个java源文件中只能有一个类被声明为public，而且一旦有一个类为public，那这个java源文件的文件名就必须要和这个被public所修饰的类的类名相同，否则编译不能通过。说到这里，穿插多一点知识。一个类作为外部类的时候只能被public或者默认访问修饰符所修饰，但是一个类如果作为内部类的时候，则可以被四种访问修饰符所修饰，因为一个类作为内部类的时候，就作为外部类的一个成员属性了，因此可以有四种访问修饰符修饰，这是内部类和外部类的一个区别。\n\n​     public用来修饰类中成员(变量和方法)，被public所修饰的成员可以在任何类中都能被访问到。通过操作该类的对象能随意访问public成员。\n\n​     public在类的继承上的体现，被public所修饰的成员能被所有的子类继承下来。\n\n**（2）protected：**受保护的权限\n\n​             修饰对象：修饰内部类，接口，属性，方法\n\n​             继承：       被protected所修饰的成员能被该类的所有子类继承下来。\n\n​             作用域：    可以被同包类访问，如果不是同包，必须是该类的子类才能访问\n\n**（3）default :** 同包权限**(默认，缺省的)**\n\n​             修饰对象：修饰类，属性，方法。\n\n​             继承：被default所修饰的成员只能被该类所在同一个package中的子类所继承下来。(也就是说只有在同一个package中的子类才能访问到父类中default修饰的成员)\n\n​             作用域：    只能被同包的类访问\n\n**（4） private :** 私有权限\n\n​             修饰对象 ： 内部类，属性，方法\n\n​              作用域：     只能在本类中使用\n\n![img](https://pic3.zhimg.com/v2-3810a5a5e7b54addbda514439b15a266_b.png)\n\n注意：\n\n（1）protected不能修饰类。\n\n（2）priavte可以修饰类，但是该类必须是一个内部类。\n\n**在定义类时，推荐访问控制级别从严处理：**\n\n**（1） 如果不允许外部直接通过 new 创建对象，构造方法必须是 private。**\n\n**（2）工具类不允许有 public 或 default 构造方法。**\n\n**（3）类非 static 成员变量并且与子类共享，必须是 protected。**\n\n**（4）类非static成员变量并且仅在本类使用，必须是private。**\n\n**（5）类 static 成员变量如果仅在本类使用，必须是 private。**\n\n**（6）若是 static 成员变量，必须考虑是否为 final。**\n\n**（7）类成员方法只供类内部调用，必须是 private。**\n\n**（8）类成员方法只对继承类公开，那么限制为 protected。**', 0, 0, '2020-08-06 21:56:44', 2, 0, 1, '权限修饰符（1）public : 公共权限\n​             修饰对象： 修饰类、方法、属性\n​             继承：       被public所修饰的成员能被该类的所有子类继承下来。\n​             作用域：    可以被任意类访问\n​      public能用来修饰类，在一个java源文件中只能有一个类被声明为public，而且一旦有一个类为public，那这个java源文件的文件名就必须要和这个被public所修饰的类的类名相同，否则编译不能通过。说到这里，穿插多一点知识。一个类作为外部类的时候只能被public或者默认访问修饰符所修饰，但是一个类如果作为内部类的时候，则可以被四种访问修饰符所修饰，因为一个类作为内部类的时候，就作为外部类的一个成员属性了，因此可以有四种访问修饰符修饰，这是内部类和外部类的一个区别。\n​     public用来修饰类中成员(变量和方法)，被public所修饰的成员可以在任何类中都能被访问到。通过操作该类的对象能随意访问public成员。\n​     public在类的继承上的体现，被public所修饰的成员能被所有的子类继承下来。\n（2）protected：受保护的权限\n​             修饰对象：修饰内部类，接口，属性，方法\n​             继承：       被protected所修饰的成员能被该类的所有子类继承下来。\n​             作用域：    可以被同包类访问，如果不是同包，必须是该类的子类才能访问\n（3）default : 同包权限(默认，缺省的)\n​             修饰对象：修饰类，属性，方法。\n​             继承：被default所修饰的成员只能被该类所在同一个package中的子类所继承下来。(也就是说只有在同一个package中的子类才能访问到父类中default修饰的成员)\n​             作用域：    只能被同包的类访问\n（4） private : 私有权限\n​             修饰对象 ： 内部类，属性，方法\n​              作用域：     只能在本类中使用\n\n注意：\n（1）protected不能修饰类。\n（2）priavte可以修饰类，但是该类必须是一个内部类。\n在定义类时，推荐访问控制级别从严处理：\n（1） 如果不允许外部直接通过 new 创建对象，构造方法必须是 private。\n（2）工具类不允许有 public 或 default 构造方法。\n（3）类非 static 成员变量并且与子类共享，必须是 protected。\n（4）类非static成员变量并且仅在本类使用，必须是private。\n（5）类 static 成员变量如果仅在本类使用，必须是 private。\n（6）若是 static 成员变量，必须考虑是否为 final。\n（7）类成员方法只供类内部调用，必须是 private。\n（8）类成员方法只对继承类公开，那么限制为 protected。\n', 0, 1);
INSERT INTO `t_article` VALUES (33, '06. 数组', 8, '## 1、一维数组\n\n创建方式：\n\n```\n//数组创建1：引用，对象，元素\n		int[] aa;\n		int[] a = new int[10];\n		int[] aaa = new int[0]; //空数组\n		\n		//创建方式2：声明，创建，\n		int[] b = new int[] {1,2};\n		String[] strings = new String[] {\"Hello World\"};\n		\n		//创建方式3：\n		int[] c = {1,2,3};\n		String[] strings2 = {\"World\"};\n```\n\n动态创建：\n\n```\nint[] a = new int[10];\n		a[0] = 1;\n		for(int i = 0; i < a.length; i++) {\n			a[i] = i;\n		}\n```\n\n静态创建：\n\n```\nint[] b = new int[] {1,2};\n```\n\nlength:\n\n```\n	//数组的length是属性\n		System.out.println(b.length);\n		String[] strings = new String[] {\"hello\"};\n		System.out.println(strings.length);\n		\n	//字符串的length是方法\n		String string3 = \"hello\";\n		System.out.println(string3.length());\n```\n\n数组的迭代：\n\n```\n//数组的迭代：一般for\n		for(int i = 0;i<b.length;i++) {\n			System.out.println(b[i]);\n		}\n		\n		//数组的迭代：增强for\n                //i表示的是数组的元素值，不是下标\n		for(int i : b) {\n			System.out.println(i);\n		}\n                 \n```\n\n## 2、多维数组\n\n创建方式：\n\n```\n                //第一种\n		int[][] array1 = {{1},{1,2},{1,2,3}};\n		\n		//第二种\n		int[][] array2 = new int[2][];\n		array2[0] = new int[] {1,2};\n		array2[1] = new int[] {1,2,3};\n		array2[1][1] = 2;\n		array2[2][2] = 4;\n```\n\n数组的赋值：\n\n本质：把b数组对应的虚地址传给了a数组，所以如果b数组发生改变，a也会相应改变。\n\n```\n                int[] a = {1,10,100,1000,10000};\n                int[] b = {2,20,200,2000,20000,200000};\n		b=a;\n		a[1] = 999;\n		for(int i : b) {\n			System.out.println(i);\n		}\n结果：\n1\n999\n100\n1000\n10000\n```\n\n## 3、数组的复制：\n\nSystem.arraycopy(原数组,原数组开始位置,目标数组, 目标数组开始位置, 复制长度);\n\n```\n                int[] a = {1,10,100,1000,10000};\n		int[] b = {2,20,200,2000,20000,200000};\n		\n		//数组复制		\n		System.arraycopy(a, 1, b, 2, 3);\n\n结果：\n2\n20\n10\n100\n1000\n200000\n```\n\n## 4、数组的生成过程\n\n转发别人的描述，感觉挺好的！！！\n\n我们先假设有这么一行代码：int[ ] arr = new int[8];\n\n即定义了一个一维数组，数组名叫arr，里面一共有8个int类型的元素。\n\n接着我们要了解空间分配的概念，这里主要涉及到堆和栈。\n\n简单点理解栈里存放着局部变量，堆里存放着所有new出来的东西。\n\n也就是说，上面的代码中，我们的arr变量是存放在栈里的，new后面那一行是存放在堆中的。\n\n看不懂？没关系，我们画一张图。\n\n![img](https://pic3.zhimg.com/v2-ce624ff47c349131d16fca75af6753d2_b.png)\n\n　　首先，编译时，Jvm看到int[] arr这边，说：“这人创建了一个局部变量，得，我在栈内存中给arr变量划分一块空间吧！”，然后arr变量就在栈内存里呆着了。接着，Jvm又看到了右边的new int[8]，心想：“这是个new出来的玩意啊，嗯，得放在堆内存里”，于是！在堆内存中建立了一个数组，这个数组有8个小格子，也就是能放8个元素，如下图\n\n![img](https://pic3.zhimg.com/v2-563e74cff936388a2f1dab2e9f852b02_b.png)\n\n把一维数组放在堆内存了以后，Jvm又想起：“这是个动态初始化的一维数组，也就是那个程序员只给出了长度，不给初值！初始化交给我？？？那怎么办，那我不如给它全填成0算了，反正把垃圾数字覆盖掉就算行了嘛！”于是Jvm高高兴兴地给每个元素赋上了初值0\n\n![img](https://pic1.zhimg.com/v2-a2cd7d735087acea5add21af7a487314_b.png)\n\n“大功告成！”Jvm以为它的活干完了，但他突然想到：“不对，数组创建好了，但程序员怎么操作这个数组？那我给堆中的数组分配一个地址吧，然后把这个地址传给栈内存中的arr变量，这样arr变量就等于指向了堆这个内存，就像遛狗绳牵着一条狗一样！这样一来arr就可以找到这个数组并且对其进行操作了！”于是给了这个数组一个地址，假设为0x001，并发送给了arr这个变量，于是就可以操作这个数组了，整个创建数组的流程也就到此结束了。\n\n![img](https://pic2.zhimg.com/v2-76f783cb3412147f840403f173d35289_b.png)\n\n这里将地址传给arr变量这种方式个人觉得挺像C中指针的概念，在C语言中同样可以通过指针来操作数组。只不过在Java中，这个arr变量不叫指针变量，而是叫引用。这里插一句题外话，两个不同的引用可以指向同一个数组，就像两根遛狗绳可以牵一条狗一样（不太恰当的比喻XD）。', 0, 0, '2020-08-06 21:57:51', 2, 0, 1, '1、一维数组创建方式：\n//数组创建1：引用，对象，元素        int[] aa;        int[] a = new int[10];        int[] aaa = new int[0]; //空数组        //创建方式2：声明，创建，        int[] b = new int[] {1,2};        String[] strings = new String[] {\"Hello World\"};        //创建方式3：        int[] c = {1,2,3};        String[] strings2 = {\"World\"};动态创建：\nint[] a = new int[10];        a[0] = 1;        for(int i = 0; i < a.length; i++) {            a[i] = i;        }静态创建：\nint[] b = new int[] {1,2};length:\n    //数组的length是属性        System.out.println(b.length);        String[] strings = new String[] {\"hello\"};        System.out.println(strings.length);    //字符串的length是方法        String string3 = \"hello\";        System.out.println(string3.length());数组的迭代：\n//数组的迭代：一般for        for(int i = 0;i<b.length;i++) {            System.out.println(b[i]);        }        //数组的迭代：增强for                //i表示的是数组的元素值，不是下标        for(int i : b) {            System.out.println(i);        }2、多维数组创建方式：\n                //第一种        int[][] array1 = {{1},{1,2},{1,2,3}};        //第二种        int[][] array2 = new int[2][];        array2[0] = new int[] {1,2};        array2[1] = new int[] {1,2,3};        array2[1][1] = 2;        array2[2][2] = 4;数组的赋值：\n本质：把b数组对应的虚地址传给了a数组，所以如果b数组发生改变，a也会相应改变。\n                int[] a = {1,10,100,1000,10000};                int[] b = {2,20,200,2000,20000,200000};        b=a;        a[1] = 999;        for(int i : b) {            System.out.println(i);        }结果：19991001000100003、数组的复制：System.arraycopy(原数组,原数组开始位置,目标数组, 目标数组开始位置, 复制长度);\n                int[] a = {1,10,100,1000,10000};        int[] b = {2,20,200,2000,20000,200000};        //数组复制                System.arraycopy(a, 1, b, 2, 3);结果：2201010010002000004、数组的生成过程转发别人的描述，感觉挺好的！！！\n我们先假设有这么一行代码：int[ ] arr = new int[8];\n即定义了一个一维数组，数组名叫arr，里面一共有8个int类型的元素。\n接着我们要了解空间分配的概念，这里主要涉及到堆和栈。\n简单点理解栈里存放着局部变量，堆里存放着所有new出来的东西。\n也就是说，上面的代码中，我们的arr变量是存放在栈里的，new后面那一行是存放在堆中的。\n看不懂？没关系，我们画一张图。\n\n　　首先，编译时，Jvm看到int[] arr这边，说：“这人创建了一个局部变量，得，我在栈内存中给arr变量划分一块空间吧！”，然后arr变量就在栈内存里呆着了。接着，Jvm又看到了右边的new int[8]，心想：“这是个new出来的玩意啊，嗯，得放在堆内存里”，于是！在堆内存中建立了一个数组，这个数组有8个小格子，也就是能放8个元素，如下图\n\n把一维数组放在堆内存了以后，Jvm又想起：“这是个动态初始化的一维数组，也就是那个程序员只给出了长度，不给初值！初始化交给我？？？那怎么办，那我不如给它全填成0算了，反正把垃圾数字覆盖掉就算行了嘛！”于是Jvm高高兴兴地给每个元素赋上了初值0\n\n“大功告成！”Jvm以为它的活干完了，但他突然想到：“不对，数组创建好了，但程序员怎么操作这个数组？那我给堆中的数组分配一个地址吧，然后把这个地址传给栈内存中的arr变量，这样arr变量就等于指向了堆这个内存，就像遛狗绳牵着一条狗一样！这样一来arr就可以找到这个数组并且对其进行操作了！”于是给了这个数组一个地址，假设为0x001，并发送给了arr这个变量，于是就可以操作这个数组了，整个创建数组的流程也就到此结束了。\n\n这里将地址传给arr变量这种方式个人觉得挺像C中指针的概念，在C语言中同样可以通过指针来操作数组。只不过在Java中，这个arr变量不叫指针变量，而是叫引用。这里插一句题外话，两个不同的引用可以指向同一个数组，就像两根遛狗绳可以牵一条狗一样（不太恰当的比喻XD）。\n', 0, 1);
INSERT INTO `t_article` VALUES (34, '07. 特性修饰符——static属性', 8, '## **1、static属性**\n\n**1.static属性的用途**\n\n**· static被称为静态，可以用来修饰类的属性和方法。**\n\n**·如果类的某个属性，不管创建多少个对象，属性的存储空间只有唯一的一个，那么这个属性就应该用static修饰，被static修饰的属性被称为静态属性。**\n\n**2.静态成员的访问**\n\n**（1）对象.静态成员**\n\n```java\nSystem.out.println(emp1.count);\n```\n\n**（2）类.静态成员**\n\n```java\nSystem.out.println(Emp.count);\n```\n\n问题：为什么几种不同的访问方式下，静态属性count的值都一样？\n\n（1）静态成员是属于**类**的。\n\n（2）类的对象可以**共享**类的静态成员。\n\n## 2、static方法\n\n**用途：**\n\n**·如果某个方法不需要与某个特定的对象绑定，那么该方法可以使用static修饰，被static修饰的方法称为静态方法。**\n\n**·基本结构如下：**\n\n**访问权限    static修饰符   返回值类型  方法名称**\n\n```java\npublic static void sellticket(){\n  System.out.println(\"所有车票都是12306卖的\");\n}\n```\n\n静态方法的定义\n\n```java\npublic class Math {\n	public static int add(int a ,int b) {\n		return a + b;\n	}\n}\n```\n\n静态方法的调用：类.方法名()\n\n```java\npublic class Client {\n	public static void main(String[] args) {\n		int c = Math.add(1,2);\n		System.out.println(c);\n	}\n}\n```\n\n**区别：静态方法与非静态方法的调用**\n\n静态方法的调用：类.方法名()\n\n非静态方法的调用：先实例对象，在对象.方法名()\n\n## 3、常用系统中的静态方法**\n\n```java\n                //Math类的静态方法\n		System.out.println( Math.abs(-1));\n		System.out.println(Math.random());\n		\n		//Math类中的静态属性\n		System.out.println(Math.PI);\n		System.out.println(Math.E);\n		\n		//包装类中的静态属性\n		System.out.println(Integer.MIN_VALUE);\n		System.out.println(Integer.MAX_VALUE);\n		\n		//包装类中的静态方法\n		System.out.println(Integer.valueOf(10));\n		System.out.println(Integer.parseInt(\"10\"))\n```\n\n## 4、static块\n\n**定义：**static块和static的属性以及方法的性质是相同的，用static修饰的代码块表示静态代码块，当Java虚拟机加载类时，就会执行该代码块。\n\n区别在于语法不同\n\n**static块语法：**\n\n直接在代码块前，加上关键词static即成为静态块。\n\n```java\nstatic{\n      System.out.println(\"123\");\n}\n```\n\n**static块的用途：**\n\n·静态块只有在类加载的时候被执行一次，不管创建多少个对象，都不会再执行。\n\n·如果一个类加载的时候，总要预先做一些事情，则可以放在静态块中。例如，读取一个属性文件，进行一些常规配置，写一些日志等。\n\n·一个类可以有多个静态块，按照顺序执行。\n\n```java\npublic class Demo {\n	\n	public static int count;\n	\n	{\n		//实例块\n		System.out.println(\"我是实例块\");\n	}\n	\n	static {\n		//静态块\n		//初始化静态属性\n		Demo.count = 1;\n		\n		System.out.println(\"我是静态块1\");\n	}\n	static {\n		//静态块\n		System.out.println(\"我是静态块2\");\n	}\n	static {\n		//静态块\n		System.out.println(\"我是静态块3\");\n	}\n}\n\npublic class Client {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Demo demo1 = new Demo();\n		Demo demo2 = new Demo();\n		Demo demo3 = new Demo();\n		\n		//1.静态块在类加载的时候加载一次，和对象的创建个数无关\n		//2.静态块在实例块之前调用\n		//3.如果一个类中有多个静态块，它们会顺序执行	\n	}\n}\n\n运行结果：\n我是静态块1\n我是静态块2\n我是静态块3\n我是实例块\n我是实例块\n我是实例块\n```\n\n## 5、静态类（只能是内部类，外部类不允许static修饰）\n\nstatic类基本语法：\n\n```java\npublic class Outer {\n	\n	//静态内部类\n	static class Inner{\n		\n	}\n}\n\npublic class Client {\n	public static void main(String[] args) {\n		//语法：外部类.内部类,是把外部类当作特殊的包名来使用\n		Outer.Inner inner =new Outer.Inner();\n	}\n}\n```\n\nstatic父子类继承：\n\n```java\npublic class Message {\n//父类\n	static class TextMessage extends Message{\n		//子类\n	}\n	\n	static class VoiceMessage extends Message{\n		\n	}\n}\n\n\npublic class Client {\n	\n	public static void main(String[] args) {\n		//外部类.内部类\n		//父类.子类\n		Message.TextMessage textMessage =new Message.TextMessage();\n	}\n}\n```\n\n静态内部类是外部类的实例\n\n```java\n//接口：飞\npublic interface FlyAble {\n	\n	//静态内部类，是外部类型的实现类\n	static class Bird implements FlyAble{\n		\n	}\n	\n	static class Leaf implements FlyAble{\n		\n	}\n}\n\npublic class Client {\n	public static void main(String[] args) {\n\n                //外部类.静态内部类\n		//接口.静态内部类\n		FlyAble.Bird bird = new FlyAble.Bird();\n		FlyAble.Leaf leaf = new FlyAble.Leaf();\n	}\n}\n```', 0, 0, '2020-08-06 21:58:30', 2, 0, 1, '1、static属性1.static属性的用途\n· static被称为静态，可以用来修饰类的属性和方法。\n·如果类的某个属性，不管创建多少个对象，属性的存储空间只有唯一的一个，那么这个属性就应该用static修饰，被static修饰的属性被称为静态属性。\n2.静态成员的访问\n（1）对象.静态成员\nSystem.out.println(emp1.count);\n（2）类.静态成员\nSystem.out.println(Emp.count);\n问题：为什么几种不同的访问方式下，静态属性count的值都一样？\n（1）静态成员是属于类的。\n（2）类的对象可以共享类的静态成员。\n2、static方法用途：\n·如果某个方法不需要与某个特定的对象绑定，那么该方法可以使用static修饰，被static修饰的方法称为静态方法。\n·基本结构如下：\n访问权限    static修饰符   返回值类型  方法名称\npublic static void sellticket(){  System.out.println(\"所有车票都是12306卖的\");}\n静态方法的定义\npublic class Math {    public static int add(int a ,int b) {        return a + b;    }}\n静态方法的调用：类.方法名()\npublic class Client {    public static void main(String[] args) {        int c = Math.add(1,2);        System.out.println(c);    }}\n区别：静态方法与非静态方法的调用\n静态方法的调用：类.方法名()\n非静态方法的调用：先实例对象，在对象.方法名()\n3、常用系统中的静态方法**                //Math类的静态方法        System.out.println( Math.abs(-1));        System.out.println(Math.random());        //Math类中的静态属性        System.out.println(Math.PI);        System.out.println(Math.E);        //包装类中的静态属性        System.out.println(Integer.MIN_VALUE);        System.out.println(Integer.MAX_VALUE);        //包装类中的静态方法        System.out.println(Integer.valueOf(10));        System.out.println(Integer.parseInt(\"10\"))\n4、static块定义：static块和static的属性以及方法的性质是相同的，用static修饰的代码块表示静态代码块，当Java虚拟机加载类时，就会执行该代码块。\n区别在于语法不同\nstatic块语法：\n直接在代码块前，加上关键词static即成为静态块。\nstatic{      System.out.println(\"123\");}\nstatic块的用途：\n·静态块只有在类加载的时候被执行一次，不管创建多少个对象，都不会再执行。\n·如果一个类加载的时候，总要预先做一些事情，则可以放在静态块中。例如，读取一个属性文件，进行一些常规配置，写一些日志等。\n·一个类可以有多个静态块，按照顺序执行。\npublic class Demo {    public static int count;    {        //实例块        System.out.println(\"我是实例块\");    }    static {        //静态块        //初始化静态属性        Demo.count = 1;        System.out.println(\"我是静态块1\");    }    static {        //静态块        System.out.println(\"我是静态块2\");    }    static {        //静态块        System.out.println(\"我是静态块3\");    }}public class Client {    public static void main(String[] args) {        // TODO Auto-generated method stub        Demo demo1 = new Demo();        Demo demo2 = new Demo();        Demo demo3 = new Demo();        //1.静态块在类加载的时候加载一次，和对象的创建个数无关        //2.静态块在实例块之前调用        //3.如果一个类中有多个静态块，它们会顺序执行        }}运行结果：我是静态块1我是静态块2我是静态块3我是实例块我是实例块我是实例块\n5、静态类（只能是内部类，外部类不允许static修饰）static类基本语法：\npublic class Outer {    //静态内部类    static class Inner{    }}public class Client {    public static void main(String[] args) {        //语法：外部类.内部类,是把外部类当作特殊的包名来使用        Outer.Inner inner =new Outer.Inner();    }}\nstatic父子类继承：\npublic class Message {//父类    static class TextMessage extends Message{        //子类    }    static class VoiceMessage extends Message{    }}public class Client {    public static void main(String[] args) {        //外部类.内部类        //父类.子类        Message.TextMessage textMessage =new Message.TextMessage();    }}\n静态内部类是外部类的实例\n//接口：飞public interface FlyAble {    //静态内部类，是外部类型的实现类    static class Bird implements FlyAble{    }    static class Leaf implements FlyAble{    }}public class Client {    public static void main(String[] args) {                //外部类.静态内部类        //接口.静态内部类        FlyAble.Bird bird = new FlyAble.Bird();        FlyAble.Leaf leaf = new FlyAble.Leaf();    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (35, '08. 特性修饰符——final', 8, '## 1、final定义：\n\n**·final用于声明属性，方法，形参和类**\n\n​      **（1）属性：定义就必须直接赋值或者在构造方法中进行赋值，并且后期都不能修改。**\n\n```java\npublic class Demo {\n	\n	//final修饰属性必须要赋初值\n	public final int a = 1;\n	public final int b ;\n	public Demo() {\n		//如果被final修饰的属性，没有被初始化，那么就必须在构造器中初始化\n		b = 0;\n		\n		//初始化后的final属性不能再被修改\n		//a = 100;\n		\n	}\n}\n```\n\n​      **（2）方法：定义必须有实现代码，并且子类里不可被覆盖。**\n\n```java\n//类：动物\npublic abstract class Animal {\n	\n	//抽象方法,不允许final修饰\n//	public abstract void eat();\n	\n	//具体方法,最终方法\n	public final void run() {\n		\n	}\n	\n	public void fun() {\n		\n	}\n}\n\npublic class Dog extends Animal{\n	\n	//父类中的final方法不能被子类重写\n//	public final void run() {\n//		\n//	}\n	\n	//父类的非final方法可以被子类重写\n\n	public void fun() {\n		\n		super.fun();\n	}\n}\n```\n\n​      **（3）类：不能定义为抽象类或者是接口，不可被继承。**\n\n```java\n//抽象类上不允许使用final修饰\npublic abstract class Demo {\n \n}\n\n//接口不允许final修饰\npublic interface FlyAble {\n\n}\n\n//类：树叶，叶类，不能再被继承\npublic final class Leaf {\n\n}\n\n//class A extends Leaf{\n//	\n//}\n```\n\n​      **（4）形参：方法体内不允许被修改。**\n\n```java\npublic class Demo {\n	public void fun(final int a , final int b ) {\n		\n	//形参用final修饰，那么在该方法内不允许被修改	\n//		a=1;\n//		b=2;\n		System.out.println( a );\n		System.out.println( b );\n		\n		//局部变量,final修饰的只能赋值一次\n		final int c ;\n		c=1;\n		\n		//c=2;\n	}\n}\n```\n\n**（5）常量（用static 和 final 同时修饰的属性）**\n\n```java\npublic class MyMath {\n\n	//常量，属性，变量\n	public static final double PI = 3.14;\n	\n	public  static final double LIGHT_SPEED = 30.0;\n}\n```\n\n## 2、对变量和常量的总结\n\n**（1）按作用域区分**\n\n·在类中声明的变量或常量叫属性，或者叫成员变量。\n\n·在方法中声明的变量叫局部变量，或者临时变量。\n\n·属性可以使用四种权限修饰符，局部变量不可以\n\n·属性可以使用static修饰，局部变量不可以。\n\n·属性可以使用final修饰，局部变量也可以\n\n·属性的生命周期很长，随着类的加载或者创建对象被初始化，直到没有对象引用才回收。\n\n·局部变量生命周期很短，执行某个方法时临时被初始化，方法解时被回收。\n\n·如果局部变量与属性重名，则遵守就近原则，可以使用this区分。\n\n·属性可以在整个类中被使用，局部变量只在当前方法中使用。\n\n·属性都有默认的初始化值，如引用类型都是null，整型是0。局部变量不被自动初始化，必须手动初始化。', 0, 0, '2020-08-06 21:59:02', 2, 0, 1, '1、final定义：·final用于声明属性，方法，形参和类\n​      （1）属性：定义就必须直接赋值或者在构造方法中进行赋值，并且后期都不能修改。\npublic class Demo {    //final修饰属性必须要赋初值    public final int a = 1;    public final int b ;    public Demo() {        //如果被final修饰的属性，没有被初始化，那么就必须在构造器中初始化        b = 0;        //初始化后的final属性不能再被修改        //a = 100;    }}\n​      （2）方法：定义必须有实现代码，并且子类里不可被覆盖。\n//类：动物public abstract class Animal {    //抽象方法,不允许final修饰//    public abstract void eat();    //具体方法,最终方法    public final void run() {    }    public void fun() {    }}public class Dog extends Animal{    //父类中的final方法不能被子类重写//    public final void run() {//        //    }    //父类的非final方法可以被子类重写    public void fun() {        super.fun();    }}\n​      （3）类：不能定义为抽象类或者是接口，不可被继承。\n//抽象类上不允许使用final修饰public abstract class Demo {}//接口不允许final修饰public interface FlyAble {}//类：树叶，叶类，不能再被继承public final class Leaf {}//class A extends Leaf{//    //}\n​      （4）形参：方法体内不允许被修改。\npublic class Demo {    public void fun(final int a , final int b ) {    //形参用final修饰，那么在该方法内不允许被修改    //        a=1;//        b=2;        System.out.println( a );        System.out.println( b );        //局部变量,final修饰的只能赋值一次        final int c ;        c=1;        //c=2;    }}\n（5）常量（用static 和 final 同时修饰的属性）\npublic class MyMath {    //常量，属性，变量    public static final double PI = 3.14;    public  static final double LIGHT_SPEED = 30.0;}\n2、对变量和常量的总结（1）按作用域区分\n·在类中声明的变量或常量叫属性，或者叫成员变量。\n·在方法中声明的变量叫局部变量，或者临时变量。\n·属性可以使用四种权限修饰符，局部变量不可以\n·属性可以使用static修饰，局部变量不可以。\n·属性可以使用final修饰，局部变量也可以\n·属性的生命周期很长，随着类的加载或者创建对象被初始化，直到没有对象引用才回收。\n·局部变量生命周期很短，执行某个方法时临时被初始化，方法解时被回收。\n·如果局部变量与属性重名，则遵守就近原则，可以使用this区分。\n·属性可以在整个类中被使用，局部变量只在当前方法中使用。\n·属性都有默认的初始化值，如引用类型都是null，整型是0。局部变量不被自动初始化，必须手动初始化。\n', 0, 1);
INSERT INTO `t_article` VALUES (36, '09. 基本数据类型', 8, '## **一.八种基本数据类型**\n\n![img](https://pic3.zhimg.com/v2-d8b180a1db1fb276009cdef00bb99666_b.png)\n\n解释一下float和doble为什么是精确到有效数字前7位和15位？\n\n```java\nfloat f = 1234567.1934567F;\nSystem.out.println(f);\n		\ndouble d = 12345647.123456789123456;\nSystem.out.println(d);\n\n结果：\n1234567.2\n1.234564712345679E7\n```\n\n明显在float f赋值时，只精确保存了前7位，从第八位开始就要加上第九位四舍五入的进位，\n\n同理，double赋值时，只精确保存了前15位，从第十六位开始就要加上第九位四舍五入的进位。\n\n![img](https://pic1.zhimg.com/v2-a84c87fad091458244f008801eaa398c_b.png)\n\n## **二.float在计算机中存储：**\n\n1、float类型数字在计算机中用4个字节存储，也就是32位。遵循IEEE-754格式标准：\n\n（电气和电子工程师协会（IEEE，全称是Institute of Electrical and Electronics Engineers））\n\n​     一个浮点数有2部分组成：底数m和指数e。\n\n​     格式：SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM\n\n​    S表示浮点数正负    \n\n​    E指数加上127后的值得二进制数据\n\n​    M底数\n\n2、底数部分 \n\n​    使用二进制数来表示此浮点数的实际值。底数部分实际是占用24bit的一个值，但是最高位始终为1，所以最高位省去不存储，故底数部分在存储中占23bit\n\n3、指数部分 \n\n​     指数部分占用8bit的二进制数，可表示数值范围为0-255。但是指数可正可负，所以，IEEE规定，此处算出的次方必须减去127才是真正的指数。 所以，float类型的指数可从-126到128。\n\n这种结构是一种科学计数法：用**符号**、**指数**和**尾数**来表示。指数可正可负，所以，IEEE规定，此处算出的次方必须减去127才是真正的指数。底数定为**2**，即把一个浮点数表示为**尾数乘以2的指数次方再添上符号**。\n\n4、举例：浮点数-12.5 在内存中的存储\n\n   首先浮点数为负，所以 S=1。\n\n​    整数部分为12 ，转换为二进制就是：1100\n\n​    小数部分为0.5，转换为二进制就是 ：0.1\n\n​    故12.5的二进制为：1100.1 。 用科学计数法表示为：1.1001*2^3\n\n​    这样，我们的底数和指数就出来了\n\n​    底数：因为小数点前必为1，所以IEEE规定只记录小数点后的就好。所以，此处的底数为：1001    \n\n​    指数：实际为3，必须加上127(转出的时候，减去127)，所以为130。也就是10000010\n\n   符号部分是整数，所以是1\n\n   综上所述，-12.5在内存中的存储格式是： 1100 0001 0100 1000 0000 0000 0000\n\n## **三.类型转换**\n\n### **（1）自动转换类型**（类型提升）\n\n（1）两种类型之间相互兼容\n\n（2）目标类型大于源类型\n\n（3）对于表达式而言，其最终结果将会与表达式中最高的数据类型相同。\n\n### **（2）强制类型转换（显式类型转换）**\n\n   如果被转换的值的数据类型大于其目标类型，将会丢失部分信息。\n\n```java\nint x = 65;\nchar ch = (char)x;\n```', 0, 0, '2020-08-06 21:59:45', 2, 0, 1, '一.八种基本数据类型\n解释一下float和doble为什么是精确到有效数字前7位和15位？\nfloat f = 1234567.1934567F;System.out.println(f);double d = 12345647.123456789123456;System.out.println(d);结果：1234567.21.234564712345679E7\n明显在float f赋值时，只精确保存了前7位，从第八位开始就要加上第九位四舍五入的进位，\n同理，double赋值时，只精确保存了前15位，从第十六位开始就要加上第九位四舍五入的进位。\n\n二.float在计算机中存储：1、float类型数字在计算机中用4个字节存储，也就是32位。遵循IEEE-754格式标准：\n（电气和电子工程师协会（IEEE，全称是Institute of Electrical and Electronics Engineers））\n​     一个浮点数有2部分组成：底数m和指数e。\n​     格式：SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM\n​    S表示浮点数正负    \n​    E指数加上127后的值得二进制数据\n​    M底数\n2、底数部分 \n​    使用二进制数来表示此浮点数的实际值。底数部分实际是占用24bit的一个值，但是最高位始终为1，所以最高位省去不存储，故底数部分在存储中占23bit\n3、指数部分 \n​     指数部分占用8bit的二进制数，可表示数值范围为0-255。但是指数可正可负，所以，IEEE规定，此处算出的次方必须减去127才是真正的指数。 所以，float类型的指数可从-126到128。\n这种结构是一种科学计数法：用符号、指数和尾数来表示。指数可正可负，所以，IEEE规定，此处算出的次方必须减去127才是真正的指数。底数定为2，即把一个浮点数表示为尾数乘以2的指数次方再添上符号。\n4、举例：浮点数-12.5 在内存中的存储\n   首先浮点数为负，所以 S=1。\n​    整数部分为12 ，转换为二进制就是：1100\n​    小数部分为0.5，转换为二进制就是 ：0.1\n​    故12.5的二进制为：1100.1 。 用科学计数法表示为：1.1001*2^3\n​    这样，我们的底数和指数就出来了\n​    底数：因为小数点前必为1，所以IEEE规定只记录小数点后的就好。所以，此处的底数为：1001    \n​    指数：实际为3，必须加上127(转出的时候，减去127)，所以为130。也就是10000010\n   符号部分是整数，所以是1\n   综上所述，-12.5在内存中的存储格式是： 1100 0001 0100 1000 0000 0000 0000\n三.类型转换（1）自动转换类型（类型提升）（1）两种类型之间相互兼容\n（2）目标类型大于源类型\n（3）对于表达式而言，其最终结果将会与表达式中最高的数据类型相同。\n（2）强制类型转换（显式类型转换）   如果被转换的值的数据类型大于其目标类型，将会丢失部分信息。\nint x = 65;char ch = (char)x;\n', 0, 1);
INSERT INTO `t_article` VALUES (37, '10. 类的关系——关联关系', 8, '## 1、类的四种关系\n\n**· 关联关系**\n\n**· 依赖关系**\n\n**· 继承关系**\n\n**· 实现关系（本质也是继承关系）**\n\n## 2、关联关系\n\n在关联关系中，没有新的语法和概念，不过是一种思想。\n\n对象和对象之间的连接。在Java中，关联关系的代码表现形式为一个类做为另一个类的属性类型存在。即语义上是“有”的关系：”has-a”。\n\n### **2.1 按整体和部分分类：**\n\n（1）组合——同生共死\n\n（2）聚合——不同生不同死\n\n区别：生命周期不同\n\n例：组合——同生同死\n\n​       创建整体时部分也同时创建，整体销毁部分也销毁\n\n```java\n//组合（同生同死）\n\n//人类\npublic class People {\n	private String name;\n	private String age;\n	private Phone[] phones;\n	\n	public People() {\n		phones = new Phone[3];\n	}\n\n	public String getName() {\n		return name;\n	}\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public String getAge() {\n		return age;\n	}\n\n	public void setAge(String age) {\n		this.age = age;\n	}\n\n	public Phone[] getPhones() {\n		return phones;\n	}\n\n	public void setPhones(Phone[] phones) {\n		this.phones = phones;\n	}\n\n	@Override\n	public String toString() {\n		return \"People [name=\" + name + \", age=\" + age + \", phones=\" + Arrays.toString(phones) + \"]\";\n	}\n	\n	\n}\n\n//电话类\npublic class Phone {\n	private String color;\n	private String num;\n	\n	public Phone() {\n		// TODO Auto-generated constructor stub\n	}\n\n	public String getColor() {\n		return color;\n	}\n\n	public void setColor(String color) {\n		this.color = color;\n	}\n\n	public String getNum() {\n		return num;\n	}\n\n	public void setNum(String num) {\n		this.num = num;\n	}\n\n	@Override\n	public String toString() {\n		return \"Phone [color=\" + color + \", num=\" + num + \"]\";\n	}\n	\n	\n}\n\n//测试\npublic class Client {\n	public static void main(String[] args) {\n		People people = new People();\n		people = null;\n		System.out.println(people.getPhones());\n	}\n}\n```\n\n结果：\n\n![img](https://pic2.zhimg.com/v2-aeb13083673a88ebc1ab76133d626a69_b.png)\n\n例：聚合——不同死不同\n\n创建整体时部分可以不创建，整体消亡时部分还存在。\n\n```java\n///聚合（不同生不同死）\n\n//人类\npublic class People {\n	private String name;\n	private String age;\n	private Phone[] phones;\n	\n	public People() {\n		// TODO Auto-generated constructor stub\n	}\n\n	public String getName() {\n		return name;\n	}\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public String getAge() {\n		return age;\n	}\n\n	public void setAge(String age) {\n		this.age = age;\n	}\n\n	public Phone[] getPhones() {\n		return phones;\n	}\n\n	public void setPhones(Phone[] phones) {\n		this.phones = phones;\n	}\n\n//电话类\npublic class Phone {\n	\n	private String color;\n	private String num;\n	\n	public Phone() {\n		// TODO Auto-generated constructor stub\n	}\n\n	public String getColor() {\n		return color;\n	}\n\n	public void setColor(String color) {\n		this.color = color;\n	}\n\n	public String getNum() {\n		return num;\n	}\n\n	public void setNum(String num) {\n		this.num = num;\n	}\n\n	@Override\n	public String toString() {\n		return \"Phone [color=\" + color + \", num=\" + num + \"]\";\n	}\n}\n\n//测试类\npublic class Client {\n	public Client() {\n		// TODO Auto-generated constructor stub\n	}\n	\n	public static void main(String[] args) {\n		People people = new People();\n		Phone[] phones = new Phone[3];\n		\n		\n		people.setPhones(phones);\n		\n		people = null ; \n		System.out.println(phones);\n		System.out.println(people.getPhones());\n		\n	}\n}\n```\n\n结果：\n\n![img](https://pic2.zhimg.com/v2-48d4126d5a112c58ae36f3dce53e1bad_b.png)\n\n### **2.2 按方向分类：**\n\n（1）单向关联：A类关联B类\n\n（2）双向关联：A关联B，B也关联A\n\n例：单向关联\n\n```java\n//类： 电话\npublic class Phone {\n\n    // 属性：型号\n    private String type;\n\n    // 属性：颜色\n    private String color;\n\n    // 属性：品牌\n    private String brand;\n\n    // 构造方法\n    public Phone() {\n\n    }\n\n    // Getters and Setters\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n}\n\n//类：人\npublic class Person {\n\n    // 属性：电话\n    private Phone phone;\n\n    // 构造方法：默认的\n    public Person() {\n\n    }\n\n    // Getters and Setters\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n\n}\n```\n\n例：双向关联\n\n```java\n//类： 电话\npublic class Phone {\n\n    // 属性：型号\n    private String type;\n\n    // 属性：颜色\n    private String color;\n\n    // 属性：品牌\n    private String brand;\n\n    // 属性：所有者\n    private Person owner;\n\n    // 构造方法：默认的\n    public Phone() {\n\n    }\n\n    // Getters and Setters\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n    public Person getOwner() {\n        return owner;\n    }\n\n    public void setOwner(Person owner) {\n        this.owner = owner;\n    }\n\n}\n\n//类：人\npublic class Person {\n\n    private Phone phone;\n\n    public Person() {\n        \n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n\n}\n```\n\n### **2.3按多重性分类：**\n\n（1）一对一\n\n（2）一对多\n\n例：一对一\n\n```java\n//类： 电话\npublic class Phone {\n\n    // 属性：型号\n    private String type;\n\n    // 属性：颜色\n    private String color;\n\n    // 属性：品牌\n    private String brand;\n\n    // 构造方法：默认的\n    public Phone() {\n\n    }\n\n    // Getters and Setters\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n}\n\n//类：人\npublic class Person {\n\n    private Phone phone;\n\n    public Person() {\n        \n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n\n}\n```\n\n例：一对多\n\n```java\n//类： 电话\npublic class Phone {\n\n    // 属性：型号\n    private String type;\n\n    // 属性：颜色\n    private String color;\n\n    // 属性：品牌\n    private String brand;\n\n    // 构造方法\n    public Phone() {\n\n    }\n\n    // Getters and Setters\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n}\n\n\n//类：人\npublic class Person {\n    \n    //数组\n    private Phone[]  phones0 ;\n\n    //集合\n    private List<Phone> phones;\n\n    private Set<Phone> phones2;\n\n    private Map<String, Phone> phone3;\n\n    public Person() {\n        \n        this.phones0 = new Phone[3];\n\n        phones = new ArrayList<Phone>();\n\n    }\n\n}\n```', 0, 0, '2020-08-06 22:00:17', 2, 0, 1, '1、类的四种关系· 关联关系\n· 依赖关系\n· 继承关系\n· 实现关系（本质也是继承关系）\n2、关联关系在关联关系中，没有新的语法和概念，不过是一种思想。\n对象和对象之间的连接。在Java中，关联关系的代码表现形式为一个类做为另一个类的属性类型存在。即语义上是“有”的关系：”has-a”。\n2.1 按整体和部分分类：（1）组合——同生共死\n（2）聚合——不同生不同死\n区别：生命周期不同\n例：组合——同生同死\n​       创建整体时部分也同时创建，整体销毁部分也销毁\n//组合（同生同死）//人类public class People {    private String name;    private String age;    private Phone[] phones;    public People() {        phones = new Phone[3];    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getAge() {        return age;    }    public void setAge(String age) {        this.age = age;    }    public Phone[] getPhones() {        return phones;    }    public void setPhones(Phone[] phones) {        this.phones = phones;    }    @Override    public String toString() {        return \"People [name=\" + name + \", age=\" + age + \", phones=\" + Arrays.toString(phones) + \"]\";    }}//电话类public class Phone {    private String color;    private String num;    public Phone() {        // TODO Auto-generated constructor stub    }    public String getColor() {        return color;    }    public void setColor(String color) {        this.color = color;    }    public String getNum() {        return num;    }    public void setNum(String num) {        this.num = num;    }    @Override    public String toString() {        return \"Phone [color=\" + color + \", num=\" + num + \"]\";    }}//测试public class Client {    public static void main(String[] args) {        People people = new People();        people = null;        System.out.println(people.getPhones());    }}\n结果：\n\n例：聚合——不同死不同\n创建整体时部分可以不创建，整体消亡时部分还存在。\n///聚合（不同生不同死）//人类public class People {    private String name;    private String age;    private Phone[] phones;    public People() {        // TODO Auto-generated constructor stub    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getAge() {        return age;    }    public void setAge(String age) {        this.age = age;    }    public Phone[] getPhones() {        return phones;    }    public void setPhones(Phone[] phones) {        this.phones = phones;    }//电话类public class Phone {    private String color;    private String num;    public Phone() {        // TODO Auto-generated constructor stub    }    public String getColor() {        return color;    }    public void setColor(String color) {        this.color = color;    }    public String getNum() {        return num;    }    public void setNum(String num) {        this.num = num;    }    @Override    public String toString() {        return \"Phone [color=\" + color + \", num=\" + num + \"]\";    }}//测试类public class Client {    public Client() {        // TODO Auto-generated constructor stub    }    public static void main(String[] args) {        People people = new People();        Phone[] phones = new Phone[3];        people.setPhones(phones);        people = null ;         System.out.println(phones);        System.out.println(people.getPhones());    }}\n结果：\n\n2.2 按方向分类：（1）单向关联：A类关联B类\n（2）双向关联：A关联B，B也关联A\n例：单向关联\n//类： 电话public class Phone {    // 属性：型号    private String type;    // 属性：颜色    private String color;    // 属性：品牌    private String brand;    // 构造方法    public Phone() {    }    // Getters and Setters    public String getType() {        return type;    }    public void setType(String type) {        this.type = type;    }    public String getColor() {        return color;    }    public void setColor(String color) {        this.color = color;    }    public String getBrand() {        return brand;    }    public void setBrand(String brand) {        this.brand = brand;    }}//类：人public class Person {    // 属性：电话    private Phone phone;    // 构造方法：默认的    public Person() {    }    // Getters and Setters    public Phone getPhone() {        return phone;    }    public void setPhone(Phone phone) {        this.phone = phone;    }}\n例：双向关联\n//类： 电话public class Phone {    // 属性：型号    private String type;    // 属性：颜色    private String color;    // 属性：品牌    private String brand;    // 属性：所有者    private Person owner;    // 构造方法：默认的    public Phone() {    }    // Getters and Setters    public String getType() {        return type;    }    public void setType(String type) {        this.type = type;    }    public String getColor() {        return color;    }    public void setColor(String color) {        this.color = color;    }    public String getBrand() {        return brand;    }    public void setBrand(String brand) {        this.brand = brand;    }    public Person getOwner() {        return owner;    }    public void setOwner(Person owner) {        this.owner = owner;    }}//类：人public class Person {    private Phone phone;    public Person() {    }    public Phone getPhone() {        return phone;    }    public void setPhone(Phone phone) {        this.phone = phone;    }}\n2.3按多重性分类：（1）一对一\n（2）一对多\n例：一对一\n//类： 电话public class Phone {    // 属性：型号    private String type;    // 属性：颜色    private String color;    // 属性：品牌    private String brand;    // 构造方法：默认的    public Phone() {    }    // Getters and Setters    public String getType() {        return type;    }    public void setType(String type) {        this.type = type;    }    public String getColor() {        return color;    }    public void setColor(String color) {        this.color = color;    }    public String getBrand() {        return brand;    }    public void setBrand(String brand) {        this.brand = brand;    }}//类：人public class Person {    private Phone phone;    public Person() {    }    public Phone getPhone() {        return phone;    }    public void setPhone(Phone phone) {        this.phone = phone;    }}\n例：一对多\n//类： 电话public class Phone {    // 属性：型号    private String type;    // 属性：颜色    private String color;    // 属性：品牌    private String brand;    // 构造方法    public Phone() {    }    // Getters and Setters    public String getType() {        return type;    }    public void setType(String type) {        this.type = type;    }    public String getColor() {        return color;    }    public void setColor(String color) {        this.color = color;    }    public String getBrand() {        return brand;    }    public void setBrand(String brand) {        this.brand = brand;    }}//类：人public class Person {    //数组    private Phone[]  phones0 ;    //集合    private List<Phone> phones;    private Set<Phone> phones2;    private Map<String, Phone> phone3;    public Person() {        this.phones0 = new Phone[3];        phones = new ArrayList<Phone>();    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (38, '11. 类的关系——依赖关系', 8, '## 1、特点\n\n- 指一个类A使用到了另一个类B\n- 这种关系具有偶然性的，临时性，非常弱的，但类B的变化影响类A\n- 表现：类B作为参数被类A在某个方法中使用（形参）\n\n## 2、代码实现\n\n### **2.1 形式参数**\n\n```java\n//依赖关系\n\n//公交车类\npublic class Bus {\n	private int num;\n	private String name;\n	\n	public Bus() {\n		// TODO Auto-generated constructor stub\n	}	\n}\n\n\n//食物类\npublic class Food {\n	private String name;\n	private double price;\n	\n	public Food() {\n		// TODO Auto-generated constructor stub\n	}	\n}\n\n//人类（测试类）\npublic class People {\n	private String name ; \n	private int age;\n	\n	public People() {\n		// TODO Auto-generated constructor stub\n	}\n	\n	public void travel(Bus bus) {\n		\n	}\n	\n	public void eat(Food food) {\n		\n	}\n}\n```\n\n### 2.2 局部变量\n\n```java\n//类A\npublic class A {\n\n    public A() {\n\n    }\n\n    public void method() {\n        B b = new B();\n    }\n}\n\n//类B\npublic class B {\n\n    public B() {\n\n    }\n\n}\n```\n\n### 2.3 静态方法的调用\n\n```java\n//类A\npublic class A {\n\n    public A() {\n\n    }\n\n    public void method() {\n        B.staticMethod();\n    }\n\n}\n\n//类B\npublic class B {\n\n    public B() {\n\n    }\n    \n    public static void staticMethod() {\n           \n    }\n}\n```\n\n### 2.4 返回值\n\n```java\n//类A\npublic class A {\n\n    public A() {\n\n    }\n\n    public B method() {\n        return null;\n    }\n\n}\n\n//类B\npublic class B {\n\n    public B() {\n\n    }\n\n}\n```\n\n## 三、依赖与关联的区别\n\n**关联是“HAS”关系，依赖是“USE”关系**\n-A类关联B类，指的是B类对象作为A类的属性存在，称为“has”关系。\n-A类依赖B类，指的是B的对象作为A类的方法形式参数存在，称为“use”关系。当然，也包括局部变量、返回值类型和静态方法调用这三种场景。\n**生命周期不同**\n-如果A类关联B类，那么创建A类的对象时实例化B类的对象，直到A类对象被销毁，所关联的B类对象也被销毁。即只要A类对象存在，B类对象就存在。\n-如果A类依赖B类，那么只有当A类对象调用到相应方法时，B类对象才被临时创建，方法执行结束，B类对象即被回收，A类和B类之间的依赖关系是一种瞬时的关系。\n\n\n\n## 四、经典案例\n\n### 4.1 发送器和消息\n\n```java\n//类：发送器\npublic class Sender {\n    \n    public Sender() {\n        \n    }\n    \n    public void send(Message message) {\n        \n        \n    }\n\n}\n\n//类：消息\npublic class Message {\n    \n    public Message() {\n        \n    }\n\n}\n```\n\n### 4.2 Java API静态方法\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n\n        // 常用静态方法\n        long currentTime = System.currentTimeMillis();\n\n        double randomNum = Math.random();\n\n        int num = Integer.parseInt(\"100\");\n\n        String string = String.valueOf(true);\n\n        DateFormat dateFormat = DateFormat.getDateInstance();\n\n    }\n\n}\n```', 0, 0, '2020-08-06 22:00:44', 2, 0, 1, '1、特点\n指一个类A使用到了另一个类B这种关系具有偶然性的，临时性，非常弱的，但类B的变化影响类A表现：类B作为参数被类A在某个方法中使用（形参）\n2、代码实现2.1 形式参数//依赖关系//公交车类public class Bus {    private int num;    private String name;    public Bus() {        // TODO Auto-generated constructor stub    }    }//食物类public class Food {    private String name;    private double price;    public Food() {        // TODO Auto-generated constructor stub    }    }//人类（测试类）public class People {    private String name ;     private int age;    public People() {        // TODO Auto-generated constructor stub    }    public void travel(Bus bus) {    }    public void eat(Food food) {    }}\n2.2 局部变量//类Apublic class A {    public A() {    }    public void method() {        B b = new B();    }}//类Bpublic class B {    public B() {    }}\n2.3 静态方法的调用//类Apublic class A {    public A() {    }    public void method() {        B.staticMethod();    }}//类Bpublic class B {    public B() {    }    public static void staticMethod() {    }}\n2.4 返回值//类Apublic class A {    public A() {    }    public B method() {        return null;    }}//类Bpublic class B {    public B() {    }}\n三、依赖与关联的区别关联是“HAS”关系，依赖是“USE”关系-A类关联B类，指的是B类对象作为A类的属性存在，称为“has”关系。-A类依赖B类，指的是B的对象作为A类的方法形式参数存在，称为“use”关系。当然，也包括局部变量、返回值类型和静态方法调用这三种场景。生命周期不同-如果A类关联B类，那么创建A类的对象时实例化B类的对象，直到A类对象被销毁，所关联的B类对象也被销毁。即只要A类对象存在，B类对象就存在。-如果A类依赖B类，那么只有当A类对象调用到相应方法时，B类对象才被临时创建，方法执行结束，B类对象即被回收，A类和B类之间的依赖关系是一种瞬时的关系。\n四、经典案例4.1 发送器和消息//类：发送器public class Sender {    public Sender() {    }    public void send(Message message) {    }}//类：消息public class Message {    public Message() {    }}\n4.2 Java API静态方法public class Client {    public static void main(String[] args) {        // 常用静态方法        long currentTime = System.currentTimeMillis();        double randomNum = Math.random();        int num = Integer.parseInt(\"100\");        String string = String.valueOf(true);        DateFormat dateFormat = DateFormat.getDateInstance();    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (39, '12.类的关系——继承关系', 8, '## 1、继承关系\n\n### 1.1 继承的概念\n\n·继承机制是面向对象程序设计不可缺少的关键概念，是实现**代码可重用**的根基，是提高软件系统的可拓展性与可维护性的主要途径。\n\n·所谓继承是指一个类的定义可以基于另外一个已经存在的类，即子类基于父类，从而实现父类代码的重用，**子类能吸收已有类的属性和行为，并能拓展新的能力**。\n\n**形式：【访问权限修饰符】【修饰符】子类名 extends 父类名{子类体}**\n\n**例：**\n\n```java\n//类：图形\npublic class Shape {\n\n    private int x;\n\n    private int y;\n\n    public Shape() {\n\n    }\n\n    // 方法：绘图\n    public void draw() {\n\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n}\n\n//类：圆形\npublic class Circle extends Shape {\n\n    private int r;\n\n    public Circle() {\n\n    }\n\n    // 方法：获取直径\n    public int getDiameter() {\n\n        return 2 * r;\n    }\n\n    public int getR() {\n        return r;\n    }\n\n    public void setR(int r) {\n        this.r = r;\n    }\n\n}\n```\n\n我们观察上面的代码发现，类Circle的定义中通过使用extends关键字继承了类Shape，此时，我们把Shape称为Circle的父类，反之，把Circle称为Shape的子类。而且，子类Circle新增了半径属性r，新增了获取直径的方法getDiameter()。\n\n### **1.2 继承的作用**\n\n继承的主要作用是代码复用。代码表现为子类对象可以直接调用父类的属性和方法。\n\n```java\n//类：使用场景\npublic class Client {\n\n    public static void main(String[] args) {\n\n        Circle circle = new Circle();\n\n        // 访问父类的属性和方法\n        circle.setX(1);\n        circle.setY(1);\n\n        circle.draw();\n\n        // 访问子类的属性和方法\n        circle.setR(9);\n\n        circle.getDiameter();\n\n    }\n\n}\n```\n\n### 1.3 构造方法与继承\n\n子类构造方法总是先调用父类构造方法。\n\n默认情况下，调用父类无参构造方法。\n\n可以在子类构造方法的第一行，使用super关键字调用父类任意一个构造方法。\n\n#### 1.3.1 继承中构造方法的调用\n\n子类构造方法总是先调用父类构造方法。\n\n默认情况下，调用父类无参构造方法。\n\n可以在子类构造方法的第一行，使用super关键字调用父类任意一个构造方法。\n\n```java\n//类：图形\npublic class Shape {\n\n    public int x;\n\n    public int y;\n\n    public Shape() {\n\n        System.out.println(\"这是父类的无参构造方法！\");\n\n    }\n\n    public Shape(int x, int y) {\n\n        this.x = x;\n        this.y = y;\n\n        System.out.println(\"这是父类的有参构造方法！\");\n    }\n\n    public void draw() {\n\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n}\n\n//类：圆形\npublic class Circle extends Shape {\n\n    private int r;\n\n    public Circle() {\n\n        // super();\n        // super(0, 0);\n\n        System.out.println(\"这是子类的无参构造方法！\");\n\n    }\n\n    // 方法：获取直径\n    public int getDiameter() {\n\n        return 2 * r;\n    }\n\n    public int getR() {\n        return r;\n    }\n\n    public void setR(int r) {\n        this.r = r;\n    }\n\n}\n\n//测试\npublic class Client {\n\n    public static void main(String[] args) {\n\n        Circle circle = new Circle();\n\n    }\n\n}\n\n//输出\n这是父类的无参构造方法！\n这是子类的无参构造方法！\n```\n\n#### 1.3.2 子类调用父类构造方法的原因\n\n Java 语言中，要求子类有责任保证它所继承的父类尽快进入到一个稳定、完整的状态中。如果没有这个约束，那么子类的某个继承自父类的方法可能会使用到父类中的一些变量，而这些变量并没有进行初始化，从而产生一些难以预料的后果。\n\n#### 1.3.3 子类构造方法的执行详解\n\n​     必须将调用父类构造方法的这条语句放在子类构造方法的第一条语句位置。如果第一条语句没有调用父类的构造方法，系统将会自动地在这个位置上插入一条调用父类默认构造方法的语句,即super();     由于默认的构造方法不带参数，所以，如果在父类中定义了带参数的构造方法，而没有定义不带参数的构造方法将会出现编译错误。这也正是建议大家在定义带参数的构造方法时，一定要定义一个不带参数的构造方法的原因所在。     父类中那些带参数的构造方法，子类将不会自动地调用它们，必须人工地将调用它们的语句写入子类的构造方法中。\n\n## 2、this关键字\n\n​      this关键字其实与继承没有关系，之所以放在这里学习，是因为this和super的作用非常类似。都有两大作用，即调用属性和方法，调用构造方法。区别是，this调用的都是本类的，super调用的都是父类的。\n\n### 2.1 this关键字用途\n\n####  2.1.1 this关键字代表类自身\n\n​      使用this关键字在自身构造方法内部引用其它构造方法。      在一个类的构造方法内部，也可以使用this关键字引用其它的构造方法，这样可以降低代码的重复，也可以使所有的构造方法保持统一，这样方便以后的代码修改和维护，也方便代码的阅读。\n\n例：\n\n```java\n public class Demo {\n\n    private int a;\n\n    private int b;\n\n    public Demo() {\n\n        // this引用构造方法\n        this(1, 2);\n\n    }\n\n    public Demo(int a, int b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n\n    public int getA() {\n        return a;\n    }\n\n    public void setA(int a) {\n        this.a = a;\n    }\n\n    public int getB() {\n        return b;\n    }\n\n    public void setB(int b) {\n        this.b = b;\n    }\n\n}\n```\n\n#### 2.1.2 this关键字代表自身类的对象\n\n-直接使用this\n\n-使用this关键字引用成员变量\n\n-使用this关键字引用成员方法\n\n注意：this关键字必须放在非静态方法里面\n\n**this代表自身对象** 在一个类的内部，也可以使用this代表自身类的对象，或者换句话说，每个类内部都有一个隐含的成员变量，该成员变量的类型是该类的类型，该成员变量的名称是this \n\n```java\npublic class Demo {\n\n    private Demo instance;\n\n    public Demo() {\n\n        instance = this;\n\n    }\n\n}\n```\n\n **this引用成员变量** 在一个类的方法或构造方法内部，可以使用“this.成员变量名”这样的格式来引用成员变量名，常常用来区分同名的成员变量和局部变量。\n\n```java\npublic class Demo {\n\n    private int a;\n\n    private int b;\n\n    public Demo() {\n\n    }\n\n    public int getA() {\n        return a;\n    }\n\n    public void setA(int a) {\n        // this引用成员变量\n        this.a = a;\n    }\n\n    public int getB() {\n        return b;\n    }\n\n    public void setB(int b) {\n        // this引用成员变量\n        this.b = b;\n    }\n\n}\n```\n\n **this引用成员方法** 在一个类的内部，成员方法之间的互相调用时也可以使用“this.方法名(参数)”来进行引用。 \n\n```java\npublic class Demo {\n\n    public Demo() {\n\n    }\n\n    public void method1() {\n\n        //this引用成员方法\n        this.method2();\n\n    }\n\n    public void method2() {\n\n    }\n\n}\n```\n\n## 3、super关键字\n\nsuper关键字的使用方式与this很类似，不过super一定是在继承关系中使用，指的是父类或者父类的对象。\n\n### 3.1 super关键字用途\n\n#### 3.1.1 super代表父类\n\n在子类构造方法中要调用父类的构造方法，需要注意：super语句只能出现在子类构造方法体的第一行。\n\n#### 3.1.2 super调用父类成员变量\n\n当子类方法体中的局部变量或者子类的成员变量与父类成员变量同名时，即子类局部变量覆盖父类成员变量时，用“super.成员变量名”来引用父类成员变量\n\n#### 3.1.3 super调用父类的成员方法\n\n 当子类的成员方法覆盖了父类的成员方法时，也就是子类和父类有完全相同的方法定义（方法体可以不同），此时，用“super.方法名（参数列表）”的方式访问父类的方法。\n\n#### 3.2 super与this的区别\n\nthis通常指代当前对象，super通常指代父类。\n\n## 4、方法覆盖\n\n​      继承的作用就是复用，即子类直接使用父类的属性和方法。\n\n然而，有些时候，子类希望修改父类的方法的方法体，可以怎么做呢？\n\n​      第一种做法是子类创建一个不同名字的新方法，实现新的逻辑，然而，这种做法会导致子类依然包含父类中的那个方法，却不应该使用，破坏封装性。      第二种我们希望子类中的方法依然和父类方法的声明形式一样，但是具体方法体却不同，这种做法就叫做**方法覆盖**。\n\n 建议：抽象这章从头到尾使用一个例子扩展，一直到抽象部分。\n\n###  4.1方法覆盖定义及原则\n\n####  4.1.1方法覆盖的定义\n\n​     子类可以重写父类中某一个方法，称为方法覆盖，也称方法重写，是继承中非常重要的知识点。如果子类需要修改从父类继承到的方法的方法体，就可以使用方法覆盖。\n\n#### 4.1.2 方法覆盖的原则\n\n同名 同参 同返回值 访问权限不能缩小\n\n方法覆盖例子：\n\n//父类\n\n```java\npublic class Animal {\n	String name;\n	Integer age;\n\n	public Animal() {\n\n	}\n\n	public Animal(String name, Integer age) {\n		this.name = name;\n		this.age = age;\n	}\n\n	void run() {\n		System.out.println(\"一只\" + this.age + \"岁的\" + this.name + \"在奔跑!~~\");\n	}\n\n	void sound() {\n		System.out.println(\"一只\" + this.age + \"岁的\" + this.name + \"在吼叫!~~\");\n	}\n}\n```\n\n//子类：\n\n```java\npublic class Tiger extends Animal {\n	String color;\n\n	public Tiger(String name, Integer age, String color) {\n		super(name, age);\n\n		this.color = color;\n	}\n\n	void hunt() {\n		System.out.println(\"一只\" + this.color + \"的\" + this.name + \"在捕猎!~~\");\n	}\n\n	void sound() {\n		System.out.print(\"我是一只老虎~\");\n		super.sound();\n	}\n}\n```\n\n​      此处可以提使用tigerSound（）方法，而不使用方法覆盖的方式，sound（）会被tiger类继承，这违反了面向对象的封装性特征。对象封装了属性和方法，对象的属性和方法都是该对象可以使用的。因此，上面的方法虽然实现了新算法，却存在严重漏洞，破坏了对象的封装性。如果子类需要修改自父类继承到的新方法，可以使用“方法覆盖”来完成。在子类中，声明一个与父类同名、同参、同返回值类型、访问权限不缩小的方法，就可以将父类中的方法覆盖。子类对象调用该方法，将自动绑定到子类覆盖后的新方法。\n\n示例代码-测试类\n\n```java\npublic class Tester {\n\n	public static void main(String[] args) {\n\n		Tiger t = new Tiger(\"东北虎\", 1, \"白色\");\n\n		t.sound();\n\n	}\n}\n```\n\n', 0, 0, '2020-08-06 22:01:15', 2, 0, 1, '1、继承关系1.1 继承的概念·继承机制是面向对象程序设计不可缺少的关键概念，是实现代码可重用的根基，是提高软件系统的可拓展性与可维护性的主要途径。\n·所谓继承是指一个类的定义可以基于另外一个已经存在的类，即子类基于父类，从而实现父类代码的重用，子类能吸收已有类的属性和行为，并能拓展新的能力。\n形式：【访问权限修饰符】【修饰符】子类名 extends 父类名{子类体}\n例：\n//类：图形public class Shape {    private int x;    private int y;    public Shape() {    }    // 方法：绘图    public void draw() {    }    public int getX() {        return x;    }    public void setX(int x) {        this.x = x;    }    public int getY() {        return y;    }    public void setY(int y) {        this.y = y;    }}//类：圆形public class Circle extends Shape {    private int r;    public Circle() {    }    // 方法：获取直径    public int getDiameter() {        return 2 * r;    }    public int getR() {        return r;    }    public void setR(int r) {        this.r = r;    }}\n我们观察上面的代码发现，类Circle的定义中通过使用extends关键字继承了类Shape，此时，我们把Shape称为Circle的父类，反之，把Circle称为Shape的子类。而且，子类Circle新增了半径属性r，新增了获取直径的方法getDiameter()。\n1.2 继承的作用继承的主要作用是代码复用。代码表现为子类对象可以直接调用父类的属性和方法。\n//类：使用场景public class Client {    public static void main(String[] args) {        Circle circle = new Circle();        // 访问父类的属性和方法        circle.setX(1);        circle.setY(1);        circle.draw();        // 访问子类的属性和方法        circle.setR(9);        circle.getDiameter();    }}\n1.3 构造方法与继承子类构造方法总是先调用父类构造方法。\n默认情况下，调用父类无参构造方法。\n可以在子类构造方法的第一行，使用super关键字调用父类任意一个构造方法。\n1.3.1 继承中构造方法的调用子类构造方法总是先调用父类构造方法。\n默认情况下，调用父类无参构造方法。\n可以在子类构造方法的第一行，使用super关键字调用父类任意一个构造方法。\n//类：图形public class Shape {    public int x;    public int y;    public Shape() {        System.out.println(\"这是父类的无参构造方法！\");    }    public Shape(int x, int y) {        this.x = x;        this.y = y;        System.out.println(\"这是父类的有参构造方法！\");    }    public void draw() {    }    public int getX() {        return x;    }    public void setX(int x) {        this.x = x;    }    public int getY() {        return y;    }    public void setY(int y) {        this.y = y;    }}//类：圆形public class Circle extends Shape {    private int r;    public Circle() {        // super();        // super(0, 0);        System.out.println(\"这是子类的无参构造方法！\");    }    // 方法：获取直径    public int getDiameter() {        return 2 * r;    }    public int getR() {        return r;    }    public void setR(int r) {        this.r = r;    }}//测试public class Client {    public static void main(String[] args) {        Circle circle = new Circle();    }}//输出这是父类的无参构造方法！这是子类的无参构造方法！\n1.3.2 子类调用父类构造方法的原因 Java 语言中，要求子类有责任保证它所继承的父类尽快进入到一个稳定、完整的状态中。如果没有这个约束，那么子类的某个继承自父类的方法可能会使用到父类中的一些变量，而这些变量并没有进行初始化，从而产生一些难以预料的后果。\n1.3.3 子类构造方法的执行详解​     必须将调用父类构造方法的这条语句放在子类构造方法的第一条语句位置。如果第一条语句没有调用父类的构造方法，系统将会自动地在这个位置上插入一条调用父类默认构造方法的语句,即super();     由于默认的构造方法不带参数，所以，如果在父类中定义了带参数的构造方法，而没有定义不带参数的构造方法将会出现编译错误。这也正是建议大家在定义带参数的构造方法时，一定要定义一个不带参数的构造方法的原因所在。     父类中那些带参数的构造方法，子类将不会自动地调用它们，必须人工地将调用它们的语句写入子类的构造方法中。\n2、this关键字​      this关键字其实与继承没有关系，之所以放在这里学习，是因为this和super的作用非常类似。都有两大作用，即调用属性和方法，调用构造方法。区别是，this调用的都是本类的，super调用的都是父类的。\n2.1 this关键字用途2.1.1 this关键字代表类自身​      使用this关键字在自身构造方法内部引用其它构造方法。      在一个类的构造方法内部，也可以使用this关键字引用其它的构造方法，这样可以降低代码的重复，也可以使所有的构造方法保持统一，这样方便以后的代码修改和维护，也方便代码的阅读。\n例：\n public class Demo {    private int a;    private int b;    public Demo() {        // this引用构造方法        this(1, 2);    }    public Demo(int a, int b) {        super();        this.a = a;        this.b = b;    }    public int getA() {        return a;    }    public void setA(int a) {        this.a = a;    }    public int getB() {        return b;    }    public void setB(int b) {        this.b = b;    }}\n2.1.2 this关键字代表自身类的对象-直接使用this\n-使用this关键字引用成员变量\n-使用this关键字引用成员方法\n注意：this关键字必须放在非静态方法里面\nthis代表自身对象 在一个类的内部，也可以使用this代表自身类的对象，或者换句话说，每个类内部都有一个隐含的成员变量，该成员变量的类型是该类的类型，该成员变量的名称是this \npublic class Demo {    private Demo instance;    public Demo() {        instance = this;    }}\n this引用成员变量 在一个类的方法或构造方法内部，可以使用“this.成员变量名”这样的格式来引用成员变量名，常常用来区分同名的成员变量和局部变量。\npublic class Demo {    private int a;    private int b;    public Demo() {    }    public int getA() {        return a;    }    public void setA(int a) {        // this引用成员变量        this.a = a;    }    public int getB() {        return b;    }    public void setB(int b) {        // this引用成员变量        this.b = b;    }}\n this引用成员方法 在一个类的内部，成员方法之间的互相调用时也可以使用“this.方法名(参数)”来进行引用。 \npublic class Demo {    public Demo() {    }    public void method1() {        //this引用成员方法        this.method2();    }    public void method2() {    }}\n3、super关键字super关键字的使用方式与this很类似，不过super一定是在继承关系中使用，指的是父类或者父类的对象。\n3.1 super关键字用途3.1.1 super代表父类在子类构造方法中要调用父类的构造方法，需要注意：super语句只能出现在子类构造方法体的第一行。\n3.1.2 super调用父类成员变量当子类方法体中的局部变量或者子类的成员变量与父类成员变量同名时，即子类局部变量覆盖父类成员变量时，用“super.成员变量名”来引用父类成员变量\n3.1.3 super调用父类的成员方法 当子类的成员方法覆盖了父类的成员方法时，也就是子类和父类有完全相同的方法定义（方法体可以不同），此时，用“super.方法名（参数列表）”的方式访问父类的方法。\n3.2 super与this的区别this通常指代当前对象，super通常指代父类。\n4、方法覆盖​      继承的作用就是复用，即子类直接使用父类的属性和方法。\n然而，有些时候，子类希望修改父类的方法的方法体，可以怎么做呢？\n​      第一种做法是子类创建一个不同名字的新方法，实现新的逻辑，然而，这种做法会导致子类依然包含父类中的那个方法，却不应该使用，破坏封装性。      第二种我们希望子类中的方法依然和父类方法的声明形式一样，但是具体方法体却不同，这种做法就叫做方法覆盖。\n 建议：抽象这章从头到尾使用一个例子扩展，一直到抽象部分。\n4.1方法覆盖定义及原则4.1.1方法覆盖的定义​     子类可以重写父类中某一个方法，称为方法覆盖，也称方法重写，是继承中非常重要的知识点。如果子类需要修改从父类继承到的方法的方法体，就可以使用方法覆盖。\n4.1.2 方法覆盖的原则同名 同参 同返回值 访问权限不能缩小\n方法覆盖例子：\n//父类\npublic class Animal {    String name;    Integer age;    public Animal() {    }    public Animal(String name, Integer age) {        this.name = name;        this.age = age;    }    void run() {        System.out.println(\"一只\" + this.age + \"岁的\" + this.name + \"在奔跑!~~\");    }    void sound() {        System.out.println(\"一只\" + this.age + \"岁的\" + this.name + \"在吼叫!~~\");    }}\n//子类：\npublic class Tiger extends Animal {    String color;    public Tiger(String name, Integer age, String color) {        super(name, age);        this.color = color;    }    void hunt() {        System.out.println(\"一只\" + this.color + \"的\" + this.name + \"在捕猎!~~\");    }    void sound() {        System.out.print(\"我是一只老虎~\");        super.sound();    }}\n​      此处可以提使用tigerSound（）方法，而不使用方法覆盖的方式，sound（）会被tiger类继承，这违反了面向对象的封装性特征。对象封装了属性和方法，对象的属性和方法都是该对象可以使用的。因此，上面的方法虽然实现了新算法，却存在严重漏洞，破坏了对象的封装性。如果子类需要修改自父类继承到的新方法，可以使用“方法覆盖”来完成。在子类中，声明一个与父类同名、同参、同返回值类型、访问权限不缩小的方法，就可以将父类中的方法覆盖。子类对象调用该方法，将自动绑定到子类覆盖后的新方法。\n示例代码-测试类\npublic class Tester {    public static void main(String[] args) {        Tiger t = new Tiger(\"东北虎\", 1, \"白色\");        t.sound();    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (40, '13. Java类中的封装', 8, '## 1、Java类中的封装\n\n学习了访问权限修饰符后，应该可以理解封装性的概念和含义。封装性是面向对象三大特征之一 **封装性是一种信息隐藏技术**\n\n## **2、封装的概念**\n\n在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。\n\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。\n\n要访问该类的代码和数据，必须通过严格的接口控制。\n\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n## **3、两个含义：**\n\n-对象的全部属性和全部方法结合在一起，形成一个不可分割的独立单位 -尽可能隐藏对象的内部结构\n\n##  **4、具体表现：**\n\n-属性使用private权限 -方法使用public权限\n\n## 5、封装的优点\n\n- 良好的封装能够减少耦合。\n- 类内部的结构可以自由修改。\n- 可以对成员变量进行更精确的控制。\n- 隐藏信息，实现细节。\n\n## 6、封装的步骤\n\n1. 修改属性的可见性来限制对属性的访问（一般限制为private）\n\n2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问\n\n3. 重写从父类Object继承下来的toString()方法，来输出自己想要的信息。\n\n4. 重写从父类Object继承的hashCode()方法，计算hashCode值，hashCode值主要用来判断对象的属性是否相同，进行数组的排序。\n\n5. 重写从父类Object继承的equals()方法，判断两个对象属性值是否完全相同。\n\n 示例：\n\n```java\npackage com.company.practice.demo;\n\npublic class User {\n\n    private String name;\n\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n}\n```\n\n完整代码：\n\n```java\npackage com.company.practice.demo;\n\npublic class User {\n\n    private String name;\n\n    private int age;\n\n    public User() {\n\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + age;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        User other = (User) obj;\n        if (age != other.age)\n            return false;\n        if (name == null) {\n            if (other.name != null)\n                return false;\n        } else if (!name.equals(other.name))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"User [name=\" + name + \", age=\" + age + \"]\";\n    }\n\n}\n```', 0, 0, '2020-08-06 22:07:17', 2, 0, 1, '1、Java类中的封装学习了访问权限修饰符后，应该可以理解封装性的概念和含义。封装性是面向对象三大特征之一 封装性是一种信息隐藏技术\n2、封装的概念在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。\n要访问该类的代码和数据，必须通过严格的接口控制。\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n3、两个含义：-对象的全部属性和全部方法结合在一起，形成一个不可分割的独立单位 -尽可能隐藏对象的内部结构\n4、具体表现：-属性使用private权限 -方法使用public权限\n5、封装的优点\n良好的封装能够减少耦合。类内部的结构可以自由修改。可以对成员变量进行更精确的控制。隐藏信息，实现细节。\n6、封装的步骤\n修改属性的可见性来限制对属性的访问（一般限制为private）\n对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问\n重写从父类Object继承下来的toString()方法，来输出自己想要的信息。\n重写从父类Object继承的hashCode()方法，计算hashCode值，hashCode值主要用来判断对象的属性是否相同，进行数组的排序。\n重写从父类Object继承的equals()方法，判断两个对象属性值是否完全相同。\n示例：\n\npackage com.company.practice.demo;public class User {    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}\n完整代码：\npackage com.company.practice.demo;public class User {    private String name;    private int age;    public User() {    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        User other = (User) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }    @Override    public String toString() {        return \"User [name=\" + name + \", age=\" + age + \"]\";    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (41, '14.  类的关系——抽象', 8, '##  1、 Java抽象类\n\n在继承中，抽象是一个非常重要的概念。 类可以是抽象的，方法也可以是抽象的。\n\n​     如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 如形状类是抽象的类，圆、三角形等是具体类。      用abstract修饰的类就是抽象类。如果某个类中包含有抽象方法，那么该类就必须定义成抽象类。但是抽象类中不一定有抽象方法。      在面向对象的概念中，知道所有的对象都是通过类来描绘的，但是反过来却不是这样。并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。       比如：如果我们进行一个图形编辑软件的开发，就会发现问题领域存在着圆、 三角形这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域是不存在的，它就是一个抽象概念。\n\n### 1.1抽象类的定义语法\n\n[访问权限] abstract class 类名 { 成员列表 }\n\n```java\npublic abstract class Shapes {\npublic abstract void draw();\n}\n\n public abstract class Shapes {\npublic void draw(){\n//具体代码\n}\n}\n```\n\n### 1.2抽象类的注意描述\n\n**·** 用abstract修饰的类就是抽象类\n\n**·**如果有抽象方法，就必须把类定义为抽象类；但抽象类不一定有抽象方法。\n\n**·**抽象类可以有成员属性和非抽象成员方法\n\n**·**抽象类不可以被实例化，但可以有构造方法。（构造方法的作用用于子类对父类属性的赋值）。\n\n**·**抽象类只能作为基类，表示一种继承关系。\n\n**·**继承抽象类的非抽象类必须实现其中的所有抽象方法，而已实现方法的参数、返回值要和抽象类的方法一样。否则，该类也必须声明为抽象类。\n\n**·**构造方法和静态方法不可以修饰为abstract。\n\n## 2、抽象方法\n\n​      有时候，父类中的某一个方法，每一个子类都要去重写。这种情况下，父类中的这个方法，就没有必要有方法体，因为子类都不会直接使用，都要重写。\n\n​      要强调，软件工程中，往往是要有需求分析，设计，再到编码。在设计阶段，设计人员要想办法让程序员知道某些类中应该实现哪些功能的，也就是what to do。父类往往都是设计人员设计的。因此不能把这样的方法删除掉，如果删除，就没有办法约束子类必须实现这些方法。这种时候，就把父类中的这样的方法的方法体去掉，就成为抽象方法。 抽象方法定义了what to do，而how to do在子类中实现。\n\n### 2.1抽象方法的概念\n\n​      在某些情况下，类无法（或者没有必要）提供方法的具体实现，可以将此方法声明成抽象方法；\n\n​       在类中没有方法体的方法，就是抽象方法；\n\n​       含有抽象方法的类，一定是抽象类。       抽象方法只需声明，而不需实现某些功能。\n\n###  2.2抽象方法的语法\n\n使用关键字abstract声明抽象方法，一般语法：\n\n[访问权限] abstract 返回值类型 方法名称(参数列表);\n\n如： public abstract void draw();\n\n抽象方法的作用就是定义 How to do，而what to do留到子类去实现\n\n###  2.3抽象的作用\n\n **·**抽象最核心的作用是用来实现应用的可扩展性。 **·**在面向对象领域，抽象类主要用来进行类型隐藏；也就是使用抽象的类型来编程，但是具体运行时就可以使用具体类型。 **·**利用抽象的概念，能够在开发项目中创建扩展性很好的架构，优化程序。 **·**抽象类，抽象方法，在软件开发过程中都是设计层面的概念。也就是说，设计人员会设计出抽象类，抽象方法，程序员都是来继承这些抽象类并覆盖抽象方法，实现具体功能。  例子：\n\n人物穿装备和脱装备\n\n场景：游戏中有一个人，人会有自己的装备位用来装装备，有个鞋子位和一个武器位，装备每个位置只能穿一件，如果穿第二件就会先把第一件脱了再穿上第二件，每次穿脱装备都会有属性的改变。\n\n首先抽象出鞋子和武器统称为装备，先定义抽象类武器类\n\n```java\n//装备抽象\npublic abstract class Equip {\n	// 装备名\n	private String name;\n\n	// 攻击力\n	private int atk;\n\n	// 护甲值\n	private int protectValue;\n\n	public Equip() {\n		// TODO Auto-generated constructor stub\n	}\n\n	//增加攻击力\n	public abstract void addAtk(People people);\n	\n	\n	//增加护甲值\n	public abstract void addProtectValue(People people);\n\n	public String getName() {\n		return name;\n	}\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public int getAtk() {\n		return atk;\n	}\n\n	public void setAtk(int atk) {\n		this.atk = atk;\n	}\n\n	public int getProtectValue() {\n		return protectValue;\n	}\n\n	public void setProtectValue(int protectValue) {\n		this.protectValue = protectValue;\n	}\n\n	@Override\n	public String toString() {\n		return \"Equip [name=\" + name + \", atk=\" + atk + \", protectValue=\" + protectValue + \"]\";\n	}\n\n	\n}\n```\n\n其次，定义鞋子类和武器类，继承装备抽象类\n\n```java\n//鞋子类\npublic class Shoe extends Equip {\n\n	public Shoe(String name, int atk, int protectValue) {\n		// TODO Auto-generated constructor stub\n		super.setName(name);\n		super.setProtectValue(protectValue);\n		super.setAtk(atk);\n	}\n\n	public void addAtk(People people) {\n		// TODO Auto-generated method stub\n		people.setAtk(people.getAtk() + this.getAtk());\n\n		System.out.println(\"攻击力上升\" + this.getAtk());\n\n	}\n\n	public void addProtectValue(People people) {\n		// TODO Auto-generated method stub\n		people.setProtectValue(people.getProtectValue() + this.getProtectValue());\n\n		System.out.println(\"护甲值上升\" + this.getProtectValue());\n\n	}\n\n}\n//武器类\npublic class Weapon extends Equip {\n\n	public Weapon(String name, int atk,int protectValue) {\n		// TODO Auto-generated constructor stub\n		super.setName(name);\n		super.setProtectValue(protectValue);\n		super.setAtk(atk);\n	}\n	@Override\n	public void addAtk(People people) {\n		// TODO Auto-generated method stub\n		people.setAtk(people.getAtk() + this.getAtk());\n		System.out.println(\"攻击力上升\" + this.getAtk());\n	}\n\n	@Override\n	public void addProtectValue(People people) {\n		// TODO Auto-generated method stub\n		people.setProtectValue(people.getProtectValue() + this.getProtectValue());\n		\n		System.out.println(\"护甲值上升\" + this.getProtectValue());\n		\n	}	\n	\n}\n```\n\n再定义一个人类\n\n```java\n//人类\npublic class People {\n	\n	//人物名字\n	private String name;\n	\n	// 攻击力\n	private int atk;\n\n	//护甲值\n	private int protectValue;\n	\n	//鞋子位\n	private Shoe shoe;\n	\n	//武器位\n	private Weapon weapon;\n	\n	public People(String name, int atk,int protectValue) {\n		// TODO Auto-generated constructor stub\n		this.name = name;\n		this.atk = atk;\n		this.protectValue = protectValue;\n	}\n	\n	\n	\n	//穿装备\n	public void putOn(Equip equip) {\n		\n		System.out.println(this.name + \"捡了\"+ equip.getName());\n\n		//判断装备属于鞋子，是的话穿到鞋子位\n		if (equip instanceof Shoe) {\n			//判断鞋子位是否为空，不为空脱掉已穿的，更换鞋子\n			if(this.getShoe()!= null) {\n				this.getOff(this.shoe);\n			}\n			this.shoe = (Shoe)equip;\n		}\n		//判断装备属于武器，是的话穿到武器位\n		else if(equip instanceof Weapon) {\n			//判断武器位是否为空，不为空脱掉已带的，更换武器\n			if(this.getWeapon()!= null) {\n				this.getOff(this.weapon);\n			}\n			this.weapon = (Weapon)equip;\n		}\n		System.out.println(equip.toString());\n		equip.addAtk(this);\n		equip.addProtectValue(this);\n		System.out.println(this.toString());\n	}\n	\n	//脱装备\n	public void getOff(Equip equip) {\n		System.out.println(this.name + \"脱了\"+ equip.getName());\n		System.out.println(equip.toString());\n		System.out.println(\"攻击力下降\" + equip.getAtk());\n		\n		this.setAtk(this.getAtk() - equip.getAtk());\n		\n		this.setProtectValue(this.getProtectValue() - equip.getProtectValue());\n		System.out.println(\"护甲值下降\" + equip.getProtectValue());\n		System.out.println(this.toString());\n		\n		//判断装备属于鞋子\n		if (equip instanceof Shoe) {\n			//清空鞋子位\n			this.shoe = null;\n		}\n		//判断装备属于武器\n		else if(equip instanceof Weapon) {\n			//清空装备位\n			this.weapon = null;\n		}\n	}\n	\n	\n	\n	@Override\n	public String toString() {\n		return \"People [name=\" + name + \", atk=\" + atk + \", protectValue=\" + protectValue + \"]\";\n	}\n\n	public String getName() {\n		return name;\n	}\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public int getAtk() {\n		return atk;\n	}\n\n	public void setAtk(int atk) {\n		this.atk = atk;\n	}\n\n	public int getProtectValue() {\n		return protectValue;\n	}\n\n	public void setProtectValue(int protectValue) {\n		this.protectValue = protectValue;\n	}\n\n\n\n	public Shoe getShoe() {\n		return shoe;\n	}\n\n\n\n	public void setShoe(Shoe shoe) {\n		this.shoe = shoe;\n	}\n\n\n\n	public Weapon getWeapon() {\n		return weapon;\n	}\n\n\n\n	public void setWeapon(Weapon weapon) {\n		this.weapon = weapon;\n	}\n	\n	\n}\n```\n\n最后，我们来测试一下我们的穿脱装备\n\n```java\npublic class Client {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		People people = new People(\"周凡\", 0, 0);\n		Shoe shoe = new Shoe(\"护甲鞋\", 0, 100);\n		Shoe shoe1 = new Shoe(\"攻速鞋\", 0, 100);\n		Weapon weapon = new Weapon(\"暴风大剑\", 100, 0);\n		\n		people.putOn(shoe);\n		people.putOn(shoe1);\n		people.getOff(shoe1);\n		people.putOn(shoe);\n		people.putOn(weapon);\n		\n		people.getOff(weapon);\n		\n		\n	}\n\n}\n```\n\n结果：\n\n```java\n周凡捡了护甲鞋\nEquip [name=护甲鞋, atk=0, protectValue=100]\n攻击力上升0\n护甲值上升100\nPeople [name=周凡, atk=0, protectValue=100]\n周凡捡了攻速鞋\n周凡脱了护甲鞋\nEquip [name=护甲鞋, atk=0, protectValue=100]\n攻击力下降0\n护甲值下降100\nPeople [name=周凡, atk=0, protectValue=0]\nEquip [name=攻速鞋, atk=0, protectValue=100]\n攻击力上升0\n护甲值上升100\nPeople [name=周凡, atk=0, protectValue=100]\n周凡脱了攻速鞋\nEquip [name=攻速鞋, atk=0, protectValue=100]\n攻击力下降0\n护甲值下降100\nPeople [name=周凡, atk=0, protectValue=0]\n周凡捡了护甲鞋\nEquip [name=护甲鞋, atk=0, protectValue=100]\n攻击力上升0\n护甲值上升100\nPeople [name=周凡, atk=0, protectValue=100]\n周凡捡了暴风大剑\nEquip [name=暴风大剑, atk=100, protectValue=0]\n攻击力上升100\n护甲值上升0\nPeople [name=周凡, atk=100, protectValue=100]\n周凡脱了暴风大剑\nEquip [name=暴风大剑, atk=100, protectValue=0]\n攻击力下降100\n护甲值下降0\nPeople [name=周凡, atk=0, protectValue=100]\n```\n\n通过上述简单的案例，我们总结了今天以及前几天学习的知识，活学活用，\n\n希望明天的我们更加优秀！！！', 0, 0, '2020-08-06 22:07:49', 2, 0, 1, '1、 Java抽象类在继承中，抽象是一个非常重要的概念。 类可以是抽象的，方法也可以是抽象的。\n​     如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 如形状类是抽象的类，圆、三角形等是具体类。      用abstract修饰的类就是抽象类。如果某个类中包含有抽象方法，那么该类就必须定义成抽象类。但是抽象类中不一定有抽象方法。      在面向对象的概念中，知道所有的对象都是通过类来描绘的，但是反过来却不是这样。并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。       比如：如果我们进行一个图形编辑软件的开发，就会发现问题领域存在着圆、 三角形这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域是不存在的，它就是一个抽象概念。\n1.1抽象类的定义语法[访问权限] abstract class 类名 { 成员列表 }\npublic abstract class Shapes {public abstract void draw();} public abstract class Shapes {public void draw(){//具体代码}}\n1.2抽象类的注意描述· 用abstract修饰的类就是抽象类\n·如果有抽象方法，就必须把类定义为抽象类；但抽象类不一定有抽象方法。\n·抽象类可以有成员属性和非抽象成员方法\n·抽象类不可以被实例化，但可以有构造方法。（构造方法的作用用于子类对父类属性的赋值）。\n·抽象类只能作为基类，表示一种继承关系。\n·继承抽象类的非抽象类必须实现其中的所有抽象方法，而已实现方法的参数、返回值要和抽象类的方法一样。否则，该类也必须声明为抽象类。\n·构造方法和静态方法不可以修饰为abstract。\n2、抽象方法​      有时候，父类中的某一个方法，每一个子类都要去重写。这种情况下，父类中的这个方法，就没有必要有方法体，因为子类都不会直接使用，都要重写。\n​      要强调，软件工程中，往往是要有需求分析，设计，再到编码。在设计阶段，设计人员要想办法让程序员知道某些类中应该实现哪些功能的，也就是what to do。父类往往都是设计人员设计的。因此不能把这样的方法删除掉，如果删除，就没有办法约束子类必须实现这些方法。这种时候，就把父类中的这样的方法的方法体去掉，就成为抽象方法。 抽象方法定义了what to do，而how to do在子类中实现。\n2.1抽象方法的概念​      在某些情况下，类无法（或者没有必要）提供方法的具体实现，可以将此方法声明成抽象方法；\n​       在类中没有方法体的方法，就是抽象方法；\n​       含有抽象方法的类，一定是抽象类。       抽象方法只需声明，而不需实现某些功能。\n2.2抽象方法的语法使用关键字abstract声明抽象方法，一般语法：\n[访问权限] abstract 返回值类型 方法名称(参数列表);\n如： public abstract void draw();\n抽象方法的作用就是定义 How to do，而what to do留到子类去实现\n2.3抽象的作用 ·抽象最核心的作用是用来实现应用的可扩展性。 ·在面向对象领域，抽象类主要用来进行类型隐藏；也就是使用抽象的类型来编程，但是具体运行时就可以使用具体类型。 ·利用抽象的概念，能够在开发项目中创建扩展性很好的架构，优化程序。 ·抽象类，抽象方法，在软件开发过程中都是设计层面的概念。也就是说，设计人员会设计出抽象类，抽象方法，程序员都是来继承这些抽象类并覆盖抽象方法，实现具体功能。  例子：\n人物穿装备和脱装备\n场景：游戏中有一个人，人会有自己的装备位用来装装备，有个鞋子位和一个武器位，装备每个位置只能穿一件，如果穿第二件就会先把第一件脱了再穿上第二件，每次穿脱装备都会有属性的改变。\n首先抽象出鞋子和武器统称为装备，先定义抽象类武器类\n//装备抽象public abstract class Equip {    // 装备名    private String name;    // 攻击力    private int atk;    // 护甲值    private int protectValue;    public Equip() {        // TODO Auto-generated constructor stub    }    //增加攻击力    public abstract void addAtk(People people);    //增加护甲值    public abstract void addProtectValue(People people);    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAtk() {        return atk;    }    public void setAtk(int atk) {        this.atk = atk;    }    public int getProtectValue() {        return protectValue;    }    public void setProtectValue(int protectValue) {        this.protectValue = protectValue;    }    @Override    public String toString() {        return \"Equip [name=\" + name + \", atk=\" + atk + \", protectValue=\" + protectValue + \"]\";    }}\n其次，定义鞋子类和武器类，继承装备抽象类\n//鞋子类public class Shoe extends Equip {    public Shoe(String name, int atk, int protectValue) {        // TODO Auto-generated constructor stub        super.setName(name);        super.setProtectValue(protectValue);        super.setAtk(atk);    }    public void addAtk(People people) {        // TODO Auto-generated method stub        people.setAtk(people.getAtk() + this.getAtk());        System.out.println(\"攻击力上升\" + this.getAtk());    }    public void addProtectValue(People people) {        // TODO Auto-generated method stub        people.setProtectValue(people.getProtectValue() + this.getProtectValue());        System.out.println(\"护甲值上升\" + this.getProtectValue());    }}//武器类public class Weapon extends Equip {    public Weapon(String name, int atk,int protectValue) {        // TODO Auto-generated constructor stub        super.setName(name);        super.setProtectValue(protectValue);        super.setAtk(atk);    }    @Override    public void addAtk(People people) {        // TODO Auto-generated method stub        people.setAtk(people.getAtk() + this.getAtk());        System.out.println(\"攻击力上升\" + this.getAtk());    }    @Override    public void addProtectValue(People people) {        // TODO Auto-generated method stub        people.setProtectValue(people.getProtectValue() + this.getProtectValue());        System.out.println(\"护甲值上升\" + this.getProtectValue());    }    }\n再定义一个人类\n//人类public class People {    //人物名字    private String name;    // 攻击力    private int atk;    //护甲值    private int protectValue;    //鞋子位    private Shoe shoe;    //武器位    private Weapon weapon;    public People(String name, int atk,int protectValue) {        // TODO Auto-generated constructor stub        this.name = name;        this.atk = atk;        this.protectValue = protectValue;    }    //穿装备    public void putOn(Equip equip) {        System.out.println(this.name + \"捡了\"+ equip.getName());        //判断装备属于鞋子，是的话穿到鞋子位        if (equip instanceof Shoe) {            //判断鞋子位是否为空，不为空脱掉已穿的，更换鞋子            if(this.getShoe()!= null) {                this.getOff(this.shoe);            }            this.shoe = (Shoe)equip;        }        //判断装备属于武器，是的话穿到武器位        else if(equip instanceof Weapon) {            //判断武器位是否为空，不为空脱掉已带的，更换武器            if(this.getWeapon()!= null) {                this.getOff(this.weapon);            }            this.weapon = (Weapon)equip;        }        System.out.println(equip.toString());        equip.addAtk(this);        equip.addProtectValue(this);        System.out.println(this.toString());    }    //脱装备    public void getOff(Equip equip) {        System.out.println(this.name + \"脱了\"+ equip.getName());        System.out.println(equip.toString());        System.out.println(\"攻击力下降\" + equip.getAtk());        this.setAtk(this.getAtk() - equip.getAtk());        this.setProtectValue(this.getProtectValue() - equip.getProtectValue());        System.out.println(\"护甲值下降\" + equip.getProtectValue());        System.out.println(this.toString());        //判断装备属于鞋子        if (equip instanceof Shoe) {            //清空鞋子位            this.shoe = null;        }        //判断装备属于武器        else if(equip instanceof Weapon) {            //清空装备位            this.weapon = null;        }    }    @Override    public String toString() {        return \"People [name=\" + name + \", atk=\" + atk + \", protectValue=\" + protectValue + \"]\";    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAtk() {        return atk;    }    public void setAtk(int atk) {        this.atk = atk;    }    public int getProtectValue() {        return protectValue;    }    public void setProtectValue(int protectValue) {        this.protectValue = protectValue;    }    public Shoe getShoe() {        return shoe;    }    public void setShoe(Shoe shoe) {        this.shoe = shoe;    }    public Weapon getWeapon() {        return weapon;    }    public void setWeapon(Weapon weapon) {        this.weapon = weapon;    }}\n最后，我们来测试一下我们的穿脱装备\npublic class Client {    public static void main(String[] args) {        // TODO Auto-generated method stub        People people = new People(\"周凡\", 0, 0);        Shoe shoe = new Shoe(\"护甲鞋\", 0, 100);        Shoe shoe1 = new Shoe(\"攻速鞋\", 0, 100);        Weapon weapon = new Weapon(\"暴风大剑\", 100, 0);        people.putOn(shoe);        people.putOn(shoe1);        people.getOff(shoe1);        people.putOn(shoe);        people.putOn(weapon);        people.getOff(weapon);    }}\n结果：\n周凡捡了护甲鞋Equip [name=护甲鞋, atk=0, protectValue=100]攻击力上升0护甲值上升100People [name=周凡, atk=0, protectValue=100]周凡捡了攻速鞋周凡脱了护甲鞋Equip [name=护甲鞋, atk=0, protectValue=100]攻击力下降0护甲值下降100People [name=周凡, atk=0, protectValue=0]Equip [name=攻速鞋, atk=0, protectValue=100]攻击力上升0护甲值上升100People [name=周凡, atk=0, protectValue=100]周凡脱了攻速鞋Equip [name=攻速鞋, atk=0, protectValue=100]攻击力下降0护甲值下降100People [name=周凡, atk=0, protectValue=0]周凡捡了护甲鞋Equip [name=护甲鞋, atk=0, protectValue=100]攻击力上升0护甲值上升100People [name=周凡, atk=0, protectValue=100]周凡捡了暴风大剑Equip [name=暴风大剑, atk=100, protectValue=0]攻击力上升100护甲值上升0People [name=周凡, atk=100, protectValue=100]周凡脱了暴风大剑Equip [name=暴风大剑, atk=100, protectValue=0]攻击力下降100护甲值下降0People [name=周凡, atk=0, protectValue=100]\n通过上述简单的案例，我们总结了今天以及前几天学习的知识，活学活用，\n希望明天的我们更加优秀！！！\n', 0, 1);
INSERT INTO `t_article` VALUES (42, '15. 类的关系——实现（接口）', 8, '## 1、接口\n\n### 1.1 接口的引入\n\nJava语言中，类与类的继承只能是单继承。 试想一下，如果一个类中的所有方法都是抽象方法，子类继承后，需要重写所有方法，但是因为单继承，就不能去继承其他有实际方法的父类了。 为了解决这个弊端，Java语言中把一种特殊的抽象类定义成一个新的概念，接口，即interface 接口的本质就是一个类，不过是一个纯的抽象类，就是没有变量，没有具体方法的抽象类。\n\n### 1.2 接口的定义\n\n​      Java接口是一系列方法的声明，是一些抽象的集合      一个接口只有抽象方法没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。       简单地说，接口就是特殊的抽象类，即所有方法都是抽象方法，抽象类就是Java中的接口（interface）。\n\n###  **1.3 接口的基本格式**\n\n```java\n [修饰符] interface 接口名 [extends 父接口名列表]{\n\n[public] [static] [final] 常量; \n\n [public] [abstract] 方法; \n\n}\n```\n\n\n\n注意： **·**修饰符：可选，用于指定接口的访问权限，可选值为public。即使省略，也依然是public。 **·**接口名：必选参数，用于指定接口的名称，接口名必须是合法的Java标识符。一般情况下，要求首字母大写。 **·**extends 父接口名列表：可选参数，用于指定要定义的接口继承于哪个父接口。当使用**·**extends关键字时，父接口名为必选参数。父接口可以存在多个，用逗号隔开。 方法：接口中的方法只有定义而没有被实现。\n\n例：\n\n```java\npublic interface Flyable extends Runnable , Comparable<Flyable>{\n\n	//常量，没有变量属性	\n	public static final double PI = 3.14;\n	\n	//public static final可以省略，默认会加上\n	double LB = 30.0;\n	\n	//只能是抽象方法，也没有构造方法\n	public abstract void fly();\n	\n	//public abstract可以省略，默认会加上\n	void run();\n	\n	//可以有内部类\n	class Inner{\n		\n	}\n	\n	static class StaticInner{\n		\n	}\n	\n}\n```\n\n### 1.4 接口的特点\n\n**·**接口是一种特殊的抽象类 **·**接口中没有变量，只能有public static final修饰的静态常量。三个修饰符可以省略。 **·**接口中所有方法都是抽象方法，且默认就是public权限。\n\n## 2、类实现接口\n\n### 2.1 类实现接口的引入\n\n​       抽象类存在的意义是作为父类，也就是定义了子类的共同特征，抽象类中往往既有抽象方法，又有具体方法。       接口的作用和抽象类类似，也不能直接创建对象，都是被其他类实现，implements，本质和extends一样\n\n###  2.2 类实现接口的特点\n\n​      类实现接口，本质上与类继承类相似，区别在于“类最多只能继承一个类，即单继承，而一个类却可以同时实现多个接口”，多个接口用逗号隔开即可。实现类需要覆盖所有接口中的所有抽象方法，否则该类也必须声明为抽象类。      接口是抽象的，接口中没有任何具体方法和变量，所以接口不能进行实例化。接口定义的是多个类都要实现的操作，即“what to do”。类可以实现接口，从而覆盖接口中的方法，实现“how to do”。\n\n### 2.3 类实现接口的格式\n\n```java\n[修饰符] class <类名> [extends 父类名] [implements 接口列表]{\n\n}\n```\n\n修饰符：可选参数，用于指定类的访问权限，可选值为public、abstract和final。 类名：必选参数，用于指定类的名称，类名必须是合法的Java标识符。一般情况下，要求首字母大写。 extends 父类名：可选参数，用于指定要定义的类继承于哪个父类。当使用extends关键字时，父类名为必选参数。 implements 接口列表：可选参数，用于指定该类实现的是哪些接口。当使用implements关键字时，接口列表为必选参数。当接口列表中存在多个接口名时，各个接口名之间使用逗号分隔。\n\n### **2.4 接口继承接口**\n\n有些时候，定义了一个接口后，需要对该接口进一步细化，再定义它的子接口。\n\n也就是接口和接口之间也可以继承，使用extends实现。区别是，接口和接口之间继承是一对多继承。\n\n### 2.5 Java接口继承接口的原则\n\n**·**Java接口可以继承多个接口\n\n**·**接口继承接口依然使用关键字extends，不要错用成implements\n\n### 2.6 Java接口继承接口的形式\n\n```java\n[修饰符] class <类名> [extends 父类名] [implements Interface0, Interface1, interface……]{\n\n}\n```\n\n\n\n### 2.7 实现多重继承\n\n由于Java类要求单继承，如果没有接口的概念，子类一旦继承那些“纯粹”的抽象类，将不能继承其他类。所以Java语言将“纯粹”的抽象类定义为一种新的类型，即“接口”。类可以同时继承类以及实现接口，也就是说extends和implements关键字可以同时使用。而且一个类可以同时实现多个接口，从而实现了对于“纯粹”的抽象类的多重继承，解决了类与类单继承的局限性。\n\n### 3、接口继承与类继承\n\n接口继承与类继承对比：Java类的继承是单一继承，Java接口的继承是多重继承。\n\n**·接口可实现多继承原因分析**       不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A无法确定该继承那一个。      接口全都是抽象方法继承谁都可以，所以接口可继承多个接口。\n\n## 4、接口与抽象类区别\n\n我们一直在强调，接口的本质就是一个纯的抽象类，但是具体细节有些区别。\n\n![img](https://pic4.zhimg.com/v2-c0bdffa49245b01a127b61102a6ec593_b.png)\n\n**区别总结** abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface. 在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法都是abstract的。 实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。 接口中的方法默认都是 public，abstract 类型的。\n\n## 5、接口的作用——面向接口编程\n\n​       面向接口编程  是一个非常重要的编程原则，意思是，尽量使用接口类型作为编译期类型，以便实现应用的可扩展性。       值得强调的是，抽象类，接口，都是设计层面的概念。在API中，大体结构都是最顶层是接口，然后是抽象类，最后是具体类。       接口是设计层面的概念，往往由设计师设计，将定义与实现分离。\n\n​       程序员实现接口，实现具体方法。\n\n### 5.1 面向接口编程\n\n面向接口编程和面向对象编程并不是平级的，它并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其一部分。 或者说，它是面向对象编程体系中的思想精髓之一。 面向接口编程的意思是指在面向对象的系统中所有的类或者模块之间的交互是由接口完成的。\n\n> 要让抽象能工作，必须将实现封装起来。在实践中，这意味着每个类必须有两个部分：一个接口和一个实现。类的接口描述了它的外部视图，包含了这个类所有实例的共同行为的抽象。类的实现包括抽象的表示以及实现期望行为的机制。通过类的接口，我们能知道客户可以对这个类的所有的实例做出哪些假定。实现了封装细节，客户不能对这些细节做出任何假定。                                                                                                              --格雷迪 布谢\n\n### 5.2 深入了解接口的作用——Comparable接口\n\nComparable接口中定义了比较方法，compareTo（），返回值为int（忽略泛型，后续学习） 当int值为正数，表示大于；为负数，表示小于；为0，表示等于 API中很多类实现了该接口，很多方法借助该接口。\n\n通过使用Arrays.sort(Object[])方法，理解该接口的作用，进一步理解接口的作用，Arrays.sort(Object[])方法是一个对数组的排序，而排序就会有比较的规则，Comparable接口中的compareTo（）方法就是在类里面定义这种比较规则，通过类实现接口，然后重写其中的compareTo（）方法来定义自己想要的排序规则。\n\n例如：下述对一个类的数组进行排序，按照其哈希值大小进行排序。\n\n```java\npublic class Demo implements Comparable<Demo>{\n\n	public String name ;\n	\n	public Demo() {\n		// TODO Auto-generated constructor stub\n	}\n	\n	public Demo(String name) {\n		\n		this.name = name;\n	}\n\n	@Override\n	public int compareTo(Demo demo) {\n		\n		int result = 0;\n		if(this.hashCode() > demo.hashCode())\n			result = 1;\n		else if(this.hashCode() == demo.hashCode())\n			result = 0;\n		else \n			result = -1;\n		\n		return result;\n	}\n\n	@Override\n	public int hashCode() {\n		final int prime = 31;\n		int result = 1;\n		result = prime * result + ((name == null) ? 0 : name.hashCode());\n		return result;\n	}\n\n}\n	\n```\n\n测试：\n\n```java\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\n\npublic class Client {\n	public static void main(String[] args) {\n		Demo[] demos = new Demo[3];\n		demos[0] = new Demo(\"zzz\");\n		demos[1] = new Demo(\"yyy\");\n		demos[2] = new Demo(\"xxx\");\n		\n		for (Demo demo : demos) {\n			System.out.println(demo);\n		}\n		System.out.println(\"------------------------\");\n		Arrays.sort(demos);\n		\n		for(Demo demo :demos) {\n			System.out.println(demo);\n		}	\n	}	\n}\n\n结果：\nDemo [name=zzz]\nDemo [name=yyy]\nDemo [name=xxx]\n------------------------\nDemo [name=xxx]\nDemo [name=yyy]\nDemo [name=zzz]\n```\n\n这样就实现了让数组按照对象的哈希值升序排序。\n\n如果需要倒序排序，也只需要改变实现Comparable接口中的compareTo（）方法，就可以完成。\n\n```java\n@Override\n	public int compareTo(Demo demo) {\n		\n		int result = 0;\n		if(this.hashCode() > demo.hashCode())\n			result = -1;\n		else if(this.hashCode() == demo.hashCode())\n			result = 0;\n		else \n			result = 1;\n		\n		return result;\n	}\n```\n\n到这里接口的语法，也就结束了。\n\n希望大家能够多多交流！！！', 0, 0, '2020-08-06 22:08:22', 2, 0, 1, '1、接口1.1 接口的引入Java语言中，类与类的继承只能是单继承。 试想一下，如果一个类中的所有方法都是抽象方法，子类继承后，需要重写所有方法，但是因为单继承，就不能去继承其他有实际方法的父类了。 为了解决这个弊端，Java语言中把一种特殊的抽象类定义成一个新的概念，接口，即interface 接口的本质就是一个类，不过是一个纯的抽象类，就是没有变量，没有具体方法的抽象类。\n1.2 接口的定义​      Java接口是一系列方法的声明，是一些抽象的集合      一个接口只有抽象方法没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。       简单地说，接口就是特殊的抽象类，即所有方法都是抽象方法，抽象类就是Java中的接口（interface）。\n1.3 接口的基本格式 [修饰符] interface 接口名 [extends 父接口名列表]{[public] [static] [final] 常量;  [public] [abstract] 方法; }\n注意： ·修饰符：可选，用于指定接口的访问权限，可选值为public。即使省略，也依然是public。 ·接口名：必选参数，用于指定接口的名称，接口名必须是合法的Java标识符。一般情况下，要求首字母大写。 ·extends 父接口名列表：可选参数，用于指定要定义的接口继承于哪个父接口。当使用·extends关键字时，父接口名为必选参数。父接口可以存在多个，用逗号隔开。 方法：接口中的方法只有定义而没有被实现。\n例：\npublic interface Flyable extends Runnable , Comparable<Flyable>{    //常量，没有变量属性        public static final double PI = 3.14;    //public static final可以省略，默认会加上    double LB = 30.0;    //只能是抽象方法，也没有构造方法    public abstract void fly();    //public abstract可以省略，默认会加上    void run();    //可以有内部类    class Inner{    }    static class StaticInner{    }}\n1.4 接口的特点·接口是一种特殊的抽象类 ·接口中没有变量，只能有public static final修饰的静态常量。三个修饰符可以省略。 ·接口中所有方法都是抽象方法，且默认就是public权限。\n2、类实现接口2.1 类实现接口的引入​       抽象类存在的意义是作为父类，也就是定义了子类的共同特征，抽象类中往往既有抽象方法，又有具体方法。       接口的作用和抽象类类似，也不能直接创建对象，都是被其他类实现，implements，本质和extends一样\n2.2 类实现接口的特点​      类实现接口，本质上与类继承类相似，区别在于“类最多只能继承一个类，即单继承，而一个类却可以同时实现多个接口”，多个接口用逗号隔开即可。实现类需要覆盖所有接口中的所有抽象方法，否则该类也必须声明为抽象类。      接口是抽象的，接口中没有任何具体方法和变量，所以接口不能进行实例化。接口定义的是多个类都要实现的操作，即“what to do”。类可以实现接口，从而覆盖接口中的方法，实现“how to do”。\n2.3 类实现接口的格式[修饰符] class <类名> [extends 父类名] [implements 接口列表]{}\n修饰符：可选参数，用于指定类的访问权限，可选值为public、abstract和final。 类名：必选参数，用于指定类的名称，类名必须是合法的Java标识符。一般情况下，要求首字母大写。 extends 父类名：可选参数，用于指定要定义的类继承于哪个父类。当使用extends关键字时，父类名为必选参数。 implements 接口列表：可选参数，用于指定该类实现的是哪些接口。当使用implements关键字时，接口列表为必选参数。当接口列表中存在多个接口名时，各个接口名之间使用逗号分隔。\n2.4 接口继承接口有些时候，定义了一个接口后，需要对该接口进一步细化，再定义它的子接口。\n也就是接口和接口之间也可以继承，使用extends实现。区别是，接口和接口之间继承是一对多继承。\n2.5 Java接口继承接口的原则·Java接口可以继承多个接口\n·接口继承接口依然使用关键字extends，不要错用成implements\n2.6 Java接口继承接口的形式[修饰符] class <类名> [extends 父类名] [implements Interface0, Interface1, interface……]{}\n2.7 实现多重继承由于Java类要求单继承，如果没有接口的概念，子类一旦继承那些“纯粹”的抽象类，将不能继承其他类。所以Java语言将“纯粹”的抽象类定义为一种新的类型，即“接口”。类可以同时继承类以及实现接口，也就是说extends和implements关键字可以同时使用。而且一个类可以同时实现多个接口，从而实现了对于“纯粹”的抽象类的多重继承，解决了类与类单继承的局限性。\n3、接口继承与类继承接口继承与类继承对比：Java类的继承是单一继承，Java接口的继承是多重继承。\n·接口可实现多继承原因分析       不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A无法确定该继承那一个。      接口全都是抽象方法继承谁都可以，所以接口可继承多个接口。\n4、接口与抽象类区别我们一直在强调，接口的本质就是一个纯的抽象类，但是具体细节有些区别。\n\n区别总结 abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface. 在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法都是abstract的。 实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。 接口中的方法默认都是 public，abstract 类型的。\n5、接口的作用——面向接口编程​       面向接口编程  是一个非常重要的编程原则，意思是，尽量使用接口类型作为编译期类型，以便实现应用的可扩展性。       值得强调的是，抽象类，接口，都是设计层面的概念。在API中，大体结构都是最顶层是接口，然后是抽象类，最后是具体类。       接口是设计层面的概念，往往由设计师设计，将定义与实现分离。\n​       程序员实现接口，实现具体方法。\n5.1 面向接口编程面向接口编程和面向对象编程并不是平级的，它并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其一部分。 或者说，它是面向对象编程体系中的思想精髓之一。 面向接口编程的意思是指在面向对象的系统中所有的类或者模块之间的交互是由接口完成的。\n\n要让抽象能工作，必须将实现封装起来。在实践中，这意味着每个类必须有两个部分：一个接口和一个实现。类的接口描述了它的外部视图，包含了这个类所有实例的共同行为的抽象。类的实现包括抽象的表示以及实现期望行为的机制。通过类的接口，我们能知道客户可以对这个类的所有的实例做出哪些假定。实现了封装细节，客户不能对这些细节做出任何假定。                                                                                                              —格雷迪 布谢\n\n5.2 深入了解接口的作用——Comparable接口Comparable接口中定义了比较方法，compareTo（），返回值为int（忽略泛型，后续学习） 当int值为正数，表示大于；为负数，表示小于；为0，表示等于 API中很多类实现了该接口，很多方法借助该接口。\n通过使用Arrays.sort(Object[])方法，理解该接口的作用，进一步理解接口的作用，Arrays.sort(Object[])方法是一个对数组的排序，而排序就会有比较的规则，Comparable接口中的compareTo（）方法就是在类里面定义这种比较规则，通过类实现接口，然后重写其中的compareTo（）方法来定义自己想要的排序规则。\n例如：下述对一个类的数组进行排序，按照其哈希值大小进行排序。\npublic class Demo implements Comparable<Demo>{    public String name ;    public Demo() {        // TODO Auto-generated constructor stub    }    public Demo(String name) {        this.name = name;    }    @Override    public int compareTo(Demo demo) {        int result = 0;        if(this.hashCode() > demo.hashCode())            result = 1;        else if(this.hashCode() == demo.hashCode())            result = 0;        else             result = -1;        return result;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }}\n测试：\nimport java.lang.reflect.Array;import java.util.Arrays;public class Client {    public static void main(String[] args) {        Demo[] demos = new Demo[3];        demos[0] = new Demo(\"zzz\");        demos[1] = new Demo(\"yyy\");        demos[2] = new Demo(\"xxx\");        for (Demo demo : demos) {            System.out.println(demo);        }        System.out.println(\"------------------------\");        Arrays.sort(demos);        for(Demo demo :demos) {            System.out.println(demo);        }        }    }结果：Demo [name=zzz]Demo [name=yyy]Demo [name=xxx]------------------------Demo [name=xxx]Demo [name=yyy]Demo [name=zzz]\n这样就实现了让数组按照对象的哈希值升序排序。\n如果需要倒序排序，也只需要改变实现Comparable接口中的compareTo（）方法，就可以完成。\n@Override    public int compareTo(Demo demo) {        int result = 0;        if(this.hashCode() > demo.hashCode())            result = -1;        else if(this.hashCode() == demo.hashCode())            result = 0;        else             result = 1;        return result;    }\n到这里接口的语法，也就结束了。\n希望大家能够多多交流！！！\n', 0, 1);
INSERT INTO `t_article` VALUES (43, '16. Object类', 8, '##前言\nJava类不是单继承么？如果一个类继承了其他父类，就不会直接继承Object，但是它的父类如果再没有父类，就会继承Object，也就是说，Object是任何一个类的直接或间接的父类。因此，我们随意创建一个类，其实也不是空的，起码这个类中有Object类中的属性和方法。\n\n例如：\n\n```java\npublic class Example {\n\n    public Example() {\n\n    }\n\n}\npublic class Client {\n\n    public static void main(String[] args) {\n\n        //任何类都是Object的派生类或者子类\n        Example example = new Example();\n\n        System.out.println(example.equals(null));\n        System.out.println(example.getClass());\n        System.out.println(example.hashCode());\n        System.out.println(example.toString());\n\n    }\n\n}\n```\n\n输出：\n\n```\nfalse\nclass com.company.project.demo0.Example\n2018699554\ncom.company.project.demo0.Example@7852e922\n```\n\n## 1、Object类的作用和地位\n\nObject类在java.lang包下，是类层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现了这个类的方法。\n\n例如：\n\n```java\npublic class Example {\n\n    public static void main(String[] args) {\n\n        //数组也是Object的子类\n        int[] array = new int[0];\n\n        System.out.println(array.equals(null));\n        System.out.println(array.getClass());\n        System.out.println(array.hashCode());\n        System.out.println(array.toString());\n\n    }\n\n}\n```\n\n输出：\n\n```\nfalse\nclass [I\n2018699554\n[I@7852e922\n```\n\n## 2、Object类的方法\n\n> protected Object clone() Creates and returns a copy of this object. 创建并返回此对象的一个副本。\n\n> boolean equals(Object obj) Indicates whether some other object is \"equal to\" this one. 判断其他某个对象是否与此对象“相等”。\n\n> protected  void finalize() Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.A subclass overrides the  finalize  method to dispose of system resources or to perform other cleanup. 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 一个子类覆盖finalize方法来处理系统资源或执行其他清理。\n\n> Class<?> getClass() Returns the runtime class of this Object. 返回此 Object 的运行时类。\n\n> int hashCode() Returns a hash code value for the object. 返回该对象的哈希码值。\n\n> void notify() Wakes up a single thread that is waiting on this object\'s monitor. 唤醒在此对象监视器上等待的单个线程。\n\n> void notifyAll() Wakes up all threads that are waiting on this object\'s monitor. 唤醒在此对象监视器上等待的所有线程。\n\n> String toString() Returns a string representation of the object. 返回该对象的字符串表示。\n\n> void wait() Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.In other words, this method behaves exactly as if it simply performs the call wait(0). 导致当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法。换句话说，这个方法的行为与它简单地执行调用wait(0)完全一样。\n\n> void wait(long timeout) Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed. 导致当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法，或者经过指定的时间量。\n\n> void wait(long timeout, int nanos) Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object, or some other thread interrupts the current thread, or a certain amount of real time has elapsed. 导致当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法，或其他一些线程中断当前线程，或已经过了一定时间。\n\n## 3.Object常用方法\n\n### 3.1  toString方法\n\ntoString方法可以返回该对象的字符串表示。或者说将任何一个对象转换成字符串返回。方法定义如下：\n\n```java\npublic String toString() {\n        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n    }\n```\n\n通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。 Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于： *getClass().getName() + \'@\' + Integer.toHexString(hashCode())*\n\n### 3.2   equals方法和==\n\n### 3.2.1、equals方法\n\nequals方法判断其它某个对象是否与此对象“相等”。方法定义如下：\n\n```java\npublic boolean equals(Object obj) {\n        return (this == obj);\n    }\n```\n\n​      由方法定义可知，Object类中的equals方法，用来比较两个引用的虚地址。当且仅当两个引用在物理上是同一个对象时，返回值为true，否则将返回false。\n\n> equals 方法在非空对象引用上实现相等关系：\n>\n> ●自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。\n> ●对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。\n> ●传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。\n> ●一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。\n> ●对于任何非空引用值 x，x.equals(null) 都应返回 false。 Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。\n\n**注意：**当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。\n\n### 3.2.2、==\n\n==比较的是内存中的虚地址。\n\n具体equals方法和==的区别和原理，我会另做一篇文章。\n\n## 3.3、hashCode方法\n\n###  3.3.1、hashCode方法\n\n hashCode方法用来获取对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。方法定义如下：\n\n```\npublic native int hashCode();\n```\n\n> hashCode的常规协定是： 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据  equals(Object)  方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 如果根据 equals(java.lang.Object)  方法，两个对象不相等，那么对这两个对象中的任一对象上调用hashCode方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 Java编程语言不需要这种实现技巧。）\n\n### 3.3.2、equals方法与hashCode方法关系\n\n -如果两个对象使用equals比较返回true，那么它们的hashCode值一定要相同。 -如果两个对象equals比较返回false，那么它们的hashCode值不一定不同。 -覆盖equals，往往需要覆盖hashCode，可以使用Eclipse自动生成，保证equals返回true，则hashCode相同；equals返回false，则hashCode不同。 -在Set集合部分有实际应用。\n\n## 4、Object和Object[]之间的区别\n\n方法中的形参是Object类型时，**任何引用类型**的参数都可以传进去执行。 方法中形参是Object[]类型时，只有**对象数组**可以传入执行。\n\n\n\n\n\n> 部分内容来自老师阿宝哥的笔记~~~ \n>\n> 作者：AT阿宝哥 链接：https://www.jianshu.com/p/98638a3a399e 来源：简书', 0, 0, '2020-08-06 22:09:17', 2, 0, 1, '前言Java类不是单继承么？如果一个类继承了其他父类，就不会直接继承Object，但是它的父类如果再没有父类，就会继承Object，也就是说，Object是任何一个类的直接或间接的父类。因此，我们随意创建一个类，其实也不是空的，起码这个类中有Object类中的属性和方法。\n例如：\npublic class Example {    public Example() {    }}public class Client {    public static void main(String[] args) {        //任何类都是Object的派生类或者子类        Example example = new Example();        System.out.println(example.equals(null));        System.out.println(example.getClass());        System.out.println(example.hashCode());        System.out.println(example.toString());    }}\n输出：\nfalseclass com.company.project.demo0.Example2018699554com.company.project.demo0.Example@7852e9221、Object类的作用和地位Object类在java.lang包下，是类层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现了这个类的方法。\n例如：\npublic class Example {    public static void main(String[] args) {        //数组也是Object的子类        int[] array = new int[0];        System.out.println(array.equals(null));        System.out.println(array.getClass());        System.out.println(array.hashCode());        System.out.println(array.toString());    }}\n输出：\nfalseclass [I2018699554[I@7852e9222、Object类的方法\nprotected Object clone() Creates and returns a copy of this object. 创建并返回此对象的一个副本。\nboolean equals(Object obj) Indicates whether some other object is “equal to” this one. 判断其他某个对象是否与此对象“相等”。\nprotected  void finalize() Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.A subclass overrides the  finalize  method to dispose of system resources or to perform other cleanup. 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 一个子类覆盖finalize方法来处理系统资源或执行其他清理。\nClass<?> getClass() Returns the runtime class of this Object. 返回此 Object 的运行时类。\nint hashCode() Returns a hash code value for the object. 返回该对象的哈希码值。\nvoid notify() Wakes up a single thread that is waiting on this object’s monitor. 唤醒在此对象监视器上等待的单个线程。\nvoid notifyAll() Wakes up all threads that are waiting on this object’s monitor. 唤醒在此对象监视器上等待的所有线程。\nString toString() Returns a string representation of the object. 返回该对象的字符串表示。\nvoid wait() Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.In other words, this method behaves exactly as if it simply performs the call wait(0). 导致当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法。换句话说，这个方法的行为与它简单地执行调用wait(0)完全一样。\nvoid wait(long timeout) Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed. 导致当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法，或者经过指定的时间量。\nvoid wait(long timeout, int nanos) Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object, or some other thread interrupts the current thread, or a certain amount of real time has elapsed. 导致当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法，或其他一些线程中断当前线程，或已经过了一定时间。\n\n3.Object常用方法3.1  toString方法toString方法可以返回该对象的字符串表示。或者说将任何一个对象转换成字符串返回。方法定义如下：\npublic String toString() {        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());    }\n通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。 Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于： getClass().getName() + ‘@’ + Integer.toHexString(hashCode())\n3.2   equals方法和==3.2.1、equals方法equals方法判断其它某个对象是否与此对象“相等”。方法定义如下：\npublic boolean equals(Object obj) {        return (this == obj);    }\n​      由方法定义可知，Object类中的equals方法，用来比较两个引用的虚地址。当且仅当两个引用在物理上是同一个对象时，返回值为true，否则将返回false。\n\nequals 方法在非空对象引用上实现相等关系：\n●自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。●对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。●传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。●一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。●对于任何非空引用值 x，x.equals(null) 都应返回 false。 Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。\n\n注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。\n3.2.2、====比较的是内存中的虚地址。\n具体equals方法和==的区别和原理，我会另做一篇文章。\n3.3、hashCode方法3.3.1、hashCode方法 hashCode方法用来获取对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。方法定义如下：\npublic native int hashCode();\nhashCode的常规协定是： 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据  equals(Object)  方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 如果根据 equals(java.lang.Object)  方法，两个对象不相等，那么对这两个对象中的任一对象上调用hashCode方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 Java编程语言不需要这种实现技巧。）\n\n3.3.2、equals方法与hashCode方法关系 -如果两个对象使用equals比较返回true，那么它们的hashCode值一定要相同。 -如果两个对象equals比较返回false，那么它们的hashCode值不一定不同。 -覆盖equals，往往需要覆盖hashCode，可以使用Eclipse自动生成，保证equals返回true，则hashCode相同；equals返回false，则hashCode不同。 -在Set集合部分有实际应用。\n4、Object和Object[]之间的区别方法中的形参是Object类型时，任何引用类型的参数都可以传进去执行。 方法中形参是Object[]类型时，只有对象数组可以传入执行。\n\n部分内容来自老师阿宝哥的笔记~~~ \n作者：AT阿宝哥 链接：https://www.jianshu.com/p/98638a3a399e 来源：简书\n\n', 0, 1);
INSERT INTO `t_article` VALUES (44, '17. equals和==的区别', 8, '\n\n> 文章参考： \n>\n> https://www.jianshu.com/p/7a349a75c324 \n>\n> https://www.cnblogs.com/blueskyli/p/9932017.html\n\n## 1、背景介绍\n\n**== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。**\n\n**equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。**\n\njava中的数据类型可以分为两类：\n\n### **1.1 基本数据类型**\n\nbyte,short,char,int,long,float,double,boolean\n\n基本数据类型之间的比较需要用双等号（==），因为他们比较的是值\n\n### **1.2 引用数据类型**\n\n接口、类、数组等非基本数据类型\n\nJava中的字符串String属于引用数据类型。因为String是一个类\n\n当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为没new一次就会重新开辟一个新的堆内存空间\n\n## 2、Java中的==\n\n### 2.1 Java中的==\n\nJava中的==表示的是什么呢？有时候很令人费解。比如，以下例子输出是什么？\n\n```java\n        // 例一\n        String str = \"wo\";\n        String str1 = \"wo\";\n        System.out.println(\"例一：\" + (str == str1));\n\n        // 例二\n        String str2 = new String(\"wo\");\n        String str3 = new String(\"wo\");\n        System.out.println(\"例二：\" + (str2 == str3));\n\n        // 例三\n        int i1 = 1;\n        int i2 = 1;\n        System.out.println(\"例三：\" + (i1 == i2));\n\n        // 例四\n        TestObject t1 = new TestObject();\n        TestObject t2 = new TestObject();\n        System.out.println(\"例四：\" + (t1 == t2));\n```\n\n其中，TestObject为一个类\n\n```java\npublic class TestObject {\n    public TestObject(){\n        \n    }\n}\n```\n\n最终结果如下：\n\n```java\n例一：true\n例二：false\n例三：true\n例四：false\n```\n\n其实，在Java中，如果是基本数据类型，则 == 比较的是值；如果是对象类型，则  == 比较的是对象的地址。但是，有时候会疑惑，String不是对象类型么？为什么例一是true呢？这个就要谈谈字符串常量池的问题。\n\n### 2.2 字符串常量池\n\n String类是我们平常项目中使用频率非常高的一种对象类型，JVM为了提升性能和减少开销，避免字符串的重复创建，维护了一块特殊的内存空间，即字符串常量池。当需要使用字符串时，先去字符串常量池查看该字符串是否已经存在，如果存在，则可直接使用；如果不存在，初始化，并将该字符串放入到字符串常量池中。 \n\n> 在JDK1.6及之前版本，字符串常量池在方法区中 在JDK1.7及以后版本，字符串常量池移到了堆中\n\n 使用String str=\"wo\"，可能创建一个或者不创建对象。如果“wo”在字符串常量池中已经存在，则不会再创建String类型的值为“wo”的对象，而是将str指向这个“wo”对象内存地址，后续无论用这种方式创建多少个指向“wo”的引用，在内存中，都只有一个“wo”内存地址被分配。而==判断的是对象内存的地址，所以例一返回true。下图是用这种方式创建字符串的示例图。\n\n![img](https://pic4.zhimg.com/v2-3c3a07afa263ae010a10ba6acebd114f_b.png)\n\n例一 原理图\n\n> 对象存放在堆中，字符串常量池是堆中一块特殊区域，new出来的是对象，字符串可以通过直接赋值创建一个对象，如上所述。 对象的引用存放在栈中，String str是对象的引用\n\n在上图中，栈存放的是字符串的引用，str和str1存放的都是对象“wo”的内存地址，==判断对象时，判断的是他们存储的内存地址是否相同，由上图可见，他们的内存地址是相同的，所以例一输出的是true。\n\n![img](https://pic1.zhimg.com/v2-8fa816d997c3bd3c106e6e40c1a4ca24_b.jpeg)\n\n例二的两个字符串都是通过new的方式创建对象的，所以在堆上有两个String对象，且这两个对象指向字符串常量池中的同一个对象“wo”，如上图所示，此时str2和str3存储的对象地址就不相同，所以例二返回的是false。\n\n> String str = new String(\"wo\")创建了几个对象?如果字符串常量池中没有“wo”，则该句创建了两个对象，首先会创建一个“wo”存放在字符串常量池中，其本身就是一个对象；然后会new 一个字符串对象，并将“wo”的引用返回给new出来的对象；如果字符串常量池中有“wo”，则该句只创建了一个对象，因为该句首先会查找字符串常量池中是否存在“wo”，如果存在则直接返回\"wo\"的引用给new出来的对象。\n\n### 2.3 总结\n\n- 如果是基本数据类型，==判断的是值\n- 如果是对象类型，==判断的是对象的地址\n- 通过直接赋值而不是new的方式给String赋值，如果字符串常量池中有该对象，则不会再创建，此时通过 == 判断，返回的是true。如：String str=\"wo\"；String str1=\"wo\";str == str1为true.\n- 在JDK1.6及以前版本，字符串常量池在方法区中；在JDK1.7及以后，字符串常量池在堆中。\n- 对象的引用保存在栈中。\n\n## 3、java中**equals()方法**\n\nJava中所有的类都是继承与Object这个基类的，在Object类中定义了一个equals方法，这个方法的初始行为是比较对象的内存地址，但在一些类库中已经重写了这个方法（一般都是用来比较对象的成员变量值是否相同），比如：String，Integer，Date 等类中，所以他们不再是比较类在堆中的地址了、\n\nObject类中源码\n\n```java\npublic boolean equals(Object var1) {\n    return this == var1;\n}\n```\n\nString类中重写后的代码\n\n```java\npublic boolean equals(Object var1) {\n        if (this == var1) {\n            return true;\n        } else {\n            if (var1 instanceof String) {\n                String var2 = (String)var1;\n                int var3 = this.value.length;\n                if (var3 == var2.value.length) {\n                    char[] var4 = this.value;\n                    char[] var5 = var2.value;\n\n                    for(int var6 = 0; var3-- != 0; ++var6) {\n                        if (var4[var6] != var5[var6]) {\n                            return false;\n                        }\n                    }\n\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n```\n\n**String类的equals()方法**\n\n```java\nString a = \"abc\";// abc在常量池中\nString b = \"abc\";//栈中b指向常量池中的abc\nString c = new String(\"abc\");// 在堆内存中重新开辟了一个abc的空间\nString d = c.intern();//检查字符串池里是否存在\"abc\"这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把\"abc\"添加到字符串池中，然后再返回它的引用。\n        \n\nSystem.out.println(a==b);\nSystem.out.println(a.equals(b));\nSystem.out.println(a==c);\nSystem.out.println(a.equals(c));\nSystem.out.println(a==d);\nSystem.out.println(a.equals(d));\n```\n\n结果：\n\n```java\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\n```\n\n**equals 的作用:**\n\n　　引用类型：默认情况下，比较的是地址值，重写该方法后比较对象的成员变量值是否相同。\n\n## **4、总结：**\n\n对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。', 0, 0, '2020-08-06 22:09:50', 2, 0, 1, '\n文章参考： \nhttps://www.jianshu.com/p/7a349a75c324 \nhttps://www.cnblogs.com/blueskyli/p/9932017.html\n\n1、背景介绍== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。\nequals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。\njava中的数据类型可以分为两类：\n1.1 基本数据类型byte,short,char,int,long,float,double,boolean\n基本数据类型之间的比较需要用双等号（==），因为他们比较的是值\n1.2 引用数据类型接口、类、数组等非基本数据类型\nJava中的字符串String属于引用数据类型。因为String是一个类\n当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为没new一次就会重新开辟一个新的堆内存空间\n2、Java中的==2.1 Java中的==Java中的==表示的是什么呢？有时候很令人费解。比如，以下例子输出是什么？\n        // 例一        String str = \"wo\";        String str1 = \"wo\";        System.out.println(\"例一：\" + (str == str1));        // 例二        String str2 = new String(\"wo\");        String str3 = new String(\"wo\");        System.out.println(\"例二：\" + (str2 == str3));        // 例三        int i1 = 1;        int i2 = 1;        System.out.println(\"例三：\" + (i1 == i2));        // 例四        TestObject t1 = new TestObject();        TestObject t2 = new TestObject();        System.out.println(\"例四：\" + (t1 == t2));\n其中，TestObject为一个类\npublic class TestObject {    public TestObject(){    }}\n最终结果如下：\n例一：true例二：false例三：true例四：false\n其实，在Java中，如果是基本数据类型，则 == 比较的是值；如果是对象类型，则  == 比较的是对象的地址。但是，有时候会疑惑，String不是对象类型么？为什么例一是true呢？这个就要谈谈字符串常量池的问题。\n2.2 字符串常量池 String类是我们平常项目中使用频率非常高的一种对象类型，JVM为了提升性能和减少开销，避免字符串的重复创建，维护了一块特殊的内存空间，即字符串常量池。当需要使用字符串时，先去字符串常量池查看该字符串是否已经存在，如果存在，则可直接使用；如果不存在，初始化，并将该字符串放入到字符串常量池中。 \n\n在JDK1.6及之前版本，字符串常量池在方法区中 在JDK1.7及以后版本，字符串常量池移到了堆中\n\n 使用String str=”wo”，可能创建一个或者不创建对象。如果“wo”在字符串常量池中已经存在，则不会再创建String类型的值为“wo”的对象，而是将str指向这个“wo”对象内存地址，后续无论用这种方式创建多少个指向“wo”的引用，在内存中，都只有一个“wo”内存地址被分配。而==判断的是对象内存的地址，所以例一返回true。下图是用这种方式创建字符串的示例图。\n\n例一 原理图\n\n对象存放在堆中，字符串常量池是堆中一块特殊区域，new出来的是对象，字符串可以通过直接赋值创建一个对象，如上所述。 对象的引用存放在栈中，String str是对象的引用\n\n在上图中，栈存放的是字符串的引用，str和str1存放的都是对象“wo”的内存地址，==判断对象时，判断的是他们存储的内存地址是否相同，由上图可见，他们的内存地址是相同的，所以例一输出的是true。\n\n例二的两个字符串都是通过new的方式创建对象的，所以在堆上有两个String对象，且这两个对象指向字符串常量池中的同一个对象“wo”，如上图所示，此时str2和str3存储的对象地址就不相同，所以例二返回的是false。\n\nString str = new String(“wo”)创建了几个对象?如果字符串常量池中没有“wo”，则该句创建了两个对象，首先会创建一个“wo”存放在字符串常量池中，其本身就是一个对象；然后会new 一个字符串对象，并将“wo”的引用返回给new出来的对象；如果字符串常量池中有“wo”，则该句只创建了一个对象，因为该句首先会查找字符串常量池中是否存在“wo”，如果存在则直接返回”wo”的引用给new出来的对象。\n\n2.3 总结\n如果是基本数据类型，==判断的是值如果是对象类型，==判断的是对象的地址通过直接赋值而不是new的方式给String赋值，如果字符串常量池中有该对象，则不会再创建，此时通过 == 判断，返回的是true。如：String str=”wo”；String str1=”wo”;str == str1为true.在JDK1.6及以前版本，字符串常量池在方法区中；在JDK1.7及以后，字符串常量池在堆中。对象的引用保存在栈中。\n3、java中equals()方法Java中所有的类都是继承与Object这个基类的，在Object类中定义了一个equals方法，这个方法的初始行为是比较对象的内存地址，但在一些类库中已经重写了这个方法（一般都是用来比较对象的成员变量值是否相同），比如：String，Integer，Date 等类中，所以他们不再是比较类在堆中的地址了、\nObject类中源码\npublic boolean equals(Object var1) {    return this == var1;}\nString类中重写后的代码\npublic boolean equals(Object var1) {        if (this == var1) {            return true;        } else {            if (var1 instanceof String) {                String var2 = (String)var1;                int var3 = this.value.length;                if (var3 == var2.value.length) {                    char[] var4 = this.value;                    char[] var5 = var2.value;                    for(int var6 = 0; var3-- != 0; ++var6) {                        if (var4[var6] != var5[var6]) {                            return false;                        }                    }                    return true;                }            }            return false;        }    }\nString类的equals()方法\nString a = \"abc\";// abc在常量池中String b = \"abc\";//栈中b指向常量池中的abcString c = new String(\"abc\");// 在堆内存中重新开辟了一个abc的空间String d = c.intern();//检查字符串池里是否存在\"abc\"这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把\"abc\"添加到字符串池中，然后再返回它的引用。System.out.println(a==b);System.out.println(a.equals(b));System.out.println(a==c);System.out.println(a.equals(c));System.out.println(a==d);System.out.println(a.equals(d));\n结果：\ntruetruefalsetruetruetrue\nequals 的作用:\n　　引用类型：默认情况下，比较的是地址值，重写该方法后比较对象的成员变量值是否相同。\n4、总结：对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。\n', 0, 1);
INSERT INTO `t_article` VALUES (45, '18. 异常处理篇', 8, '## 1、异常的定义\n\n异常是不正常的事件，不是错误\n\n异常是指程序运行的过程中，发生某些意外的事情，比如10除以0， 文件不存在等。\n\n```java\npublic class ExcptionTest {\npublic void test(){\nSystem.out.println(\"====运行前====\");\nint a=10/0;\nSystem.out.println(\"====运行后====\");\n}\npublic static void main(String[] args) {\nExcptionTest et= new ExcptionTest();\net.test();\n}\n}\n```\n\n在运行期我们int型的a 被除以0 那么 这样的事件称之为不正常事件，将发生异常，异常不是错误，是不正常的事情，错误往往是跟源代码的BUG 或者内部环境有关，如内存泄漏等。\n\n## 2、错误的定义\n\n​      错误是很难处理的，比如内存溢出等，不能够通过异常处理机制来解决。      异常是程序中发生的不正常事件流，通过处理程序依然可以运行下去。但是错误是无法控制的，程序肯定要中断。      应用软件与操作系统或其他应用软件发生不兼容造成应用程序发生错误。\n\n## 3、API中异常结构及常见异常\n\n所谓异常处理，就是把一些不正常的事件，用类标记出来。\n\n当发生某种不正常事件时，抛出这个类的对象，JVM的异常处理机制能够识别这种对象，并进行处理。\n\n API中根据需要，定义了一些类，来标记各种不正常的事件。我们把API中定义的这些异常类称为标准异常。  另外，需要理解的是，API中定义的异常类型，除了运行期异常是运行时检测到的一些异常，编译期异常都是用来标记API中其他类中的一些事件，比如IO处理的文件找不到等。\n\n### 3.1 异常的体系\n\n在Java中，Throwable是所有错误和异常的父类，Throwable类有两个直接子类：Exception类、Error类。\n\nError表示Java程序运行错误，可能是编译期错误或者系统错误，往往程序中并不处理，如果程序出现Error，则系统能做的工作也只能有记录错误的成因和安全终止。\n\nException表示Java程序运行异常，即运行中的程序发生了人们不期望发生的事件，可以被Java异常处理机制处理。是所有异常类的父类，是程序员所关心的。\n\n### 3.2 Exception的分类\n\n异常分为运行期异常和编译期异常两种。\n\n（1）运行期异常(RuntimeException)：指在 Java 虚拟机正常运行期间抛出的异常，是可以被捕获处理的，如果出现RuntimeException异常，那么一定是程序发生错误导致的。\n\n- NullPointerException —— 空指针异常\n- ClassCastException —— 类型转换异常\n- ArrayIndexOutOfBundsException —— 数组下标越界 ……\n\n（2）编译期异常(CheckedException)：指在编译阶段 Java 编译器会检查 CheckedException 异常并强制程序捕获和处理此类程序，即要求程序在可能出现异常的地方通过 try catch 语句块捕获并处理异常。\n\n- IOException —— 输入输出异常（打开错误文件）\n- SQLExeption —— SQL 语法错误\n- ClassNotFoundException —— 类不存在\n\n​    ……\n\n### 3.3 常见异常\n\nException                                            异常层次结构的根类\n\nRuntimeException                               所有运行期异常的基类 \n\nArithmeticException                            算术错误情形，如以零作除数 \n\nIllegalArgumentException                   方法接收到非法参数 \n\nArrayIndexOutOfBoundsException     数组大小小于或大于实际的数组大小 \n\nNullPointerException                           尝试访问  null 对象成员 \n\nClassNotFoundException                     不能加载所需的类 \n\nNumberFormatException                     例如字符串到 float 型数字的转换无效 \n\nIOException                                           I/O 异常的根类 \n\nFileNotFoundException                         找不到文件 \n\nEOFException                                         文件结束  \n\nInterruptedException                             线程中断\n\n## \n\n## 4、使用 try catch 捕获并处理异常\n\n### 4.1  try的使用和定义\n\n 检测不安全的代码块（发现异常） try块中任何一条语句发生了异常，下面的代码将不会被执行，程序将跳转到异常处理代码块中，即catch块。因此，不要随意将不相关的代码放到try块中，因为随时可能会中断执行。\n\n try{ 可能会发生异常的代码 }\n\n### 4.1 catch的使用和定义\n\n把抓到的类型匹配的异常捕获，保证程序能继续运行下去。 catch语句必须紧跟着try语句之后，称为捕获异常，也就是异常处理函数，一个try后面可以写多个catch，分别捕获不同类型的异常，要从子类往父类的顺序写，否则有编译错误。\n\n catch(异常类型 引用名)｛ 异常处理代码 ｝\n\n### 4.1 finally的使用和定义\n\nfinally该内容总是会执行的，只能有一个finally语句\n\nfinally{ 必须执行的逻辑 }\n\n### 4.4 try/catch/finally基本语法\n\n```java\ntry{\n\n可能会发生异常的代码\n\n}catch(异常类型 引用名){\n\n异常处理代码\n\n}finally{\n\n必须执行代码\n\n}\n```\n\n（1）运行流程（无异常情况）\n\n```java\ntry{\nSystem.out.println(\"try\");\n}catch(Exception e) {\nSystem.out.println(\"Exception\");\n}\nfinally{\nSystem.out.println(\"Finally\");\n}\n```\n\n结果：\n\n```java\ntry\nFinally\n```\n\n（2）运行流程（有异常情况）\n\n```java\ntry{\nString demo = null;\ndemo.split(\"a\");\nSystem.out.println(\"try\");\n}catch(Exception e) {\nSystem.out.println(\"Exception\");\ne.printStackTrace();\n}\nfinally{\nSystem.out.println(\"Finally\");\n}\n```\n\n结果：\n\n```java\njava.lang.NullPointerException\nException\n	at com.company.project.test.t1201.Demo.main(Demo.java:9)\nFinally\n```\n\n### 4.5  finally与return\n\n在try中没有异常的情况下try、catch、finally的执行顺序 try --- finally\n\n如果try中有异常，执行顺序是try --- catch --- finally\n\n如果try中没有异常并且try中有return这时候正常执行顺序是try ---- finally --- return\n\n如果try中有异常并且try中有return这时候正常执行顺序是try----catch---finally--- return\n\n如果try有异常，相应catch中有return，顺序是try---catch---finally---return  总之 finally 永远执行！\n\n除非，关掉Java虚拟机，System.exit(0)，finall将不会执行。\n\n## 5、抛出异常（throw与throws ）\n\n​       遇到异常时不进行具体处理，而是将异常抛给调用者，由调用者根据情况处理。有时候是直接捕获并处理，也有可能是继续向上抛出异常。\n\n **抛出异常有三种形式：throw、throws、系统自动抛出异常。**\n\n​       **其中，throws 作用在方法上，用于定义方法可能抛出的异常；throw 作用在方法内，表明抛出一个异常。他们两个共同处理编译器异常，而运行期异常通常是系统自动抛出异常。**\n\n​       系统自动抛出异常：前面我们学习过，异常使用一些特殊类标记的，所谓发生异常，就是抛出一个异常类对象，JVM的异常机制能够识别这样的对象，并进行处理。       运行期异常都是JVM在运行时自行抛出的，而编译期异常都是程序员在编写代码时，通过语句自行抛出的。 \n\n### 5.1  throw\n\n关键字throw用于显式抛出异常，抛除异常后处理。 使用try-catch捕获异常\n\n**5.1.1语法：** throw new 异常类构造方法; 例如：throw new Exception();\n\n**5.1.2  为什么要throw异常呢？**    主要是要用这种异常类型标记一些不正常的事件，而且希望这些事件发生时，一定能被调用者关注并处理。 throw抛出异常后，可以有两种方式处理，一般使用第二种，即throws。 因为如果throw后使用try catch自行处理，意义不大。异常只被处理一次，调用者就没法处理该异常。 如果throw后使用了try catch，往往也会在catch中再使用throw继续抛出。 利用抛出的异常来标记不正常的事件，从而对事件流统一处理。\n\n**5.1.3 throw的使用**\n\n（1）一般配合try-catch 使用 \n\n格式如下：\n\n```java\npublic class ThisDemo06{\npublic static void main(String args[]){\ntry{\nthrow new Exception(\"自己抛着玩的。\") ;// 抛出异常的实例化对象\n}catch(Exception e){\nSystem.out.println(e) ;\n}\n```\n\nthrow e 实现了在try-catch块中对异常的上抛,catch块中不再对异常进行处理 在catch块中，throw e后不能再跟代码 ，且cathc块外，后面的代码不被执行。\n\n（2）也可以不配合try-catch，需要配合throws\n\n```java\nstatic int avg(int n1,int n2)throws Exception{\nif (n1<0||n2<0) { //判断方法参数是否满足条件\nthrow new Exception(\"不能使用负数\");//错误信息\n}\nif (n1>100||n2>100) {\nthrow new Exception(\"数值太大了\");\n}\nreturn (n1+n2)/2; // 将参数的平均值返回\n\n}\n```\n\n### 5.2  throws\n\n这里的throws抛出的是一个异常类对象，这个对象带有所发生异常的信息。我们可以直接使用JAVA中已经封装好的异常信息类，也可以自己去定义一个异常类。\n\n用了throws关键字，相当于给一个方法加上了 **不安全** 标签。 使得调用这个方法的方法必须处理这些类型的异常，否则将出现编译错误。 当然，处理的方法也依然有两种，即try catch或者继续throws。\n\n任何方法都可以无条件的使用throws声明抛出任意类型的异常，抽象方法也可以。 可以说方法使用throws声明异常，在语法上没有任何要求。如果子类覆盖父类方法，子类的方法不能声明抛除比父类方法更多的异常类型。 就想你的年龄肯定没有你老爸的年龄大一样。\n\n#### **5.2.1  throws 使用地方**\n\n用于方法声明处，指出方法引发的异常。\n\n可以声明多种异常类型，用逗号分开即可。\n\n#### **5.2.2 格式**\n\npublic void test throws 异常1，异常2，异常3{\n\n}\n\n#### **5.2.3 throw的使用**\n\n**（1）调用系统的异常信息类**\n\n```java\npublic class Test {\n	int age;\n	\n	public void Abnormal() throws IOException{\n		int i=0;\n		int x=5/i;\n		System.out.println(x);\n	}\n	\n	//主函数入口\n	public static void main(String[] args) throws IOException {\n		Test t=new Test();\n		t.Abnormal();\n	}\n}\n```\n\n**（2）自定义异常类**\n\n1.自定义异常就是自己定义的异常类，也就是API中的标准异常类的直接或间接的子类。\n\n​    自定义异常类中往往不写其他方法，只重载需要使用的构造方法\n\n2.作用：用自定义异常标记业务逻辑的异常，避免与标准异常混淆。\n\n3.基本语法：\n\npublic class 异常类名 extends Exception{\n\npublic 异常类名(String msg){\n\nsuper(msg);\n\n}\n\n}\n\n**例如：**\n\n```java\n//自定义异常类\npublic class AgeException extends Exception{\n	public AgeException() {\n		\n	}\n	public AgeException(String msg) {\n		super(msg);\n	}\n}\n//测试类\npublic class Test1 {\n	public static void main(String[] args) {\n		User u = new User();\n		try {\n			u.setAge(-1);\n		}catch(AgeException e){\n			System.out.println(e.getMessage());\n		}\n		System.out.println(u);\n	}\n}\n\nclass User {\n	private int age;\n	public User() {\n	}\n\n	public int getAge() {\n		return age;\n	}\n	public void setAge(int age) throws AgeException {\n		if (age < 0 || age > 150) {\n			throw new AgeException(\"年龄输入有误\");\n		}\n		this.age = age;\n	}\n	@Override\n	public String toString() {\n		return \"User [age=\" + age + \"]\";\n	}\n}\n```\n\n### 5.3 throws 和 throw 的区别\n\n- 位置不同：throws 是作用在方法上，后面跟着的是异常的类；而 throw 作用在方法内，后面跟着的是异常的对象。\n- 功能不同：throws 用来声明方法在运行过程中可能出现的异常，以便调用者根据不同的异常类型预先定义不同的处理方式；throw 用来抛出封装了异常信息的对象，程序在执行到 throw 时后续的代码将不再执行，而是跳转到调用者，并将异常信息抛给调用者。也就是说，throw 后面的语句将不再执行 ( finally 语句块除外)。\n\n## 6、总结\n\nthrow/throws就是一个甩手掌柜，它只会把异常一层层地往上抛，直到有人去处理它。而try...catch就是那个劳苦工人，负责获取相应的异常并对它进行处理。\n\n遇到异常，有两种处理方式，第一种自己处理，第二种向上抛，交给调用自己的时候再做处理。', 0, 0, '2020-08-06 22:10:15', 2, 0, 1, '1、异常的定义异常是不正常的事件，不是错误\n异常是指程序运行的过程中，发生某些意外的事情，比如10除以0， 文件不存在等。\npublic class ExcptionTest {public void test(){System.out.println(\"====运行前====\");int a=10/0;System.out.println(\"====运行后====\");}public static void main(String[] args) {ExcptionTest et= new ExcptionTest();et.test();}}\n在运行期我们int型的a 被除以0 那么 这样的事件称之为不正常事件，将发生异常，异常不是错误，是不正常的事情，错误往往是跟源代码的BUG 或者内部环境有关，如内存泄漏等。\n2、错误的定义​      错误是很难处理的，比如内存溢出等，不能够通过异常处理机制来解决。      异常是程序中发生的不正常事件流，通过处理程序依然可以运行下去。但是错误是无法控制的，程序肯定要中断。      应用软件与操作系统或其他应用软件发生不兼容造成应用程序发生错误。\n3、API中异常结构及常见异常所谓异常处理，就是把一些不正常的事件，用类标记出来。\n当发生某种不正常事件时，抛出这个类的对象，JVM的异常处理机制能够识别这种对象，并进行处理。\n API中根据需要，定义了一些类，来标记各种不正常的事件。我们把API中定义的这些异常类称为标准异常。  另外，需要理解的是，API中定义的异常类型，除了运行期异常是运行时检测到的一些异常，编译期异常都是用来标记API中其他类中的一些事件，比如IO处理的文件找不到等。\n3.1 异常的体系在Java中，Throwable是所有错误和异常的父类，Throwable类有两个直接子类：Exception类、Error类。\nError表示Java程序运行错误，可能是编译期错误或者系统错误，往往程序中并不处理，如果程序出现Error，则系统能做的工作也只能有记录错误的成因和安全终止。\nException表示Java程序运行异常，即运行中的程序发生了人们不期望发生的事件，可以被Java异常处理机制处理。是所有异常类的父类，是程序员所关心的。\n3.2 Exception的分类异常分为运行期异常和编译期异常两种。\n（1）运行期异常(RuntimeException)：指在 Java 虚拟机正常运行期间抛出的异常，是可以被捕获处理的，如果出现RuntimeException异常，那么一定是程序发生错误导致的。\n\nNullPointerException —— 空指针异常ClassCastException —— 类型转换异常ArrayIndexOutOfBundsException —— 数组下标越界 ……\n（2）编译期异常(CheckedException)：指在编译阶段 Java 编译器会检查 CheckedException 异常并强制程序捕获和处理此类程序，即要求程序在可能出现异常的地方通过 try catch 语句块捕获并处理异常。\n\nIOException —— 输入输出异常（打开错误文件）SQLExeption —— SQL 语法错误ClassNotFoundException —— 类不存在\n​    ……\n3.3 常见异常Exception                                            异常层次结构的根类\nRuntimeException                               所有运行期异常的基类 \nArithmeticException                            算术错误情形，如以零作除数 \nIllegalArgumentException                   方法接收到非法参数 \nArrayIndexOutOfBoundsException     数组大小小于或大于实际的数组大小 \nNullPointerException                           尝试访问  null 对象成员 \nClassNotFoundException                     不能加载所需的类 \nNumberFormatException                     例如字符串到 float 型数字的转换无效 \nIOException                                           I/O 异常的根类 \nFileNotFoundException                         找不到文件 \nEOFException                                         文件结束  \nInterruptedException                             线程中断\n 4、使用 try catch 捕获并处理异常4.1  try的使用和定义 检测不安全的代码块（发现异常） try块中任何一条语句发生了异常，下面的代码将不会被执行，程序将跳转到异常处理代码块中，即catch块。因此，不要随意将不相关的代码放到try块中，因为随时可能会中断执行。\n try{ 可能会发生异常的代码 }\n4.1 catch的使用和定义把抓到的类型匹配的异常捕获，保证程序能继续运行下去。 catch语句必须紧跟着try语句之后，称为捕获异常，也就是异常处理函数，一个try后面可以写多个catch，分别捕获不同类型的异常，要从子类往父类的顺序写，否则有编译错误。\n catch(异常类型 引用名)｛ 异常处理代码 ｝\n4.1 finally的使用和定义finally该内容总是会执行的，只能有一个finally语句\nfinally{ 必须执行的逻辑 }\n4.4 try/catch/finally基本语法try{可能会发生异常的代码}catch(异常类型 引用名){异常处理代码}finally{必须执行代码}\n（1）运行流程（无异常情况）\ntry{System.out.println(\"try\");}catch(Exception e) {System.out.println(\"Exception\");}finally{System.out.println(\"Finally\");}\n结果：\ntryFinally\n（2）运行流程（有异常情况）\ntry{String demo = null;demo.split(\"a\");System.out.println(\"try\");}catch(Exception e) {System.out.println(\"Exception\");e.printStackTrace();}finally{System.out.println(\"Finally\");}\n结果：\njava.lang.NullPointerExceptionException    at com.company.project.test.t1201.Demo.main(Demo.java:9)Finally\n4.5  finally与return在try中没有异常的情况下try、catch、finally的执行顺序 try —- finally\n如果try中有异常，执行顺序是try —- catch —- finally\n如果try中没有异常并且try中有return这时候正常执行顺序是try —— finally —- return\n如果try中有异常并且try中有return这时候正常执行顺序是try——catch—-finally—- return\n如果try有异常，相应catch中有return，顺序是try—-catch—-finally—-return  总之 finally 永远执行！\n除非，关掉Java虚拟机，System.exit(0)，finall将不会执行。\n5、抛出异常（throw与throws ）​       遇到异常时不进行具体处理，而是将异常抛给调用者，由调用者根据情况处理。有时候是直接捕获并处理，也有可能是继续向上抛出异常。\n 抛出异常有三种形式：throw、throws、系统自动抛出异常。\n​       其中，throws 作用在方法上，用于定义方法可能抛出的异常；throw 作用在方法内，表明抛出一个异常。他们两个共同处理编译器异常，而运行期异常通常是系统自动抛出异常。\n​       系统自动抛出异常：前面我们学习过，异常使用一些特殊类标记的，所谓发生异常，就是抛出一个异常类对象，JVM的异常机制能够识别这样的对象，并进行处理。       运行期异常都是JVM在运行时自行抛出的，而编译期异常都是程序员在编写代码时，通过语句自行抛出的。 \n5.1  throw关键字throw用于显式抛出异常，抛除异常后处理。 使用try-catch捕获异常\n5.1.1语法： throw new 异常类构造方法; 例如：throw new Exception();\n5.1.2  为什么要throw异常呢？    主要是要用这种异常类型标记一些不正常的事件，而且希望这些事件发生时，一定能被调用者关注并处理。 throw抛出异常后，可以有两种方式处理，一般使用第二种，即throws。 因为如果throw后使用try catch自行处理，意义不大。异常只被处理一次，调用者就没法处理该异常。 如果throw后使用了try catch，往往也会在catch中再使用throw继续抛出。 利用抛出的异常来标记不正常的事件，从而对事件流统一处理。\n5.1.3 throw的使用\n（1）一般配合try-catch 使用 \n格式如下：\npublic class ThisDemo06{public static void main(String args[]){try{throw new Exception(\"自己抛着玩的。\") ;// 抛出异常的实例化对象}catch(Exception e){System.out.println(e) ;}\nthrow e 实现了在try-catch块中对异常的上抛,catch块中不再对异常进行处理 在catch块中，throw e后不能再跟代码 ，且cathc块外，后面的代码不被执行。\n（2）也可以不配合try-catch，需要配合throws\nstatic int avg(int n1,int n2)throws Exception{if (n1<0||n2<0) { //判断方法参数是否满足条件throw new Exception(\"不能使用负数\");//错误信息}if (n1>100||n2>100) {throw new Exception(\"数值太大了\");}return (n1+n2)/2; // 将参数的平均值返回}\n5.2  throws这里的throws抛出的是一个异常类对象，这个对象带有所发生异常的信息。我们可以直接使用JAVA中已经封装好的异常信息类，也可以自己去定义一个异常类。\n用了throws关键字，相当于给一个方法加上了 不安全 标签。 使得调用这个方法的方法必须处理这些类型的异常，否则将出现编译错误。 当然，处理的方法也依然有两种，即try catch或者继续throws。\n任何方法都可以无条件的使用throws声明抛出任意类型的异常，抽象方法也可以。 可以说方法使用throws声明异常，在语法上没有任何要求。如果子类覆盖父类方法，子类的方法不能声明抛除比父类方法更多的异常类型。 就想你的年龄肯定没有你老爸的年龄大一样。\n5.2.1  throws 使用地方用于方法声明处，指出方法引发的异常。\n可以声明多种异常类型，用逗号分开即可。\n5.2.2 格式public void test throws 异常1，异常2，异常3{\n}\n5.2.3 throw的使用（1）调用系统的异常信息类\npublic class Test {    int age;    public void Abnormal() throws IOException{        int i=0;        int x=5/i;        System.out.println(x);    }    //主函数入口    public static void main(String[] args) throws IOException {        Test t=new Test();        t.Abnormal();    }}\n（2）自定义异常类\n1.自定义异常就是自己定义的异常类，也就是API中的标准异常类的直接或间接的子类。\n​    自定义异常类中往往不写其他方法，只重载需要使用的构造方法\n2.作用：用自定义异常标记业务逻辑的异常，避免与标准异常混淆。\n3.基本语法：\npublic class 异常类名 extends Exception{\npublic 异常类名(String msg){\nsuper(msg);\n}\n}\n例如：\n//自定义异常类public class AgeException extends Exception{    public AgeException() {    }    public AgeException(String msg) {        super(msg);    }}//测试类public class Test1 {    public static void main(String[] args) {        User u = new User();        try {            u.setAge(-1);        }catch(AgeException e){            System.out.println(e.getMessage());        }        System.out.println(u);    }}class User {    private int age;    public User() {    }    public int getAge() {        return age;    }    public void setAge(int age) throws AgeException {        if (age < 0 || age > 150) {            throw new AgeException(\"年龄输入有误\");        }        this.age = age;    }    @Override    public String toString() {        return \"User [age=\" + age + \"]\";    }}\n5.3 throws 和 throw 的区别\n位置不同：throws 是作用在方法上，后面跟着的是异常的类；而 throw 作用在方法内，后面跟着的是异常的对象。功能不同：throws 用来声明方法在运行过程中可能出现的异常，以便调用者根据不同的异常类型预先定义不同的处理方式；throw 用来抛出封装了异常信息的对象，程序在执行到 throw 时后续的代码将不再执行，而是跳转到调用者，并将异常信息抛给调用者。也就是说，throw 后面的语句将不再执行 ( finally 语句块除外)。\n6、总结throw/throws就是一个甩手掌柜，它只会把异常一层层地往上抛，直到有人去处理它。而try…catch就是那个劳苦工人，负责获取相应的异常并对它进行处理。\n遇到异常，有两种处理方式，第一种自己处理，第二种向上抛，交给调用自己的时候再做处理。\n', 0, 1);
INSERT INTO `t_article` VALUES (46, '19. 泛型', 8, '## **1.  概述**\n\n泛型，即“**参数化类型**”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？ 顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参）， 然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中， 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n使用<T>来声明一个类型持有者名称，然后就可以把T当作一个类型代表来声明成员、参数和返回值类型。当然T仅仅是个名字，这个名字可以自行定义。\n\n## 2.  Java中泛型的作用\n\n（1）简单安全\n\n​      在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。      消除代码中的强制类型转换，同时获得一个附加的类型检查层，该检查层可以防止有人将错误类型的值保存在集合中      在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。\n\n（2）可提高代码的高扩展性和重用率\n\n## 3. 注意：\n\n1、泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。 2、同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 3、泛型的类型参数可以有多个。 4、泛型的参数类型可以使用extends语句，例如<T extends superclass>习惯上称为“有界类型”。 5、泛型的参数类型还可以是通配符类型。 例如： Class<?> classType =Class.forName(\"java.lang.String\");\n\n## 4.   泛型类\n\n泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。\n\n此时，泛型类型可以用在该类的任意用到数据类型的位置，泛型在静态的方法、块、类、属性中不能使用。\n\n原因：静态的东西众所周知是属于类本身的，在类加载的时候，必须要清楚的加载到内存中。\n\n基本语法：\n\n```java\nclass 类名称 <泛型标识：可以随便写任意标识号，标识指定的泛型的类型>{\n  private 泛型标识 /*（成员变量类型）*/ var; \n  .....\n\n  }\n}\n```\n\n例子：\n\n定义：\n\n```java\n//在实例化泛型类时，必须指定T的具体类型\npublic class Generic<T>{ \n    //key这个成员变量的类型为T,T的类型由外部指定  \n    private T key;\n\n    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定\n        this.key = key;\n    }\n\n    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定\n        return key;\n    }\n}\n```\n\n实现：\n\n泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。\n\n不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。\n\n```java\n//传入的实参类型需与泛型的类型参数类型相同，即为Integer.\nGeneric<Integer> genericInteger = new Generic<Integer>(123456);\n\n//传入的实参类型需与泛型的类型参数类型相同，即为String.\nGeneric<String> genericString = new Generic<String>(\"key_vlaue\");\n\nLog.d(\"泛型测试\",\"key is \" + genericInteger.getKey());\nLog.d(\"泛型测试\",\"key is \" + genericString.getKey());\n```\n\n## 5.泛型接口\n\n泛型接口与泛型类的定义及使用基本相同。\n\n定义泛型接口：\n\n```java\npublic interface Generator<T> {\n    public T next();\n}\n```\n\n实现泛型接口：\n\n（1）当实现泛型接口的类，未传入泛型实参时：\n\n```java\n/**\n * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中\n * 即：class FruitGenerator<T> implements Generator<T>{\n * 如果不声明泛型，如：class FruitGenerator implements Generator<T>，编译器会报错：\"Unknown class\"\n */\n\nclass FruitGenerator<T> implements Generator<T>{\n    @Override\n    public T next() {\n        return null;\n    }\n}\n```\n\n（2）当实现泛型接口的类，传入泛型实参时：\n\n```java\n/**\n * 传入泛型实参时：\n * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator<T>\n * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。\n * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型\n * 即：Generator<T>，public T next();中的的T都要替换成传入的String类型。\n */\npublic class FruitGenerator implements Generator<String> {\n\n    private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"};\n\n    @Override\n    public String next() {\n        Random rand = new Random();\n        return fruits[rand.nextInt(3)];\n    }\n}\n```\n\n## 6.泛型方法\n\n是否拥有泛型方法，与其所在的类是否泛型没有关系。要定义泛型方法，只需将泛型参数列表置于返回值前。\n\n```java\npublic class ExampleA {\n\npublic <T> void f(T x) {\n\nSystem.out.println(x.getClass().getName());\n\n}\n```\n\n使用泛型方法时，不必指明参数类型，编译器会自己找出具体的类型。\n\n泛型方法除了定义不同，调用就像普通方法一样。\n\n## **7. 泛型通配符**\n\n类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。\n\n可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。\n\n例如：\n\n我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic<Ingeter>与Generic<Number>实际上是相同的一种基本类型。\n\n在使用Generic<Number>作为形参的方法中，不能使用Generic<Ingeter>的实例传入。\n\n因此我们需要一个在逻辑上可以表示同时是Generic<Integer>和Generic<Number>父类的引用类型。由此类型通配符应运而生。\n\n```java\npublic void showKeyValue1(Generic<?> obj){\n    Log.d(\"泛型测试\",\"key value is \" + obj.getKey());\n}\n\nGeneric<Integer> gInteger = new Generic<Integer>(123);\nGeneric<Number> gNumber = new Generic<Number>(456);\n```\n\n## 8.  泛型与静态成员\n\n泛型在静态的方法、块、类、属性中不能使用，静态方法无法访问类上定义的泛型。\n\n原因：静态的东西众所周知是属于类本身的，在类加载的时候，必须要清楚的加载到内存中。\n\n## 9.  **泛型上下边界**\n\n由于没有限制class GenericsFoo<T>类型持有者T的范围，实际上这里的限定类型相当于Object，这和“Object泛型”实质是一样的。\n\n在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。\n\n为泛型添加上边界，即传入的类型实参必须是指定类型的子类型。\n\n比如我们要限制T为集合接口类型。只需要这么做：\n\nclass GenericsFoo<T extends Collection>，这样类中的泛型T只能是Collection接口的实现类，传入非Collection接口编译会出错。\n\n注意： <T extends Collection>这里的限定使用关键字 extends，后面可以是类也可以是接口。但这里的extends已经不是继承的含义了，应该理解为T类型是实现Collection接口的类型，或者T是继承了XX类的类型。\n\n下面继续对上面的例子改进，我只要实现了集合接口的类型：\n\n```java\npublic class CollectionGenFoo<T extends Collection> {\n\nprivate T x;\n\npublic CollectionGenFoo(T x) {\n\nthis.x = x;\n\n}\n\npublic T getX() {\n\nreturn x;\n\n}\n\npublic void setX(T x) {\n\nthis.x = x;\n\n}\n\n}\n```\n\n## 10.总结\n\n一句话，泛型就是**类型参数化**。', 0, 0, '2020-08-06 22:11:40', 2, 0, 1, '1.  概述泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？ 顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参）， 然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中， 操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n使用<T>来声明一个类型持有者名称，然后就可以把T当作一个类型代表来声明成员、参数和返回值类型。当然T仅仅是个名字，这个名字可以自行定义。\n2.  Java中泛型的作用（1）简单安全\n​      在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。      消除代码中的强制类型转换，同时获得一个附加的类型检查层，该检查层可以防止有人将错误类型的值保存在集合中      在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。\n（2）可提高代码的高扩展性和重用率\n3. 注意：1、泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。 2、同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 3、泛型的类型参数可以有多个。 4、泛型的参数类型可以使用extends语句，例如<T extends superclass>习惯上称为“有界类型”。 5、泛型的参数类型还可以是通配符类型。 例如： Class<?> classType =Class.forName(“java.lang.String”);\n4.   泛型类泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。\n此时，泛型类型可以用在该类的任意用到数据类型的位置，泛型在静态的方法、块、类、属性中不能使用。\n原因：静态的东西众所周知是属于类本身的，在类加载的时候，必须要清楚的加载到内存中。\n基本语法：\nclass 类名称 <泛型标识：可以随便写任意标识号，标识指定的泛型的类型>{  private 泛型标识 /*（成员变量类型）*/ var;   .....  }}\n例子：\n定义：\n//在实例化泛型类时，必须指定T的具体类型public class Generic<T>{     //key这个成员变量的类型为T,T的类型由外部指定      private T key;    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定        this.key = key;    }    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定        return key;    }}\n实现：\n泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。\n不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。\n//传入的实参类型需与泛型的类型参数类型相同，即为Integer.Generic<Integer> genericInteger = new Generic<Integer>(123456);//传入的实参类型需与泛型的类型参数类型相同，即为String.Generic<String> genericString = new Generic<String>(\"key_vlaue\");Log.d(\"泛型测试\",\"key is \" + genericInteger.getKey());Log.d(\"泛型测试\",\"key is \" + genericString.getKey());\n5.泛型接口泛型接口与泛型类的定义及使用基本相同。\n定义泛型接口：\npublic interface Generator<T> {    public T next();}\n实现泛型接口：\n（1）当实现泛型接口的类，未传入泛型实参时：\n/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator<T> implements Generator<T>{ * 如果不声明泛型，如：class FruitGenerator implements Generator<T>，编译器会报错：\"Unknown class\" */class FruitGenerator<T> implements Generator<T>{    @Override    public T next() {        return null;    }}\n（2）当实现泛型接口的类，传入泛型实参时：\n/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator<T> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator<T>，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator<String> {    private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"};    @Override    public String next() {        Random rand = new Random();        return fruits[rand.nextInt(3)];    }}\n6.泛型方法是否拥有泛型方法，与其所在的类是否泛型没有关系。要定义泛型方法，只需将泛型参数列表置于返回值前。\npublic class ExampleA {public <T> void f(T x) {System.out.println(x.getClass().getName());}\n使用泛型方法时，不必指明参数类型，编译器会自己找出具体的类型。\n泛型方法除了定义不同，调用就像普通方法一样。\n7. 泛型通配符类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。\n可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。\n例如：\n我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic<Ingeter>与Generic<Number>实际上是相同的一种基本类型。\n在使用Generic<Number>作为形参的方法中，不能使用Generic<Ingeter>的实例传入。\n因此我们需要一个在逻辑上可以表示同时是Generic<Integer>和Generic<Number>父类的引用类型。由此类型通配符应运而生。\npublic void showKeyValue1(Generic<?> obj){    Log.d(\"泛型测试\",\"key value is \" + obj.getKey());}Generic<Integer> gInteger = new Generic<Integer>(123);Generic<Number> gNumber = new Generic<Number>(456);\n8.  泛型与静态成员泛型在静态的方法、块、类、属性中不能使用，静态方法无法访问类上定义的泛型。\n原因：静态的东西众所周知是属于类本身的，在类加载的时候，必须要清楚的加载到内存中。\n9.  泛型上下边界由于没有限制class GenericsFoo<T>类型持有者T的范围，实际上这里的限定类型相当于Object，这和“Object泛型”实质是一样的。\n在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。\n为泛型添加上边界，即传入的类型实参必须是指定类型的子类型。\n比如我们要限制T为集合接口类型。只需要这么做：\nclass GenericsFoo<T extends Collection>，这样类中的泛型T只能是Collection接口的实现类，传入非Collection接口编译会出错。\n注意： <T extends Collection>这里的限定使用关键字 extends，后面可以是类也可以是接口。但这里的extends已经不是继承的含义了，应该理解为T类型是实现Collection接口的类型，或者T是继承了XX类的类型。\n下面继续对上面的例子改进，我只要实现了集合接口的类型：\npublic class CollectionGenFoo<T extends Collection> {private T x;public CollectionGenFoo(T x) {this.x = x;}public T getX() {return x;}public void setX(T x) {this.x = x;}}\n10.总结一句话，泛型就是类型参数化。\n', 0, 1);
INSERT INTO `t_article` VALUES (47, '20. Eclipse可视化GUI插件', 8, '\n> 参考链接：https://blog.csdn.net/qq_42035966/article/details/82258199#5.%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8DWindowBuilderblog.csdn.net\n\n\n\n其实最方便的方法是用插件制作，当然大家先了解完代码原理是最好的哈哈。eclispe安装windowbuilder有两种方式，一种是离线安装，一种是在线安装。\n\n### 1、介绍WindowBuilder插件\n\n找到http://www.eclipse.org/windowbuilder/download.php\n\n![img](https://pic1.zhimg.com/v2-0c1b52b0deb18ddeb9992eba3e7bb280_b.png)\n\n根据自己的eclipse版本选择，因为我的版本较高，所以只能在线安装。\n\n### 2、在eclipse的中安装\n\n（1）选择Help - Eclipse MarketPlace\n\n![img](https://pic4.zhimg.com/v2-56987351719c37e8b1bfa0b98072f287_b.png)\n\n（2）在商店中搜索windowbuilder ，会出现WindowBuilder插件，点击Installed。\n\n![img](https://pic2.zhimg.com/v2-1591b290ddc1165529280dda7ba051e9_b.png)\n\n（3）直接默认选择，点击confirm。\n\n![img](https://pic1.zhimg.com/v2-fa7f64d958649406e6e73bad925efb04_b.png)\n\n（4）选择我同意，然后点击finish。\n\n![img](https://pic1.zhimg.com/v2-75c100f474acb454cd187e87ec4984a4_b.png)\n\n（5） 等待下载完毕\n\n![img](https://pic4.zhimg.com/v2-8a22c265d9f78b0fd8aa6d234dd655df_b.png)\n\n（6）下载完后需要重启，系统会给提升。\n\n### 3、WindowBuilder插件的使用\n\n（1）在Eclipe菜单中File - New -Other ，选中WindowBuilder - Swing Designer - JFrame。\n\n![img](https://pic2.zhimg.com/v2-c693862557b411f3b99566c0b06cf315_b.png)\n\n（2）打开文件，点击左下角的Design进入视图模式，左边对应代码模式\n\n左上是整个视图结构，左下是单个结构的属性，可以在这里修改窗口的一些属性，\n\n中间是整个swing的界面按钮，前面第二点介绍过的，这里就不说了，\n\n右边就是视图了，可以点击按钮往视图里面添加，如下图。\n\n![img](https://pic4.zhimg.com/v2-96099f43ba926a0e8d760523b7115673_b.png)\n\n ', 0, 0, '2020-08-06 22:12:18', 2, 0, 1, '\n参考链接：https://blog.csdn.net/qq_42035966/article/details/82258199#5.%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8DWindowBuilderblog.csdn.net\n\n其实最方便的方法是用插件制作，当然大家先了解完代码原理是最好的哈哈。eclispe安装windowbuilder有两种方式，一种是离线安装，一种是在线安装。\n1、介绍WindowBuilder插件找到http://www.eclipse.org/windowbuilder/download.php\n\n根据自己的eclipse版本选择，因为我的版本较高，所以只能在线安装。\n2、在eclipse的中安装（1）选择Help - Eclipse MarketPlace\n\n（2）在商店中搜索windowbuilder ，会出现WindowBuilder插件，点击Installed。\n\n（3）直接默认选择，点击confirm。\n\n（4）选择我同意，然后点击finish。\n\n（5） 等待下载完毕\n\n（6）下载完后需要重启，系统会给提升。\n3、WindowBuilder插件的使用（1）在Eclipe菜单中File - New -Other ，选中WindowBuilder - Swing Designer - JFrame。\n\n（2）打开文件，点击左下角的Design进入视图模式，左边对应代码模式\n左上是整个视图结构，左下是单个结构的属性，可以在这里修改窗口的一些属性，\n中间是整个swing的界面按钮，前面第二点介绍过的，这里就不说了，\n右边就是视图了，可以点击按钮往视图里面添加，如下图。\n\n', 0, 1);
INSERT INTO `t_article` VALUES (48, '21. 集合', 8, '\n> 参考链接： \n>\n> [https://blog.csdn.net/zhangqunshuai/article/details/80660974]\n>\n> [(https://blog.csdn.net/zhangqunshuai/article/details/80660974)\n>\n> https://blog.csdn.net/t_testview/article/details/89014863\n>\n> 参考书籍： Offer来了（Java面试核心知识点）王磊  电子工业出版社\n\n## 1、概述\n\n![img](https://pic2.zhimg.com/v2-9d1ac5e50d314a6113f3f62f3386497d_b.png)\n\nList , Set, Map都是接口，前两个继承至Collection接口，Map为独立接口\n\nSet下有HashSet，LinkedHashSet，TreeSet\n\nList下有ArrayList，Vector，LinkedList\n\nMap下有Hashtable，LinkedHashMap，HashMap，TreeMap\n\nCollection接口下还有个Queue接口，有PriorityQueue类\n\nJava中集合类是放在java.util中，是一个用来存放对象的容器。 1、只能存放对象，不能存放int等类型，存的是对应的是Integer等对象 2、存的是对象的引用，对象本身是放在堆内存中 3、可以存放不同类型的对象（因为实现的时候使用了泛型），不建议使用。\n\n**注意：**\n\nQueue接口与List、Set同一级别，都是继承了Collection接口。\n\n看图你会发现,LinkedList既可以实现Queue接口,也可以实现List接口.只不过呢, LinkedList实现了Queue接口。Queue接口窄化了对LinkedList的方法的访问权限（即在方法中的参数类型如果是Queue时，就完全只能访问Queue接口所定义的方法 了，而不能直接访问 LinkedList的非Queue的方法），以使得只有恰当的方法才可以使用。\n\nSortedSet是个接口，它里面的（只有TreeSet这一个实现可用）中的元素一定是有序的。\n\n## 2、Connection接口（所有集合类的根接口）\n\n![img](https://pic1.zhimg.com/v2-153bc27c94977a439cc71abd1a13f06c_b.jpg)\n\n### 2.1 **List集合**\n\n特点： 有序,可重复\n\n- ArrayList **优点:** 底层数据结构是**数组**，**查询快**；定义时不需要定义数组大小，如果数组大小不够，会创建一个新的更大的数组将原来的元素复制过去。 **缺点:** **线程不安全**；**增删慢**。（元素必须连续存储，因此如果在中间位置添加或删除元素，需要其后面所有元素进行移动，不适合随机插入和删除，更适合随机查找和遍历操作）\n- Vector **优点:** 底层数据结构是**数组**，**查询快**；**线程安全**，支持线程同步（即同一时刻只允许一个线程对Vector进行写操作，以保证多线程下数据的一致性） **缺点:** **增删慢**；读写效率比ArrayList低（因为需要频繁的对Vector对象进行加锁和释放锁操作）\n- LinkedList **优点:** 底层数据结构是**双向链表**，**增删快**（链表操作，增删只需要移动对应指针）。 **缺点:** **线程不安全**，效率高，**查询慢**（需要从头到尾遍历）\n\n### 2.2 Queue队列\n\n- ArrayBlockingQueue:基于数组数据结构实现的有界阻塞队列。\n- LinkedBlockingQueue:基于链表数据结构的有界阻塞队列。\n- PriorityBlockingQueue:支持优先级排序的无界阻塞队列。\n- DelayQueue:支持延迟操作的无界阻塞队列。\n- SynchronousQueue:用于线程同步的阻塞队列。\n- LinkedTransferQueue:基于链表数据结构实现的无界阻塞队列。\n- LinkedBlockingQueue:基于链表数据结构实现的双向阻塞队列。\n\n### 2.3 Set 集合\n\n特点：不可重复，无序\n\n**（1）HashSet**\n\n特点：底层数据结构是**哈希表**。(**无序,唯一**)\n\n**如何来保证元素唯一性?**\n\n依赖两个方法：**hashCode()和equals()**\n\n**（2）LinkedHashSet（HashTable实现数据存储，双向链表记录顺序 ）**\n\n特点：底层数据结构是链表和哈希表。(FIFO插入有序,唯一)\n\n1.由链表保证元素有序\n\n2.由哈希表保证元素唯一\n\n**（3）TreeSet**\n\n特点：底层数据结构是红黑树。基于二叉树的原理对新添加的对象按照指定的顺序排序（升序或降序），每添加一个对象都会进行排序，并将对象插入二叉树的指定位置。(唯一，有序)\n\n1）.如何保证元素唯一性的呢?\n\n根据比较的返回值是否是0来决定\n\n2）. 如何保证元素排序的呢?\n\n**① 自然排序**\n\n- 需要排序的类中实现 Comparable接口\n- 重写Comparable接口中的Compareto方法\n\n代码演示：\n\n把用户类按照名字长度排序，长度相等的按照名字的hash值，如果hash值相等则名字相等，按照年龄排序。\n\nUser类：\n\n```java\npublic class User implements Comparable<User> {\n	private String name;\n	private int age;\n\n	public User(String name, int age) {\n		this.name = name;\n		this.age = age;\n	}\n\n	public String getName() {\n		return name;\n	}\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public int getAge() {\n		return age;\n	}\n\n	public void setAge(int age) {\n		this.age = age;\n	}\n\n	@Override\n	public int hashCode() {\n		final int prime = 31;\n		int result = 1;\n		result = prime * result + age;\n		result = prime * result + ((name == null) ? 0 : name.hashCode());\n		return result;\n	}\n\n	@Override\n	public boolean equals(Object obj) {\n		if (this == obj)\n			return true;\n		if (obj == null)\n			return false;\n		if (getClass() != obj.getClass())\n			return false;\n		User other = (User) obj;\n		if (age != other.age)\n			return false;\n		if (name == null) {\n			if (other.name != null)\n				return false;\n		} else if (!name.equals(other.name))\n			return false;\n		return true;\n	}\n\n	@Override\n	public int compareTo(User o) {\n		// return -1; //-1表示放在红黑树的左边,即逆序输出\n		// return 1; //1表示放在红黑树的右边，即顺序输出\n		// return 0; //表示元素相同，仅存放第一个元素\n		// 主要条件 姓名的长度,如果姓名长度小的就放在左子树，否则放在右子树\n		int num = this.name.length() - o.name.length();\n		// 姓名的长度相同，不代表内容相同,如果按字典顺序此 String 对象位于参数字符串之前，则比较结果为一个负整数。\n		// 如果按字典顺序此 String 对象位于参数字符串之后，则比较结果为一个正整数。\n		// 如果这两个字符串相等，则结果为 0\n		int num1 = num == 0 ? (this.name.hashCode() - o.name.hashCode()) : num;\n		// 姓名的长度和内容相同，不代表年龄相同，所以还要判断年龄\n		int num2 = num1 == 0 ? this.age - o.age : num1;\n		return num2;\n\n	}\n\n	@Override\n	public String toString() {\n		return \"User [name=\" + name + \", age=\" + age + \"]\";\n	}\n\n}\n```\n\n测试类：\n\n```java\nimport java.util.TreeSet;\n\npublic class Demo {\n	public static void main(String[] args) {\n		User user1 = new User(\"zhanggengying\", 18);\n		User user2 = new User(\"zhoufan\", 21);\n		User user3 = new User(\"zhoufan\", 20);\n\n		TreeSet<User> ts = new TreeSet<User>();\n		ts.add(user1);\n		ts.add(user2);\n		ts.add(user3);\n\n		for (User user : ts) {\n			System.out.println(user);\n		}\n	}\n}\n```\n\n结果：\n\n```\nUser [name=zhoufan, age=20]\nUser [name=zhoufan, age=21]\nUser [name=zhanggengying, age=18]\n```\n\n**② 比较器排序**\n\n比较器排序步骤：\n\n- 单独创建一个比较类，这里以MyComparator为例，并且要让其继承Comparator接口。\n- 重写Comparator接口中的Compare方法。\n\n代码案例：和上述案例相同，不过是另一种实现方式\n\n//用户类\n\n```java\npackage com.company.project.test09;\n\npublic class User {\n	private String name;\n	private int age;\n\n	public User(String name, int age) {\n		this.name = name;\n		this.age = age;\n	}\n\n	public String getName() {\n		return name;\n	}\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public int getAge() {\n		return age;\n	}\n\n	public void setAge(int age) {\n		this.age = age;\n	}\n\n	@Override\n	public int hashCode() {\n		final int prime = 31;\n		int result = 1;\n		result = prime * result + age;\n		result = prime * result + ((name == null) ? 0 : name.hashCode());\n		return result;\n	}\n\n	@Override\n	public boolean equals(Object obj) {\n		if (this == obj)\n			return true;\n		if (obj == null)\n			return false;\n		if (getClass() != obj.getClass())\n			return false;\n		User other = (User) obj;\n		if (age != other.age)\n			return false;\n		if (name == null) {\n			if (other.name != null)\n				return false;\n		} else if (!name.equals(other.name))\n			return false;\n		return true;\n	}\n\n	@Override\n	public String toString() {\n		return \"User [name=\" + name + \", age=\" + age + \"]\";\n	}\n\n}\n```\n\n//自己写的比较器\n\n```java\npackage com.company.project.test09;\n\nimport java.util.Comparator;\n\npublic class MyComparator implements Comparator<User> {\n\n	@Override\n	public int compare(User s1, User s2) {\n		// 姓名长度\n		int num = s1.getName().length() - s2.getName().length();\n		// 姓名内容\n		int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num;\n		// 年龄\n		int num3 = num2 == 0 ? s1.getAge() - s2.getAge() : num2;\n		return num3;\n	}\n\n}\n```\n\n//测试类\n\n```java\npackage com.company.project.test09;\n\nimport java.util.TreeSet;\n\n//TreeSet的自然排序\n//实现Comparable接口，重写compareTo方法\npublic class Demo {\n	public static void main(String[] args) {\n		User user1 = new User(\"zhanggengying\", 18);\n		User user2 = new User(\"zhoufan\", 21);\n		User user3 = new User(\"zhoufan\", 20);\n\n		TreeSet<User> ts = new TreeSet<User>(new MyComparator());\n		ts.add(user1);\n		ts.add(user2);\n		ts.add(user3);\n\n		for (User user : ts) {\n			System.out.println(user);\n		}\n	}\n}\n```\n\n\n\n**（4）TreeSet, LinkedHashSet and HashSet 的区别**\n\n1）介绍：\n\n- TreeSet, LinkedHashSet and HashSet 在java中都是实现Set的数据结构\n- TreeSet的主要功能用于排序\n- LinkedHashSet的主要功能用于保证FIFO即有序的集合(先进先出)\n- HashSet只是通用的存储数据的集合，通过传入的数据，计算出哈希值，存入哈希表中。\n\n2）相同点\n\n- Duplicates elements: 因为三者都实现Set interface，所以三者都不包含duplicate elements\n- Thread safety: 三者都不是线程安全的，如果要使用线程安全可以Collections.synchronizedSet()\n\n3）不同点\n\n- Performance and Speed: HashSet插入数据最快，其次LinkHashSet，最慢的是TreeSet因为内部实现排序\n- Ordering: HashSet不保证有序，LinkHashSet保证FIFO即按插入顺序排序，TreeSet安装内部实现排序，也可以自定义排序规则\n- null:HashSet和LinkHashSet允许存在null数据，但是TreeSet中插入null数据时会报NullPointerException\n\n代码：\n\n```java\npackage com.company.project.test07;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.TreeSet;\n\n//TreeSet, LinkedHashSet and HashSet的区别\npublic class Demo {\n	public static void main(String[] args) {\n		HashSet<Integer> hashSet = new HashSet<>();\n		LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n		TreeSet<Integer> treeSet = new TreeSet<>();\n\n		for (Integer data : Arrays.asList(5, 4, 3, 6, 8, 9, 10, 50, 30, 90, 111)) {\n			// hashSet.add(data);\n			hashSet.add(data);\n			linkedHashSet.add(data);\n			treeSet.add(data);\n		}\n\n		// 不保证有序\n		System.out.println(\"Ordering in HashSet :\" + hashSet);\n\n		// FIFO保证安装插入顺序排序\n		System.out.println(\"Order of element in LinkedHashSet :\" + linkedHashSet);\n\n		// 内部实现排序\n		System.out.println(\"Order of objects in TreeSet :\" + treeSet);\n\n	}\n\n}\n```\n\n结果：\n\n```\nOrdering in HashSet :[50, 3, 4, 5, 6, 8, 9, 10, 90, 30, 111]\nOrder of element in LinkedHashSet :[5, 4, 3, 6, 8, 9, 10, 50, 30, 90, 111]\nOrder of objects in TreeSet :[3, 4, 5, 6, 8, 9, 10, 30, 50, 90, 111]\n```\n\n### 2.4 总结\n\n**针对Collection集合我们到底使用谁呢?(掌握)**\n\n![img](https://pic4.zhimg.com/v2-5eba4cf43105e4f4899e75e793d41c9f_b.jpg)\n\n## 3. Map接口（映射接口，存放键值对）\n\n![img](https://pic3.zhimg.com/v2-b37ca31b6903a4a01bb18d77cb059446_b.jpg)\n\n**特点：**\n\n以键值对的形式存放对象。key-value。一般是key为String类型，value为Object的类型。\n\nMap接口有四个比较重要的实现类，分别是HashMap、TreeMap、LinkedHashMap和HashTable。\n\n### 3.1 Map集合\n\n1. **HashMap（数组+链表/红黑树，线程不安全）**\n\nHashMap的数据结构，内部为数组，数组的每个元素又是一个单向链表，如果单链表的元素超过8个，HashMap又会将链式结构变为红黑树来提高查找效率。\n\n如果想要线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全，或者使用ConcurrentHashMap。\n\n![img](https://pic3.zhimg.com/v2-2dfedb378f5a074ffbcf4ab3bc864afe_b.png)\n\nHashMap数组+链表结构\n\n![img](https://pic3.zhimg.com/v2-715b7962d5522724dc7a7d7f97a565ca_b.png)\n\nHashMap数组+红黑树结构\n\n2.**ConcurrentHashMap(分段锁实现，线程安全)**\n\n**采用分段锁的思想实现并发操作，因此线程安全。**\n\nConcurrentHashMap由多个Segment组成（Segment的数量是锁的并发度），每个Segment都是继承ReentrantLock并单独加锁，所有每次加锁操作是锁住的都是一个Segment，这样只要保证每个Segment都是线程安全的，也就实现了全局的线程安全。\n\n![img](https://pic4.zhimg.com/v2-7d70d9d05254f87e66f3b95536d5a4ef_b.png)\n\nConcurrentHashMap数组+单向链表结构\n\n![img](https://pic3.zhimg.com/v2-6b9680e7409cb860c078af0e45864f16_b.png)\n\nConcurrentHashMap数组+红黑树结构\n\n3.**HashTable(线程安全，哈希表)**\n\n继承Dictionary类，同一时刻只有一个线程能写HashTable,并发性不如ConcurrentHashMap\n\n4.**TreeMap(二叉树数据结构，有序)**\n\n实现了SortedMap接口保证元素顺序存储，默认按键值升序存储，也可自定义比较器（实现Comparable接口或者自定义比较器）\n\n5.**LinkedHashMap（基于HashTable数据结构，使用链表保存插入顺序）**\n\nLinkedHashMap是HashMap的子类，内部使用链表保存元素的插入顺序，通过Iterator遍历LinkedHashMap时，会按照元素的插入顺序访问元素。\n\n（1）HashMap、TreeMap、LinkedHashMap的区别：\n\n![img](https://pic3.zhimg.com/v2-40a69290a6e289ff3b0473cdfcdb8dce_b.jpg)\n\n（2）Hashtable和HashMap的区别：\n\n- Hashtable的方法是同步的，HashMap的方法不是同步的。这是两者最主要的区别。\n- Hashtable是线程安全的，HashMap不是线程安全的。\n- HashMap效率较高，Hashtable效率较低。\n- Hashtable不允许null值，HashMap允许null值（key和value都允许，HashMap允许多条记录的值为null）\n- 父类不同：Hashtable的父类是Dictionary，HashMap的父类是AbstractMap\n\n（3）如何选择Hashtable和HashMap？\n\n如果对同步性或与遗留代码的兼容性没有任何要求，建议使用HashMap。 查看Hashtable的源代码就可以发现，除构造函数外，Hashtable的所有 public 方法声明中都有 synchronized关键字，而HashMap的源码中则没有。\n\n（4）所有带hash的前缀的Map集合的存储原理：\n\n- 通过 new 关键字在 Heap 堆中申请空间\n- 保存其中元素的空间，按照hash码，预设好一个个的空间，这个空间就是 Hash Bucket(哈希桶)\n- 每个桶有自己的Hash编号 ，一开始有少量的 Hash Bucket\n- 当程序试图将一个 key-value(Entry) 放入 HashMap 中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的Bucket位置。\n- 如果该Bucket为空，直接存放入该Bucket;\n- 如果该Bucket不为空，使用 equals 比较两个Entry 的 Key；\n- if(true){新 value 将覆盖 Entry 原 value，key 不变}\n- if(false){新 Entry 将与 Bucket中原 Entry 形成 Entry 链，而且新 Entry 位于 Entry 链的头部}\n\n### 3.2 Map集合的遍历：\n\n1、通过内部类Entry进行遍历\n\n2、通过迭代器进行遍历，先获得Entry的Set集合\n\n3、通过keySet方法获得键的Set集合，通过遍历键取值\n\n4、通过map.values()获得所有值，但是不能获得键\n\n代码演示：\n\n```java\npackage com.company.project.test1001;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n//Map集合的遍历\npublic class Demo {\n	public static void main(String[] args) {\n		Map<String, String> map = new HashMap<String, String>();\n		map.put(\"A\", \"北京\");\n		map.put(\"D\", \"上海\");\n		map.put(\"C\", \"广东\");\n\n		for (Map.Entry<String, String> entry : map.entrySet()) {\n			System.out.println(entry);\n		}\n\n	}\n}\n```\n\n结果：\n\n```\nA=北京\nC=广东\nD=上海\n```', 0, 0, '2020-08-06 22:12:54', 2, 0, 1, '\n参考链接： \n[https://blog.csdn.net/zhangqunshuai/article/details/80660974]\n[(https://blog.csdn.net/zhangqunshuai/article/details/80660974)\nhttps://blog.csdn.net/t_testview/article/details/89014863\n参考书籍： Offer来了（Java面试核心知识点）王磊  电子工业出版社\n\n1、概述\nList , Set, Map都是接口，前两个继承至Collection接口，Map为独立接口\nSet下有HashSet，LinkedHashSet，TreeSet\nList下有ArrayList，Vector，LinkedList\nMap下有Hashtable，LinkedHashMap，HashMap，TreeMap\nCollection接口下还有个Queue接口，有PriorityQueue类\nJava中集合类是放在java.util中，是一个用来存放对象的容器。 1、只能存放对象，不能存放int等类型，存的是对应的是Integer等对象 2、存的是对象的引用，对象本身是放在堆内存中 3、可以存放不同类型的对象（因为实现的时候使用了泛型），不建议使用。\n注意：\nQueue接口与List、Set同一级别，都是继承了Collection接口。\n看图你会发现,LinkedList既可以实现Queue接口,也可以实现List接口.只不过呢, LinkedList实现了Queue接口。Queue接口窄化了对LinkedList的方法的访问权限（即在方法中的参数类型如果是Queue时，就完全只能访问Queue接口所定义的方法 了，而不能直接访问 LinkedList的非Queue的方法），以使得只有恰当的方法才可以使用。\nSortedSet是个接口，它里面的（只有TreeSet这一个实现可用）中的元素一定是有序的。\n2、Connection接口（所有集合类的根接口）\n2.1 List集合特点： 有序,可重复\n\nArrayList 优点: 底层数据结构是数组，查询快；定义时不需要定义数组大小，如果数组大小不够，会创建一个新的更大的数组将原来的元素复制过去。 缺点: 线程不安全；增删慢。（元素必须连续存储，因此如果在中间位置添加或删除元素，需要其后面所有元素进行移动，不适合随机插入和删除，更适合随机查找和遍历操作）Vector 优点: 底层数据结构是数组，查询快；线程安全，支持线程同步（即同一时刻只允许一个线程对Vector进行写操作，以保证多线程下数据的一致性） 缺点: 增删慢；读写效率比ArrayList低（因为需要频繁的对Vector对象进行加锁和释放锁操作）LinkedList 优点: 底层数据结构是双向链表，增删快（链表操作，增删只需要移动对应指针）。 缺点: 线程不安全，效率高，查询慢（需要从头到尾遍历）\n2.2 Queue队列\nArrayBlockingQueue:基于数组数据结构实现的有界阻塞队列。LinkedBlockingQueue:基于链表数据结构的有界阻塞队列。PriorityBlockingQueue:支持优先级排序的无界阻塞队列。DelayQueue:支持延迟操作的无界阻塞队列。SynchronousQueue:用于线程同步的阻塞队列。LinkedTransferQueue:基于链表数据结构实现的无界阻塞队列。LinkedBlockingQueue:基于链表数据结构实现的双向阻塞队列。\n2.3 Set 集合特点：不可重复，无序\n（1）HashSet\n特点：底层数据结构是哈希表。(无序,唯一)\n如何来保证元素唯一性?\n依赖两个方法：hashCode()和equals()\n（2）LinkedHashSet（HashTable实现数据存储，双向链表记录顺序 ）\n特点：底层数据结构是链表和哈希表。(FIFO插入有序,唯一)\n1.由链表保证元素有序\n2.由哈希表保证元素唯一\n（3）TreeSet\n特点：底层数据结构是红黑树。基于二叉树的原理对新添加的对象按照指定的顺序排序（升序或降序），每添加一个对象都会进行排序，并将对象插入二叉树的指定位置。(唯一，有序)\n1）.如何保证元素唯一性的呢?\n根据比较的返回值是否是0来决定\n2）. 如何保证元素排序的呢?\n① 自然排序\n\n需要排序的类中实现 Comparable接口重写Comparable接口中的Compareto方法\n代码演示：\n把用户类按照名字长度排序，长度相等的按照名字的hash值，如果hash值相等则名字相等，按照年龄排序。\nUser类：\npublic class User implements Comparable<User> {    private String name;    private int age;    public User(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        User other = (User) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }    @Override    public int compareTo(User o) {        // return -1; //-1表示放在红黑树的左边,即逆序输出        // return 1; //1表示放在红黑树的右边，即顺序输出        // return 0; //表示元素相同，仅存放第一个元素        // 主要条件 姓名的长度,如果姓名长度小的就放在左子树，否则放在右子树        int num = this.name.length() - o.name.length();        // 姓名的长度相同，不代表内容相同,如果按字典顺序此 String 对象位于参数字符串之前，则比较结果为一个负整数。        // 如果按字典顺序此 String 对象位于参数字符串之后，则比较结果为一个正整数。        // 如果这两个字符串相等，则结果为 0        int num1 = num == 0 ? (this.name.hashCode() - o.name.hashCode()) : num;        // 姓名的长度和内容相同，不代表年龄相同，所以还要判断年龄        int num2 = num1 == 0 ? this.age - o.age : num1;        return num2;    }    @Override    public String toString() {        return \"User [name=\" + name + \", age=\" + age + \"]\";    }}\n测试类：\nimport java.util.TreeSet;public class Demo {    public static void main(String[] args) {        User user1 = new User(\"zhanggengying\", 18);        User user2 = new User(\"zhoufan\", 21);        User user3 = new User(\"zhoufan\", 20);        TreeSet<User> ts = new TreeSet<User>();        ts.add(user1);        ts.add(user2);        ts.add(user3);        for (User user : ts) {            System.out.println(user);        }    }}\n结果：\nUser [name=zhoufan, age=20]User [name=zhoufan, age=21]User [name=zhanggengying, age=18]② 比较器排序\n比较器排序步骤：\n\n单独创建一个比较类，这里以MyComparator为例，并且要让其继承Comparator接口。重写Comparator接口中的Compare方法。\n代码案例：和上述案例相同，不过是另一种实现方式\n//用户类\npackage com.company.project.test09;public class User {    private String name;    private int age;    public User(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        User other = (User) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }    @Override    public String toString() {        return \"User [name=\" + name + \", age=\" + age + \"]\";    }}\n//自己写的比较器\npackage com.company.project.test09;import java.util.Comparator;public class MyComparator implements Comparator<User> {    @Override    public int compare(User s1, User s2) {        // 姓名长度        int num = s1.getName().length() - s2.getName().length();        // 姓名内容        int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num;        // 年龄        int num3 = num2 == 0 ? s1.getAge() - s2.getAge() : num2;        return num3;    }}\n//测试类\npackage com.company.project.test09;import java.util.TreeSet;//TreeSet的自然排序//实现Comparable接口，重写compareTo方法public class Demo {    public static void main(String[] args) {        User user1 = new User(\"zhanggengying\", 18);        User user2 = new User(\"zhoufan\", 21);        User user3 = new User(\"zhoufan\", 20);        TreeSet<User> ts = new TreeSet<User>(new MyComparator());        ts.add(user1);        ts.add(user2);        ts.add(user3);        for (User user : ts) {            System.out.println(user);        }    }}\n（4）TreeSet, LinkedHashSet and HashSet 的区别\n1）介绍：\n\nTreeSet, LinkedHashSet and HashSet 在java中都是实现Set的数据结构TreeSet的主要功能用于排序LinkedHashSet的主要功能用于保证FIFO即有序的集合(先进先出)HashSet只是通用的存储数据的集合，通过传入的数据，计算出哈希值，存入哈希表中。\n2）相同点\n\nDuplicates elements: 因为三者都实现Set interface，所以三者都不包含duplicate elementsThread safety: 三者都不是线程安全的，如果要使用线程安全可以Collections.synchronizedSet()\n3）不同点\n\nPerformance and Speed: HashSet插入数据最快，其次LinkHashSet，最慢的是TreeSet因为内部实现排序Ordering: HashSet不保证有序，LinkHashSet保证FIFO即按插入顺序排序，TreeSet安装内部实现排序，也可以自定义排序规则null:HashSet和LinkHashSet允许存在null数据，但是TreeSet中插入null数据时会报NullPointerException\n代码：\npackage com.company.project.test07;import java.util.Arrays;import java.util.HashSet;import java.util.LinkedHashSet;import java.util.TreeSet;//TreeSet, LinkedHashSet and HashSet的区别public class Demo {    public static void main(String[] args) {        HashSet<Integer> hashSet = new HashSet<>();        LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();        TreeSet<Integer> treeSet = new TreeSet<>();        for (Integer data : Arrays.asList(5, 4, 3, 6, 8, 9, 10, 50, 30, 90, 111)) {            // hashSet.add(data);            hashSet.add(data);            linkedHashSet.add(data);            treeSet.add(data);        }        // 不保证有序        System.out.println(\"Ordering in HashSet :\" + hashSet);        // FIFO保证安装插入顺序排序        System.out.println(\"Order of element in LinkedHashSet :\" + linkedHashSet);        // 内部实现排序        System.out.println(\"Order of objects in TreeSet :\" + treeSet);    }}\n结果：\nOrdering in HashSet :[50, 3, 4, 5, 6, 8, 9, 10, 90, 30, 111]Order of element in LinkedHashSet :[5, 4, 3, 6, 8, 9, 10, 50, 30, 90, 111]Order of objects in TreeSet :[3, 4, 5, 6, 8, 9, 10, 30, 50, 90, 111]2.4 总结针对Collection集合我们到底使用谁呢?(掌握)\n\n3. Map接口（映射接口，存放键值对）\n特点：\n以键值对的形式存放对象。key-value。一般是key为String类型，value为Object的类型。\nMap接口有四个比较重要的实现类，分别是HashMap、TreeMap、LinkedHashMap和HashTable。\n3.1 Map集合\nHashMap（数组+链表/红黑树，线程不安全）\nHashMap的数据结构，内部为数组，数组的每个元素又是一个单向链表，如果单链表的元素超过8个，HashMap又会将链式结构变为红黑树来提高查找效率。\n如果想要线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全，或者使用ConcurrentHashMap。\n\nHashMap数组+链表结构\n\nHashMap数组+红黑树结构\n2.ConcurrentHashMap(分段锁实现，线程安全)\n采用分段锁的思想实现并发操作，因此线程安全。\nConcurrentHashMap由多个Segment组成（Segment的数量是锁的并发度），每个Segment都是继承ReentrantLock并单独加锁，所有每次加锁操作是锁住的都是一个Segment，这样只要保证每个Segment都是线程安全的，也就实现了全局的线程安全。\n\nConcurrentHashMap数组+单向链表结构\n\nConcurrentHashMap数组+红黑树结构\n3.HashTable(线程安全，哈希表)\n继承Dictionary类，同一时刻只有一个线程能写HashTable,并发性不如ConcurrentHashMap\n4.TreeMap(二叉树数据结构，有序)\n实现了SortedMap接口保证元素顺序存储，默认按键值升序存储，也可自定义比较器（实现Comparable接口或者自定义比较器）\n5.LinkedHashMap（基于HashTable数据结构，使用链表保存插入顺序）\nLinkedHashMap是HashMap的子类，内部使用链表保存元素的插入顺序，通过Iterator遍历LinkedHashMap时，会按照元素的插入顺序访问元素。\n（1）HashMap、TreeMap、LinkedHashMap的区别：\n\n（2）Hashtable和HashMap的区别：\n\nHashtable的方法是同步的，HashMap的方法不是同步的。这是两者最主要的区别。Hashtable是线程安全的，HashMap不是线程安全的。HashMap效率较高，Hashtable效率较低。Hashtable不允许null值，HashMap允许null值（key和value都允许，HashMap允许多条记录的值为null）父类不同：Hashtable的父类是Dictionary，HashMap的父类是AbstractMap\n（3）如何选择Hashtable和HashMap？\n如果对同步性或与遗留代码的兼容性没有任何要求，建议使用HashMap。 查看Hashtable的源代码就可以发现，除构造函数外，Hashtable的所有 public 方法声明中都有 synchronized关键字，而HashMap的源码中则没有。\n（4）所有带hash的前缀的Map集合的存储原理：\n\n通过 new 关键字在 Heap 堆中申请空间保存其中元素的空间，按照hash码，预设好一个个的空间，这个空间就是 Hash Bucket(哈希桶)每个桶有自己的Hash编号 ，一开始有少量的 Hash Bucket当程序试图将一个 key-value(Entry) 放入 HashMap 中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的Bucket位置。如果该Bucket为空，直接存放入该Bucket;如果该Bucket不为空，使用 equals 比较两个Entry 的 Key；if(true){新 value 将覆盖 Entry 原 value，key 不变}if(false){新 Entry 将与 Bucket中原 Entry 形成 Entry 链，而且新 Entry 位于 Entry 链的头部}\n3.2 Map集合的遍历：1、通过内部类Entry进行遍历\n2、通过迭代器进行遍历，先获得Entry的Set集合\n3、通过keySet方法获得键的Set集合，通过遍历键取值\n4、通过map.values()获得所有值，但是不能获得键\n代码演示：\npackage com.company.project.test1001;import java.util.HashMap;import java.util.Map;//Map集合的遍历public class Demo {    public static void main(String[] args) {        Map<String, String> map = new HashMap<String, String>();        map.put(\"A\", \"北京\");        map.put(\"D\", \"上海\");        map.put(\"C\", \"广东\");        for (Map.Entry<String, String> entry : map.entrySet()) {            System.out.println(entry);        }    }}\n结果：\nA=北京C=广东D=上海', 0, 1);
INSERT INTO `t_article` VALUES (49, '22. 多态', 8, '**Java三大特性有封装、继承、多态。**\n\n前面我们已经学过了封装和继承，今天学习多态，如需前面内容的可自行查看。\n\n\n\n## 1、多态的引入\n\n**多态是继封装、继承之后，面向对象的第三大特性**\n\n**生活中，比如交通工具的种类可以分为飞机、汽车、轮船**\n\n**再比如交通工具的运行方式飞机运行方式是飞在天上、汽车是在马路上开、轮船是在海上行驶**\n\n**可见，同一行为，通过不同的事物，可以体现出来的不同的形态**\n\n**多态，描述的就是这样的状态。**\n\n## 2、多态性的概念\n\n### 2.1 多态的含义\n\n多态性是面向对象的三大特征之一，同一行为，通过不同的事物，可以体现出来的不同的形态。\n\n### 2.2 Java中多态的具体体现\n\n- 方法重载（在同一个类中，同名的方法，由于形参的不同，实现方法的重载，在调用方法时，可根据实参的组合来选择所调用的方法）\n- 方法覆盖（主要在继承时用到，子类继承父类，可以重写父类的非静态的方法）\n- 多态参数（新内容，重点、难点，本章主要讲）\n\n### 2.3  多态的前提\n\n1. 存在继承或者实现关系 \n2. 子类或实现类必须重写父类方法\n3. 父类引用指向子类对象\n\n### 2.4  父类引用指向子类对象\n\n提个概念，编译器类型指的是‘=’左边的类型，运行期类型指的是‘=’右边的类型。\n\n​      当有继承关系时，可能发生编译期类型和运行期类型不同的情况，即编译期类型是父类类型，运行期类型是子类类型。\n\n即：**父类引用指向子类对象**\n\n例如：\n\n//动物类\n\n```java\npublic class Animal {\n	private String name;\n	\n	public Animal() {\n		// TODO Auto-generated constructor stub\n		this.name = \"动物\";\n	}\n	public void eat() { \n		System.out.println(\"动物在吃\");\n	}\n	\n	static void look() {\n		System.out.println(\"动物在看\");\n	}\n	\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}	\n}\n```\n\n//狗类\n\n```java\npublic class Dog extends Animal {\n	private String name;\n	\n	public Dog() {\n		// TODO Auto-generated constructor stub\n		this.name = \"狗\";\n	}\n	public void eat() {\n		System.out.println(\"狗在吃\");\n	}\n	\n	public void bite() {\n		System.out.println(\"狗咬人\");\n	}\n	\n	static void look() {\n		System.out.println(\"狗在看\");\n	}\n	\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n}\n```\n\n//测试类：\n\n```java\npublic class Demo {\n\n	public static void main(String[] args) {\n		// 父类对象指向子类引用\n		Animal animal = new Dog();\n\n		// 如果子类中重写了父类的方法，按照子类重写的方法执行\n		animal.eat();\n\n		// 子类自己扩展的方法，不能调用\n//		animal.bite();\n\n		// 调用父类和子类同名的静态方法，调用的是父类的静态方法\n		animal.look();\n\n	}\n}\n```\n\n## 3、多态参数\n\n### 3.1 形参具有多态性\n\n接着上述的案例，如果我们有个方法需要分别调用他们同名的方法，应该怎么做呢？\n\n比如：在Demo类中有个doing（）方法，我想要传进来的对象，让他们都执行他们的eat（）这个方法，此时，我们就需要利用方法参数多态性。\n\n我们只需要把形参的类型定义成父类的类型，我们可以利用上面提到过的验证（当父类引用调用子类对象时，调用重写的方法，是执行子类的重写后方法）。\n\n在一个方法的形参类型你设成父类类型，你传入一个实参对象，如果是一个子类的对象就相当于上述的父类引用调用子类对象，如果传入的是父类对象那就是正常的编译器类型等于运行期类型情况，正常调用。\n\n如此，我们就实现了形参的多态性，在很大程度上减少了代码的重复性，也提高了代码的扩展性。\n\n```java\nclass Demo{\nvoid doing(Animal a){\na.eat();\n}\n}\n```\n\n### 3.2 多态环境下对象造型\n\n上述情况，只是描述对于一些子类重写父类方法的调用，在第一个案例中，我们知道父类引用指向子类对象时，没有办法调用子类扩展的方法，那我们应该怎么做了？\n\n此时，我们就需要用到我们在学习数据类型时的一个概念，**强制转换**，将父类引用强制转换成子类的类型。\n\n注意：强制转换，只能是将父类类型转换成运行期类型，不能是别的类型。\n\n不仅父类引用可以强制转换成子类的类型，子类的引用也可以强制转换成父类的类型。\n\n从**造型方向**上看，可分为：\n\n（1）**向上造型 –又称自动类型提升**\n\n​        即父类引用指向子类对象，将子类对象向上造型成为父类类型。\n\n​        作用是：提高程序的扩展性。\n\n（2）**向下造型 –又称向下转型**\n\n​       即将子类对象强制转换成父类类型\n\n​       作用：实现子类扩展方法的调用。\n\n例如：接着上述例子\n\n```java\n//父类引用指向子类对象\nAnimal animal=new Dog();    \nDog dog = (Dog)animal;      //将父类引用强制转换成子类的类型\ndog.look();     //此时调用的子类的静态方法\ndog.bite();     //可以调用子类扩展的方法\n\n//子类引用指向子类对象\nDog dog1 = new Dog();\nAnimal a = (Animal)dog1;   //将子类引用转换成父类类型\na.eat();           //调用的是子类的方法\na.look();          //调用的是父类的静态方法\n//a.bite();          //子类扩展的方法不能调用\n```\n\n## 4、instanceof ()方法\n\n### 4.1 instanceof 操作符\n\n使用instanceof操作符来判断一个**对象的运行期类型，即**用来在运行时指出对象是否是特定类的一个实例。\n\n### 4.1 instanceof 用法\n\n语法：\n\n对象名称 instanceof 类型；\n\n返回值类型：布尔类型\n\n```java\nDog dog1 = new Dog();\nAnimal a = (Animal)dog1;\nSystem.out.println(a instanceof Animal);\n\n//结果：\ntrue\n```', 0, 0, '2020-08-06 22:13:35', 2, 0, 1, 'Java三大特性有封装、继承、多态。\n前面我们已经学过了封装和继承，今天学习多态，如需前面内容的可自行查看。\n1、多态的引入多态是继封装、继承之后，面向对象的第三大特性\n生活中，比如交通工具的种类可以分为飞机、汽车、轮船\n再比如交通工具的运行方式飞机运行方式是飞在天上、汽车是在马路上开、轮船是在海上行驶\n可见，同一行为，通过不同的事物，可以体现出来的不同的形态\n多态，描述的就是这样的状态。\n2、多态性的概念2.1 多态的含义多态性是面向对象的三大特征之一，同一行为，通过不同的事物，可以体现出来的不同的形态。\n2.2 Java中多态的具体体现\n方法重载（在同一个类中，同名的方法，由于形参的不同，实现方法的重载，在调用方法时，可根据实参的组合来选择所调用的方法）方法覆盖（主要在继承时用到，子类继承父类，可以重写父类的非静态的方法）多态参数（新内容，重点、难点，本章主要讲）\n2.3  多态的前提\n存在继承或者实现关系 子类或实现类必须重写父类方法父类引用指向子类对象\n2.4  父类引用指向子类对象提个概念，编译器类型指的是‘=’左边的类型，运行期类型指的是‘=’右边的类型。\n​      当有继承关系时，可能发生编译期类型和运行期类型不同的情况，即编译期类型是父类类型，运行期类型是子类类型。\n即：父类引用指向子类对象\n例如：\n//动物类\npublic class Animal {    private String name;    public Animal() {        // TODO Auto-generated constructor stub        this.name = \"动物\";    }    public void eat() {         System.out.println(\"动物在吃\");    }    static void look() {        System.out.println(\"动物在看\");    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    }\n//狗类\npublic class Dog extends Animal {    private String name;    public Dog() {        // TODO Auto-generated constructor stub        this.name = \"狗\";    }    public void eat() {        System.out.println(\"狗在吃\");    }    public void bite() {        System.out.println(\"狗咬人\");    }    static void look() {        System.out.println(\"狗在看\");    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}\n//测试类：\npublic class Demo {    public static void main(String[] args) {        // 父类对象指向子类引用        Animal animal = new Dog();        // 如果子类中重写了父类的方法，按照子类重写的方法执行        animal.eat();        // 子类自己扩展的方法，不能调用//        animal.bite();        // 调用父类和子类同名的静态方法，调用的是父类的静态方法        animal.look();    }}\n3、多态参数3.1 形参具有多态性接着上述的案例，如果我们有个方法需要分别调用他们同名的方法，应该怎么做呢？\n比如：在Demo类中有个doing（）方法，我想要传进来的对象，让他们都执行他们的eat（）这个方法，此时，我们就需要利用方法参数多态性。\n我们只需要把形参的类型定义成父类的类型，我们可以利用上面提到过的验证（当父类引用调用子类对象时，调用重写的方法，是执行子类的重写后方法）。\n在一个方法的形参类型你设成父类类型，你传入一个实参对象，如果是一个子类的对象就相当于上述的父类引用调用子类对象，如果传入的是父类对象那就是正常的编译器类型等于运行期类型情况，正常调用。\n如此，我们就实现了形参的多态性，在很大程度上减少了代码的重复性，也提高了代码的扩展性。\nclass Demo{void doing(Animal a){a.eat();}}\n3.2 多态环境下对象造型上述情况，只是描述对于一些子类重写父类方法的调用，在第一个案例中，我们知道父类引用指向子类对象时，没有办法调用子类扩展的方法，那我们应该怎么做了？\n此时，我们就需要用到我们在学习数据类型时的一个概念，强制转换，将父类引用强制转换成子类的类型。\n注意：强制转换，只能是将父类类型转换成运行期类型，不能是别的类型。\n不仅父类引用可以强制转换成子类的类型，子类的引用也可以强制转换成父类的类型。\n从造型方向上看，可分为：\n（1）向上造型 –又称自动类型提升\n​        即父类引用指向子类对象，将子类对象向上造型成为父类类型。\n​        作用是：提高程序的扩展性。\n（2）向下造型 –又称向下转型\n​       即将子类对象强制转换成父类类型\n​       作用：实现子类扩展方法的调用。\n例如：接着上述例子\n//父类引用指向子类对象Animal animal=new Dog();    Dog dog = (Dog)animal;      //将父类引用强制转换成子类的类型dog.look();     //此时调用的子类的静态方法dog.bite();     //可以调用子类扩展的方法//子类引用指向子类对象Dog dog1 = new Dog();Animal a = (Animal)dog1;   //将子类引用转换成父类类型a.eat();           //调用的是子类的方法a.look();          //调用的是父类的静态方法//a.bite();          //子类扩展的方法不能调用\n4、instanceof ()方法4.1 instanceof 操作符使用instanceof操作符来判断一个对象的运行期类型，即用来在运行时指出对象是否是特定类的一个实例。\n4.1 instanceof 用法语法：\n对象名称 instanceof 类型；\n返回值类型：布尔类型\nDog dog1 = new Dog();Animal a = (Animal)dog1;System.out.println(a instanceof Animal);//结果：true\n', 0, 1);
INSERT INTO `t_article` VALUES (50, '23. GUI图形用户界面', 8, '> *参考链接：* https://blog.csdn.net/qq_42035966/article/details/82258199#5.插件介绍WindowBuilder\n\n## **1、GUI的介绍**\n\n### 1.1 GUI概述\n\n　　早期，电脑向用户提供的是单调、枯燥、纯字符状态的“命令行界面（CLI）”。就是到现在，我们还可以依稀看到它们的身影：在Windows中开个DOS窗口，就可看到历史的足迹。后来，Apple公司率先在电脑的操作系统中实现了**图形化的用户界面（Graphical User Interface，简称GUI）**，但由于Apple公司封闭的市场策略，自己完成电脑硬件、操作系统、应用软件一条龙的产品，与其它PC不兼容。这使得Apple公司错过了一次一统全球PC的好机会。\n\n　　后来，Microsoft公司推出了风靡全球的Windows操作系统，它凭借着优秀的图形化用户界面，一举奠定了操作系统标准的地位。这也造就了世界首富---比尔.盖茨和IT业的泰山北斗微软公司。\n\n　　在这图形用户界面风行于世的今天，一个应用软件没有良好的GUI是无法让用户接受的。而Java语言也深知这一点的重要性，它提供了一套可以轻松构建GUI的工具。在本章和下一章中，我们将向你充分证明这一点。\n\n### **1.2 Java提供了三个主要包做GUI开发：**\n\njava.awt 包 – 主要提供字体/布局管理器\n\njavax.swing 包[商业开发常用] – 主要提供各种组件(窗口/按钮/文本框)\n\njava.awt.event 包 – 事件处理，后台功能的实现。\n\n## 2、Swing组件\n\n如图所示：swing组件主要可分为三个部分，后面会详细介绍\n\n（1）顶层容器:：常用有JFrame，JDialog\n\n（2）中间容器：JPanel，JOptionPane，JScrollPane，JLayeredPane 等，主要以panel结尾。\n\n（3）基本组件：JLabel，JButton，JTextField，JPasswordField，JRadioButton 等。\n\n### 2.1 顶层容器\n\n![img](https://pic4.zhimg.com/v2-4c58072d2fd4fe813870e3f9d94f81bf_b.jpg)\n\n顶层容器\n\nJFrame组件在**javax.swing.JFrame**\n\n### 2.2 中间容器\n\n![img](https://pic4.zhimg.com/v2-631c3c3095506fed1b2053c0e6809a87_b.jpg)\n\n中间容器\n\n### 2.3 基本组件\n\n![img](https://pic4.zhimg.com/v2-ff9c60fd25a22726909356ced167309b_b.jpg)\n\n基本组件\n\n## 3、组件API介绍\n\n### **3.1 JFrame组件(一般需要继承JFrame类)**\n\n- **javax.swing.JFrame**\n- JFrame组件用于在Swing程序中创建窗体；\n- JFrame类的构造方法有4种重载方式：\n- [JFrame](https://zhuanlan.zhihu.com/javax/swing/JFrame.html#JFrame--)() 构造一个最初不可见的新框架。\n- [JFrame](https://zhuanlan.zhihu.com/javax/swing/JFrame.html#JFrame-java.awt.GraphicsConfiguration-)([GraphicsConfiguration](https://zhuanlan.zhihu.com/java/awt/GraphicsConfiguration.html) gc) 在屏幕设备的指定 GraphicsConfiguration中创建一个  Frame和一个空白标题。\n- [JFrame](https://zhuanlan.zhihu.com/javax/swing/JFrame.html#JFrame-java.lang.String-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) title) 创建一个新的，最初不可见的 Frame与指定的标题。\n- [JFrame](https://zhuanlan.zhihu.com/javax/swing/JFrame.html#JFrame-java.lang.String-java.awt.GraphicsConfiguration-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) title,  [GraphicsConfiguration](https://zhuanlan.zhihu.com/java/awt/GraphicsConfiguration.html) gc) 创建 JFrame具有指定标题和指定  GraphicsConfiguration屏幕设备的。\n\nJFrame常用方法：\n\n1. public void setTitle(String title) 设置窗体标题 \n2. public void setBounds(int a,int b,int width,int height)设置窗口的初始位置是(a,b),即距屏幕左面a个像素，距屏幕上方b个像素，窗口的宽是width,高是height。\n3. public void setSize(int width,int height)设置窗口的大小。\n4. public void setLocation(int x,int y)设置窗口的位置，默认位置是(0,0)。\n5. public void setVisible(boolean b)设置窗口是否可见，窗口默认是不可见的。\n6. public void setResizable(boolean b)设置窗口是否可调整大小，默认可调整大小。\n7. public void dispose()撤销当前窗口，并释放当前窗口所使用的资源。\n8. public Container getContentPane() 获得当前窗体的内容面板\n9. void dispose()释放当前窗体及其所有子组件所占用的资源。\n10. void repaint()从新绘制当前窗体。\n11. public void setExtendedState(int state)设置窗口的扩展状态，其中参数state取JFrame类中的下列类常量:\n\n- MAXIMIZED_HORIZ (水平方向最大化)，\n- MAXIMIZED_VERT (垂直方向最大化)，\n- MAXIMIZED_BOTH (水平、垂直方向都最大化)。\n\n12. public void setDefaultCloseOperation(int operation)该方法用来设置单击窗体右上角的关闭图标后，程序会做出怎样的处理，其中的参数operation取JFrame类中的下列int型static常量，程序根据参数operation取值做出不同的处理:\n\n- DO_NOTHING_ON_CLOSE(什么也不做)，\n- HIDE_ON_CLOSE (隐藏当前窗口)，\n- DISPOSE_ON_CLOSE (隐藏当前窗口，并释放窗体占有的其他资源)，\n- EXIT_ON_CLOSE (结束窗口所在的应用程序)。\n\n代码演示：\n\n//创建一个窗口\n\n```\nimport javax.swing.JFrame;\n\npublic class JFrameDemo extends JFrame{\n	public static void main(String[] args) {\n		//创建JFrame对象\n		JFrame jFrame1 = new JFrame(\"第一个JFrame窗口\");\n		\n		//设置窗口的大小\n		jFrame1.setSize(720,680);\n		\n		//设置窗口显示位置\n		jFrame1.setLocation(500,200);\n		\n		//设置窗口大小可调整\n		jFrame1.setResizable(true);\n		\n		//设置窗口拓展延水平方向最大化\n		jFrame1.setExtendedState(MAXIMIZED_HORIZ);\n		\n		//设置关闭窗口的操作为什么都不做\n		jFrame1.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);\n		\n		//设置窗口可视化，一般放在最后一步\n		jFrame1.setVisible(true);\n	}\n}\n```\n\n结果：\n\n![img](https://pic2.zhimg.com/v2-35004205a2effbc6580157e1cbfdc099_b.png)\n\n### 3.2 J**Panel**组件\n\n- **javax.swing.JPanel**\n- JPanel提供面板组件，它是轻量级的容器组件；\n- 面板中可以添加其它组件，也可以设置布局，我们一般使用面板来实现布局嵌套；\n- JFrame类的构造方法有4种重载方式： \n- [JPanel](https://zhuanlan.zhihu.com/javax/swing/JPanel.html#JPanel--)() 创建一个新的 JPanel双缓冲区和流布局。\n- [JPanel](https://zhuanlan.zhihu.com/javax/swing/JPanel.html#JPanel-boolean-)(boolean isDoubleBuffered) 创建一个新的 JPanel与 FlowLayout和指定的缓冲策略。 \n- [JPanel](https://zhuanlan.zhihu.com/javax/swing/JPanel.html#JPanel-java.awt.LayoutManager-)([LayoutManager](https://zhuanlan.zhihu.com/java/awt/LayoutManager.html) layout) 使用指定的布局管理器创建一个新的缓冲JPanel。\n- [JPanel](https://zhuanlan.zhihu.com/javax/swing/JPanel.html#JPanel-java.awt.LayoutManager-boolean-)([LayoutManager](https://zhuanlan.zhihu.com/java/awt/LayoutManager.html) layout,  boolean isDoubleBuffered) 使用指定的布局管理器和缓冲策略创建一个新的JPanel。\n\nJPanel常用方法：\n\n1. public [Component](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html) add([Component](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html) comp)设置面板的背景色\n2. public void setLayout([LayoutManager](https://docs.oracle.com/javase/8/docs/api/java/awt/LayoutManager.html) mgr)设置面板的布局 ，选null为空布局，下面会讲几种常用的布局。\n3. public [Component](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html) add([Component](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html) comp)向面板中添加组件\n4. public void setLayout([LayoutManager](https://docs.oracle.com/javase/8/docs/api/java/awt/LayoutManager.html) mgr)向面板中指定位置添组件\n5. public void remove([Component](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html) comp)移除指定组件\n6. public void removeAll()移除面板上所有组件\n7. public void repaint() 重新绘制\n\n代码演示：\n\n//JPanel组件的使用\n\n```\nimport javax.swing.JFrame;\nimport java.awt.*;\nimport javax.swing.JPanel;\n\npublic class JPanelDemo extends JFrame {\n\n	public JPanelDemo() {\n		this.init();\n	}\n\n	public static void main(String[] args) {\n		JPanelDemo frameDemo = new JPanelDemo();\n	}\n\n	private void init() {\n\n		// 获取当前的内容面板\n		Container container = this.getContentPane();\n\n		// 设置布局为空布局\n		setLayout(null);\n\n		// 创建JPanel组件面板\n		JPanel jPanel = new JPanel();\n\n		// 设置JPanel组件面板大下小\n		jPanel.setSize(540, 420);\n\n		jPanel.setBackground(new Color(86,182,255));\n\n		jPanel.setLocation(0, 0);\n		container.add(jPanel);\n\n		// 设置窗口可视化，一般放在最后一步\n		this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n		this.setTitle(\"登录界面\");\n		this.setSize(540, 420);\n		this.setVisible(true);\n	}\n}\n```\n\n结果：\n\n![img](https://pic4.zhimg.com/v2-e62c75205705853f44f712425f6e0eef_b.png)\n\n### 3.3  Container容器\n\nContainer类通常用于操作JFrame的内容面板\n\n常用方法：\n\n1. **public void setBackground(Color bg)设置背景色**\n2. **public void setLayout(LayoutManager mgr)设置容器的布局**\n3. **public Component add(Component comp)往容器中添加组件**\n4. **public Component add(Component comp, int index)往容器的指定位置添加组件‘**\n5. **public void remove(Component comp)移除指定的组件**\n6. **public void removeAll()移除所有的组件**\n7. **public void repaint()重新绘制**\n\n### **3.3 JButton**组件\n\n- **javax.swing.JButton**\n- 在Swing程序中，按钮可能是使用量最大的组件之一，JButton则是用来创建按钮的；\n- JButton类的构造方法有5种重载方式\n- [JButton](https://zhuanlan.zhihu.com/javax/swing/JButton.html#JButton--)() 创建一个没有设置文本或图标的按钮。\n- [JButton](https://zhuanlan.zhihu.com/javax/swing/JButton.html#JButton-javax.swing.Action-)([Action](https://zhuanlan.zhihu.com/javax/swing/Action.html) a) 创建一个按钮，其中的属性取自提供的 Action 。\n- [JButton](https://zhuanlan.zhihu.com/javax/swing/JButton.html#JButton-javax.swing.Icon-)([Icon](https://zhuanlan.zhihu.com/javax/swing/Icon.html) icon) 创建一个带有图标的按钮。\n- [JButton](https://zhuanlan.zhihu.com/javax/swing/JButton.html#JButton-java.lang.String-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) text) 创建一个带文本的按钮。\n- [JButton](https://zhuanlan.zhihu.com/javax/swing/JButton.html#JButton-java.lang.String-javax.swing.Icon-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) text,  [Icon](https://zhuanlan.zhihu.com/javax/swing/Icon.html) icon) 创建一个带有初始文本和图标的按钮。 \n\nJButton常用方法：\n\n1. public void setText([String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) text)设置按钮上的文本\n2. public [String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) getText()获取按钮上的文本\n3. public void setBackground([Color](https://docs.oracle.com/javase/8/docs/api/java/awt/Color.html) bg)设置按钮的背景色\n4. public Color getBackground()获取按钮的背景色\n5. public void setEnabled(boolean b)设置按钮的启用或禁用\n6. public void setVisible(boolean b)设置按钮是否可见\n7. public void setToolTipText(String text)设置按钮悬停的提示信息\n8. public void setMnemonic(int mnemonic)设置按钮的快捷键\n9. public void addActionListener(ActionListener al)增加对按钮对象的事件监听\n\n### 3.4 JLabel组件\n\n- **javax.swing.JLabel**\n- JLabel是最简单的Swing组件之一，用于在窗体上显示标签，JLabel既可以显示文本，也可以显示图像；\n- JLabel类的构造方法有6种重载方式：\n- [JLabel](https://zhuanlan.zhihu.com/javax/swing/JLabel.html#JLabel--)() 创建一个没有图像的 JLabel实例，标题为空字符串。\n- [JLabel](https://zhuanlan.zhihu.com/javax/swing/JLabel.html#JLabel-javax.swing.Icon-)([Icon](https://zhuanlan.zhihu.com/javax/swing/Icon.html) image) 使用指定的图像创建一个 JLabel实例。 \n- [JLabel](https://zhuanlan.zhihu.com/javax/swing/JLabel.html#JLabel-javax.swing.Icon-int-)([Icon](https://zhuanlan.zhihu.com/javax/swing/Icon.html) image,  int horizontalAlignment) 创建一个具有指定图像和水平对齐的 JLabel实例。\n- [JLabel](https://zhuanlan.zhihu.com/javax/swing/JLabel.html#JLabel-java.lang.String-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) text) 使用指定的文本创建一个 JLabel实例。\n- [JLabel](https://zhuanlan.zhihu.com/javax/swing/JLabel.html#JLabel-java.lang.String-javax.swing.Icon-int-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) text,  [Icon](https://zhuanlan.zhihu.com/javax/swing/Icon.html) icon,  int horizontalAlignment) 创建具有 JLabel文本，图像和水平对齐的JLabel实例。\n- [JLabel](https://zhuanlan.zhihu.com/javax/swing/JLabel.html#JLabel-java.lang.String-int-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) text,  int horizontalAlignment) 创建一个具有指定文本和水平对齐的 JLabel实例。 \n\nJLabel常用方法：\n\n1. public void setText(String text) 设置标签上的文本\n2. public String getText()获得标签上的文本\n3. public void setIcon(Icon icon)设置标签中的图像\n4. public Icon getIcon()获得标签中的图像\n5. public void setHorizontalAlignment(int alignment)设置标签中文本的对齐方式    alignment -一个中所定义的以下常量 SwingConstants ：  LEFT ， CENTER （仅用于图像的标签的默认值）， RIGHT ，  LEADING （默认为纯文本的标记），或 TRAILING 。\n6. public void setVisible(boolean b)设置标签是否可见\n7. public void setFont(Font f)设置标签对象的字体\n\n### 3.5 JTextField组件\n\n- **javax.swing.JTextField**\n- JTextField是文本框组件，主要用来接受用户的输入；\n- JTextField类的构造方法有5种重载方式\n- [JTextField](https://zhuanlan.zhihu.com/javax/swing/JTextField.html#JTextField--)() 构造新的 TextField 。\n- [JTextField](https://zhuanlan.zhihu.com/javax/swing/JTextField.html#JTextField-javax.swing.text.Document-java.lang.String-int-)([Document](https://zhuanlan.zhihu.com/javax/swing/text/Document.html) doc, [String](https://zhuanlan.zhihu.com/java/lang/String.html) text,  int columns) 构造一个新   的 JTextField ，它使用给定的文本存储模型和给定的列数。\n- [JTextField](https://zhuanlan.zhihu.com/javax/swing/JTextField.html#JTextField-int-)(int columns) 构造一个新的空的 TextField与指定的列数。\n- [JTextField](https://zhuanlan.zhihu.com/javax/swing/JTextField.html#JTextField-java.lang.String-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) text) 构造一个新的 TextField ，用指定的文本初始化。\n- [JTextField](https://zhuanlan.zhihu.com/javax/swing/JTextField.html#JTextField-java.lang.String-int-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) text,  int columns) 构造一个新的 TextField ，用指定的文本和列初始化。\n\n**JTextField的常用方法 ：**\n\n1. public void setText(String text)设置文本框的文本\n2. public String getText()获得文本框中的文本\n3. public void setHorizontalAlignment(int alignment)设置文本框的文本对齐方式。\n\n-  设置文本的水平对齐方式。 有效的密钥是： \n-  JTextField.LEFT \n-  JTextField.CENTER \n-  JTextField.RIGHT \n-  JTextField.LEADING \n-  JTextField.TRAILING \n\n4. public void setEditable(boolean b)设置文本框是否可以编辑\n\n5. public void setEnabled(boolean enabled)设置文本框的启用或禁用\n\n6. public void setVisible(boolean b)设置文本框是否可见\n\n7. public int getColumns()获取文本域的宽度\n\n8. public void setColumns(int columns)设置文本域的宽度\n\n9. public void setEchoChar(char c)设置文本域的回显字符为c，比如输入密码的输入框，设置回显字符为*\n\n10. public void addActionListener(ActionListener al) 添加对文本框的监听器，由按Enter键触发\n\n### 3.6 **JTextArea** 组件\n\n- **javax.swing.JTextArea**\n- 当用户有大量文本需要输入的时候，就可以使用到文本域组件；\n- JTextArea的构造方法共有6种重载\n- [JTextArea](https://zhuanlan.zhihu.com/javax/swing/JTextArea.html#JTextArea--)() 构造一个新的TextArea。\n- [JTextArea](https://zhuanlan.zhihu.com/javax/swing/JTextArea.html#JTextArea-javax.swing.text.Document-)([Document](https://zhuanlan.zhihu.com/javax/swing/text/Document.html) doc) 使用给定的文档模型构造一个新的JTextArea，默认为所有其他参数（null，0，0）。\n- [JTextArea](https://zhuanlan.zhihu.com/javax/swing/JTextArea.html#JTextArea-javax.swing.text.Document-java.lang.String-int-int-)([Document](https://zhuanlan.zhihu.com/javax/swing/text/Document.html) doc, [String](https://zhuanlan.zhihu.com/java/lang/String.html) text,  int rows, int columns) 构造具有指定行数和列数的新JTextArea以及给定模型。\n- [JTextArea](https://zhuanlan.zhihu.com/javax/swing/JTextArea.html#JTextArea-int-int-)(int rows,  int columns) 构造具有指定行数和列数的新的空TextArea。\n- [JTextArea](https://zhuanlan.zhihu.com/javax/swing/JTextArea.html#JTextArea-java.lang.String-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) text) 构造一个新的TextArea，并显示指定的文本。\n- [JTextArea](https://zhuanlan.zhihu.com/javax/swing/JTextArea.html#JTextArea-java.lang.String-int-int-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) text,  int rows, int columns) 构造具有指定文本和行数和列数的新TextArea。 \n\n**JTextArea的常用方法：**\n\n1. void setText(String text)\n2. String getText()\n3. void setFont(Font font)\n4. void setLineWrap(boolean wrap)\n5. void setTabSize(int size)\n6. void append(String str) 在原文本尾添加字符串str\n7. int getColumns()获取文本区的列数\n8. int getRows()获取文本区的行数\n9. void setEditable(boolean b)设置文本区是否可以编辑\n\n## 4、**布局管理器**\n\n- 用户界面上的组件可以按照不同的方式进行排列，例如：可以依序水平排列，或者按网格方式进行排列；\n- 每种方案都是指组件的一种布局，要管理这些布局，就需要使用布局管理器；\n- 布局管理器是一组实现了java.awt.LayoutManager接口的类，由这些类自动定位组件；\n- 布局管理器类在java.awt包中。\n\n几种常见的布局：\n\n1. 流式布局 java.awt.FlowLayout\n2. 边界布局 java.awt.BorderLayout\n3. 网格布局 java.awt.GridLayout\n4. 卡片布局 Java.awt.CardLayout\n5. 网袋布局管理器 Java.awt.GridBagLayout\n\n### 4.1 **流式布局**（FlowLayout）\n\n流式布局（FlowLayout）是最基本的一种布局，容器缺省的布局就是流式布局。\n\n流式布局是值把图形元素一个接一个的放在容器中，按照组件加入的先后顺序从左到右排列，当一行排列满后就转到下一行继续从左到右排列。\n\n构造方法：\n\n- [FlowLayout](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#FlowLayout--)() 构造一个新的 FlowLayout中心对齐和默认的5单位水平和垂直间隙。\n- [FlowLayout](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#FlowLayout-int-)(int align) 构造一个新的 FlowLayout具有指定的对齐和默认的5单位水平和垂直间隙。\n- [FlowLayout](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#FlowLayout-int-int-int-)(int align,  int hgap, int vgap) 创建一个新的流程布局管理器，具有指示的对齐方式和指示的水平和垂直间距。\n\n静态属性：\n\n- static int [CENTER](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#CENTER) 该值表示每行的组件应该居中。\n- static int [LEADING](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#LEADING) 该值表示组件的每一行应该对齐到容器方向的前端，例如从左到右的方向向左。\n- static int [LEFT](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#LEFT) 该值表示每一行的组件应为左对齐。\n- static int [RIGHT](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#RIGHT) 该值表示组件的每一行都应该是右对齐的。\n- static int [TRAILING](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#TRAILING) 该值表示组件的每一行应该对齐到容器方向的后端，例如从左到右的方向向右。 \n\n常用方法：\n\n1. int getAlignment()获取对齐方式\n2. int getHgap()获取水平间隙\n3. int getVgap()获取垂直间隙\n4. void setAlignment(int align)设置对齐方式\n5. void setHgap(int hgap)设置水平间隙\n6. void setVgap(int vgap)设置垂直间隙\n\n代码演示：\n\n```java\npackage com.company.project.sample.s1;\n\nimport java.awt.Button;\nimport java.awt.FlowLayout;\n\nimport javax.swing.JFrame;\n\npublic class FlowLayoutDemo extends JFrame {\n\n	Button bt1 = new Button(\"A\");\n	Button bt2 = new Button(\"B\");\n	Button bt3 = new Button(\"C\");\n	Button bt4 = new Button(\"D\");\n	Button bt5 = new Button(\"E\");\n	Button bt6 = new Button(\"F\");\n\n	public void init() {\n		//初始化流式布局（向左对齐，水平间距为20，垂直间距为30）\n		FlowLayout flowLayout = new FlowLayout(FlowLayout.LEFT, 20, 30);\n		\n		//设置布局为流式布局\n		setLayout(flowLayout);\n		\n		add(bt1);\n		add(bt2);\n		add(bt3);\n		add(bt4);\n		add(bt4);\n		add(bt5);\n		add(bt6);\n		this.setSize(200, 200);\n		this.setVisible(true);\n	}\n\n	public static void main(String[] args) {\n		FlowLayoutDemo flowLayoutDemo = new FlowLayoutDemo();\n		flowLayoutDemo.init();\n	}\n}\n```\n\n结果：\n\n![img](https://pic4.zhimg.com/v2-85e818d6d24512c0d13f063780473de3_b.png)\n\n### 4.2 边界布局（BorderLayout）\n\n边界布局（BorderLayout）将窗口区域分为东、南、西、北和中央五个区域，在窗口边缘是四个狭窄的、固定宽度的区域，中间为一个大的区域。\n\n构造方法：\n\n- [BorderLayout](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#BorderLayout--)() 构建新的边框布局，组件间没有间隙。\n- [BorderLayout](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#BorderLayout-int-int-)(int hgap,  int vgap) 构造具有组件之间指定间隙的边框布局。\n\n静态属性：\n\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [AFTER_LAST_LINE](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#AFTER_LAST_LINE) PAGE_END的同义词。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [AFTER_LINE_ENDS](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#AFTER_LINE_ENDS) LINE_END的同义词。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [BEFORE_FIRST_LINE](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#BEFORE_FIRST_LINE) PAGE_START的同义词。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [BEFORE_LINE_BEGINS](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#BEFORE_LINE_BEGINS) LINE_START的同义词。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [CENTER](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#CENTER) 中心布局约束（容器中间）。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [EAST](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#EAST) 东面布局限制（容器右侧）。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [LINE_END](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#LINE_END) 组件在布局的行方向的末尾。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [LINE_START](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#LINE_START) 组件在布局的行方向的开始处。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [NORTH](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#NORTH) 北面布局约束（容器顶部）。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [PAGE_END](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#PAGE_END) 该组件来自布局内容的最后一行。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [PAGE_START](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#PAGE_START) 该组件位于布局内容的第一行之前。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [SOUTH](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#SOUTH) 南布局约束（容器底部）。\n- static [String](https://zhuanlan.zhihu.com/java/lang/String.html) [WEST](https://zhuanlan.zhihu.com/java/awt/BorderLayout.html#WEST) 西布局限制（容器左侧）。\n\n成员方法： \n\n- void [addLayoutComponent](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#addLayoutComponent-java.lang.String-java.awt.Component-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) name,  [Component](https://zhuanlan.zhihu.com/java/awt/Component.html) comp) 将指定的组件添加到布局。\n- int [getAlignment](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#getAlignment--)() 获取此布局的对齐方式。\n- boolean [getAlignOnBaseline](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#getAlignOnBaseline--)() 如果组件沿其基线垂直对齐，则返回true。\n- int [getHgap](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#getHgap--)() 获得组件之间以及组件与Container的边框之间的 Container \n- int [getVgap](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#getVgap--)() 获取组件之间以及组件与所述边界之间的垂直间隙 Container \n- void [layoutContainer](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#layoutContainer-java.awt.Container-)([Container](https://zhuanlan.zhihu.com/java/awt/Container.html) target) 放出容器。\n- [Dimension](https://zhuanlan.zhihu.com/java/awt/Dimension.html) [minimumLayoutSize](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#minimumLayoutSize-java.awt.Container-)([Container](https://zhuanlan.zhihu.com/java/awt/Container.html) target) 返回布局指定目标容器中包含的 *可见*组件所需的最小尺寸。\n- [Dimension](https://zhuanlan.zhihu.com/java/awt/Dimension.html) [preferredLayoutSize](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#preferredLayoutSize-java.awt.Container-)([Container](https://zhuanlan.zhihu.com/java/awt/Container.html) target) 给定指定目标容器中 *可见*组件的返回值。\n- void [removeLayoutComponent](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#removeLayoutComponent-java.awt.Component-)([Component](https://zhuanlan.zhihu.com/java/awt/Component.html) comp) 从布局中删除指定的组件。\n- void [setAlignment](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#setAlignment-int-)(int align) 设置此布局的对齐方式。\n- void [setAlignOnBaseline](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#setAlignOnBaseline-boolean-)(boolean alignOnBaseline) 组件是否应沿其基线垂直排列。\n- void [setHgap](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#setHgap-int-)(int hgap) 设置组件之间以及组件与Container的边框之间的水平 Container 。\n- void [setVgap](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#setVgap-int-)(int vgap) 设置组件之间以及组件与所述边界之间的垂直间隙 Container 。\n- [String](https://zhuanlan.zhihu.com/java/lang/String.html) [toString](https://zhuanlan.zhihu.com/java/awt/FlowLayout.html#toString--)() 返回此 FlowLayout对象及其值的字符串表示形式。 \n\n代码演示：\n\n```java\npackage com.company.project.sample.s1;\n\nimport java.awt.BorderLayout;\nimport java.awt.Button;\nimport java.awt.FlowLayout;\nimport java.awt.Label;\n\nimport javax.swing.JFrame;\n\npublic class BorderLayoutDemo extends JFrame {\n\n	Button bt1 = new Button(\"北\");\n	Button bt2 = new Button(\"西\");\n	Button bt3 = new Button(\"东\");\n	Button bt4 = new Button(\"南\");\n\n	Label label = new Label(\"中\");\n\n	public void init() {\n		// 初始化边界布局\n		BorderLayout borderLayout = new BorderLayout(10, 10);\n\n		// 设置布局为边界布局\n		setLayout(borderLayout);\n\n		add(bt1, BorderLayout.NORTH);\n		add(bt2, BorderLayout.WEST);\n		add(bt3, BorderLayout.EAST);\n		add(bt4, borderLayout.SOUTH);\n		add(\"Center\", label);\n\n		this.setSize(200, 200);\n		this.setVisible(true);\n	}\n\n	public static void main(String[] args) {\n		BorderLayoutDemo borderLayoutDemo = new BorderLayoutDemo();\n		borderLayoutDemo.init();\n	}\n}\n```\n\n结果：\n\n![img](https://pic1.zhimg.com/v2-4c0de841e511f2592b1b0d1b273aeecc_b.png)\n\n### 4.3 网格布局（GridLayout）\n\nGridLayout类是一个布局管理器，它将一个容器的组件放在矩形网格中。 容器被分成等大小的矩形，并且每个矩形中放置一个组件。\n\n构造方法: \n\n- [GridLayout](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#GridLayout--)() 在单个行中创建一个每个组件的默认值为一列的网格布局。\n- [GridLayout](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#GridLayout-int-int-)(int rows,  int cols) 创建具有指定行数和列数的网格布局。\n- [GridLayout](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#GridLayout-int-int-int-int-)(int rows,  int cols, int hgap, int vgap) 创建具有指定行数和列数的网格布局。\n\n成员方法：\n\n- void [addLayoutComponent](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#addLayoutComponent-java.lang.String-java.awt.Component-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) name,  [Component](https://zhuanlan.zhihu.com/java/awt/Component.html) comp) 将具有指定名称的指定组件添加到布局。\n- int [getColumns](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#getColumns--)() 获取该布局中的列数。\n- int [getHgap](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#getHgap--)() 获得组件之间的水平间隙。\n- int [getRows](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#getRows--)() 获取此布局中的行数。\n- int [getVgap](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#getVgap--)() 获取组件之间的垂直间距。\n- void [layoutContainer](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#layoutContainer-java.awt.Container-)([Container](https://zhuanlan.zhihu.com/java/awt/Container.html) parent) 使用此布局放出指定的容器。\n- [Dimension](https://zhuanlan.zhihu.com/java/awt/Dimension.html) [minimumLayoutSize](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#minimumLayoutSize-java.awt.Container-)([Container](https://zhuanlan.zhihu.com/java/awt/Container.html) parent) 使用此网格布局确定容器参数的最小大小。\n- [Dimension](https://zhuanlan.zhihu.com/java/awt/Dimension.html) [preferredLayoutSize](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#preferredLayoutSize-java.awt.Container-)([Container](https://zhuanlan.zhihu.com/java/awt/Container.html) parent) 使用此网格布局确定容器参数的首选大小。\n- void [removeLayoutComponent](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#removeLayoutComponent-java.awt.Component-)([Component](https://zhuanlan.zhihu.com/java/awt/Component.html) comp) 从布局中删除指定的组件。\n- void [setColumns](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#setColumns-int-)(int cols) 将此布局中的列数设置为指定的值。\n- void [setHgap](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#setHgap-int-)(int hgap) 将组件之间的水平间距设置为指定的值。\n- void [setRows](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#setRows-int-)(int rows) 将此布局中的行数设置为指定的值。\n- void [setVgap](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#setVgap-int-)(int vgap) 将组件之间的垂直间距设置为指定值。\n- [String](https://zhuanlan.zhihu.com/java/lang/String.html) [toString](https://zhuanlan.zhihu.com/java/awt/GridLayout.html#toString--)() 返回此网格布局值的字符串表示形式。 \n\n代码演示：\n\n```java\npackage com.company.project.sample.s1;\n\nimport java.awt.*;\nimport java.applet.Applet;\n\npublic class GridLayoutDemo extends Applet {\n	public void init() {\n		setLayout(new GridLayout(3, 2));\n		add(new Button(\"1\"));\n		add(new Button(\"2\"));\n		add(new Button(\"3\"));\n		add(new Button(\"4\"));\n		add(new Button(\"5\"));\n		add(new Button(\"6\"));\n	}\n}\n```\n\n结果：\n\n![img](https://pic2.zhimg.com/v2-be85a80d9d8ad2bb4650ad59b2250935_b.png)\n\n## 5、面板Panel类\n\n### 5.1 概述\n\n在设计用户界面时，为了更加合理的安排各组件在窗口的位置，可以考虑将所需组件先安排在一个容器中，然后再将其作为一个整体加入另一个容器。\n\nPanel类是这样一个被称为面板的容器类，它是一种无边框的，不能移动、放大、缩小或关闭的容器。\n\n### 5.2 用途\n\nPanel对象不能作为最底层的容器，也不能指定大小。\n\nPanel总是作为一个容器组件被加入到Applet或Frame等其他容器，也可以加入到其他的Panel容器中，形成复杂的图形界面系统。\n\n### 5.3 用法\n\n首先创建Panel的对象，然后设置对象的布局 格式，即设置Panel容器的布局，设置方法在与Applet容器中的设置一样，只是需要使用Panel对象的setLayout()方法，并使用Panel对象的add()方法往Panel容器加入组件。\n\n5.4 代码案例\n\n```java\npackage com.company.project.sample.s1;\n\nimport java.applet.Applet;\nimport java.awt.*;\n\npublic class AppletPanelCalc extends Applet {\n	public void init() {\n		setLayout(new BorderLayout());\n		add(\"North\", new Button(\"按钮北\"));\n		add(\"West\", new Button(\"按钮西\"));\n		add(\"South\", new Button(\"按钮南\"));\n		add(\"East\", new Button(\"按钮东\"));\n\n		Panel panel = new Panel();\n		panel.setLayout(new GridLayout(3, 3));\n		for (int i = 1; i < 10; i++) {\n			panel.add(new Button((new Integer(i)).toString()));\n		}\n		add(\"Center\", panel);\n	}\n}\n```\n\n结果：\n\n![img](https://pic2.zhimg.com/v2-6c2a2e24093715558474da36bd3d247d_b.png)\n\n还有一些Swing基本组件，这里就不一一列举了！！！\n\n## 6、事件处理\n\n### 6.1  监听器的概述\n\n监听器，字面上的理解就是监听观察某个事件（程序）的发生情况，当被监听的事件真的发生了的时候，事件发生者（事件源） 就会给注册该事件的监听者（监听器）发送消息，告诉监听者某些信息，同时监听者也可以获得一份事件对象，根据这个对象可以获得相关属性和执行相关操作。\n\n监听器模型涉及以下三个对象：\n\n（1）事件：用户对组件的一个操作，或者说程序执行某个方法，称之为一个事件，如机器人程序执行工作。 （2）事件源：发生事件的组件就是事件源，也就是被监听的对象，如机器人可以工作，可以跳舞，那么就可以把机器人看做是一个事件源。 （3）事件监听器（处理器）：监听并负责处理事件的方法，如监听机器人工作情况，在机器人工作前后做出相应的动作，或者获取机器人的状态信息。\n\n执行顺序如下：\n\n1、给事件源注册监听器。 2、组件接受外部作用，也就是事件被触发。 3、组件产生一个相应的事件对象，并把此对象传递给与之关联的事件处理器。 4、事件处理器启动，并执行相关的代码来处理该事件。\n\n监听器模式：事件源注册监听器之后，当事件源触发事件，监听器就可以回调事件对象的方法；更形象地说，监听者模式是基于：注册-回调的事件/消息通知处理模式，就是被监控者将消息通知给所有监控者。 \n\n1、注册监听器：事件源.setListener。 2、回调：事件源实现onListener。\n\n![img](https://pic4.zhimg.com/v2-38e118a31dea0859af142187638424b3_b.png)\n\n代码案例：\n\n```java\npackage com.company.project.sample.s1;\n\nimport java.applet.Applet;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.JTextField;\n\n@SuppressWarnings(\"serial\")\npublic class Calc extends Applet implements ActionListener {\n	JTextField jTextField;\n	Button[] buttons = new Button[9];\n\n	public void init() {\n		setLayout(new BorderLayout());\n		jTextField = new JTextField();\n		add(\"North\", jTextField);\n\n		Panel panel = new Panel();\n		panel.setLayout(new GridLayout(3, 3));\n\n		for (int i = 0; i < 9; i++) {\n			buttons[i] = new Button((new Integer(i + 1)).toString());\n			buttons[i].addActionListener(this);\n			panel.add(buttons[i]);\n		}\n		add(\"Center\", panel);\n	}\n\n	@Override\n	public void actionPerformed(ActionEvent e) {\n		// TODO Auto-generated method stub\n		for (int i = 0; i < 9; i++) {\n			if (e.getSource() == buttons[i]) {\n				jTextField.setText(jTextField.getText() + (i + 1));\n			}\n		}\n	}\n}\n```\n\n结果：\n\n![img](https://pic4.zhimg.com/v2-7366895e515348287de0d5060d5b6f4f_b.png)', 0, 0, '2020-08-06 22:23:12', 2, 0, 1, '\n参考链接： https://blog.csdn.net/qq_42035966/article/details/82258199#5.插件介绍WindowBuilder\n\n1、GUI的介绍1.1 GUI概述　　早期，电脑向用户提供的是单调、枯燥、纯字符状态的“命令行界面（CLI）”。就是到现在，我们还可以依稀看到它们的身影：在Windows中开个DOS窗口，就可看到历史的足迹。后来，Apple公司率先在电脑的操作系统中实现了图形化的用户界面（Graphical User Interface，简称GUI），但由于Apple公司封闭的市场策略，自己完成电脑硬件、操作系统、应用软件一条龙的产品，与其它PC不兼容。这使得Apple公司错过了一次一统全球PC的好机会。\n　　后来，Microsoft公司推出了风靡全球的Windows操作系统，它凭借着优秀的图形化用户界面，一举奠定了操作系统标准的地位。这也造就了世界首富—-比尔.盖茨和IT业的泰山北斗微软公司。\n　　在这图形用户界面风行于世的今天，一个应用软件没有良好的GUI是无法让用户接受的。而Java语言也深知这一点的重要性，它提供了一套可以轻松构建GUI的工具。在本章和下一章中，我们将向你充分证明这一点。\n1.2 Java提供了三个主要包做GUI开发：java.awt 包 – 主要提供字体/布局管理器\njavax.swing 包[商业开发常用] – 主要提供各种组件(窗口/按钮/文本框)\njava.awt.event 包 – 事件处理，后台功能的实现。\n2、Swing组件如图所示：swing组件主要可分为三个部分，后面会详细介绍\n（1）顶层容器:：常用有JFrame，JDialog\n（2）中间容器：JPanel，JOptionPane，JScrollPane，JLayeredPane 等，主要以panel结尾。\n（3）基本组件：JLabel，JButton，JTextField，JPasswordField，JRadioButton 等。\n2.1 顶层容器\n顶层容器\nJFrame组件在javax.swing.JFrame\n2.2 中间容器\n中间容器\n2.3 基本组件\n基本组件\n3、组件API介绍3.1 JFrame组件(一般需要继承JFrame类)\njavax.swing.JFrameJFrame组件用于在Swing程序中创建窗体；JFrame类的构造方法有4种重载方式：JFrame() 构造一个最初不可见的新框架。JFrame(GraphicsConfiguration gc) 在屏幕设备的指定 GraphicsConfiguration中创建一个  Frame和一个空白标题。JFrame(String title) 创建一个新的，最初不可见的 Frame与指定的标题。JFrame(String title,  GraphicsConfiguration gc) 创建 JFrame具有指定标题和指定  GraphicsConfiguration屏幕设备的。\nJFrame常用方法：\n\npublic void setTitle(String title) 设置窗体标题 public void setBounds(int a,int b,int width,int height)设置窗口的初始位置是(a,b),即距屏幕左面a个像素，距屏幕上方b个像素，窗口的宽是width,高是height。public void setSize(int width,int height)设置窗口的大小。public void setLocation(int x,int y)设置窗口的位置，默认位置是(0,0)。public void setVisible(boolean b)设置窗口是否可见，窗口默认是不可见的。public void setResizable(boolean b)设置窗口是否可调整大小，默认可调整大小。public void dispose()撤销当前窗口，并释放当前窗口所使用的资源。public Container getContentPane() 获得当前窗体的内容面板void dispose()释放当前窗体及其所有子组件所占用的资源。void repaint()从新绘制当前窗体。public void setExtendedState(int state)设置窗口的扩展状态，其中参数state取JFrame类中的下列类常量:\n\nMAXIMIZED_HORIZ (水平方向最大化)，MAXIMIZED_VERT (垂直方向最大化)，MAXIMIZED_BOTH (水平、垂直方向都最大化)。\n\npublic void setDefaultCloseOperation(int operation)该方法用来设置单击窗体右上角的关闭图标后，程序会做出怎样的处理，其中的参数operation取JFrame类中的下列int型static常量，程序根据参数operation取值做出不同的处理:\n\nDO_NOTHING_ON_CLOSE(什么也不做)，HIDE_ON_CLOSE (隐藏当前窗口)，DISPOSE_ON_CLOSE (隐藏当前窗口，并释放窗体占有的其他资源)，EXIT_ON_CLOSE (结束窗口所在的应用程序)。\n代码演示：\n//创建一个窗口\nimport javax.swing.JFrame;public class JFrameDemo extends JFrame{    public static void main(String[] args) {        //创建JFrame对象        JFrame jFrame1 = new JFrame(\"第一个JFrame窗口\");        //设置窗口的大小        jFrame1.setSize(720,680);        //设置窗口显示位置        jFrame1.setLocation(500,200);        //设置窗口大小可调整        jFrame1.setResizable(true);        //设置窗口拓展延水平方向最大化        jFrame1.setExtendedState(MAXIMIZED_HORIZ);        //设置关闭窗口的操作为什么都不做        jFrame1.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);        //设置窗口可视化，一般放在最后一步        jFrame1.setVisible(true);    }}结果：\n\n3.2 JPanel组件\njavax.swing.JPanelJPanel提供面板组件，它是轻量级的容器组件；面板中可以添加其它组件，也可以设置布局，我们一般使用面板来实现布局嵌套；JFrame类的构造方法有4种重载方式： JPanel() 创建一个新的 JPanel双缓冲区和流布局。JPanel(boolean isDoubleBuffered) 创建一个新的 JPanel与 FlowLayout和指定的缓冲策略。 JPanel(LayoutManager layout) 使用指定的布局管理器创建一个新的缓冲JPanel。JPanel(LayoutManager layout,  boolean isDoubleBuffered) 使用指定的布局管理器和缓冲策略创建一个新的JPanel。\nJPanel常用方法：\n\npublic Component add(Component comp)设置面板的背景色public void setLayout(LayoutManager mgr)设置面板的布局 ，选null为空布局，下面会讲几种常用的布局。public Component add(Component comp)向面板中添加组件public void setLayout(LayoutManager mgr)向面板中指定位置添组件public void remove(Component comp)移除指定组件public void removeAll()移除面板上所有组件public void repaint() 重新绘制\n代码演示：\n//JPanel组件的使用\nimport javax.swing.JFrame;import java.awt.*;import javax.swing.JPanel;public class JPanelDemo extends JFrame {    public JPanelDemo() {        this.init();    }    public static void main(String[] args) {        JPanelDemo frameDemo = new JPanelDemo();    }    private void init() {        // 获取当前的内容面板        Container container = this.getContentPane();        // 设置布局为空布局        setLayout(null);        // 创建JPanel组件面板        JPanel jPanel = new JPanel();        // 设置JPanel组件面板大下小        jPanel.setSize(540, 420);        jPanel.setBackground(new Color(86,182,255));        jPanel.setLocation(0, 0);        container.add(jPanel);        // 设置窗口可视化，一般放在最后一步        this.setDefaultCloseOperation(EXIT_ON_CLOSE);        this.setTitle(\"登录界面\");        this.setSize(540, 420);        this.setVisible(true);    }}结果：\n\n3.3  Container容器Container类通常用于操作JFrame的内容面板\n常用方法：\n\npublic void setBackground(Color bg)设置背景色public void setLayout(LayoutManager mgr)设置容器的布局public Component add(Component comp)往容器中添加组件public Component add(Component comp, int index)往容器的指定位置添加组件‘public void remove(Component comp)移除指定的组件public void removeAll()移除所有的组件public void repaint()重新绘制\n3.3 JButton组件\njavax.swing.JButton在Swing程序中，按钮可能是使用量最大的组件之一，JButton则是用来创建按钮的；JButton类的构造方法有5种重载方式JButton() 创建一个没有设置文本或图标的按钮。JButton(Action a) 创建一个按钮，其中的属性取自提供的 Action 。JButton(Icon icon) 创建一个带有图标的按钮。JButton(String text) 创建一个带文本的按钮。JButton(String text,  Icon icon) 创建一个带有初始文本和图标的按钮。 \nJButton常用方法：\n\npublic void setText(String text)设置按钮上的文本public String getText()获取按钮上的文本public void setBackground(Color bg)设置按钮的背景色public Color getBackground()获取按钮的背景色public void setEnabled(boolean b)设置按钮的启用或禁用public void setVisible(boolean b)设置按钮是否可见public void setToolTipText(String text)设置按钮悬停的提示信息public void setMnemonic(int mnemonic)设置按钮的快捷键public void addActionListener(ActionListener al)增加对按钮对象的事件监听\n3.4 JLabel组件\njavax.swing.JLabelJLabel是最简单的Swing组件之一，用于在窗体上显示标签，JLabel既可以显示文本，也可以显示图像；JLabel类的构造方法有6种重载方式：JLabel() 创建一个没有图像的 JLabel实例，标题为空字符串。JLabel(Icon image) 使用指定的图像创建一个 JLabel实例。 JLabel(Icon image,  int horizontalAlignment) 创建一个具有指定图像和水平对齐的 JLabel实例。JLabel(String text) 使用指定的文本创建一个 JLabel实例。JLabel(String text,  Icon icon,  int horizontalAlignment) 创建具有 JLabel文本，图像和水平对齐的JLabel实例。JLabel(String text,  int horizontalAlignment) 创建一个具有指定文本和水平对齐的 JLabel实例。 \nJLabel常用方法：\n\npublic void setText(String text) 设置标签上的文本public String getText()获得标签上的文本public void setIcon(Icon icon)设置标签中的图像public Icon getIcon()获得标签中的图像public void setHorizontalAlignment(int alignment)设置标签中文本的对齐方式    alignment -一个中所定义的以下常量 SwingConstants ：  LEFT ， CENTER （仅用于图像的标签的默认值）， RIGHT ，  LEADING （默认为纯文本的标记），或 TRAILING 。public void setVisible(boolean b)设置标签是否可见public void setFont(Font f)设置标签对象的字体\n3.5 JTextField组件\njavax.swing.JTextFieldJTextField是文本框组件，主要用来接受用户的输入；JTextField类的构造方法有5种重载方式JTextField() 构造新的 TextField 。JTextField(Document doc, String text,  int columns) 构造一个新   的 JTextField ，它使用给定的文本存储模型和给定的列数。JTextField(int columns) 构造一个新的空的 TextField与指定的列数。JTextField(String text) 构造一个新的 TextField ，用指定的文本初始化。JTextField(String text,  int columns) 构造一个新的 TextField ，用指定的文本和列初始化。\nJTextField的常用方法 ：\n\npublic void setText(String text)设置文本框的文本public String getText()获得文本框中的文本public void setHorizontalAlignment(int alignment)设置文本框的文本对齐方式。\n\n设置文本的水平对齐方式。 有效的密钥是： JTextField.LEFT JTextField.CENTER JTextField.RIGHT JTextField.LEADING JTextField.TRAILING \n\npublic void setEditable(boolean b)设置文本框是否可以编辑\npublic void setEnabled(boolean enabled)设置文本框的启用或禁用\npublic void setVisible(boolean b)设置文本框是否可见\npublic int getColumns()获取文本域的宽度\npublic void setColumns(int columns)设置文本域的宽度\npublic void setEchoChar(char c)设置文本域的回显字符为c，比如输入密码的输入框，设置回显字符为*\npublic void addActionListener(ActionListener al) 添加对文本框的监听器，由按Enter键触发\n\n3.6 JTextArea 组件\njavax.swing.JTextArea当用户有大量文本需要输入的时候，就可以使用到文本域组件；JTextArea的构造方法共有6种重载JTextArea() 构造一个新的TextArea。JTextArea(Document doc) 使用给定的文档模型构造一个新的JTextArea，默认为所有其他参数（null，0，0）。JTextArea(Document doc, String text,  int rows, int columns) 构造具有指定行数和列数的新JTextArea以及给定模型。JTextArea(int rows,  int columns) 构造具有指定行数和列数的新的空TextArea。JTextArea(String text) 构造一个新的TextArea，并显示指定的文本。JTextArea(String text,  int rows, int columns) 构造具有指定文本和行数和列数的新TextArea。 \nJTextArea的常用方法：\n\nvoid setText(String text)String getText()void setFont(Font font)void setLineWrap(boolean wrap)void setTabSize(int size)void append(String str) 在原文本尾添加字符串strint getColumns()获取文本区的列数int getRows()获取文本区的行数void setEditable(boolean b)设置文本区是否可以编辑\n4、布局管理器\n用户界面上的组件可以按照不同的方式进行排列，例如：可以依序水平排列，或者按网格方式进行排列；每种方案都是指组件的一种布局，要管理这些布局，就需要使用布局管理器；布局管理器是一组实现了java.awt.LayoutManager接口的类，由这些类自动定位组件；布局管理器类在java.awt包中。\n几种常见的布局：\n\n流式布局 java.awt.FlowLayout边界布局 java.awt.BorderLayout网格布局 java.awt.GridLayout卡片布局 Java.awt.CardLayout网袋布局管理器 Java.awt.GridBagLayout\n4.1 流式布局（FlowLayout）流式布局（FlowLayout）是最基本的一种布局，容器缺省的布局就是流式布局。\n流式布局是值把图形元素一个接一个的放在容器中，按照组件加入的先后顺序从左到右排列，当一行排列满后就转到下一行继续从左到右排列。\n构造方法：\n\nFlowLayout() 构造一个新的 FlowLayout中心对齐和默认的5单位水平和垂直间隙。FlowLayout(int align) 构造一个新的 FlowLayout具有指定的对齐和默认的5单位水平和垂直间隙。FlowLayout(int align,  int hgap, int vgap) 创建一个新的流程布局管理器，具有指示的对齐方式和指示的水平和垂直间距。\n静态属性：\n\nstatic int CENTER 该值表示每行的组件应该居中。static int LEADING 该值表示组件的每一行应该对齐到容器方向的前端，例如从左到右的方向向左。static int LEFT 该值表示每一行的组件应为左对齐。static int RIGHT 该值表示组件的每一行都应该是右对齐的。static int TRAILING 该值表示组件的每一行应该对齐到容器方向的后端，例如从左到右的方向向右。 \n常用方法：\n\nint getAlignment()获取对齐方式int getHgap()获取水平间隙int getVgap()获取垂直间隙void setAlignment(int align)设置对齐方式void setHgap(int hgap)设置水平间隙void setVgap(int vgap)设置垂直间隙\n代码演示：\npackage com.company.project.sample.s1;import java.awt.Button;import java.awt.FlowLayout;import javax.swing.JFrame;public class FlowLayoutDemo extends JFrame {    Button bt1 = new Button(\"A\");    Button bt2 = new Button(\"B\");    Button bt3 = new Button(\"C\");    Button bt4 = new Button(\"D\");    Button bt5 = new Button(\"E\");    Button bt6 = new Button(\"F\");    public void init() {        //初始化流式布局（向左对齐，水平间距为20，垂直间距为30）        FlowLayout flowLayout = new FlowLayout(FlowLayout.LEFT, 20, 30);        //设置布局为流式布局        setLayout(flowLayout);        add(bt1);        add(bt2);        add(bt3);        add(bt4);        add(bt4);        add(bt5);        add(bt6);        this.setSize(200, 200);        this.setVisible(true);    }    public static void main(String[] args) {        FlowLayoutDemo flowLayoutDemo = new FlowLayoutDemo();        flowLayoutDemo.init();    }}\n结果：\n\n4.2 边界布局（BorderLayout）边界布局（BorderLayout）将窗口区域分为东、南、西、北和中央五个区域，在窗口边缘是四个狭窄的、固定宽度的区域，中间为一个大的区域。\n构造方法：\n\nBorderLayout() 构建新的边框布局，组件间没有间隙。BorderLayout(int hgap,  int vgap) 构造具有组件之间指定间隙的边框布局。\n静态属性：\n\nstatic String AFTER_LAST_LINE PAGE_END的同义词。static String AFTER_LINE_ENDS LINE_END的同义词。static String BEFORE_FIRST_LINE PAGE_START的同义词。static String BEFORE_LINE_BEGINS LINE_START的同义词。static String CENTER 中心布局约束（容器中间）。static String EAST 东面布局限制（容器右侧）。static String LINE_END 组件在布局的行方向的末尾。static String LINE_START 组件在布局的行方向的开始处。static String NORTH 北面布局约束（容器顶部）。static String PAGE_END 该组件来自布局内容的最后一行。static String PAGE_START 该组件位于布局内容的第一行之前。static String SOUTH 南布局约束（容器底部）。static String WEST 西布局限制（容器左侧）。\n成员方法： \n\nvoid addLayoutComponent(String name,  Component comp) 将指定的组件添加到布局。int getAlignment() 获取此布局的对齐方式。boolean getAlignOnBaseline() 如果组件沿其基线垂直对齐，则返回true。int getHgap() 获得组件之间以及组件与Container的边框之间的 Container int getVgap() 获取组件之间以及组件与所述边界之间的垂直间隙 Container void layoutContainer(Container target) 放出容器。Dimension minimumLayoutSize(Container target) 返回布局指定目标容器中包含的 可见组件所需的最小尺寸。Dimension preferredLayoutSize(Container target) 给定指定目标容器中 可见组件的返回值。void removeLayoutComponent(Component comp) 从布局中删除指定的组件。void setAlignment(int align) 设置此布局的对齐方式。void setAlignOnBaseline(boolean alignOnBaseline) 组件是否应沿其基线垂直排列。void setHgap(int hgap) 设置组件之间以及组件与Container的边框之间的水平 Container 。void setVgap(int vgap) 设置组件之间以及组件与所述边界之间的垂直间隙 Container 。String toString() 返回此 FlowLayout对象及其值的字符串表示形式。 \n代码演示：\npackage com.company.project.sample.s1;import java.awt.BorderLayout;import java.awt.Button;import java.awt.FlowLayout;import java.awt.Label;import javax.swing.JFrame;public class BorderLayoutDemo extends JFrame {    Button bt1 = new Button(\"北\");    Button bt2 = new Button(\"西\");    Button bt3 = new Button(\"东\");    Button bt4 = new Button(\"南\");    Label label = new Label(\"中\");    public void init() {        // 初始化边界布局        BorderLayout borderLayout = new BorderLayout(10, 10);        // 设置布局为边界布局        setLayout(borderLayout);        add(bt1, BorderLayout.NORTH);        add(bt2, BorderLayout.WEST);        add(bt3, BorderLayout.EAST);        add(bt4, borderLayout.SOUTH);        add(\"Center\", label);        this.setSize(200, 200);        this.setVisible(true);    }    public static void main(String[] args) {        BorderLayoutDemo borderLayoutDemo = new BorderLayoutDemo();        borderLayoutDemo.init();    }}\n结果：\n\n4.3 网格布局（GridLayout）GridLayout类是一个布局管理器，它将一个容器的组件放在矩形网格中。 容器被分成等大小的矩形，并且每个矩形中放置一个组件。\n构造方法: \n\nGridLayout() 在单个行中创建一个每个组件的默认值为一列的网格布局。GridLayout(int rows,  int cols) 创建具有指定行数和列数的网格布局。GridLayout(int rows,  int cols, int hgap, int vgap) 创建具有指定行数和列数的网格布局。\n成员方法：\n\nvoid addLayoutComponent(String name,  Component comp) 将具有指定名称的指定组件添加到布局。int getColumns() 获取该布局中的列数。int getHgap() 获得组件之间的水平间隙。int getRows() 获取此布局中的行数。int getVgap() 获取组件之间的垂直间距。void layoutContainer(Container parent) 使用此布局放出指定的容器。Dimension minimumLayoutSize(Container parent) 使用此网格布局确定容器参数的最小大小。Dimension preferredLayoutSize(Container parent) 使用此网格布局确定容器参数的首选大小。void removeLayoutComponent(Component comp) 从布局中删除指定的组件。void setColumns(int cols) 将此布局中的列数设置为指定的值。void setHgap(int hgap) 将组件之间的水平间距设置为指定的值。void setRows(int rows) 将此布局中的行数设置为指定的值。void setVgap(int vgap) 将组件之间的垂直间距设置为指定值。String toString() 返回此网格布局值的字符串表示形式。 \n代码演示：\npackage com.company.project.sample.s1;import java.awt.*;import java.applet.Applet;public class GridLayoutDemo extends Applet {    public void init() {        setLayout(new GridLayout(3, 2));        add(new Button(\"1\"));        add(new Button(\"2\"));        add(new Button(\"3\"));        add(new Button(\"4\"));        add(new Button(\"5\"));        add(new Button(\"6\"));    }}\n结果：\n\n5、面板Panel类5.1 概述在设计用户界面时，为了更加合理的安排各组件在窗口的位置，可以考虑将所需组件先安排在一个容器中，然后再将其作为一个整体加入另一个容器。\nPanel类是这样一个被称为面板的容器类，它是一种无边框的，不能移动、放大、缩小或关闭的容器。\n5.2 用途Panel对象不能作为最底层的容器，也不能指定大小。\nPanel总是作为一个容器组件被加入到Applet或Frame等其他容器，也可以加入到其他的Panel容器中，形成复杂的图形界面系统。\n5.3 用法首先创建Panel的对象，然后设置对象的布局 格式，即设置Panel容器的布局，设置方法在与Applet容器中的设置一样，只是需要使用Panel对象的setLayout()方法，并使用Panel对象的add()方法往Panel容器加入组件。\n5.4 代码案例\npackage com.company.project.sample.s1;import java.applet.Applet;import java.awt.*;public class AppletPanelCalc extends Applet {    public void init() {        setLayout(new BorderLayout());        add(\"North\", new Button(\"按钮北\"));        add(\"West\", new Button(\"按钮西\"));        add(\"South\", new Button(\"按钮南\"));        add(\"East\", new Button(\"按钮东\"));        Panel panel = new Panel();        panel.setLayout(new GridLayout(3, 3));        for (int i = 1; i < 10; i++) {            panel.add(new Button((new Integer(i)).toString()));        }        add(\"Center\", panel);    }}\n结果：\n\n还有一些Swing基本组件，这里就不一一列举了！！！\n6、事件处理6.1  监听器的概述监听器，字面上的理解就是监听观察某个事件（程序）的发生情况，当被监听的事件真的发生了的时候，事件发生者（事件源） 就会给注册该事件的监听者（监听器）发送消息，告诉监听者某些信息，同时监听者也可以获得一份事件对象，根据这个对象可以获得相关属性和执行相关操作。\n监听器模型涉及以下三个对象：\n（1）事件：用户对组件的一个操作，或者说程序执行某个方法，称之为一个事件，如机器人程序执行工作。 （2）事件源：发生事件的组件就是事件源，也就是被监听的对象，如机器人可以工作，可以跳舞，那么就可以把机器人看做是一个事件源。 （3）事件监听器（处理器）：监听并负责处理事件的方法，如监听机器人工作情况，在机器人工作前后做出相应的动作，或者获取机器人的状态信息。\n执行顺序如下：\n1、给事件源注册监听器。 2、组件接受外部作用，也就是事件被触发。 3、组件产生一个相应的事件对象，并把此对象传递给与之关联的事件处理器。 4、事件处理器启动，并执行相关的代码来处理该事件。\n监听器模式：事件源注册监听器之后，当事件源触发事件，监听器就可以回调事件对象的方法；更形象地说，监听者模式是基于：注册-回调的事件/消息通知处理模式，就是被监控者将消息通知给所有监控者。 \n1、注册监听器：事件源.setListener。 2、回调：事件源实现onListener。\n\n代码案例：\npackage com.company.project.sample.s1;import java.applet.Applet;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JTextField;@SuppressWarnings(\"serial\")public class Calc extends Applet implements ActionListener {    JTextField jTextField;    Button[] buttons = new Button[9];    public void init() {        setLayout(new BorderLayout());        jTextField = new JTextField();        add(\"North\", jTextField);        Panel panel = new Panel();        panel.setLayout(new GridLayout(3, 3));        for (int i = 0; i < 9; i++) {            buttons[i] = new Button((new Integer(i + 1)).toString());            buttons[i].addActionListener(this);            panel.add(buttons[i]);        }        add(\"Center\", panel);    }    @Override    public void actionPerformed(ActionEvent e) {        // TODO Auto-generated method stub        for (int i = 0; i < 9; i++) {            if (e.getSource() == buttons[i]) {                jTextField.setText(jTextField.getText() + (i + 1));            }        }    }}\n结果：\n\n', 0, 1);
INSERT INTO `t_article` VALUES (51, '24. File类 及I/O操作', 8, '## 1、File类\n\n### 1.1 概述\n\n- File类是[http://java.io](http://java.io/)包很重要的一个类；\n- File类的对象可以表示文件，也可以是目录。\n- File对象只可以对文件或目录的属性进行操作，不可以操作文件的具体数据，即不能对文件进行读/写操作。\n\n### 1.2 构造方法\n\n（1） [File](https://zhuanlan.zhihu.com/java/io/File.html#File-java.io.File-java.lang.String-)([File](https://zhuanlan.zhihu.com/java/io/File.html) parent, [String](https://zhuanlan.zhihu.com/java/lang/String.html) child)\n\n从父抽象路径名和子路径名字符串创建新的 File实例。\n\n（2）[File](https://zhuanlan.zhihu.com/java/io/File.html#File-java.lang.String-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) pathname)\n\n通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。\n\n（3） [File](https://zhuanlan.zhihu.com/java/io/File.html#File-java.lang.String-java.lang.String-)([String](https://zhuanlan.zhihu.com/java/lang/String.html) parent, [String](https://zhuanlan.zhihu.com/java/lang/String.html) child)\n\n从父路径名字符串和子路径名字符串创建新的 File实例。\n\n（4） [File](https://zhuanlan.zhihu.com/java/io/File.html#File-java.net.URI-)([URI](https://zhuanlan.zhihu.com/java/net/URI.html) uri)\n\n通过将给定的 file: URI转换为抽象路径名来创建新的 File实例。\n\n代码案例：\n\n//创建文件的方法\n\n```java\npublic class CreateFile {\n\n	public static void main(String[] args) {\n		// 创建文件对象。\n		File file = new File(\"D:/FileDemo/FileDemo.txt\");\n		// 创建文件\n		if (!file.exists()) {\n			try {\n				if (file.createNewFile()) {\n					System.out.println(\"文件创建成功\");\n				} else {\n					System.out.println(\"文件创建失败\");\n				}\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n		} else {\n			System.out.println(\"文件已存在\");\n		}\n\n	}\n\n}\n```\n\n//创建目录的方法\n\n```java\nimport java.io.File;\n\npublic class CreateDirectory {\n\n	public static void main(String[] args) {\n		File file = new File(\"D:\\\\FileDemo\");\n\n		if (!file.exists()) {\n			if (file.mkdirs()) {\n				System.out.println(\"创建成功\");\n			} else {\n				System.out.println(\"创建目录失败\");\n			}\n		} else {\n			System.out.println(\"目录已存在,创建失败\");\n		}\n	}\n\n}\n```\n\n### 1.3 常用方法\n\n遍历方法：\n\n//遍历方法\n\n```java\nimport java.io.File;\n\npublic class FileList{\n	public static void main(String[] args) {\n		// 创建目录对象。\n		File file = new File(\"E:\\\\\");\n\n		// 使用list方法\n		String[] fileNameList = file.list();\n		\n		// 遍历目录数组\n		for (String s : fileNameList) {\n			System.out.println(s);\n		}\n		\n		System.out.println(\"------------------------------------\");\n\n		// 使用listFiles方法\n		File[] fileList = file.listFiles();	\n		\n		for (File f : fileList) {\n			System.out.println(f.getAbsolutePath());\n		}\n	}\n}\n```\n\n### 1.4 FileFilter文件过滤器\n\n1.4.1 两个作用：\n\n（1）过滤不符合规格的文件名\n\n- 文件名过滤器接口：interface FilenameFilter\n- 需重写accept方法自定义过滤规则\n\n> **boolean accept**(File dir, String name)  -- dir：表示文件的当前目录。  -- name：表示当前目录的子目录或者文件的名字。\n\n- File类中提供了使用文件名过滤器遍历目录的方法\n\n> **String[] list**(FilenameFilter filter)  -- 把满足指定过滤条件的文件和目录，返回到String数组中。  **File[] listFiles**(FilenameFilter filter)  -- 把满足指定过滤条件的文件和目录，返回到File数组中。\n\n（2）常用于检测文件是否存在\n\n- 文件过滤器接口：interface FileFilter\n- 需重写accept方法自定义过滤规则,如下：\n\n> **boolean accept**(File pathName)  -- pathName：表示当前目录的子目录或者文件的名字。\n\n- File类中提供了使用文件过滤器遍历目录的方法：\n\n> **File[] listFiles**(FilenameFilter filter)  -- 把满足指定过滤条件的文件和目录，返回到File数组中。\n\n代码演示：\n\n```java\npublic class FileFilterDemo {\n\n	public static void main(String[] args) {\n		//创建目录对象\n		File dir = new File(\"D:\\\\FileDemo\");\n\n		//使用\"匿名内部类\"的方式创建过滤器\n		FileFilter filter = new FileFilter() {\n			@Override\n			public boolean accept(File file) {\n				return file.getName().toLowerCase().endsWith(\".txt\");\n			}\n		};\n		\n		File[] files = dir.listFiles(filter);\n		\n		for (File file : files) {\n			System.out.println(file);\n		}\n	}\n\n}\n```\n\n\n\n## 2、输入流与输出流\n\n类：InputStream、OutputStream、Reader、Writer\n\n### 2.1 流按着数据的传输方向分为：\n\n1. 输入流：往内存中读叫输入流。\n2. 输出流：从内存中往外写叫输出流。\n\n（1）所有输入流都是InputStream类或者Reader类的子类。\n\n- 类名以InputStream结尾的类都是InputStream的子类。\n- 类名以Reader结尾的类都是Reader类的子类。\n\n（3）所有输出流都是OutputStream类或者Writer类的子类。\n\n- 类名以OutputStream结尾的类都是OutputStream的子类。\n- 类名以Writer结尾的类都是Writer类的子类。\n\n### 2.2 从数据流编码格式上划分为：\n\n1. 字节流：处理单元为1个字节\n2. 字符流：处理单元为2个字节\n\n（1）InputStream和OutputStream的子类都是字节流\n\n- 可以读写二进制文件，主要处理音频、图片、歌曲、字节流,处理单元为1个字节。\n\n（2）Reader和Writer的子类都是字符流\n\n- 主要处理字符或字符串，字符流处理单元为2个字节。\n- 字节流将读取到的字节数据，去指定的编码表中获取对应文字。\n\n由于上述两种分类都是针对InputStream、OutputStream、Reader、Writer四个类，所以代码案例写在一起\n\n代码案例：\n\n//字节输入流（FileInputStream）\n\n```java\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n\n	public static void main(String[] args) {\n    \n        //建立文件对象\n        File file=new File(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\"); \n   \n        try\n        {\n            //建立链接\n            FileInputStream fileInputStream=new FileInputStream(file);\n            \n            int  n=0; \n            \n            StringBuffer sBuffer=new StringBuffer();\n \n            while (n!=-1)  //当n不等于-1,则代表未到末尾\n            {\n                \n               n=fileInputStream.read();//读取文件的一个字节(8个二进制位),并将其由二进制转成十进制的整数返回\n              \n               char by=(char) n; //转成字符\n               \n               sBuffer.append(by);\n \n            }\n           System.out.println(sBuffer.toString());\n   \n        }\n        catch (FileNotFoundException e)\n        {\n          \n           System.out.println(\"文件不存在或者文件不可读或者文件是目录\");\n        }\n        catch (IOException e)\n        {\n           System.out.println(\"读取过程存在异常\");\n        } \n    }\n}\n```\n\n结果：由于文件存的是字符类型，以字节形式读取，会把原本的字符分解为两个字节，所以乱码了\n\n```\n????¤§???????¤§asfsa???\nsdg sgdf???dfhfh\n?¤§?????????????????¨é??\n?????¨é???????¨é??sf?\n```\n\n//字节输出流（FileOutputStream）\n\n```java\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileOutputStreamDemo {\n\n	public static void main(String[] args) {\n		// 建立文件对象\n		File file = new File(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");\n\n		try {\n			String content = \"我生来坚强\\n只要不死\\n我就笑得猖狂\";\n			FileOutputStream out = new FileOutputStream(file, true);\n			out.write(content.getBytes());\n			System.out.println(\"写入成功\");\n		}\n\n		catch (FileNotFoundException e) {\n\n			System.out.println(\"文件不存在或者文件不可读或者文件是目录\");\n		} catch (IOException e) {\n			System.out.println(\"读取过程存在异常\");\n		}\n	}\n}\n```\n\n结果：\n\n```\n写入成功\n在没有实力之前，你要学会比狼能忍\n在有了实力之后，你要学会比狼更狠我生来坚强我生来坚强\n只要不死\n我就笑得猖狂\n```\n\n//字符输入流（FileReader）\n\n```java\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileReaderDemo2 {\n\n	public static void main(String[] args) {\n\n		// 建立文件对象\n		File file = new File(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");\n\n		try {\n			// 建立链接\n			FileReader fileReader = new FileReader(file);\n			int n = 0;\n\n			char[] chars = new char[10];\n			String s ;\n\n			while ((n = fileReader.read(chars)) != -1) // 当n不等于-1,则代表未到末尾\n			{\n				String string = new String(chars,0,n);\n				\n				System.out.println(string);\n\n			}\n\n		} catch (FileNotFoundException e) {\n\n			System.out.println(\"文件不存在或者文件不可读或者文件是目录\");\n		} catch (IOException e) {\n			System.out.println(\"读取过程存在异常\");\n		}\n	}\n}\n```\n\n//字符输出流（FileWriter）\n\n```java\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class FileWriterDemo2 {\n\n	public static void main(String[] args) {\n		FileWriter filewriter = null;\n		try {\n\n			filewriter = new FileWriter(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\",true);\n\n			String content = \"abcdefghigklmn\";\n			\n			filewriter.write( content );\n		\n		} catch (IOException e1) {\n			e1.printStackTrace();\n		}finally{\n			try {\n				//清空缓存区\n				filewriter.flush();\n				//关闭“文件字符输出流”\n				filewriter.close();\n				System.out.println(\"写入成功！\");\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n}\n```\n\n### 2.3 从封装类型不同分为：\n\n1. 节点流：如果流封装的是某种特定的数据源，如文件、字符串、字符串数组等，则称为节点流。\n2. 处理流：如果流封装的是其它流对象，称为处理流。处理流提供了缓冲功能，提高读写效率。\n\n**（1）节点流中常用类**\n\n- 字节输入流 FileInputStream\n- 字节输出流 FileOutputStream\n- 字符输入流 FileReader\n- 字符输出流 FileWriter\n\n**（2）处理流中常用类**\n\n- 缓冲字节输出流 BufferedOutputStream\n- 缓冲字节输入流 BufferedInputStream\n- 缓冲字符输入流 BufferedReader\n- 缓冲字符输出流 BufferedWriter\n\n上面的节点流就是之前描述的，在这里着重描述处理流\n\n#### 2.3.1 处理流：\n\n**1.缓冲区原理：**\n\n-缓冲区的概念。\n\n-缓冲区的作用：要对操作的数据进行临时的缓存，提高了读写效率。\n\n-缓冲区如何提高读写效率。\n\n**2.处理流的特点：**\n\n- 字符缓冲输入流提供了读取一行的方法readLine() 。\n- 字符缓冲输出流提供了写入一个空行的方法newLine()。\n- 字符缓冲输出流，把写入的数据先写入到内存，再使用flush()方法将内存数据刷到硬盘上。\n\n**注意：在使用字符缓冲输出流时，一定先flush(),然后再close(),避免数据的丢失。**\n\n代码案例：\n\n//缓冲字节输入处理流(BufferedInputStream)\n\n```java\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class BufferedInputStreamDemo2 {\n\n	public static void main(String[] args) {\n		FileInputStream fileInputStream = null;\n		BufferedInputStream bufferedInputStream = null;\n		try {\n			fileInputStream = new FileInputStream(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");\n			\n			bufferedInputStream = new BufferedInputStream(fileInputStream);		\n\n			byte[] bytes = new byte[16];\n	\n			int length = 0;\n		\n			while ((length = bufferedInputStream.read(bytes)) != -1) {\n				System.out.println(new String(bytes, 0, length));\n			}\n		} catch (IOException e) {\n			e.printStackTrace();\n		} finally {\n			try {\n				bufferedInputStream.close();\n				System.out.println(\"读取完成！\");\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n		}\n	}\n\n}\n```\n\n//缓冲字节输出处理流(BufferedOutputStream)\n\n```java\nimport java.io.BufferedOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class BufferedOutputStreamDemo2 {\n\n	public static void main(String[] args) {\n\n		FileOutputStream fileOutputStream = null;\n\n		BufferedOutputStream bufferedOutputStream = null;\n		try {\n\n			fileOutputStream = new FileOutputStream(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");\n\n			bufferedOutputStream = new BufferedOutputStream(fileOutputStream);\n\n			String content = \"abcdefghigklmn\";\n\n			byte[] bytes = content.getBytes();\n\n			bufferedOutputStream.write(bytes);\n\n			System.out.println(\"写入成功！\");\n		} catch (IOException e) {\n\n			e.printStackTrace();\n\n		} finally {\n			try {\n				// 刷新 “缓冲字节输出处理流”\n				bufferedOutputStream.flush();\n				// 关闭 “缓冲字节输出处理流”\n				bufferedOutputStream.close();\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n		}\n	}\n}\n```\n\n//缓冲字符输入处理流(BufferedReader)\n\n```java\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class BufferedReaderDemo2 {\n\n	public static void main(String[] args) {\n\n		FileReader fileReader = null;\n	\n		BufferedReader bufferedReader = null;\n		try {\n	\n			fileReader = new FileReader(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");\n	\n			bufferedReader = new BufferedReader(fileReader);\n	\n			String content = null;\n			int length = 0;\n			\n			while ((content = bufferedReader.readLine()) != null) {\n	\n				System.out.println(content);\n			}\n\n		} catch (IOException e) {\n\n			e.printStackTrace();\n		} finally {\n\n			try {\n				//关闭  “字符输入处理流”\n				bufferedReader.close();\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n		}\n	}\n}\n```\n\n//缓冲缓冲字符输出处理流(BufferedWriter )\n\n### 2.4 节点流和处理流速度的对比\n\n//用字节节点流复制一个视频\n\n```java\npackage com.company.project.homework.h11;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport javax.xml.crypto.Data;\n\n//复制两个视频文件\n//字节流\n//用节点流\n\npublic class Demo2 {\n	public static void main(String[] args) throws IOException {\n		\n		long now = System.currentTimeMillis();\n		\n		FileInputStream fis = new FileInputStream(\"D:\\\\ChromeCoreDownloads\\\\VN1v5.mp4\");\n		FileOutputStream fos ;\n		\n		File newfile = new File(\"D:\\\\ChromeCoreDownloads\\\\VN1v5ss.mp4\");\n		if(!newfile.exists()) {\n			newfile.createNewFile();\n		}\n		fos = new FileOutputStream(newfile);\n\n		\n		byte[] by = new byte[128];\n		int num = 0 ;\n		while ((num = fis.read(by)) != -1) {\n			fos.write(by,0,num);\n			\n		}\n		System.out.println(\"复制完成\");\n		System.out.println(\"使用时间:\" + (System.currentTimeMillis() - now));\n		fos.close();\n		fis.close();\n		\n	}\n}\n```\n\n结果：\n\n```\n复制完成\n使用时间:203\n```\n\n//用字节处理流复制同一个视频\n\n```java\npackage com.company.project.homework.h11;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport javax.xml.crypto.Data;\n\n//复制两个视频文件\n//字节流\n//用处理流\n\npublic class Demo {\n	public static void main(String[] args) throws IOException {\n		\n		long now = System.currentTimeMillis();\n		\n		FileInputStream fis = new FileInputStream(\"D:\\\\ChromeCoreDownloads\\\\VN1v5.mp4\");\n		FileOutputStream fos ;\n		\n		File newfile = new File(\"D:\\\\ChromeCoreDownloads\\\\VN1v5ss.mp4\");\n		if(!newfile.exists()) {\n			newfile.createNewFile();\n		}\n		fos = new FileOutputStream(newfile);\n		\n		\n		BufferedInputStream bis = new BufferedInputStream(fis);\n		BufferedOutputStream bos = new BufferedOutputStream(fos);\n		\n		byte[] by = new byte[128];\n		int num = 0 ;\n		while ((num = bis.read(by)) != -1) {\n			bos.write(by,0,num);\n			\n		}\n		System.out.println(\"复制完成\");\n		System.out.println(\"使用时间:\" + (System.currentTimeMillis() - now));\n		bos.close();\n		bis.close();\n		fos.close();\n		fis.close();\n		\n	}\n}\n```\n\n结果：\n\n```\n复制完成\n使用时间:15\n```\n\n明显速度提升了很多！！！！', 0, 0, '2020-08-06 22:23:43', 2, 0, 1, '1、File类1.1 概述\nFile类是http://java.io包很重要的一个类；File类的对象可以表示文件，也可以是目录。File对象只可以对文件或目录的属性进行操作，不可以操作文件的具体数据，即不能对文件进行读/写操作。\n1.2 构造方法（1） File(File parent, String child)\n从父抽象路径名和子路径名字符串创建新的 File实例。\n（2）File(String pathname)\n通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。\n（3） File(String parent, String child)\n从父路径名字符串和子路径名字符串创建新的 File实例。\n（4） File(URI uri)\n通过将给定的 file: URI转换为抽象路径名来创建新的 File实例。\n代码案例：\n//创建文件的方法\npublic class CreateFile {    public static void main(String[] args) {        // 创建文件对象。        File file = new File(\"D:/FileDemo/FileDemo.txt\");        // 创建文件        if (!file.exists()) {            try {                if (file.createNewFile()) {                    System.out.println(\"文件创建成功\");                } else {                    System.out.println(\"文件创建失败\");                }            } catch (IOException e) {                e.printStackTrace();            }        } else {            System.out.println(\"文件已存在\");        }    }}\n//创建目录的方法\nimport java.io.File;public class CreateDirectory {    public static void main(String[] args) {        File file = new File(\"D:\\\\FileDemo\");        if (!file.exists()) {            if (file.mkdirs()) {                System.out.println(\"创建成功\");            } else {                System.out.println(\"创建目录失败\");            }        } else {            System.out.println(\"目录已存在,创建失败\");        }    }}\n1.3 常用方法遍历方法：\n//遍历方法\nimport java.io.File;public class FileList{    public static void main(String[] args) {        // 创建目录对象。        File file = new File(\"E:\\\\\");        // 使用list方法        String[] fileNameList = file.list();        // 遍历目录数组        for (String s : fileNameList) {            System.out.println(s);        }        System.out.println(\"------------------------------------\");        // 使用listFiles方法        File[] fileList = file.listFiles();            for (File f : fileList) {            System.out.println(f.getAbsolutePath());        }    }}\n1.4 FileFilter文件过滤器1.4.1 两个作用：\n（1）过滤不符合规格的文件名\n\n文件名过滤器接口：interface FilenameFilter需重写accept方法自定义过滤规则\n\nboolean accept(File dir, String name)  — dir：表示文件的当前目录。  — name：表示当前目录的子目录或者文件的名字。\n\n\nFile类中提供了使用文件名过滤器遍历目录的方法\n\nString[] list(FilenameFilter filter)  — 把满足指定过滤条件的文件和目录，返回到String数组中。  File[] listFiles(FilenameFilter filter)  — 把满足指定过滤条件的文件和目录，返回到File数组中。\n\n（2）常用于检测文件是否存在\n\n文件过滤器接口：interface FileFilter需重写accept方法自定义过滤规则,如下：\n\nboolean accept(File pathName)  — pathName：表示当前目录的子目录或者文件的名字。\n\n\nFile类中提供了使用文件过滤器遍历目录的方法：\n\nFile[] listFiles(FilenameFilter filter)  — 把满足指定过滤条件的文件和目录，返回到File数组中。\n\n代码演示：\npublic class FileFilterDemo {    public static void main(String[] args) {        //创建目录对象        File dir = new File(\"D:\\\\FileDemo\");        //使用\"匿名内部类\"的方式创建过滤器        FileFilter filter = new FileFilter() {            @Override            public boolean accept(File file) {                return file.getName().toLowerCase().endsWith(\".txt\");            }        };        File[] files = dir.listFiles(filter);        for (File file : files) {            System.out.println(file);        }    }}\n2、输入流与输出流类：InputStream、OutputStream、Reader、Writer\n2.1 流按着数据的传输方向分为：\n输入流：往内存中读叫输入流。输出流：从内存中往外写叫输出流。\n（1）所有输入流都是InputStream类或者Reader类的子类。\n\n类名以InputStream结尾的类都是InputStream的子类。类名以Reader结尾的类都是Reader类的子类。\n（3）所有输出流都是OutputStream类或者Writer类的子类。\n\n类名以OutputStream结尾的类都是OutputStream的子类。类名以Writer结尾的类都是Writer类的子类。\n2.2 从数据流编码格式上划分为：\n字节流：处理单元为1个字节字符流：处理单元为2个字节\n（1）InputStream和OutputStream的子类都是字节流\n\n可以读写二进制文件，主要处理音频、图片、歌曲、字节流,处理单元为1个字节。\n（2）Reader和Writer的子类都是字符流\n\n主要处理字符或字符串，字符流处理单元为2个字节。字节流将读取到的字节数据，去指定的编码表中获取对应文字。\n由于上述两种分类都是针对InputStream、OutputStream、Reader、Writer四个类，所以代码案例写在一起\n代码案例：\n//字节输入流（FileInputStream）\nimport java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileInputStreamDemo {    public static void main(String[] args) {        //建立文件对象        File file=new File(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");         try        {            //建立链接            FileInputStream fileInputStream=new FileInputStream(file);            int  n=0;             StringBuffer sBuffer=new StringBuffer();            while (n!=-1)  //当n不等于-1,则代表未到末尾            {               n=fileInputStream.read();//读取文件的一个字节(8个二进制位),并将其由二进制转成十进制的整数返回               char by=(char) n; //转成字符               sBuffer.append(by);            }           System.out.println(sBuffer.toString());        }        catch (FileNotFoundException e)        {           System.out.println(\"文件不存在或者文件不可读或者文件是目录\");        }        catch (IOException e)        {           System.out.println(\"读取过程存在异常\");        }     }}\n结果：由于文件存的是字符类型，以字节形式读取，会把原本的字符分解为两个字节，所以乱码了\n????¤§???????¤§asfsa???sdg sgdf???dfhfh?¤§?????????????????¨é???????¨é???????¨é??sf?//字节输出流（FileOutputStream）\nimport java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStreamDemo {    public static void main(String[] args) {        // 建立文件对象        File file = new File(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");        try {            String content = \"我生来坚强\\n只要不死\\n我就笑得猖狂\";            FileOutputStream out = new FileOutputStream(file, true);            out.write(content.getBytes());            System.out.println(\"写入成功\");        }        catch (FileNotFoundException e) {            System.out.println(\"文件不存在或者文件不可读或者文件是目录\");        } catch (IOException e) {            System.out.println(\"读取过程存在异常\");        }    }}\n结果：\n写入成功在没有实力之前，你要学会比狼能忍在有了实力之后，你要学会比狼更狠我生来坚强我生来坚强只要不死我就笑得猖狂//字符输入流（FileReader）\nimport java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class FileReaderDemo2 {    public static void main(String[] args) {        // 建立文件对象        File file = new File(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");        try {            // 建立链接            FileReader fileReader = new FileReader(file);            int n = 0;            char[] chars = new char[10];            String s ;            while ((n = fileReader.read(chars)) != -1) // 当n不等于-1,则代表未到末尾            {                String string = new String(chars,0,n);                System.out.println(string);            }        } catch (FileNotFoundException e) {            System.out.println(\"文件不存在或者文件不可读或者文件是目录\");        } catch (IOException e) {            System.out.println(\"读取过程存在异常\");        }    }}\n//字符输出流（FileWriter）\nimport java.io.FileWriter;import java.io.IOException;public class FileWriterDemo2 {    public static void main(String[] args) {        FileWriter filewriter = null;        try {            filewriter = new FileWriter(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\",true);            String content = \"abcdefghigklmn\";            filewriter.write( content );        } catch (IOException e1) {            e1.printStackTrace();        }finally{            try {                //清空缓存区                filewriter.flush();                //关闭“文件字符输出流”                filewriter.close();                System.out.println(\"写入成功！\");            } catch (IOException e) {                e.printStackTrace();            }        }    }}\n2.3 从封装类型不同分为：\n节点流：如果流封装的是某种特定的数据源，如文件、字符串、字符串数组等，则称为节点流。处理流：如果流封装的是其它流对象，称为处理流。处理流提供了缓冲功能，提高读写效率。\n（1）节点流中常用类\n\n字节输入流 FileInputStream字节输出流 FileOutputStream字符输入流 FileReader字符输出流 FileWriter\n（2）处理流中常用类\n\n缓冲字节输出流 BufferedOutputStream缓冲字节输入流 BufferedInputStream缓冲字符输入流 BufferedReader缓冲字符输出流 BufferedWriter\n上面的节点流就是之前描述的，在这里着重描述处理流\n2.3.1 处理流：1.缓冲区原理：\n-缓冲区的概念。\n-缓冲区的作用：要对操作的数据进行临时的缓存，提高了读写效率。\n-缓冲区如何提高读写效率。\n2.处理流的特点：\n\n字符缓冲输入流提供了读取一行的方法readLine() 。字符缓冲输出流提供了写入一个空行的方法newLine()。字符缓冲输出流，把写入的数据先写入到内存，再使用flush()方法将内存数据刷到硬盘上。\n注意：在使用字符缓冲输出流时，一定先flush(),然后再close(),避免数据的丢失。\n代码案例：\n//缓冲字节输入处理流(BufferedInputStream)\nimport java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.IOException;public class BufferedInputStreamDemo2 {    public static void main(String[] args) {        FileInputStream fileInputStream = null;        BufferedInputStream bufferedInputStream = null;        try {            fileInputStream = new FileInputStream(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");            bufferedInputStream = new BufferedInputStream(fileInputStream);                    byte[] bytes = new byte[16];            int length = 0;            while ((length = bufferedInputStream.read(bytes)) != -1) {                System.out.println(new String(bytes, 0, length));            }        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                bufferedInputStream.close();                System.out.println(\"读取完成！\");            } catch (IOException e) {                e.printStackTrace();            }        }    }}\n//缓冲字节输出处理流(BufferedOutputStream)\nimport java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.io.IOException;public class BufferedOutputStreamDemo2 {    public static void main(String[] args) {        FileOutputStream fileOutputStream = null;        BufferedOutputStream bufferedOutputStream = null;        try {            fileOutputStream = new FileOutputStream(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");            bufferedOutputStream = new BufferedOutputStream(fileOutputStream);            String content = \"abcdefghigklmn\";            byte[] bytes = content.getBytes();            bufferedOutputStream.write(bytes);            System.out.println(\"写入成功！\");        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                // 刷新 “缓冲字节输出处理流”                bufferedOutputStream.flush();                // 关闭 “缓冲字节输出处理流”                bufferedOutputStream.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}\n//缓冲字符输入处理流(BufferedReader)\nimport java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class BufferedReaderDemo2 {    public static void main(String[] args) {        FileReader fileReader = null;        BufferedReader bufferedReader = null;        try {            fileReader = new FileReader(\"C:\\\\Users\\\\25849\\\\Desktop\\\\1.txt\");            bufferedReader = new BufferedReader(fileReader);            String content = null;            int length = 0;            while ((content = bufferedReader.readLine()) != null) {                System.out.println(content);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                //关闭  “字符输入处理流”                bufferedReader.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}\n//缓冲缓冲字符输出处理流(BufferedWriter )\n2.4 节点流和处理流速度的对比//用字节节点流复制一个视频\npackage com.company.project.homework.h11;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import javax.xml.crypto.Data;//复制两个视频文件//字节流//用节点流public class Demo2 {    public static void main(String[] args) throws IOException {        long now = System.currentTimeMillis();        FileInputStream fis = new FileInputStream(\"D:\\\\ChromeCoreDownloads\\\\VN1v5.mp4\");        FileOutputStream fos ;        File newfile = new File(\"D:\\\\ChromeCoreDownloads\\\\VN1v5ss.mp4\");        if(!newfile.exists()) {            newfile.createNewFile();        }        fos = new FileOutputStream(newfile);        byte[] by = new byte[128];        int num = 0 ;        while ((num = fis.read(by)) != -1) {            fos.write(by,0,num);        }        System.out.println(\"复制完成\");        System.out.println(\"使用时间:\" + (System.currentTimeMillis() - now));        fos.close();        fis.close();    }}\n结果：\n复制完成使用时间:203//用字节处理流复制同一个视频\npackage com.company.project.homework.h11;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import javax.xml.crypto.Data;//复制两个视频文件//字节流//用处理流public class Demo {    public static void main(String[] args) throws IOException {        long now = System.currentTimeMillis();        FileInputStream fis = new FileInputStream(\"D:\\\\ChromeCoreDownloads\\\\VN1v5.mp4\");        FileOutputStream fos ;        File newfile = new File(\"D:\\\\ChromeCoreDownloads\\\\VN1v5ss.mp4\");        if(!newfile.exists()) {            newfile.createNewFile();        }        fos = new FileOutputStream(newfile);        BufferedInputStream bis = new BufferedInputStream(fis);        BufferedOutputStream bos = new BufferedOutputStream(fos);        byte[] by = new byte[128];        int num = 0 ;        while ((num = bis.read(by)) != -1) {            bos.write(by,0,num);        }        System.out.println(\"复制完成\");        System.out.println(\"使用时间:\" + (System.currentTimeMillis() - now));        bos.close();        bis.close();        fos.close();        fis.close();    }}\n结果：\n复制完成使用时间:15明显速度提升了很多！！！！\n', 0, 1);
INSERT INTO `t_article` VALUES (52, '25. 线程的四种创建方式', 8, '\n\n**四种创建线程的方式：**\n\n- 继承 Thread 类\n- 实现 Runnable 接口\n- 通过 ExecutorService 和 Callable\\<Class> 实现有返回值的线程\n- 基于线程池的execute()，创建临时线程\n\n\n\n### 1 继承 Thread 类\n\nThread 类实现了 Runnable 接口并定义了操作线程的一些方法，我们可以通过创建类时继承 Thread类来创建一个线程。\n\n具体实现：\n\n（1）创建一个继承Thread的类ThreadDemo \n\n（2）重新run()方法\n\n调用步骤：\n\n（1）创建ThreadDemo 类的对象t1\n\n（2）执行t1.start() 方法来启动线程\n\n```java\n//创建线程类\npublic class ThreadDemo extends Thread {\n    //重写run()方法\n	@Override\n	public void run() {\n		for(int i = 0;i<1000;i++) {\n			System.out.println(\"Thread::\"+i);\n		}\n	}\n}\n\n/***********************************************************************/\n//调用线程\n\n//创建线程对象\nThreadDemo t1 = new ThreadDemo();\n\n//启动线程\nt1.start();\n\n```\n\nrun()方法中是线程的具体逻辑操作，\n\nstart()是一个native本地方法，通过操作系统启动一个线程。\n\n\n\n### 2 实现 Runnable 接口\n\n通过实现Runnable 接口来创建线程类 RThread，但是使用的时候，仍需要创建Thread 对象，把RThread的对象当成参数传入。\n\n具体操作：\n\n（1）实现Runnable 接口创建线程类 RThread\n\n（2）重写run()方法\n\n调用步骤：\n\n（1）创建RThread 类的对象 rThread\n\n（2）创建Thread类对象，并把rThread当成参数传入，相当于对rThread进行了封装。\n\n（3）通过start()方法启动线程\n\n```java\n//实现Runnable 接口创建线程类 RThread\npublic class RThread implements Runnable {\n	@Override\n	//重写run()方法\n	public void run() {\n		for(int i = 0;i<1000;i++) {\n			System.out.println(\"Thread::\"+i);\n		}\n	}\n}\n\n/***********************************************************************/\n//调用线程\n\n//创建RThread 类的对象 rThread\nRThread rThread = new RThread();\n\n//创建Thread类对象，并把rThread当成参数传入，相当于对rThread进行了封装。\nThread t2 = new Thread(rThread);\n\n//通过start()方法启动线程\nt2.start();\n```\n\n\n\n### 3 通过 ExecutorService 和 Callable\\<Class> 实现有返回值的线程\n\n我们需要在主线程中开启多个线程去执行一个任务，然后收集各个线程的返回结果并将最终结果进行汇总，这是就需要用到 Callable 接口。\n\n具体步骤：\n\n（1）创建一个类实现Callable接口\n\n（2）重写 call()  方法\n\n调用步骤：\n\n（1）创建线程池\n\n（2）创建接收结果的列表集合\n\n（3）创建线程对象\n\n（4）将线程对象提交到线程池中，并将返回结果接收\n\n（5）将返回结果加入结果集合\n\n（6）关闭线程池\n\n```java\n//通过实现Callable接口来创建线程类\npublic class CThread implements Callable<String> {\n	private String name;\n	\n	public CThread(String name ) {\n		this.name = name;\n	}\n	\n	//重写call()方法\n	@Override\n	public String call() throws Exception {\n		return name;\n	}	\n}\n/***********************************************************************/\n//调用线程\n\n//创建线程池\nExecutorService pool = Executors.newFixedThreadPool(5);\n\n//创建接收结果的列表集合\nList<Future> list = new ArrayList<Future>();\n\nfor(int i = 0;i<5;i++) {\n//创建线程对象\nCallable c = new CThread(\"线程\"+i);\n\n//将线程对象提交到线程池中，并将返回结果接收\nFuture future = pool.submit(c);\nSystem.out.println(\"线程\"+i+\"已经加入线程池\");\n\n//将返回结果加入集合\nlist.add(future);\n}\n\n//关闭线程池\npool.shutdown();\n\n//打印返回结果\nfor (Future future : list) {\n    try {\n        System.out.println(future.get().toString());\n    } catch (InterruptedException | ExecutionException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n	}\n}\n```\n\n\n\n### 4 基于线程池的execute()，创建临时线程\n\n我们可以利用缓存策略使用线程池来创建线程\n\n具体创建：\n\n（1）创建线程池\n\n（2）调用线程池的execute()方法\n\n（3）采用匿名内部类的方法，创建Runnable对象，并重写run()方法\n\n```java\npublic class EThread {\n	public static void main(String[] args) {\n		//创建线程池\n		ExecutorService threadPool = Executors.newFixedThreadPool(10);\n		for(int i = 0;i<10;i++) {\n			//调用execute()方法创建线程\n			//采用匿名内部类的方法，创建Runnable对象，并重写run()方法\n			threadPool.execute(new Runnable() {\n				@Override\n				public void run() {\n					System.out.println(Thread.currentThread().getName());	\n				}\n			});\n		}\n	}\n}\n```\n\n\n\n', 0, 0, '2020-08-06 22:24:23', 2, 0, 1, '四种创建线程的方式：\n\n继承 Thread 类实现 Runnable 接口通过 ExecutorService 和 Callable\\<Class> 实现有返回值的线程基于线程池的execute()，创建临时线程\n1 继承 Thread 类Thread 类实现了 Runnable 接口并定义了操作线程的一些方法，我们可以通过创建类时继承 Thread类来创建一个线程。\n具体实现：\n（1）创建一个继承Thread的类ThreadDemo \n（2）重新run()方法\n调用步骤：\n（1）创建ThreadDemo 类的对象t1\n（2）执行t1.start() 方法来启动线程\n//创建线程类public class ThreadDemo extends Thread {    //重写run()方法    @Override    public void run() {        for(int i = 0;i<1000;i++) {            System.out.println(\"Thread::\"+i);        }    }}/***********************************************************************///调用线程//创建线程对象ThreadDemo t1 = new ThreadDemo();//启动线程t1.start();\nrun()方法中是线程的具体逻辑操作，\nstart()是一个native本地方法，通过操作系统启动一个线程。\n2 实现 Runnable 接口通过实现Runnable 接口来创建线程类 RThread，但是使用的时候，仍需要创建Thread 对象，把RThread的对象当成参数传入。\n具体操作：\n（1）实现Runnable 接口创建线程类 RThread\n（2）重写run()方法\n调用步骤：\n（1）创建RThread 类的对象 rThread\n（2）创建Thread类对象，并把rThread当成参数传入，相当于对rThread进行了封装。\n（3）通过start()方法启动线程\n//实现Runnable 接口创建线程类 RThreadpublic class RThread implements Runnable {    @Override    //重写run()方法    public void run() {        for(int i = 0;i<1000;i++) {            System.out.println(\"Thread::\"+i);        }    }}/***********************************************************************///调用线程//创建RThread 类的对象 rThreadRThread rThread = new RThread();//创建Thread类对象，并把rThread当成参数传入，相当于对rThread进行了封装。Thread t2 = new Thread(rThread);//通过start()方法启动线程t2.start();\n3 通过 ExecutorService 和 Callable\\<Class> 实现有返回值的线程我们需要在主线程中开启多个线程去执行一个任务，然后收集各个线程的返回结果并将最终结果进行汇总，这是就需要用到 Callable 接口。\n具体步骤：\n（1）创建一个类实现Callable接口\n（2）重写 call()  方法\n调用步骤：\n（1）创建线程池\n（2）创建接收结果的列表集合\n（3）创建线程对象\n（4）将线程对象提交到线程池中，并将返回结果接收\n（5）将返回结果加入结果集合\n（6）关闭线程池\n//通过实现Callable接口来创建线程类public class CThread implements Callable<String> {    private String name;    public CThread(String name ) {        this.name = name;    }    //重写call()方法    @Override    public String call() throws Exception {        return name;    }    }/***********************************************************************///调用线程//创建线程池ExecutorService pool = Executors.newFixedThreadPool(5);//创建接收结果的列表集合List<Future> list = new ArrayList<Future>();for(int i = 0;i<5;i++) {//创建线程对象Callable c = new CThread(\"线程\"+i);//将线程对象提交到线程池中，并将返回结果接收Future future = pool.submit(c);System.out.println(\"线程\"+i+\"已经加入线程池\");//将返回结果加入集合list.add(future);}//关闭线程池pool.shutdown();//打印返回结果for (Future future : list) {    try {        System.out.println(future.get().toString());    } catch (InterruptedException | ExecutionException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}\n4 基于线程池的execute()，创建临时线程我们可以利用缓存策略使用线程池来创建线程\n具体创建：\n（1）创建线程池\n（2）调用线程池的execute()方法\n（3）采用匿名内部类的方法，创建Runnable对象，并重写run()方法\npublic class EThread {    public static void main(String[] args) {        //创建线程池        ExecutorService threadPool = Executors.newFixedThreadPool(10);        for(int i = 0;i<10;i++) {            //调用execute()方法创建线程            //采用匿名内部类的方法，创建Runnable对象，并重写run()方法            threadPool.execute(new Runnable() {                @Override                public void run() {                    System.out.println(Thread.currentThread().getName());                    }            });        }    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (53, '26. 正则表达式', 8, '\n> 参考链接：https://blog.csdn.net/weixin_43860260/article/details/91417485\n\n## 一、 概述\n\n正则表达式定义了字符串的模式。\n\n正则表达式可以用来搜索、编辑或处理文本。\n\n正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。\n\n## 二、 正则表达式语法\n\n在其他语言中，**\\\\** 表示：**我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。**\n\n在 Java 中，**\\\\** 表示：**我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。**\n\n所以，在其他的语言中（如Perl），一个反斜杠 **\\** 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 **\\\\** 代表其他语言中的一个 **\\**，这也就是为什么表示一位数字的正则表达式是 **\\\\d**，而表示一个普通的反斜杠是 **\\\\\\\\**。\n\n 注意了，一定要写四个反斜杠，第一和第三个反斜杠是用作java字符串的转义，实际上只代表两个反斜杠。\n\n### 字符语法：\n\n### 3.1   单个符号\n\n1.  \".\" 匹配除\"\\r\\n\"之外的任何单个字符。若要匹配包括\"\\r\\n\"在内的任意字符，请使用诸如\"[\\s\\S]\"之类的模式。 表达式\"t.o\"可以匹配：tno，t#o，teo等等。不可以匹配：tnno，to，Tno，t正o等。\n2.  \"[]\" 字符集。匹配包含的任一字符。 表达式： (1)t[abcd]n 只可以匹配：tan，tbn，tcn，tdn。不可以匹配：thn，tabn，tn 等。 (2)t[a-z]n   字符范围。匹配指定范围内的任何字符。\"[a-z]\"匹配\"a\"到\"z\"范围内的任何小写字母。\n3.  \"|\" 相当于或，可以匹配指定的字符，但是也只能选择其中一项进行匹配。 表达式：t(a|b|c|dd)n 只可以匹配：tan，tbn，tcn，tddn。不可以匹配taan，tn，tabcn。\n4.  \"^\" 表示否，如果用在方括号内，“ ^“表示不想匹配的字符。 表达式： (1) [^x]   第一个字符不能是x (2) [^*a-z*]  反向范围字符。匹配不在指定的范围内的任何字符。例如，\"[^a-z]\"匹配任何不在\"a\"到\"z\"范围内的任何字符。 (3) [^abc]  反向字符集。匹配未包含的任何字符。例如，\"[^abc]\"匹配\"plain\"中\"p\"，\"l\"，\"i\"，\"n\"。\n5.  \"\\\"           将下一字符标记为特殊字符、文本、反向引用或八进制转义符。 表达式: (1)  \"n\"匹配字符\"n\"。 (2)  \"\\n\"匹配换行符。 (3)  \"\\\\\\\\\"匹配\"\\\\\"。 (4)  \"\\\\(\"匹配\"(\"。 (5)   \\b, \\t, \\n, \\f, \\r, \\\", \\\', \\\\        其中第一个\"\\\" 都是转义字符\n\n### 3.2  匹配类型符号\n\n1. \\d 数字字符匹配。等效于 [0-9]。\n2. \\D 非数字字符匹配。等效于 [^0-9]。\n3. \\f 换页符匹配。等效于 \\x0c 和 \\cL。\n4. \\n 换行符匹配。等效于 \\x0a 和 \\cJ。\n5. \\r 匹配一个回车符。等效于 \\x0d 和 \\cM。\n6. \\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。\n7. \\S 匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。\n8. \\t 制表符匹配。与 \\x09 和 \\cI 等效。\n9. \\v 垂直制表符匹配。与 \\x0b 和 \\cK 等效。\n10. \\w 匹配任何字类字符，包括下划线。与\"[A-Za-z0-9_]\"等效。\n11. \\W 与任何非单词字符匹配。与\"[^A-Za-z0-9_]\"等效。\n\n### 3.3  次数限制\n\n1. \"*\" **零次或多次**匹配前面的字符或子表达式。 例如，zo* 匹配\"z\"和\"zoo\"。* 等效于 {0,}。\n2. \"+\" **一次或多次**匹配前面的字符或子表达式。 例如，\"zo+\"与\"zo\"和\"zoo\"匹配，但与\"z\"不匹配。+ 等效于 {1,}。\n3. \"?\" **零次或一次**匹配前面的字符或子表达式。 例如，\"do(es)?\"匹配\"do\"或\"does\"中的\"do\"。? 等效于 {0,1}。\n4. \"{*n*}\"  *n* 是非负整数。**正好匹配** **n** **次**。 例如，\"o{2}\"与\"Bob\"中的\"o\"不匹配，但与\"food\"中的两个\"o\"匹配。\n5. \"{*n*,}\"  *n* 是非负整数。**至少匹配** **n** **次**。 例如，\"o{2,}\"不匹配\"Bob\"中的\"o\"，而匹配\"foooood\"中的所有 o。\"o{1,}\"等效于\"o+\"。\"o{0,}\"等效于\"o*\"。\n6. \"{*n*,*m*}\" *m* 和 *n* 是非负整数，其中 *n* <= *m*。**匹配至少** **n** **次，至多** **m** **次**。例如，\"o{1,3}\"匹配\"fooooood\"中的头三个 o。\'o{0,1}\' 等效于 \'o?\'。注意：您不能将空格插入逗号和数字之间。\n7. \"?\"  当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是\"非贪心的\"。**\"非贪心的\"模式匹配搜索到的、尽可能短的字符串**，而默认的\"贪心的\"模式匹配搜索到的、尽可能长的字符串。 例如，在字符串\"oooo\"中，\"o+?\"只匹配单个\"o\"，而\"o+\"匹配所有\"o\"。\n\n### 3.4  边界判断\n\n1. \"^\" 添加判断字符串串首的字符限制。 \"^The\"：表示所有以\"The\"开始的字符串（\"There\"，\"The cat\"等）；\n2. \"$\" 添加判断字符串末尾的字符限制。 \"put$\":   表示所有以\"put\"结尾的字符串 (\"input\",  \"output\"等);\n3. \"\\b\" 匹配一个字边界，即字与空格间的位置。 例如，\"er\\\\b\"匹配\"never\"中的\"er\"，但不匹配\"verb\"中的\"er\"。 注意这块的第一个\"\\\"是转义字符。\n4. \"\\B\"  非字边界匹配。 例如，\"er\\\\B\" 匹配\"never\"中的\"er\"，但不匹配\"verb\"中的\"er\"。 注意这块的第一个\"\\\"是转义字符。\n\n### 3.5  捕获与非捕获\n\n**（1）捕获组**\n\n- (*pattern*) 匹配 *pattern* 并捕获该匹配的子表达式。 可以使用 **$0…$9** 属性从结果\"匹配\"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用\"\\(\"或者\"\\)\"。 例如：\"(s|ies)\"  匹配\"applies\",\"appls\",\"aspply\",只要里面含有s或ies的都匹配。\n\n**（2）非捕获**\n\n- (?:*pattern*) 匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用\"or\"字符 (|) 组合模式部件的情况很有用。例如，\"industr(?:y|ies)\" 是比 \'industry|industries\' 更经济的表达式。\n- (?=*pattern*) 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，\'Windows (?=95|98|NT|2000)\' 匹配\"Windows 2000\"中的\"Windows\"，但不匹配\"Windows 3.1\"中的\"Windows\"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\n- (?!*pattern*) 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，\'Windows (?!95|98|NT|2000)\' 匹配\"Windows 3.1\"中的 \"Windows\"，但不匹配\"Windows 2000\"中的\"Windows\"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\n\n## 三、常用正则表达式\n\n注意：凡是\"\\d\"是有真实意义的，在Java中都有在前面加上转义字符\"\\\"，即\"^\\d+$\"在Java中就是\"^\\d+$\".下式都是些通用正则表达式，在Java使用时，注意加上转义字符\"\\\".\n\n```java\n（1）\"^\\d+$\"　　//非负整数（正整数 + 0）\n（2）\"^[0-9]*[1-9][0-9]*$\"　　//正整数（001也是正整数）\n（3）\"^((-\\d+)|(0+))$\"　　//非正整数（负整数 + 0）\n（4）\"^-[0-9]*[1-9][0-9]*$\"　　//负整数\n（5）\"^-?\\d+$\"　　　　//整数\n（6）\"^\\d+(\\.\\d+)?$\"　　//非负浮点数（正浮点数 + 0）\n（7）\"^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\"　　//正浮点数\n（8）\"^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$\"　　//非正浮点数（负浮点数 + 0）\n（9）\"^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\"　　//负浮点数\n（10）\"^(-?\\d+)(\\.\\d+)?$\"　　//浮点数\n（11）\"^[A-Za-z]+$\"　　//由26个英文字母组成的字符串\n（12）\"^[A-Z]+$\"　　//由26个英文字母的大写组成的字符串\n（13）\"^[a-z]+$\"　　//由26个英文字母的小写组成的字符串\n（14）\"^[A-Za-z0-9]+$\"　　//由数字和26个英文字母组成的字符串\n（15）\"^\\w+$\"　　//由数字、26个英文字母或者下划线组成的字符串\n（16）\"^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$\"　　　　//email地址\n（17）\"^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$\"　　//url\n（18）/^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-(([0-2]([1-9]{1}))|(3[0|1]))$/   //  年-月-日\n（19）/^((0([1-9]{1}))|(1[1|2]))/(([0-2]([1-9]{1}))|(3[0|1]))/(d{2}|d{4})$/   // 月/日/年\n（20）\"^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$\"   //Emil\n（21）/^((\\+?[0-9]{2,4}\\-[0-9]{3,4}\\-)|([0-9]{3,4}\\-))?([0-9]{7,8})(\\-[0-9]+)?$/     //电话号码\n（22）\"^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$\"   //IP地址\n（23）\n（24）匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]\n（25）匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]\n（26）匹配空行的正则表达式：\\n[\\s| ]*\\r\n（27）匹配HTML标记的正则表达式：/<(.*)>.*<\\/\\1>|<(.*) \\/>/\n（28）匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)\n（29）匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\n（30）匹配网址URL的正则表达式：^[a-zA-z]+://(\\\\w+(-\\\\w+)*)(\\\\.(\\\\w+(-\\\\w+)*))*(\\\\?\\\\S*)?$\n（31）匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n（32）匹配国内电话号码：(\\d{3}-|\\d{4}-)?(\\d{8}|\\d{7})?\n（33）匹配腾讯QQ号：^[1-9]*[1-9][0-9]*$\n（34）元字符及其在正则表达式上下文中的行为：\n（35）\\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个后向引用、或一个八进制转义符。\n（36）^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的Multiline 属性，^ 也匹配 ’\\n’ 或 ’\\r’ 之后的位置。\n（37）$ 匹配输入字符串的结束位置。如果设置了 RegExp 对象的Multiline 属性，$ 也匹配 ’\\n’ 或 ’\\r’ 之前的位置。\n（38）* 匹配前面的子表达式零次或多次。\n（39）+ 匹配前面的子表达式一次或多次。+ 等价于 {1,}。\n（40）? 匹配前面的子表达式零次或一次。? 等价于 {0,1}。\n（41）{n} n 是一个非负整数，匹配确定的n 次。\n（42）{n,} n 是一个非负整数，至少匹配n 次。\n（43）{n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。在逗号和两个数之间不能有空格。\n（44）? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。\n（45）. 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 ’\\n’ 在内的任何字符，请使用象 ’[.\\n]’ 的模式。\n（46）(pattern) 匹配pattern 并获取这一匹配。\n（47）(?:pattern) 匹配pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。\n（48）(?=pattern) 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。\n（49）(?!pattern) 负向预查，与(?=pattern)作用相反\n（50）x|y 匹配 x 或 y。\n（51）[xyz] 字符集合。\n（52）[^xyz] 负值字符集合。\n（53）[a-z] 字符范围，匹配指定范围内的任意字符。\n（54）[^a-z] 负值字符范围，匹配任何不在指定范围内的任意字符。\n（55）\\b 匹配一个单词边界，也就是指单词和空格间的位置。\n（56）\\B 匹配非单词边界。\n（57）\\cx 匹配由x指明的控制字符。\n（58）\\d 匹配一个数字字符。等价于 [0-9]。\n（59）\\D 匹配一个非数字字符。等价于 [^0-9]。\n（60）\\f 匹配一个换页符。等价于 \\x0c 和 \\cL。\n（61）\\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。\n（62）\\r 匹配一个回车符。等价于 \\x0d 和 \\cM。\n（63）\\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。\n（64）\\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n（65）\\t 匹配一个制表符。等价于 \\x09 和 \\cI。\n（66）\\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。\n（67）\\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。\n（68）\\W 匹配任何非单词字符。等价于 ’[^A-Za-z0-9_]’。\n（69）\\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。\n（70）\\num 匹配 num，其中num是一个正整数。对所获取的匹配的引用。\n（71）\\n 标识一个八进制转义值或一个后向引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\n（72）\\nm 标识一个八进制转义值或一个后向引用。如果 \\nm 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。\n（73）\\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。\n（74）\\un 匹配 n，其中 n 是一个用四个十六进制数字表示的Unicode字符。\n（75）匹配中文字符的正则表达式： [u4e00-u9fa5]\n（76）匹配双字节字符(包括汉字在内)：[^x00-xff]\n（77）匹配空行的正则表达式：n[s| ]*r\n（78）匹配HTML标记的正则表达式：/<(.*)>.*</1>|<(.*) />/\n（79）匹配首尾空格的正则表达式：(^s*)|(s*$)\n（80）匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*\n（81）匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&=]*)?\n（82）利用正则表达式限制网页表单里的文本框输入内容：\n（83）用正则表达式限制只能输入中文：onkeyup=\"value=value.replace(/[^u4E00-u9FA5]/g,\'\')\" onbeforepaste=\"clipboardData.setData(\'text\',clipboardData.getData(\'text\').replace(/[^u4E00-u9FA5]/g,\'\'))\"\n（84）用正则表达式限制只能输入全角字符： onkeyup=\"value=value.replace(/[^uFF00-uFFFF]/g,\'\')\" onbeforepaste=\"clipboardData.setData(\'text\',clipboardData.getData(\'text\').replace(/[^uFF00-uFFFF]/g,\'\'))\"\n（85）用正则表达式限制只能输入数字：onkeyup=\"value=value.replace(/[^d]/g,\'\') \"onbeforepaste=\"clipboardData.setData(\'text\',clipboardData.getData(\'text\').replace(/[^d]/g,\'\'))\"\n（86）用正则表达式限制只能输入数字和英文：onkeyup=\"value=value.replace(/[W]/g,\'\') \"onbeforepaste=\"clipboardData.setData(\'text\',clipboardData.getData(\'text\').replace(/[^d]/g,\'\'))\"\n（87） \n（88） \n（89）整理：\n（90） \n（91）匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]\n（92）匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]\n（93）匹配空行的正则表达式：\\n[\\s| ]*\\r\n（94）匹配HTML标记的正则表达式：/<(.*)>.*<\\/\\1>|<(.*) \\/>/\n（95）匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)\n（96）匹配IP地址的正则表达式：/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/g //\n（97）匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\n（98）匹配网址URL的正则表达式：http://(/[\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&=]*)?\n（99）sql语句：^(select|drop|delete|create|update|insert).*$\n（100）1、非负整数：^\\d+$\n（101）2、正整数：^[0-9]*[1-9][0-9]*$\n（102）3、非正整数：^((-\\d+)|(0+))$\n（103）4、负整数：^-[0-9]*[1-9][0-9]*$\n（104）\n（105）5、整数：^-?\\d+$\n（106）\n（107）6、非负浮点数：^\\d+(\\.\\d+)?$\n（108）\n（109）7、正浮点数：^((0-9)+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\n（110）\n（111）8、非正浮点数：^((-\\d+\\.\\d+)?)|(0+(\\.0+)?))$\n（112）\n（113）9、负浮点数：^(-((正浮点数正则式)))$\n（114）\n（115）10、英文字符串：^[A-Za-z]+$\n（116）\n（117）11、英文大写串：^[A-Z]+$\n（118）\n（119）12、英文小写串：^[a-z]+$\n（120）\n（121）13、英文字符数字串：^[A-Za-z0-9]+$\n（122）\n（123）14、英数字加下划线串：^\\w+$\n（124）\n（125）15、E-mail地址：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$\n（126）\n（127）16、URL：^[a-zA-Z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\s*)?$\n（128）或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&_~`@[\\]\\\':+!]*([^<>\\\"\\\"])*$\n（129）\n（130）17、邮政编码：^[1-9]\\d{5}$\n（131）\n（132）18、中文：^[\\u0391-\\uFFE5]+$\n（133）\n（134）19、电话号码：^((\\(\\d{2,3}\\))|(\\d{3}\\-))?(\\(0\\d{2,3}\\)|0\\d{2,3}-)?[1-9]\\d{6,7}(\\-\\d{1,4})?$\n（135）\n（136）20、手机号码：^((\\(\\d{2,3}\\))|(\\d{3}\\-))?13\\d{9}$\n（137）\n（138）21、双字节字符(包括汉字在内)：^\\x00-\\xff\n（139）\n（140）22、匹配首尾空格：(^\\s*)|(\\s*$)（像vbscript那样的trim函数）\n（141）\n（142）23、匹配HTML标记：<(.*)>.*<\\/\\1>|<(.*) \\/>\n（143）\n（144）24、匹配空行：\\n[\\s| ]*\\r\n（145）\n（146）25、提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F) *= *(\'|\")?(\\w|\\\\|\\/|\\.)+(\'|\"| *|>)?\n（147）\n（148）26、提取信息中的邮件地址：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\n（149）\n（150）27、提取信息中的图片链接：(s|S)(r|R)(c|C) *= *(\'|\")?(\\w|\\\\|\\/|\\.)+(\'|\"| *|>)?\n（151）\n（152）28、提取信息中的IP地址：(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\n（153）\n（154）29、提取信息中的中国手机号码：(86)*0*13\\d{9}\n（155）\n（156）30、提取信息中的中国固定电话号码：(\\(\\d{3,4}\\)|\\d{3,4}-|\\s)?\\d{8}\n（157）\n（158）31、提取信息中的中国电话号码（包括移动和固定电话）：(\\(\\d{3,4}\\)|\\d{3,4}-|\\s)?\\d{7,14}\n（159）\n（160）32、提取信息中的中国邮政编码：[1-9]{1}(\\d+){5}\n（161）\n（162）33、提取信息中的浮点数（即小数）：(-?\\d*)\\.?\\d+\n（163）\n（164）34、提取信息中的任何数字 ：(-?\\d*)(\\.\\d+)?\n（165）\n（166）35、IP：(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\n（167）\n（168）36、电话区号：/^0\\d{2,3}$/\n（169）\n（170）37、腾讯QQ号：[1-9][0-9]{4,14}\n（171）\n（172）38、帐号(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n（173）\n（174）39、中文、英文、数字及下划线：^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$\n```\n\n### 四、 Java 中正则表达式的应用\n\n### 4.1 判断功能\n\n **public boolean matches(**[**String**](https://zhuanlan.zhihu.com/java/lang/String.html) **regex)**\n\n判断这个字符串是否匹配给定的regular expression.\n\n参数  regex - 要匹配此字符串的正则表达式。\n\n结果 true   - 如果，并且只有这个字符串与给定的正则表达式匹配 。\n\n异常 PatternSyntaxException - 如果正则表达式的语法无效 \n\n这个是String类的方法，等同于  **Pattern.matches(regex, str)；**\n\n**例：判断输入的手机号是否符合规定（第一位不能为0，长度为5-15位，全数字）**\n\n```java\npublic class Test2 {\n	public static void main(String[] args) {\n		Scanner scanner = new Scanner(System.in);\n		System.out.println(\"请输入手机号:\");\n		String string = scanner.nextLine();\n		\n		//第一位不能为0，长度5-15位\n		String regex = \"[1-9][0-9]{4,14}\";  \n		boolean flag = string.matches(regex);\n		System.out.println(flag);\n	}\n}\n```\n\n### 4.2  分割功能\n\n  **public** [**String**](https://zhuanlan.zhihu.com/java/lang/String.html)**[] split(**[**String**](https://zhuanlan.zhihu.com/java/lang/String.html) **regex)**\n\n将此字符串拆分为给定的[regular expression的](https://zhuanlan.zhihu.com/p/util/regex/Pattern.html#sum)匹配。尾随的空字符串不会包含在结果数组中。 \n\n参数 \n\nregex - 分隔正则表达式\n\n 结果 通过将该字符串围绕给定的正则表达式的匹配来计算的字符串数组\n\n 异常 [PatternSyntaxException](https://zhuanlan.zhihu.com/java/util/regex/PatternSyntaxException.html)  - 如果正则表达式的语法无效 \n\n**例：按照标点符合分割古诗**\n\n```java\n                String regex = \"[，。]\";\n		String string = \"风急天高猿啸哀，渚清沙白鸟飞回。\" + \n				\"无边落木萧萧下，不尽长江滚滚来。\" + \n				\"万里悲秋常作客，百年多病独登台。\" + \n				\"艰难苦恨繁霜鬓，潦倒新停浊酒杯。\";\n		String []arr = string.split(regex);\n		for (String string2 : arr) {\n			System.out.println(string2);\n		}\n```\n\n### 4.3  替换功能\n\n  **public** [**String**](https://zhuanlan.zhihu.com/java/lang/String.html) **replaceAll(**[**String**](https://zhuanlan.zhihu.com/java/lang/String.html) **regex,**   [**String**](https://zhuanlan.zhihu.com/java/lang/String.html) **replacement)** 用给定的替换替换与给定的[regular  expression](https://zhuanlan.zhihu.com/p/util/regex/Pattern.html#sum)匹配的此字符串的每个子字符串。 \n\n 参数 regex - 要匹配此字符串的正则表达式 replacement - 要替换每个匹配的字符串\n\n结果 所得 String \n\n异常 [PatternSyntaxException](https://zhuanlan.zhihu.com/java/util/regex/PatternSyntaxException.html)  - 如果正则表达式的语法无效 \n\n这种形式为str .replaceAll( regex , repl )方法的)产生与表达式完全相同的结果  [**Pattern**](https://zhuanlan.zhihu.com/java/util/regex/Pattern.html)**.**[**compile**](https://zhuanlan.zhihu.com/java/util/regex/Pattern.html#compile-java.lang.String-)**(regex).**[**matcher**](https://zhuanlan.zhihu.com/java/util/regex/Pattern.html#matcher-java.lang.CharSequence-)**(str).**[**replaceAll**](https://zhuanlan.zhihu.com/java/util/regex/Matcher.html#replaceAll-java.lang.String-)**(repl)**  \n\n**例：把所有小写字母换成\"-\"**\n\n```java\npublic class Test4 {\n	public static void main(String[] args) {\n		String regex = \"[a-z]\";\n		String str = \"abcABcDef\";\n		\n		str = str.replaceAll(regex, \"-\");\n		\n		System.out.println(str);			\n	}\n}\n```', 0, 0, '2020-08-06 22:25:26', 2, 0, 1, '\n参考链接：https://blog.csdn.net/weixin_43860260/article/details/91417485\n\n一、 概述正则表达式定义了字符串的模式。\n正则表达式可以用来搜索、编辑或处理文本。\n正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。\n二、 正则表达式语法在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。\n在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。\n所以，在其他的语言中（如Perl），一个反斜杠 \\ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \\，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\\\。\n 注意了，一定要写四个反斜杠，第一和第三个反斜杠是用作java字符串的转义，实际上只代表两个反斜杠。\n字符语法：3.1   单个符号\n“.” 匹配除”\\r\\n”之外的任何单个字符。若要匹配包括”\\r\\n”在内的任意字符，请使用诸如”[\\s\\S]”之类的模式。 表达式”t.o”可以匹配：tno，t#o，teo等等。不可以匹配：tnno，to，Tno，t正o等。“[]” 字符集。匹配包含的任一字符。 表达式： (1)t[abcd]n 只可以匹配：tan，tbn，tcn，tdn。不可以匹配：thn，tabn，tn 等。 (2)t[a-z]n   字符范围。匹配指定范围内的任何字符。”[a-z]”匹配”a”到”z”范围内的任何小写字母。“|” 相当于或，可以匹配指定的字符，但是也只能选择其中一项进行匹配。 表达式：t(a|b|c|dd)n 只可以匹配：tan，tbn，tcn，tddn。不可以匹配taan，tn，tabcn。“^” 表示否，如果用在方括号内，“ ^“表示不想匹配的字符。 表达式： (1) [^x]   第一个字符不能是x (2) [^a-z]  反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。 (3) [^abc]  反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。“\\”           将下一字符标记为特殊字符、文本、反向引用或八进制转义符。 表达式: (1)  “n”匹配字符”n”。 (2)  “\\n”匹配换行符。 (3)  “\\\\“匹配”\\“。 (4)  “\\(“匹配”(“。 (5)   \\b, \\t, \\n, \\f, \\r, \\”, \\’, \\        其中第一个”\\” 都是转义字符\n3.2  匹配类型符号\n\\d 数字字符匹配。等效于 [0-9]。\\D 非数字字符匹配。等效于 [^0-9]。\\f 换页符匹配。等效于 \\x0c 和 \\cL。\\n 换行符匹配。等效于 \\x0a 和 \\cJ。\\r 匹配一个回车符。等效于 \\x0d 和 \\cM。\\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。\\S 匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。\\t 制表符匹配。与 \\x09 和 \\cI 等效。\\v 垂直制表符匹配。与 \\x0b 和 \\cK 等效。\\w 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。\\W 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。\n3.3  次数限制\n““ 零次或多次匹配前面的字符或子表达式。 例如，zo 匹配”z”和”zoo”。* 等效于 {0,}。“+” 一次或多次匹配前面的字符或子表达式。 例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。“?” 零次或一次匹配前面的字符或子表达式。 例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。“{n}”  n 是非负整数。正好匹配 n 次。 例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。“{n,}”  n 是非负整数。至少匹配 n 次。 例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。“{n,m}” m 和 n 是非负整数，其中 n <= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。“?”  当此字符紧随任何其他限定符（、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。*”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。 例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。\n3.4  边界判断\n“^” 添加判断字符串串首的字符限制。 “^The”：表示所有以”The”开始的字符串（”There”，”The cat”等）；“$” 添加判断字符串末尾的字符限制。 “put$”:   表示所有以”put”结尾的字符串 (“input”,  “output”等);“\\b” 匹配一个字边界，即字与空格间的位置。 例如，”er\\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。 注意这块的第一个”\\”是转义字符。“\\B”  非字边界匹配。 例如，”er\\B” 匹配”never”中的”er”，但不匹配”verb”中的”er”。 注意这块的第一个”\\”是转义字符。\n3.5  捕获与非捕获（1）捕获组\n\n(pattern) 匹配 pattern 并捕获该匹配的子表达式。 可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。 例如：”(s|ies)”  匹配”applies”,”appls”,”aspply”,只要里面含有s或ies的都匹配。\n（2）非捕获\n\n(?:pattern) 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，”industr(?:y|ies)” 是比 ‘industry|industries’ 更经济的表达式。(?=pattern) 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。(?!pattern) 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\n三、常用正则表达式注意：凡是”\\d”是有真实意义的，在Java中都有在前面加上转义字符”\\”，即”^\\d+$”在Java中就是”^\\d+$”.下式都是些通用正则表达式，在Java使用时，注意加上转义字符”\\”.\n（1）\"^\\d+$\"　　//非负整数（正整数 + 0）（2）\"^[0-9]*[1-9][0-9]*$\"　　//正整数（001也是正整数）（3）\"^((-\\d+)|(0+))$\"　　//非正整数（负整数 + 0）（4）\"^-[0-9]*[1-9][0-9]*$\"　　//负整数（5）\"^-?\\d+$\"　　　　//整数（6）\"^\\d+(\\.\\d+)?$\"　　//非负浮点数（正浮点数 + 0）（7）\"^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\"　　//正浮点数（8）\"^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$\"　　//非正浮点数（负浮点数 + 0）（9）\"^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\"　　//负浮点数（10）\"^(-?\\d+)(\\.\\d+)?$\"　　//浮点数（11）\"^[A-Za-z]+$\"　　//由26个英文字母组成的字符串（12）\"^[A-Z]+$\"　　//由26个英文字母的大写组成的字符串（13）\"^[a-z]+$\"　　//由26个英文字母的小写组成的字符串（14）\"^[A-Za-z0-9]+$\"　　//由数字和26个英文字母组成的字符串（15）\"^\\w+$\"　　//由数字、26个英文字母或者下划线组成的字符串（16）\"^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$\"　　　　//email地址（17）\"^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$\"　　//url（18）/^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-(([0-2]([1-9]{1}))|(3[0|1]))$/   //  年-月-日（19）/^((0([1-9]{1}))|(1[1|2]))/(([0-2]([1-9]{1}))|(3[0|1]))/(d{2}|d{4})$/   // 月/日/年（20）\"^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$\"   //Emil（21）/^((\\+?[0-9]{2,4}\\-[0-9]{3,4}\\-)|([0-9]{3,4}\\-))?([0-9]{7,8})(\\-[0-9]+)?$/     //电话号码（22）\"^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$\"   //IP地址（23）（24）匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]（25）匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]（26）匹配空行的正则表达式：\\n[\\s| ]*\\r（27）匹配HTML标记的正则表达式：/<(.*)>.*<\\/\\1>|<(.*) \\/>/（28）匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)（29）匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*（30）匹配网址URL的正则表达式：^[a-zA-z]+://(\\\\w+(-\\\\w+)*)(\\\\.(\\\\w+(-\\\\w+)*))*(\\\\?\\\\S*)?$（31）匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$（32）匹配国内电话号码：(\\d{3}-|\\d{4}-)?(\\d{8}|\\d{7})?（33）匹配腾讯QQ号：^[1-9]*[1-9][0-9]*$（34）元字符及其在正则表达式上下文中的行为：（35）\\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个后向引用、或一个八进制转义符。（36）^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的Multiline 属性，^ 也匹配 ’\\n’ 或 ’\\r’ 之后的位置。（37）$ 匹配输入字符串的结束位置。如果设置了 RegExp 对象的Multiline 属性，$ 也匹配 ’\\n’ 或 ’\\r’ 之前的位置。（38）* 匹配前面的子表达式零次或多次。（39）+ 匹配前面的子表达式一次或多次。+ 等价于 {1,}。（40）? 匹配前面的子表达式零次或一次。? 等价于 {0,1}。（41）{n} n 是一个非负整数，匹配确定的n 次。（42）{n,} n 是一个非负整数，至少匹配n 次。（43）{n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。在逗号和两个数之间不能有空格。（44）? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。（45）. 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 ’\\n’ 在内的任何字符，请使用象 ’[.\\n]’ 的模式。（46）(pattern) 匹配pattern 并获取这一匹配。（47）(?:pattern) 匹配pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。（48）(?=pattern) 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。（49）(?!pattern) 负向预查，与(?=pattern)作用相反（50）x|y 匹配 x 或 y。（51）[xyz] 字符集合。（52）[^xyz] 负值字符集合。（53）[a-z] 字符范围，匹配指定范围内的任意字符。（54）[^a-z] 负值字符范围，匹配任何不在指定范围内的任意字符。（55）\\b 匹配一个单词边界，也就是指单词和空格间的位置。（56）\\B 匹配非单词边界。（57）\\cx 匹配由x指明的控制字符。（58）\\d 匹配一个数字字符。等价于 [0-9]。（59）\\D 匹配一个非数字字符。等价于 [^0-9]。（60）\\f 匹配一个换页符。等价于 \\x0c 和 \\cL。（61）\\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。（62）\\r 匹配一个回车符。等价于 \\x0d 和 \\cM。（63）\\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。（64）\\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。（65）\\t 匹配一个制表符。等价于 \\x09 和 \\cI。（66）\\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。（67）\\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。（68）\\W 匹配任何非单词字符。等价于 ’[^A-Za-z0-9_]’。（69）\\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。（70）\\num 匹配 num，其中num是一个正整数。对所获取的匹配的引用。（71）\\n 标识一个八进制转义值或一个后向引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。（72）\\nm 标识一个八进制转义值或一个后向引用。如果 \\nm 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。（73）\\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。（74）\\un 匹配 n，其中 n 是一个用四个十六进制数字表示的Unicode字符。（75）匹配中文字符的正则表达式： [u4e00-u9fa5]（76）匹配双字节字符(包括汉字在内)：[^x00-xff]（77）匹配空行的正则表达式：n[s| ]*r（78）匹配HTML标记的正则表达式：/<(.*)>.*</1>|<(.*) />/（79）匹配首尾空格的正则表达式：(^s*)|(s*$)（80）匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*（81）匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&=]*)?（82）利用正则表达式限制网页表单里的文本框输入内容：（83）用正则表达式限制只能输入中文：onkeyup=\"value=value.replace(/[^u4E00-u9FA5]/g,\'\')\" onbeforepaste=\"clipboardData.setData(\'text\',clipboardData.getData(\'text\').replace(/[^u4E00-u9FA5]/g,\'\'))\"（84）用正则表达式限制只能输入全角字符： onkeyup=\"value=value.replace(/[^uFF00-uFFFF]/g,\'\')\" onbeforepaste=\"clipboardData.setData(\'text\',clipboardData.getData(\'text\').replace(/[^uFF00-uFFFF]/g,\'\'))\"（85）用正则表达式限制只能输入数字：onkeyup=\"value=value.replace(/[^d]/g,\'\') \"onbeforepaste=\"clipboardData.setData(\'text\',clipboardData.getData(\'text\').replace(/[^d]/g,\'\'))\"（86）用正则表达式限制只能输入数字和英文：onkeyup=\"value=value.replace(/[W]/g,\'\') \"onbeforepaste=\"clipboardData.setData(\'text\',clipboardData.getData(\'text\').replace(/[^d]/g,\'\'))\"（87） （88） （89）整理：（90） （91）匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]（92）匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]（93）匹配空行的正则表达式：\\n[\\s| ]*\\r（94）匹配HTML标记的正则表达式：/<(.*)>.*<\\/\\1>|<(.*) \\/>/（95）匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)（96）匹配IP地址的正则表达式：/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/g //（97）匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*（98）匹配网址URL的正则表达式：http://(/[\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&=]*)?（99）sql语句：^(select|drop|delete|create|update|insert).*$（100）1、非负整数：^\\d+$（101）2、正整数：^[0-9]*[1-9][0-9]*$（102）3、非正整数：^((-\\d+)|(0+))$（103）4、负整数：^-[0-9]*[1-9][0-9]*$（104）（105）5、整数：^-?\\d+$（106）（107）6、非负浮点数：^\\d+(\\.\\d+)?$（108）（109）7、正浮点数：^((0-9)+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$（110）（111）8、非正浮点数：^((-\\d+\\.\\d+)?)|(0+(\\.0+)?))$（112）（113）9、负浮点数：^(-((正浮点数正则式)))$（114）（115）10、英文字符串：^[A-Za-z]+$（116）（117）11、英文大写串：^[A-Z]+$（118）（119）12、英文小写串：^[a-z]+$（120）（121）13、英文字符数字串：^[A-Za-z0-9]+$（122）（123）14、英数字加下划线串：^\\w+$（124）（125）15、E-mail地址：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$（126）（127）16、URL：^[a-zA-Z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\s*)?$（128）或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&_~`@[\\]\\\':+!]*([^<>\\\"\\\"])*$（129）（130）17、邮政编码：^[1-9]\\d{5}$（131）（132）18、中文：^[\\u0391-\\uFFE5]+$（133）（134）19、电话号码：^((\\(\\d{2,3}\\))|(\\d{3}\\-))?(\\(0\\d{2,3}\\)|0\\d{2,3}-)?[1-9]\\d{6,7}(\\-\\d{1,4})?$（135）（136）20、手机号码：^((\\(\\d{2,3}\\))|(\\d{3}\\-))?13\\d{9}$（137）（138）21、双字节字符(包括汉字在内)：^\\x00-\\xff（139）（140）22、匹配首尾空格：(^\\s*)|(\\s*$)（像vbscript那样的trim函数）（141）（142）23、匹配HTML标记：<(.*)>.*<\\/\\1>|<(.*) \\/>（143）（144）24、匹配空行：\\n[\\s| ]*\\r（145）（146）25、提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F) *= *(\'|\")?(\\w|\\\\|\\/|\\.)+(\'|\"| *|>)?（147）（148）26、提取信息中的邮件地址：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*（149）（150）27、提取信息中的图片链接：(s|S)(r|R)(c|C) *= *(\'|\")?(\\w|\\\\|\\/|\\.)+(\'|\"| *|>)?（151）（152）28、提取信息中的IP地址：(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)（153）（154）29、提取信息中的中国手机号码：(86)*0*13\\d{9}（155）（156）30、提取信息中的中国固定电话号码：(\\(\\d{3,4}\\)|\\d{3,4}-|\\s)?\\d{8}（157）（158）31、提取信息中的中国电话号码（包括移动和固定电话）：(\\(\\d{3,4}\\)|\\d{3,4}-|\\s)?\\d{7,14}（159）（160）32、提取信息中的中国邮政编码：[1-9]{1}(\\d+){5}（161）（162）33、提取信息中的浮点数（即小数）：(-?\\d*)\\.?\\d+（163）（164）34、提取信息中的任何数字 ：(-?\\d*)(\\.\\d+)?（165）（166）35、IP：(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)（167）（168）36、电话区号：/^0\\d{2,3}$/（169）（170）37、腾讯QQ号：[1-9][0-9]{4,14}（171）（172）38、帐号(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$（173）（174）39、中文、英文、数字及下划线：^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$\n四、 Java 中正则表达式的应用4.1 判断功能 public boolean matches(String regex)\n判断这个字符串是否匹配给定的regular expression.\n参数  regex - 要匹配此字符串的正则表达式。\n结果 true   - 如果，并且只有这个字符串与给定的正则表达式匹配 。\n异常 PatternSyntaxException - 如果正则表达式的语法无效 \n这个是String类的方法，等同于  Pattern.matches(regex, str)；\n例：判断输入的手机号是否符合规定（第一位不能为0，长度为5-15位，全数字）\npublic class Test2 {    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        System.out.println(\"请输入手机号:\");        String string = scanner.nextLine();        //第一位不能为0，长度5-15位        String regex = \"[1-9][0-9]{4,14}\";          boolean flag = string.matches(regex);        System.out.println(flag);    }}\n4.2  分割功能  public String[] split(String regex)\n将此字符串拆分为给定的regular expression的匹配。尾随的空字符串不会包含在结果数组中。 \n参数 \nregex - 分隔正则表达式\n 结果 通过将该字符串围绕给定的正则表达式的匹配来计算的字符串数组\n 异常 PatternSyntaxException  - 如果正则表达式的语法无效 \n例：按照标点符合分割古诗\n                String regex = \"[，。]\";        String string = \"风急天高猿啸哀，渚清沙白鸟飞回。\" +                 \"无边落木萧萧下，不尽长江滚滚来。\" +                 \"万里悲秋常作客，百年多病独登台。\" +                 \"艰难苦恨繁霜鬓，潦倒新停浊酒杯。\";        String []arr = string.split(regex);        for (String string2 : arr) {            System.out.println(string2);        }\n4.3  替换功能  public String replaceAll(String regex,   String replacement) 用给定的替换替换与给定的regular  expression匹配的此字符串的每个子字符串。 \n 参数 regex - 要匹配此字符串的正则表达式 replacement - 要替换每个匹配的字符串\n结果 所得 String \n异常 PatternSyntaxException  - 如果正则表达式的语法无效 \n这种形式为str .replaceAll( regex , repl )方法的)产生与表达式完全相同的结果  Pattern.compile(regex).matcher(str).replaceAll(repl)  \n例：把所有小写字母换成”-“\npublic class Test4 {    public static void main(String[] args) {        String regex = \"[a-z]\";        String str = \"abcABcDef\";        str = str.replaceAll(regex, \"-\");        System.out.println(str);                }}\n', 0, 1);
INSERT INTO `t_article` VALUES (54, '27. Java中的反射机制', 8, '\n## 1、Java中创建对象的方式\n\n- new + 构造方法\n- 反序列化（存储在文件中对象，还原回来）\n- java反射机制\n\n\n\n## 2、已经使用反射的场景\n\n- jdbc\n  - 加载驱动     Class.forName(\"com.mysql.jdbc.Driver\");\n- servlet\n  - servlet 对象有服务器创建\n  - \\<servlet-class>com.company.project.servlet.LoginServlet\\</servlet-class>\n- mybatis\n  - 将查询结果封装到 指定类型的对象中，mybatis 来创建对象\n  - \\<select id =\"findById\" resultType=\"com.company.project.po.User\">\n\n\n\n## 3、Java 反射的概念\n\n​	在运行过程中，可以动态根据类的地址来获取类的信息（构造方法，成员方法，成员变量），以及动态根据类的信息来创建对象，来调用对象的方法、属性的功能成为反射机制。\n\n### Java 反射的作用：\n\n动态获取类的信息，进一步实现需要的功能。\n\n### Java 反射相关的类：\n\n- Class        	\n\n  - 用来封装每个类的字节码信息，Java 中一旦某个类被加载到内存中，将会把类的信息封装到一个Class对象中。\n\n- Constructor  构造方法\n\n- Method          方法\n\n- Field                属性\n\n  \n\n## 4、Java 中Class 对象\n\n使用反射机制来操作，首先我们需要在运行时获取类的Class对象。\n\nClass对象中包含类的信息（一个类的Class对象只有一个，与字节码文件对应）。\n\n获取Class的三种方式：\n\n（1）通过Object中的getClass()\n\n（2）通过类的class属性\n\n（3）通过类的地址（常用的）\n\n\n\n```java\npackage com.company.project.Reflect;\n\npublic class ClassDemo {\n	public static void main(String[] args) {\n		/*\n		 * 	使用反射机制来操作，首先我们需要在运行时获取类的Class对象\n		 *	Class对象中包含类的信息（一个类的Class对象只有一个，与字节码文件对应）\n		 */\n		//获取Class的三种方法\n		//(1)通过Object中的getClass()\n		User user1 = new User();\n		User user2 = new User();\n		\n		Class c1 = user1.getClass();\n		Class c2 = user2.getClass();\n		System.out.println(c1 == c2);		//true\n		\n		//(2)通过类的class属性\n		Class c3 = User.class;\n		System.out.println(c1 == c3); 		//true\n		\n		//(3)通过类的地址（常用的）\n		try {\n			Class c4 = Class.forName(\"com.company.project.Reflect.User\");\n			System.out.println(c1 == c4); 	//true\n		} catch (ClassNotFoundException e) {\n			e.printStackTrace();\n		}	\n	}\n}\n```\n\n\n\n## 5、Java 中Field对象\n\n\n\n```java\npackage com.company.project.Reflect;\n\nimport java.lang.reflect.Field;\n\npublic class FieldDemo {\n	public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException {\n		//指定类的路径\n		String className = \"com.company.project.Reflect.User\";\n				\n		//获取包含对象信息的Class对象\n		Class c = Class.forName(className);\n				\n		//通过Class获取User对象\n		Object obj = c.newInstance();\n		\n		//获取属性\n		Field numf = c.getDeclaredField(\"num\");\n		//设置私有权限\n		numf.setAccessible(true);\n		//给属性赋值\n		numf.setInt(obj, 10);\n		\n		//获取所有的属性\n		Field[] fields = c.getDeclaredFields();\n		for (Field field : fields) {\n			field.setAccessible(true);\n			System.out.println(field.getName());\n			String name = field.getName();\n			String getname = \"get\" + String.valueOf(name.charAt(0)).toUpperCase()+name.substring(1);\n			System.out.println(getname);\n		}\n	}\n}\n```\n\n\n\n## 6、java中的method\n\n```java\npackage com.company.project.Reflect;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class MethodDemo {\n	public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException {\n		//指定类的路径\n		String className = \"com.company.project.Reflect.User\";\n		\n		//获取包含对象信息的Class对象\n		Class c = Class.forName(className);\n		\n		//通过Class获取User对象\n		Object obj = c.newInstance();\n		\n		//获取指定方法\n		Method m = c.getDeclaredMethod(\"eat\", String.class);\n		//设置私有权限\n		m.setAccessible(true);\n		//调用私有方法\n		m.invoke(obj, \"cat\");\n		\n		//获取所有的方法\n		Method[] methods = c.getDeclaredMethods();\n		for (Method method : methods) {\n			System.out.println(method);\n		}\n	}\n}\n```', 0, 0, '2020-08-06 22:26:21', 2, 0, 1, '1、Java中创建对象的方式\nnew + 构造方法反序列化（存储在文件中对象，还原回来）java反射机制\n2、已经使用反射的场景\njdbc\n加载驱动     Class.forName(“com.mysql.jdbc.Driver”);\nservlet\nservlet 对象有服务器创建\\<servlet-class>com.company.project.servlet.LoginServlet\\</servlet-class>\nmybatis\n将查询结果封装到 指定类型的对象中，mybatis 来创建对象\\<select id =\"findById\" resultType=\"com.company.project.po.User\">\n\n3、Java 反射的概念​    在运行过程中，可以动态根据类的地址来获取类的信息（构造方法，成员方法，成员变量），以及动态根据类的信息来创建对象，来调用对象的方法、属性的功能成为反射机制。\nJava 反射的作用：动态获取类的信息，进一步实现需要的功能。\nJava 反射相关的类：\nClass            \n\n用来封装每个类的字节码信息，Java 中一旦某个类被加载到内存中，将会把类的信息封装到一个Class对象中。\nConstructor  构造方法\nMethod          方法\nField                属性\n\n4、Java 中Class 对象使用反射机制来操作，首先我们需要在运行时获取类的Class对象。\nClass对象中包含类的信息（一个类的Class对象只有一个，与字节码文件对应）。\n获取Class的三种方式：\n（1）通过Object中的getClass()\n（2）通过类的class属性\n（3）通过类的地址（常用的）\npackage com.company.project.Reflect;public class ClassDemo {    public static void main(String[] args) {        /*         *     使用反射机制来操作，首先我们需要在运行时获取类的Class对象         *    Class对象中包含类的信息（一个类的Class对象只有一个，与字节码文件对应）         */        //获取Class的三种方法        //(1)通过Object中的getClass()        User user1 = new User();        User user2 = new User();        Class c1 = user1.getClass();        Class c2 = user2.getClass();        System.out.println(c1 == c2);        //true        //(2)通过类的class属性        Class c3 = User.class;        System.out.println(c1 == c3);         //true        //(3)通过类的地址（常用的）        try {            Class c4 = Class.forName(\"com.company.project.Reflect.User\");            System.out.println(c1 == c4);     //true        } catch (ClassNotFoundException e) {            e.printStackTrace();        }        }}\n5、Java 中Field对象package com.company.project.Reflect;import java.lang.reflect.Field;public class FieldDemo {    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException {        //指定类的路径        String className = \"com.company.project.Reflect.User\";        //获取包含对象信息的Class对象        Class c = Class.forName(className);        //通过Class获取User对象        Object obj = c.newInstance();        //获取属性        Field numf = c.getDeclaredField(\"num\");        //设置私有权限        numf.setAccessible(true);        //给属性赋值        numf.setInt(obj, 10);        //获取所有的属性        Field[] fields = c.getDeclaredFields();        for (Field field : fields) {            field.setAccessible(true);            System.out.println(field.getName());            String name = field.getName();            String getname = \"get\" + String.valueOf(name.charAt(0)).toUpperCase()+name.substring(1);            System.out.println(getname);        }    }}\n6、java中的methodpackage com.company.project.Reflect;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class MethodDemo {    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException {        //指定类的路径        String className = \"com.company.project.Reflect.User\";        //获取包含对象信息的Class对象        Class c = Class.forName(className);        //通过Class获取User对象        Object obj = c.newInstance();        //获取指定方法        Method m = c.getDeclaredMethod(\"eat\", String.class);        //设置私有权限        m.setAccessible(true);        //调用私有方法        m.invoke(obj, \"cat\");        //获取所有的方法        Method[] methods = c.getDeclaredMethods();        for (Method method : methods) {            System.out.println(method);        }    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (55, 'C语言重点——指针篇（一篇让你完全搞懂指针）', 8, '\n## 1、前言\n\nC语言是比较偏底层的语言，为什么他比较偏底层，就是因为他的很多操作都是直接针对内存操作的。\n\n这篇我们就来讲解C语言的一大特点，也是难点，指针和指针操作。\n\n这篇文章我会先从基本类型的存储过程和原理讲起，然后再讲解指针int *p，再举一反三，搞懂int **p和int ***p,学会指针。\n\n**搞懂int \\*p，int \\**p和int \\**\\*p,完全学会指针！！！！**\n\n## 二.  理解一个变量的存储过程和原理（必须清楚掌握）\n\n### 2.1  直接\'=\'赋值\n\n```\nint a = 5;\nprintf(\"a = %d\",a);\n```\n\n结果： a = 5\n\n这一句话完成了两个操作，我们先了解c语言在计算机内部干了什么? \n\n两个操作：\n\n（1）int a; \n\n在栈中定义了一个变量a，并且在内存中开辟了一个int类型大小的空间， 即4个字节 ，然后让a指向这篇空间，也就是这篇空间，计算机分配给了a， a以后就有了一片属于自己的空间； \n\n (2) a = 5;\n\n 在a的自己的那片空间，里面存放数值5 ，把5转换成二进制，存到a的4个字节的空间 。\n\n![img](https://pic1.zhimg.com/v2-913b797b0a54425197d4b8fe46bc02f4_b.png)\n\n### 2.2  利用输入流，手动赋值 \n\n```\nscanf(\"%d\",&a);\n```\n\n我们还有过输入赋值操作，刚好可以证明上述观点：\n\n用户输入了一个int类型的数值，比如输入5，然后&a，先找到a的那片地址空间，最后把5转成二进制，存入a的那片地址空间，即完成了对a的赋值，也就是在a的那片4字节的空间填入了二进制的5； \n\n### 2.3 总结\n\n从上述讲述我们可以了解，一个变量的存储，先从内存开辟一个类型大小的空间（int类型4个字节大小），在让变量指向这篇空间，即就是这片空间属于这个变量，再在这片空间中存储你要存储的数值。\n\n## 3、指针类型（int *）的存储过程和原理\n\n### 3.1  指针类型的赋值规范 \n\n(1)  第一种先定义后赋值 \n\n```\nint *p;\np = &a;	  //这种方式正确\nprintf(\"p = %d\\n\",p);\n```\n\n结果：p = 6618636\n\n变量p存放的a的地址 \n\n**重点：**\n\n**先了解，指针类型，int \\*p,虽然是\\*p在一起写着，但是变量名叫p，类型为int \\*，也就是整型的指针类型，当你理清变量名和类型之后，你对指针的理解程度已经懂了大半了 。**\n\n（2）第二种定义赋值一步完成\n\n```\nint *r = &a;\nprintf(\"r = %d\\n\",r);\n```\n\n结果：r =  6618636存放的是a的地址\n\n还有一种常用的错误赋值方法：\n\n```\n// 	p = a;    //这种赋值方式错误\n```\n\n### 错误的操作,不能把一个具体的数字赋给指针（类型不匹配），\n\n### 一个指针类型，一个int类型\n\n### 3.2  指针存储过程和原理\n\n![img](https://pic2.zhimg.com/v2-f202447aa8b2e0e3bfd63ca692dcfe3d_b.png)\n\n前面列举了两种常用的指针的赋值，下来具体讲解计算机都干了什么？\n\n- 可以把存放一个int类型变量的地址赋给一个int *指针类型的变量 \n- \'=\'左边是一个int *指针类型的变量 ，可以存放放置着int类型数值的地址\n- \'=\'右边是&a，a是int类型的变量数值5，&是取地址符，&a就是拿到int类型a的数值的地址 \n\n**总的来说，就是把a的那片空间，给了p一个钥匙，让p也可以对a的那片空间操作，这个已经属于指针操作了，后面我们会讲到。**\n\n由上述可以证明，**c语言的赋值，必须是类型对应** \n\n### 总结：int *p;  变量名叫p，类型为int *,可存放一个int数据的地址 。\n\n**注意：**这块的可存放一个int数据的地址，不是存放一个地址，是int类型\n\n例如：\n\n```\n int a = 5;\n int *p;\n p = &a;\n```\n\n- 这里a是一个int类型的变量，存放的int类型的数值5\n\n​	  &a 取到了存放int类型a的地址	 \n\n 	  p = &a; 把int类型a的地址赋给了int *类型的p\n\n​	   即就是int *类型的变量可存放一个int数据的地址 \n\n## 4、指针类型（int **）的存储过程和原理 \n\n```\nint **q;\nq = &p;\nprintf(\"q = %d\\n\",q);\n```\n\n结果：q = 6618624存放的p的地址 \n\n###  int *p明白了，那么int **q呢？\n\n首先： 先对数据类型和变量划分开\n\nint **q;  变量名为q，数据类型为int ** \n\nint *中存放的是int类型数据的地址\n\nint **中存放的是int类型数据的地址的地址\n\n上述我们明白了，一个*是指一个int数值的地址，\n\np中存放的是个int数值的地址，p = 6618636，为a的地址。 \n\n那么我们可以推到，两个*q就是存放p的地址。\n\np存放a的地址，p本身也是一个变量，他的值为a的地址 ，\n\n而内存也给他自己开辟了一片空间，让他存放而他的数值 \n\nq存放p的地址，q也是一个变量， \n\n他们的指向关系如下 ： \n\na<----p<----q \n\n## 5、指针类型（int ***）的存储过程和原理 \n\n```\nint ***m;\nm = &q;\nprintf(\"m = %d\\n\",m);\n```\n\n结果：m = 6618616存放的q的地址 \n\n既然，int *和int **都懂了，那么int ***就迎刃而解了\n\n同理，int*** 存放的是int **类型数据的地址\n\n## 6、指针操作（*操作）\n\n这块我们这说属于指针自己的操作\n\n```\n        printf(\"p = %d\\n\",p);\n	printf(\"*p = %d\\n\",*p);\n	printf(\"q = %d\\n\",q);\n	printf(\"*q = %d\\n\",*q);\n	printf(\"**q = %d\\n\",**q);\n	printf(\"m = %d\\n\",m);\n	printf(\"*m = %d\\n\",*m);\n	printf(\"**m = %d\\n\",**m);\n	printf(\"***m = %d\\n\",***m);\n```\n\n结果：\n\n```\np = 6618636\n*p = 5\nq = 6618624\n*q = 6618636\n**q = 5\nm = 6618616\n*m = 6618624\n**m = 6618636\n***m = 5\n```\n\np、q和m都是上述例子中的变量\n\n首先除了定义指针变量的时候，变量前面有*为定义类型，其他时候均为指针的取值操作，注意是取值，不是取址，拿的是指针变量中存放的值。\n\n### 6.1  举个现实中栗子\n\n举个现实中的例子，你比如说去银行开保险柜，其中*p操作比如开保险柜这个操作，你得先拿着你的柜子号在银行找到保险柜，然后拿着钥匙再打开保险柜取出里面的钱；就像是p中存放的是一个地址，你先拿着p中存放的地址，在内存中找到那块空间，然后再*p操作，取出那块空间中存放的值。\n\n所以 * 操作就是取值操作，即取出指针变量存放的地址中所存放的数据。\n\n### 6.2  *操作怎么去分析\n\n上面几个例子都属于指针的取值操作，也就是也就是拿着指针变量中存的地址号去内存中找里面存的东西。\n\n所以看这种连着好几个*后面跟个变量的表达式，需要从右往左依次抛开\n\n即：***m ；   就是* ( * ( * m )))，看的时候需要从最里层一层一层抛开。\n\n- *p ；\n- 先看成*（p）,再从里向外看，首先他有一个变量p，所有直接可以先从内存中拿到p存放的数据6618636(p中的数据)，再找到内存中6618636那片内存，最后取出6618636中的存放数据5(具体数据) \n\n- **q = 5 ；\n- 先看成 *( * (q)),再从里向外看\n- 先从内存中拿到q存放的数据6618624(q中的数据)，再从内存中找到6618624那片内存，取出存放的数据6618636(*q中存放的数据)，完成了 * (q)操作，再从内存中找到6618636那片内存，取出存放的数据5  (    *( *(q))中存放的数据   )，完成了 ***(*** (q)）操作，再中的存放数据5(具体数据)  （几个*查找几层）\n\n- ***m = 5 \n- 先看成 *(*( * (m))),再从里向外看\n- 先从内存中拿到m存放的数据6618616(m中的数据)，再从内存中找到6618616那片内存，取出存放的数据6618624(*q中存放的数据)，完成了 * (m)操作，再从内存中找到6618624那片内存，取出存放的数据6618636  (  *( *(m))  中存放的数据)，完成了 ***(*** (m)）操作，再从内存中找到6618636 那片内存，取出存放的数据5(  *(*( *(m)))  中存放的数据)，完成了 *(*( *(m)))操作，  （几个*查找几层)\n\n学习c语言好几年了，这是我对指针的理解，如有不同的看法，欢迎评论探讨！！！', 0, 0, '2020-08-06 22:27:38', 2, 0, 1, '1、前言C语言是比较偏底层的语言，为什么他比较偏底层，就是因为他的很多操作都是直接针对内存操作的。\n这篇我们就来讲解C语言的一大特点，也是难点，指针和指针操作。\n这篇文章我会先从基本类型的存储过程和原理讲起，然后再讲解指针int p，再举一反三，搞懂int p和int p,学会指针。\n搞懂int *p，int \\p和int *\\p,完全学会指针！！！！**\n二.  理解一个变量的存储过程和原理（必须清楚掌握）2.1  直接’=’赋值int a = 5;printf(\"a = %d\",a);结果： a = 5\n这一句话完成了两个操作，我们先了解c语言在计算机内部干了什么? \n两个操作：\n（1）int a; \n在栈中定义了一个变量a，并且在内存中开辟了一个int类型大小的空间， 即4个字节 ，然后让a指向这篇空间，也就是这篇空间，计算机分配给了a， a以后就有了一片属于自己的空间； \n (2) a = 5;\n 在a的自己的那片空间，里面存放数值5 ，把5转换成二进制，存到a的4个字节的空间 。\n\n2.2  利用输入流，手动赋值scanf(\"%d\",&a);我们还有过输入赋值操作，刚好可以证明上述观点：\n用户输入了一个int类型的数值，比如输入5，然后&a，先找到a的那片地址空间，最后把5转成二进制，存入a的那片地址空间，即完成了对a的赋值，也就是在a的那片4字节的空间填入了二进制的5； \n2.3 总结从上述讲述我们可以了解，一个变量的存储，先从内存开辟一个类型大小的空间（int类型4个字节大小），在让变量指向这篇空间，即就是这片空间属于这个变量，再在这片空间中存储你要存储的数值。\n3、指针类型（int *）的存储过程和原理3.1  指针类型的赋值规范(1)  第一种先定义后赋值 \nint *p;p = &a;      //这种方式正确printf(\"p = %d\\n\",p);结果：p = 6618636\n变量p存放的a的地址 \n重点：\n先了解，指针类型，int *p,虽然是*p在一起写着，但是变量名叫p，类型为int *，也就是整型的指针类型，当你理清变量名和类型之后，你对指针的理解程度已经懂了大半了 。\n（2）第二种定义赋值一步完成\nint *r = &a;printf(\"r = %d\\n\",r);结果：r =  6618636存放的是a的地址\n还有一种常用的错误赋值方法：\n//     p = a;    //这种赋值方式错误错误的操作,不能把一个具体的数字赋给指针（类型不匹配），一个指针类型，一个int类型3.2  指针存储过程和原理\n前面列举了两种常用的指针的赋值，下来具体讲解计算机都干了什么？\n\n可以把存放一个int类型变量的地址赋给一个int *指针类型的变量 ‘=’左边是一个int *指针类型的变量 ，可以存放放置着int类型数值的地址‘=’右边是&a，a是int类型的变量数值5，&是取地址符，&a就是拿到int类型a的数值的地址 \n总的来说，就是把a的那片空间，给了p一个钥匙，让p也可以对a的那片空间操作，这个已经属于指针操作了，后面我们会讲到。\n由上述可以证明，c语言的赋值，必须是类型对应 \n总结：int p;  变量名叫p，类型为int ,可存放一个int数据的地址 。注意：这块的可存放一个int数据的地址，不是存放一个地址，是int类型\n例如：\n int a = 5; int *p; p = &a;\n这里a是一个int类型的变量，存放的int类型的数值5\n​      &a 取到了存放int类型a的地址     \n   p = &a; 把int类型a的地址赋给了int *类型的p​       即就是int *类型的变量可存放一个int数据的地址 \n4、指针类型（int **）的存储过程和原理int **q;q = &p;printf(\"q = %d\\n\",q);结果：q = 6618624存放的p的地址 \nint p明白了，那么int *q呢？首先： 先对数据类型和变量划分开\nint q;  变量名为q，数据类型为int  \nint *中存放的是int类型数据的地址\nint **中存放的是int类型数据的地址的地址\n上述我们明白了，一个*是指一个int数值的地址，\np中存放的是个int数值的地址，p = 6618636，为a的地址。 \n那么我们可以推到，两个*q就是存放p的地址。\np存放a的地址，p本身也是一个变量，他的值为a的地址 ，\n而内存也给他自己开辟了一片空间，让他存放而他的数值 \nq存放p的地址，q也是一个变量， \n他们的指向关系如下 ： \na<——p<——q \n5、指针类型（int *）的存储过程和原理int ***m;m = &q;printf(\"m = %d\\n\",m);结果：m = 6618616存放的q的地址 \n既然，int 和int 都懂了，那么int 就迎刃而解了\n同理，int* 存放的是int 类型数据的地址\n6、指针操作（*操作）这块我们这说属于指针自己的操作\n        printf(\"p = %d\\n\",p);    printf(\"*p = %d\\n\",*p);    printf(\"q = %d\\n\",q);    printf(\"*q = %d\\n\",*q);    printf(\"**q = %d\\n\",**q);    printf(\"m = %d\\n\",m);    printf(\"*m = %d\\n\",*m);    printf(\"**m = %d\\n\",**m);    printf(\"***m = %d\\n\",***m);结果：\np = 6618636*p = 5q = 6618624*q = 6618636**q = 5m = 6618616*m = 6618624**m = 6618636***m = 5p、q和m都是上述例子中的变量\n首先除了定义指针变量的时候，变量前面有*为定义类型，其他时候均为指针的取值操作，注意是取值，不是取址，拿的是指针变量中存放的值。\n6.1  举个现实中栗子举个现实中的例子，你比如说去银行开保险柜，其中p操作比如开保险柜这个操作，你得先拿着你的柜子号在银行找到保险柜，然后拿着钥匙再打开保险柜取出里面的钱；就像是p中存放的是一个地址，你先拿着p中存放的地址，在内存中找到那块空间，然后再p操作，取出那块空间中存放的值。\n所以 * 操作就是取值操作，即取出指针变量存放的地址中所存放的数据。\n6.2  *操作怎么去分析上面几个例子都属于指针的取值操作，也就是也就是拿着指针变量中存的地址号去内存中找里面存的东西。\n所以看这种连着好几个*后面跟个变量的表达式，需要从右往左依次抛开\n即：**m ；   就是 (  (  m )))，看的时候需要从最里层一层一层抛开。\n\n*p ；先看成*（p）,再从里向外看，首先他有一个变量p，所有直接可以先从内存中拿到p存放的数据6618636(p中的数据)，再找到内存中6618636那片内存，最后取出6618636中的存放数据5(具体数据) \n**q = 5 ；\n先看成 (  (q)),再从里向外看先从内存中拿到q存放的数据6618624(q中的数据)，再从内存中找到6618624那片内存，取出存放的数据6618636(q中存放的数据)，完成了  (q)操作，再从内存中找到6618636那片内存，取出存放的数据5  (    ( (q))中存放的数据   )，完成了 ( (q)）操作，再中的存放数据5(具体数据)  （几个*查找几层）\n*m = 5 \n先看成 (( * (m))),再从里向外看先从内存中拿到m存放的数据6618616(m中的数据)，再从内存中找到6618616那片内存，取出存放的数据6618624(q中存放的数据)，完成了  (m)操作，再从内存中找到6618624那片内存，取出存放的数据6618636  (  ( (m))  中存放的数据)，完成了 ( (m)）操作，再从内存中找到6618636 那片内存，取出存放的数据5(  (( (m)))  中存放的数据)，完成了 (( (m)))操作，  （几个*查找几层)\n学习c语言好几年了，这是我对指针的理解，如有不同的看法，欢迎评论探讨！！！\n', 0, 1);
INSERT INTO `t_article` VALUES (56, 'Github 使用学习', 8, '\n## 1、使用Github\n\n### 1.1 目的\n\n借助 github 托管项目代码\n\n### 1.2 基本概念\n\n**仓库（Repository）：**\n\n仓库用来存放项目代码，每个项目对应一个仓库，多个开源项目则有多个仓库。\n\n**收藏（Star）:**\n\n收藏项目，方便下次查看，stat数量也是项目被认可的程度。\n\n**复制克隆项目（Fork）：**\n\n把被人的项目仓库，在自己的账号下复制一份，该fork到的项目是独立存在的。并且会有表示，来自于谁的。\n\n**发起请求（Pull Request）:**\n\nFork到别人的项目，自己可以进行修改，如果想要让创始人知道你的改动，或者想要帮助创始人升级更新，可以通过Pull Request发送给创始人，你的改动，创始人可以根据你改动的内容，如果感觉好，可以和自己的版本合并，等于是把你的改动纳入了自己版本。\n\n**关注（Watch）：**\n\n如果你watch了某个项目，那么只要该项目有任何更新，你都会第一时间收到通知提醒。\n\n**事务卡片（lssue）：**\n\n发现代码BUG，但是目前没有成型的代码，需要讨论时用。\n\n### 1.3 三个页面：\n\n**Github主页：**\n\n账号创建成功或者点击网址导航栏github图标进入github主页，该页左侧是显示用户动态以及关注用户或关注仓库的动态，右侧显示所有的git库。\n\n**仓库主页：**\n\n主要显示项目的信息，如：项目代码，版本，收藏/关注/fork 情况等\n\n**个人主页：**\n\n个人信息：头像，个人简介，关注我的人，我关注的人，我关注的git库，我开源的项目，我贡献的开源项目等信息。\n\n### 1.4 注册 github 账号\n\n![QQ截图20200611163501](../../Pictures/Typora图片/QQ截图20200611163501.jpg)\n\n\n\n\n\n# Git的初始化和仓库创建和操作\n\n### 1. 基本信息设置\n\n```\n1.设置用户名\ngit config --global user.name \'86God\'\n2.设置用户邮箱\ngit config --global user.email \'2584966199@qq.com\'\n```\n\n### 2. 初始化一个新的Git仓库\n\n（1）创建文件夹\n\n```\nmkdir XinYunBookShop\n```\n\n（2）在文件内初始化git（创建 git 仓库）\n\n```\ncd XinYunBookShop\ngit init\n```\n\n在XinYunBookShop文件夹下会创建.git，这是一个隐藏文件，需要设置显示隐藏文件，才可以看见。\n\n### 3. 如何提交文件到git仓库\n\n（1）touch命令创建文件到工作区域（windows直接操作/git命令）\n\n`git status`命令用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。`git status`不显示已经`commit`到项目历史中去的信息。看项目历史的信息要使用`git log`.\n\n```\ntouch HelloWorld.java\ngit status\n```\n\n（2）将文件从工作区域添加到暂存区\n\n```\ngit add HelloWorld.java\ngit status\n```\n\n（3）把文件从暂存区提交到仓库\n\n```\n git commit -m \'add HelloWorld.java\'\n git status\n```\n\n\n\n### 4. 如何修改仓库文件\n\n（1）修改文件（windows直接操作/git命令）\n\n```\nvim HelloWorld.java\ngit status\n```\n\n（2）添加到暂存区\n\n```\n git add HelloWorld.java\n git status\n```\n\n（3）添加修改文件到仓库\n\n```\ngit commit -m \'第一次修改文件并提交到仓库\'\ngit status\n```\n\n\n\n### 5. 如何删除仓库文件\n\n（1）删除本地文件（windows直接操作/git命令）\n\n```\nrm HelloWorld.java\n```\n\n（2）从Git中删除文件\n\n```\ngit rm HelloWorld.java\n```\n\n（3）提交操作\n\n```\ngit commit -m \'第一次通过git删除仓库文件\'\n```\n\n\n\n### 6. Git管理远程仓库\n\n（1）连接远程仓库：\n\ngit clone 仓库地址：\n\n```\ngit clone https://github.com/86God/XinYunBookShop.git\n```\n\n（2）验证是否连接成功\n\n```\ngit config --list\n```\n\n（3）添加到暂存区\n\n```\ngit add HelloWorld.java\n```\n\n（4）将暂存区提交到git仓库\n\n```\ngit commit -m \'第一次通过git提交文件到远程仓库\'\ngit status\n```\n\n（4）将git仓库同步到Github仓库\n\n```\ngit push\n```\n\n\n\n### 7. Github Pages 搭建个人网站\n\n（1）创建个人站点\n\n新建仓库（注：仓库名必须是【用户名.github.io】）\n\n例如：86God.github.io\n\n（2）在仓库下新建index.html文件即可\n\n（3）如何访问\n\n网址输入：https://86god.github.io/  即可\n\n\n\n### 8.Project Pages 项目站点\n\n\n\n（1）进入项目主页，点击settings\n\n（2）在settings页面找到GitHub Pages 部分\n\n（3）将Source 下面的None，切换到master branch \n\n（4）点击 Change theme，选择想要的主题\n\n（5）选择好，点击Select theme即可\n\n（6）在网址输入https://用户名.github.io/仓库名 即可\n\n例如：https://86god.github.io/XinYunBookShop/\n\n', 0, 0, '2020-08-06 22:41:23', 3, 0, 1, '1、使用Github1.1 目的借助 github 托管项目代码\n1.2 基本概念仓库（Repository）：\n仓库用来存放项目代码，每个项目对应一个仓库，多个开源项目则有多个仓库。\n收藏（Star）:\n收藏项目，方便下次查看，stat数量也是项目被认可的程度。\n复制克隆项目（Fork）：\n把被人的项目仓库，在自己的账号下复制一份，该fork到的项目是独立存在的。并且会有表示，来自于谁的。\n发起请求（Pull Request）:\nFork到别人的项目，自己可以进行修改，如果想要让创始人知道你的改动，或者想要帮助创始人升级更新，可以通过Pull Request发送给创始人，你的改动，创始人可以根据你改动的内容，如果感觉好，可以和自己的版本合并，等于是把你的改动纳入了自己版本。\n关注（Watch）：\n如果你watch了某个项目，那么只要该项目有任何更新，你都会第一时间收到通知提醒。\n事务卡片（lssue）：\n发现代码BUG，但是目前没有成型的代码，需要讨论时用。\n1.3 三个页面：Github主页：\n账号创建成功或者点击网址导航栏github图标进入github主页，该页左侧是显示用户动态以及关注用户或关注仓库的动态，右侧显示所有的git库。\n仓库主页：\n主要显示项目的信息，如：项目代码，版本，收藏/关注/fork 情况等\n个人主页：\n个人信息：头像，个人简介，关注我的人，我关注的人，我关注的git库，我开源的项目，我贡献的开源项目等信息。\n1.4 注册 github 账号\nGit的初始化和仓库创建和操作1. 基本信息设置1.设置用户名git config --global user.name \'86God\'2.设置用户邮箱git config --global user.email \'2584966199@qq.com\'2. 初始化一个新的Git仓库（1）创建文件夹\nmkdir XinYunBookShop（2）在文件内初始化git（创建 git 仓库）\ncd XinYunBookShopgit init在XinYunBookShop文件夹下会创建.git，这是一个隐藏文件，需要设置显示隐藏文件，才可以看见。\n3. 如何提交文件到git仓库（1）touch命令创建文件到工作区域（windows直接操作/git命令）\ngit status命令用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。git status不显示已经commit到项目历史中去的信息。看项目历史的信息要使用git log.\ntouch HelloWorld.javagit status（2）将文件从工作区域添加到暂存区\ngit add HelloWorld.javagit status（3）把文件从暂存区提交到仓库\n git commit -m \'add HelloWorld.java\' git status4. 如何修改仓库文件（1）修改文件（windows直接操作/git命令）\nvim HelloWorld.javagit status（2）添加到暂存区\n git add HelloWorld.java git status（3）添加修改文件到仓库\ngit commit -m \'第一次修改文件并提交到仓库\'git status5. 如何删除仓库文件（1）删除本地文件（windows直接操作/git命令）\nrm HelloWorld.java（2）从Git中删除文件\ngit rm HelloWorld.java（3）提交操作\ngit commit -m \'第一次通过git删除仓库文件\'6. Git管理远程仓库（1）连接远程仓库：\ngit clone 仓库地址：\ngit clone https://github.com/86God/XinYunBookShop.git（2）验证是否连接成功\ngit config --list（3）添加到暂存区\ngit add HelloWorld.java（4）将暂存区提交到git仓库\ngit commit -m \'第一次通过git提交文件到远程仓库\'git status（4）将git仓库同步到Github仓库\ngit push7. Github Pages 搭建个人网站（1）创建个人站点\n新建仓库（注：仓库名必须是【用户名.github.io】）\n例如：86God.github.io\n（2）在仓库下新建index.html文件即可\n（3）如何访问\n网址输入：https://86god.github.io/  即可\n8.Project Pages 项目站点（1）进入项目主页，点击settings\n（2）在settings页面找到GitHub Pages 部分\n（3）将Source 下面的None，切换到master branch \n（4）点击 Change theme，选择想要的主题\n（5）选择好，点击Select theme即可\n（6）在网址输入https://用户名.github.io/仓库名 即可\n例如：https://86god.github.io/XinYunBookShop/\n', 0, 1);
INSERT INTO `t_article` VALUES (58, '01.两数之和（难度：简单）', 8, '\n\n## 问题引入：\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n**示例:**\n\n```\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n## 解法一：暴力法\n\n**暴力法很简单，遍历查找每个元素 的值，判断是否存在两个数的和为target。**\n\n```\n	public static int[] twoSum(int[] nums, int target) {\n		\n		for(int i = 0;i<nums.length;i++) {\n			for(int j = i+1;j<nums.length;j++) {\n				if(nums[i] + nums[j] == target) {\n					return new int[] { i, j };\n				}\n			}\n		}\n		throw new IllegalArgumentException(\"没有找到\");\n	}\n```\n\n## 解法二：两遍哈希表\n\n为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n\n通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！\n\n```\npublic static int[] twoSum2(int[] nums, int target) {\n		Map<Integer, Integer> map = new HashMap<>();\n		for(int i = 0; i<nums.length;i++) {\n			map.put(nums[i], i);\n		}\n		\n		for(int i = 0;i<nums.length;i++) {\n			int c = target - nums[i];\n			if(map.containsKey(c) && map.get(c) != i) {\n				return new int[] {i,map.get(c)};\n			}\n		}		\n		throw new IllegalArgumentException(\"没找到\");	\n	}\n```\n\n## 解法三：一遍哈希表\n\n事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\n\n```\npublic static int[] twoSum3(int[] nums, int target) {\n		Map<Integer, Integer> map = new HashMap<>();\n		for(int i = 0; i<nums.length;i++) {\n			int c = target - nums[i];\n			if(map.containsKey(c) && map.get(c) != i) {\n				return new int[] {i,map.get(c)};\n			}\n			map.put(nums[i], i);\n		}		\n		throw new IllegalArgumentException(\"没找到\");	\n	}\n```\n\n## 测试：\n\n```\n	public static void main(String[] args) {\n		int [] nums = {2, 7, 11, 15};\n		int target = 9;\n		\n		int[] a = twoSum3(nums, target);\n		\n		for (int i : a) {\n			System.out.println(i);\n		}		\n	}\n```', 0, 0, '2020-08-06 23:03:59', 2, 0, 1, '问题引入：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n示例:\n给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]解法一：暴力法暴力法很简单，遍历查找每个元素 的值，判断是否存在两个数的和为target。\n    public static int[] twoSum(int[] nums, int target) {        for(int i = 0;i<nums.length;i++) {            for(int j = i+1;j<nums.length;j++) {                if(nums[i] + nums[j] == target) {                    return new int[] { i, j };                }            }        }        throw new IllegalArgumentException(\"没有找到\");    }解法二：两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！\npublic static int[] twoSum2(int[] nums, int target) {        Map<Integer, Integer> map = new HashMap<>();        for(int i = 0; i<nums.length;i++) {            map.put(nums[i], i);        }        for(int i = 0;i<nums.length;i++) {            int c = target - nums[i];            if(map.containsKey(c) && map.get(c) != i) {                return new int[] {i,map.get(c)};            }        }                throw new IllegalArgumentException(\"没找到\");        }解法三：一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\npublic static int[] twoSum3(int[] nums, int target) {        Map<Integer, Integer> map = new HashMap<>();        for(int i = 0; i<nums.length;i++) {            int c = target - nums[i];            if(map.containsKey(c) && map.get(c) != i) {                return new int[] {i,map.get(c)};            }            map.put(nums[i], i);        }                throw new IllegalArgumentException(\"没找到\");        }测试：    public static void main(String[] args) {        int [] nums = {2, 7, 11, 15};        int target = 9;        int[] a = twoSum3(nums, target);        for (int i : a) {            System.out.println(i);        }            }', 0, 1);
INSERT INTO `t_article` VALUES (59, '02.两数相加（难度：中等）', 8, '\n\n## 题目描述：\n\n给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n**示例：**\n\n```\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n```\n\n## 解法：\n\n按照我们小学学习的两个多位数的相加，从各位开始，各位与各位相加，如果大于10则进位，保留其与10的余数。接下来十位，百位，亦是如此。直到有一个数的没有更高位，则把另一个数的剩余高位补到结果的高位，此时需要判断，是否有进位，如有进位，还需把进位也加之到结果上。\n\n这道题主要是对链表的一些操作。\n\n具体步骤：\n\n（1）判断两个链表的所取结点至少有一个不为null（表示相加还未结束）\n\n（2）如果有一个链表索取结点已经为null了，则让其所取数为0，便于另一个数相加。\n\n（3）相加两个所取的数字之和sum\n\n（4）计算sum对10的商值，即目前的进位。\n\n（5）在结果链表上保存当前sum对10的余数，即结果数字的当前位。\n\n（6）将两个链表的指针都指向下一个结点。继续从第（1）步循环进行，直到不满足（1）的条件。\n\n（7）判断是否两数相加结束后仍存在进位，如果有，则在结果链表上创建一个新的结点，用来保存最后一次的进位（结果边界判断）。\n\n```java\npackage com.company.project.hot100;\n\npublic class Question02 {\n	public static class ListNode {\n		int val;\n		ListNode next;\n\n		ListNode(int x) {\n			val = x;\n		}\n	}\n\n	public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n\n		ListNode t = new ListNode(0);\n		ListNode s = t;\n		int c = 0;\n		while (l1 != null || l2 != null) {\n			int x = l1 == null ? 0 : l1.val;\n			int y = l2 == null ? 0 : l2.val;\n\n			int sum = x + y + c;\n			c = sum /10;\n			sum = sum %10;\n			s.next = new ListNode(sum);\n			s = s.next;\n			if(l1 != null) {\n				l1 = l1.next;\n			}\n			if(l2 != null) {\n				l2 = l2.next;\n			}\n		}\n		if(c != 0) {\n			s.next = new ListNode(c);\n		}\n\n		return t.next;\n	}\n\n	public static void main(String[] args) {\n		ListNode l1 = new ListNode(2);\n		l1.next = new ListNode(4);\n		l1.next.next = new ListNode(3);\n\n		ListNode l2 = new ListNode(5);\n		l2.next = new ListNode(6);\n		l2.next.next = new ListNode(4);\n\n		ListNode s = addTwoNumbers(l1, l2);\n\n		while (s != null) {\n			System.out.println(s.val);\n			s = s.next;\n		}\n	}\n}\n```', 0, 0, '2020-08-06 23:04:58', 2, 0, 1, '题目描述：给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例：\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)输出：7 -> 0 -> 8原因：342 + 465 = 807解法：按照我们小学学习的两个多位数的相加，从各位开始，各位与各位相加，如果大于10则进位，保留其与10的余数。接下来十位，百位，亦是如此。直到有一个数的没有更高位，则把另一个数的剩余高位补到结果的高位，此时需要判断，是否有进位，如有进位，还需把进位也加之到结果上。\n这道题主要是对链表的一些操作。\n具体步骤：\n（1）判断两个链表的所取结点至少有一个不为null（表示相加还未结束）\n（2）如果有一个链表索取结点已经为null了，则让其所取数为0，便于另一个数相加。\n（3）相加两个所取的数字之和sum\n（4）计算sum对10的商值，即目前的进位。\n（5）在结果链表上保存当前sum对10的余数，即结果数字的当前位。\n（6）将两个链表的指针都指向下一个结点。继续从第（1）步循环进行，直到不满足（1）的条件。\n（7）判断是否两数相加结束后仍存在进位，如果有，则在结果链表上创建一个新的结点，用来保存最后一次的进位（结果边界判断）。\npackage com.company.project.hot100;public class Question02 {    public static class ListNode {        int val;        ListNode next;        ListNode(int x) {            val = x;        }    }    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {        ListNode t = new ListNode(0);        ListNode s = t;        int c = 0;        while (l1 != null || l2 != null) {            int x = l1 == null ? 0 : l1.val;            int y = l2 == null ? 0 : l2.val;            int sum = x + y + c;            c = sum /10;            sum = sum %10;            s.next = new ListNode(sum);            s = s.next;            if(l1 != null) {                l1 = l1.next;            }            if(l2 != null) {                l2 = l2.next;            }        }        if(c != 0) {            s.next = new ListNode(c);        }        return t.next;    }    public static void main(String[] args) {        ListNode l1 = new ListNode(2);        l1.next = new ListNode(4);        l1.next.next = new ListNode(3);        ListNode l2 = new ListNode(5);        l2.next = new ListNode(6);        l2.next.next = new ListNode(4);        ListNode s = addTwoNumbers(l1, l2);        while (s != null) {            System.out.println(s.val);            s = s.next;        }    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (60, '03.无重复字符的最长子串', 8, '\n\n> 题目链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n\n## 问题描述：\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n```\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n\n示例 2:\n\n```\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n\n示例 3:\n\n```\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n\n\n\n\n## **1. 暴力法**\n\n**方法一：暴力法**\n\n**思路：逐步检查所有的子字符串，找到最大不重复子字符串**\n\n时间复杂度：O(n^3)\n\n空间复杂度：O(min(m,n)), 需要O(K)的空间，其中K表示set的大小，取决于字符串n的大小以及字符集/字母m的大小。\n\n```java\n	public static int lengthOfLongestSubstring1(String s) {\n		int n = s.length();\n		int ans = 0;\n		String maxson = null;\n		for (int i = 0; i < n; i++) {\n			for (int j = i + 1; j <= n; j++) {\n				if (allUnique(s, i, j)) {\n//					ans = Math.max(ans, j - i);\n					if (j - i > ans) {\n						ans = j - i;\n						maxson = s.substring(i, j);\n					}\n				}\n			}\n		}\n		System.out.println(maxson);\n		return ans;\n	}\n\n	public static boolean allUnique(String s, int start, int end) {\n		Set<Character> set = new HashSet<>();\n		for (int i = start; i < end; i++) {\n			Character c = s.charAt(i);\n			if (set.contains(c)) {\n				return false;\n			}\n			set.add(c);\n		}\n		return true;\n	}\n```\n\n## **2.滑动窗口法**\n\n**方法二：滑动窗口**\n\n**算法： 如果我们已经确定了索引i到j-1之间的子串s(i,j-1)没有重复子字符串, 那我们只需要判断字符s[j]是否已经存在子串s(i,j-1)中。**\n\n**要检查一个字符是否已经存在在子字符串中，可以通过使用HashSet作为滑动窗口， 可以使用O(1)的时间来完成**\n\n> *滑动窗口： 数组/字符串问题中常用的抽象概念。 窗口指的是数组/字符串中由开始索引到结束索引的一系列元素的集合，即[i,j) 左闭右开。滑动窗口是可以将两个边界沿某个方向滑动的窗口。 例如：我们将[i,j)向右滑动一个元素，变为[i+1,j+1)。*\n\n回到我们的问题，我们使用HashSet将字符存储在当前窗口[i,j) （开始i=j）,然后我们向右滑动索引j，如果s[j]没在HashSet中，我们继续向右滑动j。 直到s[j]已经存在HashSet中，我们当前找到的最长子字符串就是i开始到j-1的一段字符串。如果对所有的i都这样操作，就可以找到答案。\n\n时间复杂度： O(2n) = O(n),在最糟糕的情况下i和j都访问了n次 。\n\n空间复杂度：O(min(m,n)),滑动窗口需要O(K)的空间，其中K表示set的大小， 取决于字符串n的大小以及字符集/字母m的大小。\n\n```java\n		public static int lengthOfLongestSubstring2(String s) {\n		int n = s.length();\n		Set<Character> set = new HashSet<>();\n		String maxson = null;\n		int ans = 0, i = 0, j = 0;\n		while (i < n && j < n) {\n			if (!set.contains(s.charAt(j))) {\n				set.add(s.charAt(j++));\n//				ans = Math.max(ans, j - i);\n				if (j - i > ans) {\n					ans = j - i;\n					maxson = s.substring(i, j);\n				}\n			} else {\n\n				set.remove(s.charAt(i++));\n			}\n		}\n		System.out.println(maxson);\n		return ans;\n	}\n```\n\n## 3.优化的滑动窗口\n\n**方法三：优化的滑动窗口**\n\n上述的方法最多需要2n个步骤，其实可以优化到n个步骤 我们可以定义字符到索引的映射，而不是使用集合判断一个字符是否存在。\n\n当我们找到重复字符时，我们可以直接跳过该窗口。 也就是说，如果s[j]在子字符串[i,j-1)范围内与s[J]重复，我们不需要逐渐增加i，\n\n我们可以直接跳过s[i,J]范围内的所有元素，即将i变成J+1。\n\n时间复杂度：O(n)\n\n空间复杂度：O(min(m,n)),m是字符集的大小,set的大小取决于字符串n的大小以及字符集/字母m的大小。\n\n```java\n	public static int lengthOfLongestSubstring3(String s) {\n		int n = s.length();\n		int ans = 0, i = 0, j = 0;\n		String maxson = null;\n		Map<Character, Integer> map = new HashMap<>();\n		for (i = 0, j = 0; j < n; j++) {\n			if (map.containsKey(s.charAt(j))) {\n\n				i = Math.max(map.get(s.charAt(j)) + 1, i);\n			}\n//			ans = Math.max(ans, j - i);\n			if (j - i + 1 > ans) {\n				ans = j - i +1 ;\n				maxson = s.substring(i, j+1);\n			}\n			map.put(s.charAt(j), j);\n		}\n		System.out.println(maxson);\n		return ans;\n\n	}\n```\n\n## 4. 利用整数数组作为访问表来替换Map\n\n方法四：利用整数数组作为直接访问表来替换Map\n\n时间复杂度：O(n)\n\n空间复杂度：O(m),m是字符集的大小\n\n- int[26] 用于字母\'a\'~\'z\'或\'A\'~\'Z\'\n- int[128] 用于ASCII码\n- int[256] 用于扩展ASCII码\n\n```java\n	public static int lengthOfLongestSubstring4(String s) {\n		int n = s.length();\n		int[] index = new int[128];\n		int ans = 0;\n		String maxson = null;\n		for (int j = 0, i = 0; j < n; j++) {\n			i = Math.max(index[s.charAt(j)], i);\n//			ans = Math.max(ans, j-i+1);\n			if (j - i + 1 > ans) {\n				ans = j - i + 1;\n				maxson = s.substring(i, j + 1);\n			}\n			index[s.charAt(j)] = j + 1;\n		}\n		System.out.println(maxson);\n		return ans;\n	}\n```', 0, 0, '2020-08-06 23:05:38', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n\n问题描述：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1:\n输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。示例 2:\n输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。示例 3:\n输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。1. 暴力法方法一：暴力法\n思路：逐步检查所有的子字符串，找到最大不重复子字符串\n时间复杂度：O(n^3)\n空间复杂度：O(min(m,n)), 需要O(K)的空间，其中K表示set的大小，取决于字符串n的大小以及字符集/字母m的大小。\n    public static int lengthOfLongestSubstring1(String s) {        int n = s.length();        int ans = 0;        String maxson = null;        for (int i = 0; i < n; i++) {            for (int j = i + 1; j <= n; j++) {                if (allUnique(s, i, j)) {//                    ans = Math.max(ans, j - i);                    if (j - i > ans) {                        ans = j - i;                        maxson = s.substring(i, j);                    }                }            }        }        System.out.println(maxson);        return ans;    }    public static boolean allUnique(String s, int start, int end) {        Set<Character> set = new HashSet<>();        for (int i = start; i < end; i++) {            Character c = s.charAt(i);            if (set.contains(c)) {                return false;            }            set.add(c);        }        return true;    }\n2.滑动窗口法方法二：滑动窗口\n算法： 如果我们已经确定了索引i到j-1之间的子串s(i,j-1)没有重复子字符串, 那我们只需要判断字符s[j]是否已经存在子串s(i,j-1)中。\n要检查一个字符是否已经存在在子字符串中，可以通过使用HashSet作为滑动窗口， 可以使用O(1)的时间来完成\n\n滑动窗口： 数组/字符串问题中常用的抽象概念。 窗口指的是数组/字符串中由开始索引到结束索引的一系列元素的集合，即[i,j) 左闭右开。滑动窗口是可以将两个边界沿某个方向滑动的窗口。 例如：我们将[i,j)向右滑动一个元素，变为[i+1,j+1)。\n\n回到我们的问题，我们使用HashSet将字符存储在当前窗口[i,j) （开始i=j）,然后我们向右滑动索引j，如果s[j]没在HashSet中，我们继续向右滑动j。 直到s[j]已经存在HashSet中，我们当前找到的最长子字符串就是i开始到j-1的一段字符串。如果对所有的i都这样操作，就可以找到答案。\n时间复杂度： O(2n) = O(n),在最糟糕的情况下i和j都访问了n次 。\n空间复杂度：O(min(m,n)),滑动窗口需要O(K)的空间，其中K表示set的大小， 取决于字符串n的大小以及字符集/字母m的大小。\n        public static int lengthOfLongestSubstring2(String s) {        int n = s.length();        Set<Character> set = new HashSet<>();        String maxson = null;        int ans = 0, i = 0, j = 0;        while (i < n && j < n) {            if (!set.contains(s.charAt(j))) {                set.add(s.charAt(j++));//                ans = Math.max(ans, j - i);                if (j - i > ans) {                    ans = j - i;                    maxson = s.substring(i, j);                }            } else {                set.remove(s.charAt(i++));            }        }        System.out.println(maxson);        return ans;    }\n3.优化的滑动窗口方法三：优化的滑动窗口\n上述的方法最多需要2n个步骤，其实可以优化到n个步骤 我们可以定义字符到索引的映射，而不是使用集合判断一个字符是否存在。\n当我们找到重复字符时，我们可以直接跳过该窗口。 也就是说，如果s[j]在子字符串[i,j-1)范围内与s[J]重复，我们不需要逐渐增加i，\n我们可以直接跳过s[i,J]范围内的所有元素，即将i变成J+1。\n时间复杂度：O(n)\n空间复杂度：O(min(m,n)),m是字符集的大小,set的大小取决于字符串n的大小以及字符集/字母m的大小。\n    public static int lengthOfLongestSubstring3(String s) {        int n = s.length();        int ans = 0, i = 0, j = 0;        String maxson = null;        Map<Character, Integer> map = new HashMap<>();        for (i = 0, j = 0; j < n; j++) {            if (map.containsKey(s.charAt(j))) {                i = Math.max(map.get(s.charAt(j)) + 1, i);            }//            ans = Math.max(ans, j - i);            if (j - i + 1 > ans) {                ans = j - i +1 ;                maxson = s.substring(i, j+1);            }            map.put(s.charAt(j), j);        }        System.out.println(maxson);        return ans;    }\n4. 利用整数数组作为访问表来替换Map方法四：利用整数数组作为直接访问表来替换Map\n时间复杂度：O(n)\n空间复杂度：O(m),m是字符集的大小\n\nint[26] 用于字母’a’~’z’或’A’~’Z’int[128] 用于ASCII码int[256] 用于扩展ASCII码\n    public static int lengthOfLongestSubstring4(String s) {        int n = s.length();        int[] index = new int[128];        int ans = 0;        String maxson = null;        for (int j = 0, i = 0; j < n; j++) {            i = Math.max(index[s.charAt(j)], i);//            ans = Math.max(ans, j-i+1);            if (j - i + 1 > ans) {                ans = j - i + 1;                maxson = s.substring(i, j + 1);            }            index[s.charAt(j)] = j + 1;        }        System.out.println(maxson);        return ans;    }\n', 0, 1);
INSERT INTO `t_article` VALUES (61, '04.寻找两个有序数组的中位数（难度：困难）', 8, '\n\n## 题目描述\n\n给定两个大小为 m 和 n 的有序数组 `nums1` 和 `nums2`。\n\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n\n你可以假设 `nums1` 和 `nums2` 不会同时为空。\n\n**示例 1:**\n\n```\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n```\n\n**示例 2:**\n\n```\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n```\n\n\n\n## 解法一：\n\n这道题是求两个有序数组的中位数，如果不限制时间复杂度的话，那么这道题将会无比简单。\n\n把长度为m和长度为n的两个数组的数据放在一个新的数组中，然后对数组进行排序，找到中位数。\n\n找中位数的时候，因为组合后的数组元素个数(m + n)的奇偶性不确定，如果是奇数的话，那么中位数就是第（m+n）/ 2 个元素，如果是偶数的话，那么中位数就是第（m + n ）/ 2 个元素和第（m + n）/ 2 + 1个。\n\n我们可以利用int整型向下取整的特点，把上面两种情况归结为一种通用的解法，我们可以找到下标（m + n - 1）/ 2和下标（m + n ）/ 2元素，然后求两数的平均值。\n\n```java\n	public static double findMedianSortedArrays(int[] nums1, int[] nums2) {\n		int [] result = Arrays.copyOf(nums1, nums1.length + nums2.length);\n		\n		/**将一个数组片段复制到另一个数组的指定位置\n		 * System.arraycopy(src, srcPos, dest, destPos, length)\n		 * src: 源数组\n		 * srcPos: 从源数组复制数据的起始位置\n		 * dest: 目标数组\n		 * destPos: 复制到目标数组的起始位置\n		 * length: 复制的长度\n		 */\n		System.arraycopy(nums2, 0, result, nums1.length, nums2.length);		\n		Arrays.sort(result);\n		double d = (double)(result[(nums1.length + nums2.length -1)/2] + result[(nums1.length + nums2.length )/2])/2;\n		\n		return d;\n    }\n```\n\n执行用时 :4 ms, 在所有 Java 提交中击败了31.34%的用户\n\n内存消耗 :42.2 MB, 在所有 Java 提交中击败了96.67%的用户\n\n上述的关键代码虽然只有4行，但是在**时间复杂度上是不满足题目要求的**。\n\n\n\n## 解法二：\n\n看见时间复杂度的限制O(log(m+n))，肯定要用二分查找法来解决，其次，中位数的应在的位置依旧按照解法一的方法，不过这次我们不合并数组了，这样会增加时间复杂度。\n\n找中位数的时候，因为两个数组的元素个数之和(m + n)的奇偶性不确定，如果是奇数的话，那么中位数就是第（m+n）/ 2 个元素，如果是偶数的话，那么中位数就是第（m + n +1 ）/ 2 个元素和第（m + n +2）/ 2 个。\n\n下来我们着重看看，如何在两个有序数组中找到第k个元素：\n\n首先，我们利用i和j分别标记数组nums1和 nums2的起始位置，\n\n此次我们处理一些**边界问题：**\n\n（1）当一个数组的起始位置大于等于该数组的长度，表明该数组所有的数字都已经被淘汰了，相当于空数组，那么我们只需要继续在另一个数组里面找，直接可以找出来。\n\n（2）当k = 1的时候，我们只需要比较两个有序数组的起始位置i和j 的数字就好。\n\n难点在于如何处理一般情况？\n\n为了加快搜索速度，我们使用二分法：\n\n（1）我们可以先对k二分，意思就是去找到nums1和nums2的第k/2个数字。\n\n（2）因为两个数字的长度不定，所有我们需要先判断一下两个数组是否都含有第k/2个数字，如果存在就取出来，如果不存在就给它赋一个最大值，赋最大值的原因是：我们后面会通过比较两个数组中取出来的数字，如果小的那个数组，那么前k/2个元素里面必然不会有中位数，那么我们就可以把它舍去。\n\n（3）那么会不会两个数组都不存在第k/2个元素，在这道题里面是不可能的，因为k是m+n的中间值，所以至少也会有一个数组中有第k/2个元素。\n\n（4）最后就是二分法的核心，而是递归的重点。我们比较两个数组的第k/2小的元素值mid1和mid2，如果nums1的mid1小的话，那么说明中位数肯定不住nums1数组的前k/2中，我们就可以把第一个数组的前k/2个数字淘汰，将nums1的起始位置i向后移动k/2个，并且让k也减去k/2，调用递归。反之，如果是nums2的mid2小的话，那么我们就淘汰nums2的前k/2个元素，并且让k减去k/2，调用递归。\n\n```java\n	/**\n	 * 第二种解法：二分查找法\n	 * \n	 * @param nums1\n	 * @param nums2\n	 * @return\n	 */\n	public static double findMedianSortedArrays2(int[] nums1, int[] nums2) {\n		int m = nums1.length;\n		int n = nums2.length;\n		int left = (m + n + 1) / 2;\n		int right = (m + n + 2) / 2;\n		return (find(nums1, 0, nums2, 0, left) + find(nums1, 0, nums2, 0, right)) / 2.0;\n	}\n\n	/**\n	 * 在nums1和nums2中找出第k小的元素\n	 * \n	 * @param nums1 nums1数组\n	 * @param i     nums1数组的起始位置\n	 * @param nums2 nums2数组\n	 * @param j     nums2数组的起始位置\n	 * @param k     需要找到的元素的序号\n	 * @return 第k小的元素值\n	 */\n	public static int find(int[] nums1, int i, int[] nums2, int j, int k) {\n		if (i >= nums1.length)\n			return nums2[j + k - 1]; // nums1数组全部被舍弃\n		if (j >= nums2.length)\n			return nums1[i + k - 1]; // nums2数组全部被舍弃\n		// 当k = 1 的时候，两个数组的布局基本相同，最后只需要找到\n		if (k == 1) {\n			return Math.min(nums1[i], nums2[j]);\n		}\n\n		/*\n		 * 分别找到两个数组中的第k/2位置的元素，如果不存在就给他赋最大值， 比较两个值，值小的数组则淘汰其前k/2个元素 最后把k也减去k/2，继续递归\n		 */\n		int mid1 = (i + k / 2 - 1 < nums1.length) ? nums1[i + k / 2 - 1] : Integer.MAX_VALUE;\n		int mid2 = (j + k / 2 - 1 < nums2.length) ? nums2[j + k / 2 - 1] : Integer.MAX_VALUE;\n		if (mid1 < mid2) {\n			return find(nums1, i + k / 2, nums2, j, k - k / 2);\n		} else {\n			return find(nums1, i, nums2, j + k / 2, k - k / 2);\n		}\n\n	}\n```\n\n\n\n# 测试类\n\n```java\npackage com.company.project.hot100;\n\nimport java.util.Arrays;\n\n/**\n * 4. 寻找两个有序数组的中位数 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n * \n * 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n * \n * 你可以假设 nums1 和 nums2 不会同时为空。\n * \n * 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0\n * \n * 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5\n * \n * @author God_86\n *\n */\npublic class Question04 {\n	/**\n	 * 第一种解法：合并数组排序，找到中位数\n	 * \n	 * @param nums1\n	 * @param nums2\n	 * @return\n	 */\n	public static double findMedianSortedArrays(int[] nums1, int[] nums2) {\n		int[] result = Arrays.copyOf(nums1, nums1.length + nums2.length);\n\n		/**\n		 * 将一个数组片段复制到另一个数组的指定位置 System.arraycopy(src, srcPos, dest, destPos, length)\n		 * src: 源数组 srcPos: 从源数组复制数据的起始位置 dest: 目标数组 destPos: 复制到目标数组的起始位置 length: 复制的长度\n		 */\n		System.arraycopy(nums2, 0, result, nums1.length, nums2.length);\n		Arrays.sort(result);\n		double d = (double) (result[(nums1.length + nums2.length - 1) / 2] + result[(nums1.length + nums2.length) / 2])\n				/ 2;\n\n		return d;\n	}\n\n	/**\n	 * 第二种解法：和第一种一样，不过利用位运算，可以优化计算\n	 * \n	 * @param nums1\n	 * @param nums2\n	 * @return\n	 */\n	public static double findMedianSortedArrays2(int[] nums1, int[] nums2) {\n		if (nums1.length < 2 && nums2.length < 2) {\n			if (nums1.length == 0) {\n				return (double) nums2[0];\n			} else if (nums2.length == 0) {\n				return (double) nums1[0];\n			}\n			return (double) (nums1[0] + nums2[0]) / 2;\n		}\n		int[] result = Arrays.copyOf(nums1, nums1.length + nums2.length);\n		/**\n		 * 将一个数组片段复制到另一个数组的指定位置 System.arraycopy(src, srcPos, dest, destPos, length)\n		 * src: 源数组 srcPos: 从源数组复制数据的起始位置 dest: 目标数组 destPos: 复制到目标数组的起始位置 length: 复制的长度\n		 */\n		System.arraycopy(nums2, 0, result, nums1.length, nums2.length);\n		Arrays.sort(result);\n		int mid = result.length >> 1;\n		if ((result.length & 1) == 1) {\n			return (double) result[(result.length - 1) >> 1];\n		} else {\n			return (double) (result[mid - 1] + result[mid]) / 2;\n		}\n	}\n\n	/**\n	 * 第三种解法：二分查找法\n	 * \n	 * @param nums1\n	 * @param nums2\n	 * @return\n	 */\n	public static double findMedianSortedArrays3(int[] nums1, int[] nums2) {\n		int m = nums1.length;\n		int n = nums2.length;\n		int left = (m + n + 1) / 2;\n		int right = (m + n + 2) / 2;\n		return (find(nums1, 0, nums2, 0, left) + find(nums1, 0, nums2, 0, right)) / 2.0;\n	}\n\n	/**\n	 * 在nums1和nums2中找出第k小的元素\n	 * \n	 * @param nums1 nums1数组\n	 * @param i     nums1数组的起始位置\n	 * @param nums2 nums2数组\n	 * @param j     nums2数组的起始位置\n	 * @param k     需要找到的元素的序号\n	 * @return 第k小的元素值\n	 */\n	public static int find(int[] nums1, int i, int[] nums2, int j, int k) {\n		if (i >= nums1.length)\n			return nums2[j + k - 1]; // nums1数组全部被舍弃\n		if (j >= nums2.length)\n			return nums1[i + k - 1]; // nums2数组全部被舍弃\n		// 当k = 1 的时候，两个数组的布局基本相同，最后只需要找到\n		if (k == 1) {\n			return Math.min(nums1[i], nums2[j]);\n		}\n\n		/*\n		 * 分别找到两个数组中的第k/2位置的元素，如果不存在就给他赋最大值， 比较两个值，值小的数组则淘汰其前k/2个元素 最后把k也减去k/2，继续递归\n		 */\n		int mid1 = (i + k / 2 - 1 < nums1.length) ? nums1[i + k / 2 - 1] : Integer.MAX_VALUE;\n		int mid2 = (j + k / 2 - 1 < nums2.length) ? nums2[j + k / 2 - 1] : Integer.MAX_VALUE;\n		if (mid1 < mid2) {\n			return find(nums1, i + k / 2, nums2, j, k - k / 2);\n		} else {\n			return find(nums1, i, nums2, j + k / 2, k - k / 2);\n		}\n\n	}\n\n	public static void main(String[] args) {\n		int[] nums1 = { 9, 10, 11, 12, 13, 14 };\n		int[] nums2 = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21 };\n//		int[] nums1 = { 1 };\n//		int[] nums2 = { 2 };\n\n		System.out.println(findMedianSortedArrays3(nums1, nums2));\n\n	}\n}\n\n```\n\n', 0, 0, '2020-08-06 23:17:34', 9, 0, 1, '题目描述给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n你可以假设 nums1 和 nums2 不会同时为空。\n示例 1:\nnums1 = [1, 3]nums2 = [2]则中位数是 2.0示例 2:\nnums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5解法一：这道题是求两个有序数组的中位数，如果不限制时间复杂度的话，那么这道题将会无比简单。\n把长度为m和长度为n的两个数组的数据放在一个新的数组中，然后对数组进行排序，找到中位数。\n找中位数的时候，因为组合后的数组元素个数(m + n)的奇偶性不确定，如果是奇数的话，那么中位数就是第（m+n）/ 2 个元素，如果是偶数的话，那么中位数就是第（m + n ）/ 2 个元素和第（m + n）/ 2 + 1个。\n我们可以利用int整型向下取整的特点，把上面两种情况归结为一种通用的解法，我们可以找到下标（m + n - 1）/ 2和下标（m + n ）/ 2元素，然后求两数的平均值。\n    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {        int [] result = Arrays.copyOf(nums1, nums1.length + nums2.length);        /**将一个数组片段复制到另一个数组的指定位置         * System.arraycopy(src, srcPos, dest, destPos, length)         * src: 源数组         * srcPos: 从源数组复制数据的起始位置         * dest: 目标数组         * destPos: 复制到目标数组的起始位置         * length: 复制的长度         */        System.arraycopy(nums2, 0, result, nums1.length, nums2.length);                Arrays.sort(result);        double d = (double)(result[(nums1.length + nums2.length -1)/2] + result[(nums1.length + nums2.length )/2])/2;        return d;    }\n执行用时 :4 ms, 在所有 Java 提交中击败了31.34%的用户\n内存消耗 :42.2 MB, 在所有 Java 提交中击败了96.67%的用户\n上述的关键代码虽然只有4行，但是在时间复杂度上是不满足题目要求的。\n解法二：看见时间复杂度的限制O(log(m+n))，肯定要用二分查找法来解决，其次，中位数的应在的位置依旧按照解法一的方法，不过这次我们不合并数组了，这样会增加时间复杂度。\n找中位数的时候，因为两个数组的元素个数之和(m + n)的奇偶性不确定，如果是奇数的话，那么中位数就是第（m+n）/ 2 个元素，如果是偶数的话，那么中位数就是第（m + n +1 ）/ 2 个元素和第（m + n +2）/ 2 个。\n下来我们着重看看，如何在两个有序数组中找到第k个元素：\n首先，我们利用i和j分别标记数组nums1和 nums2的起始位置，\n此次我们处理一些边界问题：\n（1）当一个数组的起始位置大于等于该数组的长度，表明该数组所有的数字都已经被淘汰了，相当于空数组，那么我们只需要继续在另一个数组里面找，直接可以找出来。\n（2）当k = 1的时候，我们只需要比较两个有序数组的起始位置i和j 的数字就好。\n难点在于如何处理一般情况？\n为了加快搜索速度，我们使用二分法：\n（1）我们可以先对k二分，意思就是去找到nums1和nums2的第k/2个数字。\n（2）因为两个数字的长度不定，所有我们需要先判断一下两个数组是否都含有第k/2个数字，如果存在就取出来，如果不存在就给它赋一个最大值，赋最大值的原因是：我们后面会通过比较两个数组中取出来的数字，如果小的那个数组，那么前k/2个元素里面必然不会有中位数，那么我们就可以把它舍去。\n（3）那么会不会两个数组都不存在第k/2个元素，在这道题里面是不可能的，因为k是m+n的中间值，所以至少也会有一个数组中有第k/2个元素。\n（4）最后就是二分法的核心，而是递归的重点。我们比较两个数组的第k/2小的元素值mid1和mid2，如果nums1的mid1小的话，那么说明中位数肯定不住nums1数组的前k/2中，我们就可以把第一个数组的前k/2个数字淘汰，将nums1的起始位置i向后移动k/2个，并且让k也减去k/2，调用递归。反之，如果是nums2的mid2小的话，那么我们就淘汰nums2的前k/2个元素，并且让k减去k/2，调用递归。\n    /**     * 第二种解法：二分查找法     *      * @param nums1     * @param nums2     * @return     */    public static double findMedianSortedArrays2(int[] nums1, int[] nums2) {        int m = nums1.length;        int n = nums2.length;        int left = (m + n + 1) / 2;        int right = (m + n + 2) / 2;        return (find(nums1, 0, nums2, 0, left) + find(nums1, 0, nums2, 0, right)) / 2.0;    }    /**     * 在nums1和nums2中找出第k小的元素     *      * @param nums1 nums1数组     * @param i     nums1数组的起始位置     * @param nums2 nums2数组     * @param j     nums2数组的起始位置     * @param k     需要找到的元素的序号     * @return 第k小的元素值     */    public static int find(int[] nums1, int i, int[] nums2, int j, int k) {        if (i >= nums1.length)            return nums2[j + k - 1]; // nums1数组全部被舍弃        if (j >= nums2.length)            return nums1[i + k - 1]; // nums2数组全部被舍弃        // 当k = 1 的时候，两个数组的布局基本相同，最后只需要找到        if (k == 1) {            return Math.min(nums1[i], nums2[j]);        }        /*         * 分别找到两个数组中的第k/2位置的元素，如果不存在就给他赋最大值， 比较两个值，值小的数组则淘汰其前k/2个元素 最后把k也减去k/2，继续递归         */        int mid1 = (i + k / 2 - 1 < nums1.length) ? nums1[i + k / 2 - 1] : Integer.MAX_VALUE;        int mid2 = (j + k / 2 - 1 < nums2.length) ? nums2[j + k / 2 - 1] : Integer.MAX_VALUE;        if (mid1 < mid2) {            return find(nums1, i + k / 2, nums2, j, k - k / 2);        } else {            return find(nums1, i, nums2, j + k / 2, k - k / 2);        }    }\n测试类package com.company.project.hot100;import java.util.Arrays;/** * 4. 寻找两个有序数组的中位数 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 *  * 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 *  * 你可以假设 nums1 和 nums2 不会同时为空。 *  * 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 *  * 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 *  * @author God_86 * */public class Question04 {    /**     * 第一种解法：合并数组排序，找到中位数     *      * @param nums1     * @param nums2     * @return     */    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {        int[] result = Arrays.copyOf(nums1, nums1.length + nums2.length);        /**         * 将一个数组片段复制到另一个数组的指定位置 System.arraycopy(src, srcPos, dest, destPos, length)         * src: 源数组 srcPos: 从源数组复制数据的起始位置 dest: 目标数组 destPos: 复制到目标数组的起始位置 length: 复制的长度         */        System.arraycopy(nums2, 0, result, nums1.length, nums2.length);        Arrays.sort(result);        double d = (double) (result[(nums1.length + nums2.length - 1) / 2] + result[(nums1.length + nums2.length) / 2])                / 2;        return d;    }    /**     * 第二种解法：和第一种一样，不过利用位运算，可以优化计算     *      * @param nums1     * @param nums2     * @return     */    public static double findMedianSortedArrays2(int[] nums1, int[] nums2) {        if (nums1.length < 2 && nums2.length < 2) {            if (nums1.length == 0) {                return (double) nums2[0];            } else if (nums2.length == 0) {                return (double) nums1[0];            }            return (double) (nums1[0] + nums2[0]) / 2;        }        int[] result = Arrays.copyOf(nums1, nums1.length + nums2.length);        /**         * 将一个数组片段复制到另一个数组的指定位置 System.arraycopy(src, srcPos, dest, destPos, length)         * src: 源数组 srcPos: 从源数组复制数据的起始位置 dest: 目标数组 destPos: 复制到目标数组的起始位置 length: 复制的长度         */        System.arraycopy(nums2, 0, result, nums1.length, nums2.length);        Arrays.sort(result);        int mid = result.length >> 1;        if ((result.length & 1) == 1) {            return (double) result[(result.length - 1) >> 1];        } else {            return (double) (result[mid - 1] + result[mid]) / 2;        }    }    /**     * 第三种解法：二分查找法     *      * @param nums1     * @param nums2     * @return     */    public static double findMedianSortedArrays3(int[] nums1, int[] nums2) {        int m = nums1.length;        int n = nums2.length;        int left = (m + n + 1) / 2;        int right = (m + n + 2) / 2;        return (find(nums1, 0, nums2, 0, left) + find(nums1, 0, nums2, 0, right)) / 2.0;    }    /**     * 在nums1和nums2中找出第k小的元素     *      * @param nums1 nums1数组     * @param i     nums1数组的起始位置     * @param nums2 nums2数组     * @param j     nums2数组的起始位置     * @param k     需要找到的元素的序号     * @return 第k小的元素值     */    public static int find(int[] nums1, int i, int[] nums2, int j, int k) {        if (i >= nums1.length)            return nums2[j + k - 1]; // nums1数组全部被舍弃        if (j >= nums2.length)            return nums1[i + k - 1]; // nums2数组全部被舍弃        // 当k = 1 的时候，两个数组的布局基本相同，最后只需要找到        if (k == 1) {            return Math.min(nums1[i], nums2[j]);        }        /*         * 分别找到两个数组中的第k/2位置的元素，如果不存在就给他赋最大值， 比较两个值，值小的数组则淘汰其前k/2个元素 最后把k也减去k/2，继续递归         */        int mid1 = (i + k / 2 - 1 < nums1.length) ? nums1[i + k / 2 - 1] : Integer.MAX_VALUE;        int mid2 = (j + k / 2 - 1 < nums2.length) ? nums2[j + k / 2 - 1] : Integer.MAX_VALUE;        if (mid1 < mid2) {            return find(nums1, i + k / 2, nums2, j, k - k / 2);        } else {            return find(nums1, i, nums2, j + k / 2, k - k / 2);        }    }    public static void main(String[] args) {        int[] nums1 = { 9, 10, 11, 12, 13, 14 };        int[] nums2 = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21 };//        int[] nums1 = { 1 };//        int[] nums2 = { 2 };        System.out.println(findMedianSortedArrays3(nums1, nums2));    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (63, '05.最长回文子串', 8, '最长回文子串\n\n## 问题引入：\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n\n\n> 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。\n\n\n\n> 示例 2： 输入: \"cbbd\" 输出: \"bb\"\n\n## 1. 方法一：暴力法\n\n**思路：列举所有的子串，找到最长的回文串**\n\n时间复杂度：O(n^3),两次for循环，判断是否回文还有一次for循环\n\n空间复杂度：O(1)\n\n```java\npublic String longestPalindrome1(String s) {\n		String ans = \"\";\n		for (int i = 0; i < s.length(); i++) {\n			for (int j = i + 1; j <= s.length(); j++) {\n				String test = s.substring(i, j);\n				if (isPalindrome(test) && test.length() > ans.length()) {\n					ans = test;\n				}\n			}\n		}\n		return ans;\n	}\n\n	public boolean isPalindrome(String test) {\n		for (int i = 0; i < test.length() / 2; i++) {\n			if (test.charAt(i) != test.charAt(test.length() - 1 - i)) {\n				return false;\n			}\n		}\n		return true;\n	}\n```\n\n## 2. 方法二：中心扩展算法\n\n**思路：先找到中心点，然后分别向左右两边检测，直到遍历完所有的中心点，找到最大的回文字符字串 中心点共有2n-1个，其中有两种情况， 一种子串是奇数个字符，中心点为中间的数， 另一种是子串有偶数个字符，中间点就是中间两个数间的间隙 所以，n个数，n-1个间隙，总共2n-1个中心点**\n\n- 时间复杂度:O(n^2)\n- 空间复杂度:O(1)\n\n```java\n	public String longestPalindrome3(String s) {\n		if (s == null || s.length() == 0)\n			return \"\";\n		int start = 0, end = 0;\n		for (int i = 0; i < s.length(); i++) {\n			int len1 = nowLongest(s, i, i);\n			int len2 = nowLongest(s, i, i + 1);\n			int len = Math.max(len1, len2);\n			if (len > end - start) {\n				start = i - (len - 1) / 2;\n				end = i + len / 2;\n			}\n		}\n		return s.substring(start, end + 1);\n	}\n\n	public int nowLongest(String s, int left, int right) {\n		while (left >= 0 && right < s.length() && s.charAt(right) == s.charAt(left)) {\n			left--;\n			right++;\n		}\n		return right - left - 1;\n	}\n```\n\n## 3. 方法三：最长公共子串\n\n**算法思路：我们可以根据回文串的特点，左右对称的特点，我们可以再定义一个字符串存放原字符串的倒置字符串reverse,然后比较两个字符串找到最长公共子串，该公共子串就是该字符串的最长回文串。**\n\n但是，会有特殊情况，比如abc123cba，他的倒置字符串是abc123cba，最长公共子串为abc（或cba），\n\n我们会发现并不是正确答案，所以我们的算法还需要加个判断条件， 我们需要**判断倒置前的下标是否和倒置后的下标匹配**，即是否是同一位置的元素。\n\n找到一个字符倒置前的下标很简单，比如该字符下标为j，那么before = length - 1 - j;\n\n比如我们用i指向原字符串子串的末尾字符，用j指向倒置字符串子串的末尾字符， j倒置前的位置下标before_j = length - 1 - j；\n\n如果before_ j + maxson.len -1 == i，那么说明它就是我们要找的回文串。\n\n\n\n分析完思路，我们再来看看**最长公共子串如何求解**？ 这个有很多种方法，我们就有**动态规划法**解决。\n\n### 思路：\n\n- 申请一个二维的数组arr[len][len]，把每个元素初始化为0。\n- 写个双重循环遍历二维数组，其中i表示原字符串s的下标，j表示倒置字符串reverse的下标.\n- 然后判断对应的字符是否相等，及判断s.charAt(i)==reverse.charAt(j) 相等的话， arr[i][j] =arr[i-1][j-1] + 1。\n- 其中i=0或j=0的情况单独分析，如果字符相等的话直接赋值arr[i][j]=1.\n- 最后arr[i][j]里面就是保存着公共子串的长度，该公共子串就是以i结尾的，我们用 ![[公式]](https://www.zhihu.com/equation?tex=i-arr%5Bi%5D%5Bj%5D-1) 就可以找到子串开始的下标，\n- 再截取原字符串就可以得到最长公共子序列。\n\n\n\n时间复杂度：O(n^2)	两层for循环\n\n空间复杂度：O(n^2) 一个二维数组\n\n```java\n	public String longestPalindrome4(String s) {\n		if (s.equals(\"\"))\n			return \"\";\n		String reverse = new StringBuffer(s).reverse().toString();\n		int len = s.length();\n		int[][] arr = new int[len][len];     //arr[i][j] 存放着公共子串的长度\n		int maxlen = 0, maxEnd = 0;\n		for (int i = 0; i < len; i++) {\n			for (int j = 0; j < len; j++) {\n				if(s.charAt(i) == reverse.charAt(j)) {\n					if( i == 0 || j == 0) {\n						arr[i][j] = 1;\n					}\n					else {\n						arr[i][j] = arr[i-1][j-1]+1;\n					}\n				}\n				if(arr[i][j] > maxlen) {\n					//j是当前倒置字符串的子串的末尾下标，i是当前原子串的末尾下标，before是j在原字符串对应下标\n					int before = len - 1 - j;    \n					\n					//判断字符下标是否对应\n					if(before + arr[i][j] - 1 == i) {\n						maxlen = arr[i][j];     \n						maxEnd = i;       //i为当前子串的末尾字符\n					}\n					\n				}\n			}\n		}\n		//substring(i,j)截取从下标i到j-1的子串\n		return s.substring(maxEnd - maxlen + 1,maxEnd +1); \n	}\n```\n\n## 4. 方法四：优化后的最长公共子串\n\n特点：可以将空间复杂度降至O(n)\n\n**思路：**\n\n我们发现上述的动态规划法，用二维数组，其实每次都是一列一列更新，\n\n\\* i = 1,j=0,1,2,3……\n\n\\* i = 2,j=0,1,2,3……\n\n\\* i = 3,j=0,1,2,3……\n\n\\* ……………\n\n我们每次更新数据，用到的公式arr[i][j] = arr[i-1][j-1]+1;\n\n发现，其实只需要前一列的信息，更新第三列的时候，只用到第二列的数据，第一列就没有用了，\n\n所以我们用一个一维数组就可以了，arr[j]代表当前列的元素的最长公共子串长度\n\n但是更新每一列的时候，我们会用到这一列上一个元素的值，比如arr[i] = arr[i-1]+1\n\n所以，在遍历j的时候不能从0到len-1，而是从len-1到0遍历。\n\n```java\npublic String longestPalindrome5(String s) {\n		if (s.equals(\"\"))\n			return \"\";\n		\n		String reverse = new StringBuffer(s).reverse().toString();\n		int length = s.length();\n		int[] arr = new int[length];\n		int maxLen = 0;\n		int maxEnd = 0;\n		for (int i = 0; i < length; i++)\n			/************** 修改的地方 ***************************/\n			for (int j = length - 1; j >= 0; j--) {\n				/**************************************************/\n				if (s.charAt(i) == reverse.charAt(j)) {\n					if (i == 0 || j == 0) {\n						arr[j] = 1;\n					} else {\n						arr[j] = arr[j - 1] + 1;\n					}\n					/************** 修改的地方 ***************************/\n					// 之前二维数组，每次用的是不同的列，所以不用置 0 。\n				} else {\n					arr[j] = 0;\n				}\n				/**************************************************/\n				if (arr[j] > maxLen) {\n					int beforeRev = length - 1 - j;\n					if (beforeRev + arr[j] - 1 == i) {\n						maxLen = arr[j];\n						maxEnd = i;\n					}\n\n				}\n			}\n		return s.substring(maxEnd - maxLen + 1, maxEnd + 1);\n	}\n```', 0, 0, '2020-08-06 23:18:34', 0, 0, 1, '最长回文子串\n问题引入：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1： 输入: “babad” 输出: “bab” 注意: “aba” 也是一个有效答案。\n示例 2： 输入: “cbbd” 输出: “bb”\n\n1. 方法一：暴力法思路：列举所有的子串，找到最长的回文串\n时间复杂度：O(n^3),两次for循环，判断是否回文还有一次for循环\n空间复杂度：O(1)\npublic String longestPalindrome1(String s) {        String ans = \"\";        for (int i = 0; i < s.length(); i++) {            for (int j = i + 1; j <= s.length(); j++) {                String test = s.substring(i, j);                if (isPalindrome(test) && test.length() > ans.length()) {                    ans = test;                }            }        }        return ans;    }    public boolean isPalindrome(String test) {        for (int i = 0; i < test.length() / 2; i++) {            if (test.charAt(i) != test.charAt(test.length() - 1 - i)) {                return false;            }        }        return true;    }\n2. 方法二：中心扩展算法思路：先找到中心点，然后分别向左右两边检测，直到遍历完所有的中心点，找到最大的回文字符字串 中心点共有2n-1个，其中有两种情况， 一种子串是奇数个字符，中心点为中间的数， 另一种是子串有偶数个字符，中间点就是中间两个数间的间隙 所以，n个数，n-1个间隙，总共2n-1个中心点\n\n时间复杂度:O(n^2)空间复杂度:O(1)\n    public String longestPalindrome3(String s) {        if (s == null || s.length() == 0)            return \"\";        int start = 0, end = 0;        for (int i = 0; i < s.length(); i++) {            int len1 = nowLongest(s, i, i);            int len2 = nowLongest(s, i, i + 1);            int len = Math.max(len1, len2);            if (len > end - start) {                start = i - (len - 1) / 2;                end = i + len / 2;            }        }        return s.substring(start, end + 1);    }    public int nowLongest(String s, int left, int right) {        while (left >= 0 && right < s.length() && s.charAt(right) == s.charAt(left)) {            left--;            right++;        }        return right - left - 1;    }\n3. 方法三：最长公共子串算法思路：我们可以根据回文串的特点，左右对称的特点，我们可以再定义一个字符串存放原字符串的倒置字符串reverse,然后比较两个字符串找到最长公共子串，该公共子串就是该字符串的最长回文串。\n但是，会有特殊情况，比如abc123cba，他的倒置字符串是abc123cba，最长公共子串为abc（或cba），\n我们会发现并不是正确答案，所以我们的算法还需要加个判断条件， 我们需要判断倒置前的下标是否和倒置后的下标匹配，即是否是同一位置的元素。\n找到一个字符倒置前的下标很简单，比如该字符下标为j，那么before = length - 1 - j;\n比如我们用i指向原字符串子串的末尾字符，用j指向倒置字符串子串的末尾字符， j倒置前的位置下标before_j = length - 1 - j；\n如果before_ j + maxson.len -1 == i，那么说明它就是我们要找的回文串。\n分析完思路，我们再来看看最长公共子串如何求解？ 这个有很多种方法，我们就有动态规划法解决。\n思路：\n申请一个二维的数组arr[len][len]，把每个元素初始化为0。写个双重循环遍历二维数组，其中i表示原字符串s的下标，j表示倒置字符串reverse的下标.然后判断对应的字符是否相等，及判断s.charAt(i)==reverse.charAt(j) 相等的话， arr[i][j] =arr[i-1][j-1] + 1。其中i=0或j=0的情况单独分析，如果字符相等的话直接赋值arr[i][j]=1.最后arr[i][j]里面就是保存着公共子串的长度，该公共子串就是以i结尾的，我们用  就可以找到子串开始的下标，再截取原字符串就可以得到最长公共子序列。\n时间复杂度：O(n^2)    两层for循环\n空间复杂度：O(n^2) 一个二维数组\n    public String longestPalindrome4(String s) {        if (s.equals(\"\"))            return \"\";        String reverse = new StringBuffer(s).reverse().toString();        int len = s.length();        int[][] arr = new int[len][len];     //arr[i][j] 存放着公共子串的长度        int maxlen = 0, maxEnd = 0;        for (int i = 0; i < len; i++) {            for (int j = 0; j < len; j++) {                if(s.charAt(i) == reverse.charAt(j)) {                    if( i == 0 || j == 0) {                        arr[i][j] = 1;                    }                    else {                        arr[i][j] = arr[i-1][j-1]+1;                    }                }                if(arr[i][j] > maxlen) {                    //j是当前倒置字符串的子串的末尾下标，i是当前原子串的末尾下标，before是j在原字符串对应下标                    int before = len - 1 - j;                        //判断字符下标是否对应                    if(before + arr[i][j] - 1 == i) {                        maxlen = arr[i][j];                             maxEnd = i;       //i为当前子串的末尾字符                    }                }            }        }        //substring(i,j)截取从下标i到j-1的子串        return s.substring(maxEnd - maxlen + 1,maxEnd +1);     }\n4. 方法四：优化后的最长公共子串特点：可以将空间复杂度降至O(n)\n思路：\n我们发现上述的动态规划法，用二维数组，其实每次都是一列一列更新，\n* i = 1,j=0,1,2,3……\n* i = 2,j=0,1,2,3……\n* i = 3,j=0,1,2,3……\n* ……………\n我们每次更新数据，用到的公式arr[i][j] = arr[i-1][j-1]+1;\n发现，其实只需要前一列的信息，更新第三列的时候，只用到第二列的数据，第一列就没有用了，\n所以我们用一个一维数组就可以了，arr[j]代表当前列的元素的最长公共子串长度\n但是更新每一列的时候，我们会用到这一列上一个元素的值，比如arr[i] = arr[i-1]+1\n所以，在遍历j的时候不能从0到len-1，而是从len-1到0遍历。\npublic String longestPalindrome5(String s) {        if (s.equals(\"\"))            return \"\";        String reverse = new StringBuffer(s).reverse().toString();        int length = s.length();        int[] arr = new int[length];        int maxLen = 0;        int maxEnd = 0;        for (int i = 0; i < length; i++)            /************** 修改的地方 ***************************/            for (int j = length - 1; j >= 0; j--) {                /**************************************************/                if (s.charAt(i) == reverse.charAt(j)) {                    if (i == 0 || j == 0) {                        arr[j] = 1;                    } else {                        arr[j] = arr[j - 1] + 1;                    }                    /************** 修改的地方 ***************************/                    // 之前二维数组，每次用的是不同的列，所以不用置 0 。                } else {                    arr[j] = 0;                }                /**************************************************/                if (arr[j] > maxLen) {                    int beforeRev = length - 1 - j;                    if (beforeRev + arr[j] - 1 == i) {                        maxLen = arr[j];                        maxEnd = i;                    }                }            }        return s.substring(maxEnd - maxLen + 1, maxEnd + 1);    }\n', 0, 1);
INSERT INTO `t_article` VALUES (64, '06. Z字形变换（难度：中等）', 8, '## 问题描述\n\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 `\"LEETCODEISHIRING\"` 行数为 3 时，排列如下：\n\n```\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n```\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`\"LCIRETOESIIGEDHN\"`。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\n```\nstring convert(string s, int numRows);\n```\n\n**示例 1:**\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 3\n输出: \"LCIRETOESIIGEDHN\"\n```\n\n**示例 2:**\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 4\n输出: \"LDREOEIIECIHNTSG\"\n解释:\n\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n```\n\n\n\n## 解法一：利用周期特性\n\n根据z字排列的特性，发现字符串成周期排列，周期为2 * numRows -2，\n发现第n行的元素，为每个周期的第i个或者第（周期-i）个\n\n```java\n	public static String convert1(String s, int numRows) {\n		if(numRows == 1) return s;\n		int len = s.length();\n		int cycle = 2 * numRows -2;\n		StringBuilder sBuffer = new StringBuilder(len);\n		for (int i = 0; i < numRows; i++) {\n			for (int j = 0; j < len; j++) {\n				if (j % cycle == i || j % cycle == (cycle - i)) {\n					sBuffer.append(s.charAt(j));\n				}\n			}\n		}		\n		return sBuffer.toString();\n	}\n```\n\n时间复杂度：O(n)，其中 n == len（s）* numRows。每个索引被访问 numRows 次。\n空间复杂度：O(n)。创建了一个 len（s）大小的StringBuilder。\n\n\n\n## 解法二：第一种解法的升级\n\n去掉了跳过了许多没必要的检测，省去了大量的时间\n\n算法：\n\n每次一行一行访问，对于第k个周期：\n\n- 首先，先对边界行，做出判断：\n  - 第0行字符位于 k * ( 2 * numRows - 2 ) 处\n  - 第numRows - 1 行中字符位于索引 k * （ 2 * numRows -2 ）+numRow - 1\n- 其次，处理中间一般行：\n  - 第i行中的字符位于索引 k * （ 2 * numRows  - 2 ）+ i 以及（ k + 1）*（2 * numRows - 2 ）- i 处 \n\n```java\n	public static String convert2(String s, int numRows) {\n		if(numRows == 1) return s;\n		int len = s.length();\n		int cycle = 2 * numRows -2;\n		StringBuilder sBuilder = new StringBuilder(len);\n		for (int i = 0; i < numRows; i++) {\n            for (int j = 0; j + i < len; j += cycle) {\n            	sBuilder.append(s.charAt(j + i));\n                if (i != 0 && i != numRows - 1 && j + cycle - i < len)\n                	sBuilder.append(s.charAt(j + cycle - i));\n            }\n        }\n		return sBuilder.toString();\n	}\n```\n\n\n\n## 解法三：按行排序\n\n**思路：**\n\n遍历字符串，判断确定字符属于Z字形的哪一行，然后放在对于的行。\n\n**算法：**\n\n我们可以遍历一遍字符串，可以使用当前行和当前方向两个变量来对合适的行进行跟踪。\n\n只有当我们向上移动到最上面或者向下移动到最下面时，才会更改方向。\n\n![Z字排列](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/Z字排列.png)\n\n```java\npublic static String convert3(String s, int numRows) {\n	if(numRows == 1) return s;\n	\n	List<StringBuilder> rows = new ArrayList<>();\n	\n	//创建结果行集合（每行元素按照StringBuilder存放）\n	for(int i = 0; i<Math.min(numRows, s.length());i++) {\n		rows.add(new StringBuilder());\n	}\n	\n	//当前行序号\n	int curRow = 0;\n	\n	//direction 为方向，false 为向上，true为向下。\n	boolean direction = false;\n	\n	for (char c : s.toCharArray()) {\n		rows.get(curRow).append(c);\n		if(curRow == 0 || curRow == numRows -1 ) {\n			direction = !direction;\n		}\n		//direction为true表示向下，false表示向上\n		curRow += direction ? 1 : -1;\n	}\n			\n	StringBuffer result = new StringBuffer();\n	for (StringBuilder row : rows) {\n		result.append(row);\n	}\n	return result.toString();		\n}\n```\n\n\n\n测试类：\n\n```java\npackage com.company.project.hot100;\n\nimport java.util.List;\nimport java.util.ArrayList;\n\n/*\n * 6. Z 字形变换\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下：\n\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\nstring convert(string s, int numRows);\n示例 1:\n\n输入: s = \"LEETCODEISHIRING\", numRows = 3\n输出: \"LCIRETOESIIGEDHN\"\n示例 2:\n\n输入: s = \"LEETCODEISHIRING\", numRows = 4\n输出: \"LDREOEIIECIHNTSG\"\n解释:\n\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n */\npublic class Question06 {\n\n	/**\n	 *  解法一：利用周期特性\n	 * 根据z字排列的特性，发现字符串成周期排列，周期为2 * numRows -2，\n	 * 发现第n行的元素，为每个周期的第i个或者第（周期-i）个\n	 * @param s\n	 * @param numRows\n	 * @return\n	 */\n	public static String convert1(String s, int numRows) {\n		if(numRows == 1) return s;\n		int len = s.length();\n		int cycle = 2 * numRows -2;\n		StringBuilder sBuilder = new StringBuilder(len);\n		for (int i = 0; i < numRows; i++) {\n			for (int j = 0; j < len; j++) {\n				if (j % cycle == i || j % cycle == (cycle - i)) {\n					sBuilder.append(s.charAt(j));\n				}\n			}\n		}		\n		return sBuilder.toString();\n	}\n\n	\n	/**\n	 * 解法二：第一种解法的升级\n	 * 去掉了跳过了许多没必要的检测，省去了大量的时间\n	 * \n	 * 算法：\n	 * \n	 * @param s\n	 * @param numRows\n	 * @return\n	 */\n	public static String convert2(String s, int numRows) {\n		if(numRows == 1) return s;\n		int len = s.length();\n		int cycle = 2 * numRows -2;\n		StringBuilder sBuilder = new StringBuilder(len);\n		for (int i = 0; i < numRows; i++) {\n            for (int j = 0; j + i < len; j += cycle) {\n            	sBuilder.append(s.charAt(j + i));\n                if (i != 0 && i != numRows - 1 && j + cycle - i < len)\n                	sBuilder.append(s.charAt(j + cycle - i));\n            }\n        }\n		return sBuilder.toString();\n	}\n	\n	/**\n	 * 解法三：按行分组\n	 * 我们可以遍历一遍字符串，可以使用当前行和当前方向两个变量来对合适的行进行跟踪。\n	 * 只有当我们向上移动到最上面或者向下移动到最下面时，才会更改方向。\n	 * @param s\n	 * @param numRows\n	 * @return\n	 */\n	public static String convert3(String s, int numRows) {\n		if(numRows == 1) return s;\n		\n		List<StringBuilder> rows = new ArrayList<>();\n		\n		//创建结果行集合（每行元素按照StringBuilder存放）\n		for(int i = 0; i<Math.min(numRows, s.length());i++) {\n			rows.add(new StringBuilder());\n		}\n		\n		//当前行序号\n		int curRow = 0;\n		\n		//direction 为方向，false 为向上，true为向下。\n		boolean direction = false;\n		\n		for (char c : s.toCharArray()) {\n			rows.get(curRow).append(c);\n			if(curRow == 0 || curRow == numRows -1 ) {\n				direction = !direction;\n			}\n			//direction为true表示向下，false表示向上\n			curRow += direction ? 1 : -1;\n		}\n				\n		StringBuffer result = new StringBuffer();\n		for (StringBuilder row : rows) {\n			result.append(row);\n		}\n		return result.toString();		\n	}\n	\n	\n	public static void main(String[] args) {\n		String s = \"LEETCODEISHIRING\";\n		int numRows = 4;\n		System.out.println(convert3(s, numRows));\n	}\n}\n\n```\n\n', 0, 0, '2020-08-06 23:26:09', 5, 0, 1, '问题描述将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下：\nL   C   I   RE T O E S I I GE   D   H   N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);示例 1:\n输入: s = \"LEETCODEISHIRING\", numRows = 3输出: \"LCIRETOESIIGEDHN\"示例 2:\n输入: s = \"LEETCODEISHIRING\", numRows = 4输出: \"LDREOEIIECIHNTSG\"解释:L     D     RE   O E   I IE C   I H   NT     S     G解法一：利用周期特性根据z字排列的特性，发现字符串成周期排列，周期为2 * numRows -2，发现第n行的元素，为每个周期的第i个或者第（周期-i）个\n    public static String convert1(String s, int numRows) {        if(numRows == 1) return s;        int len = s.length();        int cycle = 2 * numRows -2;        StringBuilder sBuffer = new StringBuilder(len);        for (int i = 0; i < numRows; i++) {            for (int j = 0; j < len; j++) {                if (j % cycle == i || j % cycle == (cycle - i)) {                    sBuffer.append(s.charAt(j));                }            }        }                return sBuffer.toString();    }\n时间复杂度：O(n)，其中 n == len（s）* numRows。每个索引被访问 numRows 次。空间复杂度：O(n)。创建了一个 len（s）大小的StringBuilder。\n解法二：第一种解法的升级去掉了跳过了许多没必要的检测，省去了大量的时间\n算法：\n每次一行一行访问，对于第k个周期：\n\n首先，先对边界行，做出判断：\n第0行字符位于 k  ( 2  numRows - 2 ) 处第numRows - 1 行中字符位于索引 k  （ 2  numRows -2 ）+numRow - 1\n其次，处理中间一般行：\n第i行中的字符位于索引 k  （ 2  numRows  - 2 ）+ i 以及（ k + 1）（2  numRows - 2 ）- i 处 \n\n    public static String convert2(String s, int numRows) {        if(numRows == 1) return s;        int len = s.length();        int cycle = 2 * numRows -2;        StringBuilder sBuilder = new StringBuilder(len);        for (int i = 0; i < numRows; i++) {            for (int j = 0; j + i < len; j += cycle) {                sBuilder.append(s.charAt(j + i));                if (i != 0 && i != numRows - 1 && j + cycle - i < len)                    sBuilder.append(s.charAt(j + cycle - i));            }        }        return sBuilder.toString();    }\n解法三：按行排序思路：\n遍历字符串，判断确定字符属于Z字形的哪一行，然后放在对于的行。\n算法：\n我们可以遍历一遍字符串，可以使用当前行和当前方向两个变量来对合适的行进行跟踪。\n只有当我们向上移动到最上面或者向下移动到最下面时，才会更改方向。\n\npublic static String convert3(String s, int numRows) {    if(numRows == 1) return s;    List<StringBuilder> rows = new ArrayList<>();    //创建结果行集合（每行元素按照StringBuilder存放）    for(int i = 0; i<Math.min(numRows, s.length());i++) {        rows.add(new StringBuilder());    }    //当前行序号    int curRow = 0;    //direction 为方向，false 为向上，true为向下。    boolean direction = false;    for (char c : s.toCharArray()) {        rows.get(curRow).append(c);        if(curRow == 0 || curRow == numRows -1 ) {            direction = !direction;        }        //direction为true表示向下，false表示向上        curRow += direction ? 1 : -1;    }    StringBuffer result = new StringBuffer();    for (StringBuilder row : rows) {        result.append(row);    }    return result.toString();        }\n测试类：\npackage com.company.project.hot100;import java.util.List;import java.util.ArrayList;/* * 6. Z 字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下：L   C   I   RE T O E S I I GE   D   H   N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。请你实现这个将字符串进行指定行数变换的函数：string convert(string s, int numRows);示例 1:输入: s = \"LEETCODEISHIRING\", numRows = 3输出: \"LCIRETOESIIGEDHN\"示例 2:输入: s = \"LEETCODEISHIRING\", numRows = 4输出: \"LDREOEIIECIHNTSG\"解释:L     D     RE   O E   I IE C   I H   NT     S     G */public class Question06 {    /**     *  解法一：利用周期特性     * 根据z字排列的特性，发现字符串成周期排列，周期为2 * numRows -2，     * 发现第n行的元素，为每个周期的第i个或者第（周期-i）个     * @param s     * @param numRows     * @return     */    public static String convert1(String s, int numRows) {        if(numRows == 1) return s;        int len = s.length();        int cycle = 2 * numRows -2;        StringBuilder sBuilder = new StringBuilder(len);        for (int i = 0; i < numRows; i++) {            for (int j = 0; j < len; j++) {                if (j % cycle == i || j % cycle == (cycle - i)) {                    sBuilder.append(s.charAt(j));                }            }        }                return sBuilder.toString();    }    /**     * 解法二：第一种解法的升级     * 去掉了跳过了许多没必要的检测，省去了大量的时间     *      * 算法：     *      * @param s     * @param numRows     * @return     */    public static String convert2(String s, int numRows) {        if(numRows == 1) return s;        int len = s.length();        int cycle = 2 * numRows -2;        StringBuilder sBuilder = new StringBuilder(len);        for (int i = 0; i < numRows; i++) {            for (int j = 0; j + i < len; j += cycle) {                sBuilder.append(s.charAt(j + i));                if (i != 0 && i != numRows - 1 && j + cycle - i < len)                    sBuilder.append(s.charAt(j + cycle - i));            }        }        return sBuilder.toString();    }    /**     * 解法三：按行分组     * 我们可以遍历一遍字符串，可以使用当前行和当前方向两个变量来对合适的行进行跟踪。     * 只有当我们向上移动到最上面或者向下移动到最下面时，才会更改方向。     * @param s     * @param numRows     * @return     */    public static String convert3(String s, int numRows) {        if(numRows == 1) return s;        List<StringBuilder> rows = new ArrayList<>();        //创建结果行集合（每行元素按照StringBuilder存放）        for(int i = 0; i<Math.min(numRows, s.length());i++) {            rows.add(new StringBuilder());        }        //当前行序号        int curRow = 0;        //direction 为方向，false 为向上，true为向下。        boolean direction = false;        for (char c : s.toCharArray()) {            rows.get(curRow).append(c);            if(curRow == 0 || curRow == numRows -1 ) {                direction = !direction;            }            //direction为true表示向下，false表示向上            curRow += direction ? 1 : -1;        }        StringBuffer result = new StringBuffer();        for (StringBuilder row : rows) {            result.append(row);        }        return result.toString();            }    public static void main(String[] args) {        String s = \"LEETCODEISHIRING\";        int numRows = 4;        System.out.println(convert3(s, numRows));    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (65, '7. 整数反转（难度：简单）', 8, '##问题描述\n\n给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n\n**示例 1:**\n\n```\n输入: 123\n输出: 321\n```\n\n **示例 2:**\n\n```\n输入: -123\n输出: -321\n```\n\n**示例 3:**\n\n```\n输入: 120\n输出: 21\n```\n\n**注意:**\n\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n\n\n\n## 解法一：\n\n由于我们有范围限制，只能存储下32位的有符号整数 2^31-1=2147483647,-2^31=-2147483648，\n\n 我们反转整数，会用到n =n * 10 + x%10;x = x/10; 但是n = n * 10 + x%10;很有可能会溢出 我们来判断一下，导致溢出的条件： \n\n（1）如果n > INTMAX/10,那么n = n * 10 + x%10会溢出 \n\n（2）如果 n=INTMAX/10,并且x%10>7,那么n = n * 10 +x%10会溢出 \n\n（3）如果 n<INTMIN/10,那么n = n * 10 + x%10会溢出 \n\n（4）如果n=INTMIN/10,并且x%10<-8,那么n = n * 10 + x%10会溢出\n\n```java\n	public static int reverse1(int x) {\n		int result = 0;\n		while (x != 0) {\n			if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE && x % 10 > 7)) {\n				return 0;\n			}\n			if (result < Integer.MIN_VALUE / 10 || (result == Integer.MIN_VALUE && x % 10 < -8)) {\n				return 0;\n			}\n			result = result * 10 + x % 10;\n			x = x / 10;\n		}\n		return result;\n	}\n```\n\n\n\n## 解法二：\n\n对解法一的优化 解法一是预先会不会溢出，然后才去计算新一轮的结果 \n\n如果我们调换一下顺序，先计算新一轮的结果，再除以10， 如果没有溢出，那么得到的值，还会是上一次计算的结果， 如果溢出，那么就会不相等。\n\n```java\n	public static int reverse2(int x) {\n		/**\n		 * ret 保存旧的翻转中间值, temp 保存新的翻转过程中间值 依次提取 x 的末位加入 temp, 如果发生溢出则通过temp/10\n		 * 无法得到上一轮的翻转结果 ret\n		 **/\n		int ret = 0;\n		while (x != 0) {\n			int temp = ret * 10 + x % 10;\n			if (temp / 10 != ret)\n				return 0;\n			ret = temp;\n			x /= 10;\n		}\n		return ret;\n	}\n```\n\n\n\n## 解法三：\n\n利用long和int类型的范围特点 （有点耍流氓，因为题目说过我们的环境只能存的下32 位的有符号整数）\n\n```java\npublic static int reverse(int x) {\n		long n = 0;\n		while (x != 0) {\n			n = n * 10 + x % 10;\n			x = x / 10;\n		}\n		return (int) n == n ? (int) n : 0;\n	}\n```\n\n', 0, 0, '2020-08-06 23:29:20', 2, 0, 1, '问题描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n示例 1:\n输入: 123输出: 321 示例 2:\n输入: -123输出: -321示例 3:\n输入: 120输出: 21注意:\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n解法一：由于我们有范围限制，只能存储下32位的有符号整数 2^31-1=2147483647,-2^31=-2147483648，\n 我们反转整数，会用到n =n  10 + x%10;x = x/10; 但是n = n  10 + x%10;很有可能会溢出 我们来判断一下，导致溢出的条件： \n（1）如果n > INTMAX/10,那么n = n * 10 + x%10会溢出 \n（2）如果 n=INTMAX/10,并且x%10>7,那么n = n * 10 +x%10会溢出 \n（3）如果 n<INTMIN/10,那么n = n * 10 + x%10会溢出 \n（4）如果n=INTMIN/10,并且x%10<-8,那么n = n * 10 + x%10会溢出\n    public static int reverse1(int x) {        int result = 0;        while (x != 0) {            if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE && x % 10 > 7)) {                return 0;            }            if (result < Integer.MIN_VALUE / 10 || (result == Integer.MIN_VALUE && x % 10 < -8)) {                return 0;            }            result = result * 10 + x % 10;            x = x / 10;        }        return result;    }\n解法二：对解法一的优化 解法一是预先会不会溢出，然后才去计算新一轮的结果 \n如果我们调换一下顺序，先计算新一轮的结果，再除以10， 如果没有溢出，那么得到的值，还会是上一次计算的结果， 如果溢出，那么就会不相等。\n    public static int reverse2(int x) {        /**         * ret 保存旧的翻转中间值, temp 保存新的翻转过程中间值 依次提取 x 的末位加入 temp, 如果发生溢出则通过temp/10         * 无法得到上一轮的翻转结果 ret         **/        int ret = 0;        while (x != 0) {            int temp = ret * 10 + x % 10;            if (temp / 10 != ret)                return 0;            ret = temp;            x /= 10;        }        return ret;    }\n解法三：利用long和int类型的范围特点 （有点耍流氓，因为题目说过我们的环境只能存的下32 位的有符号整数）\npublic static int reverse(int x) {        long n = 0;        while (x != 0) {            n = n * 10 + x % 10;            x = x / 10;        }        return (int) n == n ? (int) n : 0;    }\n', 0, 1);
INSERT INTO `t_article` VALUES (66, '08. 字符串转换整数（难度：中等）', 8, '## 问题描述\n请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。\n\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n\n**说明：**\n\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n\n**示例 1:**\n\n```\n输入: \"42\"\n输出: 42\n```\n\n**示例 2:**\n\n```\n输入: \"   -42\"\n输出: -42\n解释: 第一个非空白字符为 \'-\', 它是一个负号。\n     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n```\n\n**示例 3:**\n\n```\n输入: \"4193 with words\"\n输出: 4193\n解释: 转换截止于数字 \'3\' ，因为它的下一个字符不为数字。\n```\n\n**示例 4:**\n\n```\n输入: \"words and 987\"\n输出: 0\n解释: 第一个非空字符是 \'w\', 但它不是数字或正、负号。\n     因此无法执行有效的转换。\n```\n\n**示例 5:**\n\n```\n输入: \"-91283472332\"\n输出: -2147483648\n解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 \n     因此返回 INT_MIN (−231) 。\n```\n\n\n\n解法：\n\n（1）我们需要去掉字符串前面多余的空格，生成新的字符串\n\n（2）判断字符串第一个字符是否为 \'+\' 或 \'-\'，添加一个符号变量sign来标记整数的正负性。\n\n（3）然后移动索引，开始取字符，每取一个字符，判断是否为数字，如果为数字，然后计算目前结果值，否则直接返回结果。\n\n（4）每次取到新字符时，还需要判断一下，这个新字符加入结果会不会超出范围，所以还需要对结果进行判断，结果越界大概会分为下面几种情况：\n\n①如果n > INTMAX/10,那么n = n * 10 + x%10会溢出 \n\n②如果 n=INTMAX/10,并且x%10>7,那么n = n * 10 +x%10会溢出 \n\n③如果 n<INTMIN/10,那么n = n * 10 + x%10会溢出 \n\n④如果n=INTMIN/10,并且x%10<-8,那么n = n * 10 + x%10会溢出\n\n如果越界的话，直接返回固定值INTMIN/INTMAX。\n\n## 代码：\n\n```java\n	public int myAtoi(String str) {\n		str  = str.trim();\n		\n		boolean flag = false;\n		int result  = 0;\n		int index = 0;\n		int sign = 1;\n		if(str.charAt(index) == \'+\') {\n			index++;\n		}else if(str.charAt(index) == \'-\'){\n			index ++;\n			sign = -1;\n		}\n		\n		while (index < str.length()) {\n			char ch = str.charAt(index);\n			if(ch > \'9\' || ch < \'0\') {\n				break;\n			}\n			\n			if(result > Integer.MAX_VALUE/10 || (result == Integer.MAX_VALUE/10 && (ch - \'0\') > 7)) {\n				return Integer.MAX_VALUE;\n			}\n			if(result < Integer.MIN_VALUE/10 || (result == Integer.MIN_VALUE/10 && (ch - \'0\') > 8 )){\n				return Integer.MIN_VALUE;\n			}\n			\n			result = result * 10 + sign * ( ch - \'0\');\n			index++;\n			\n		}\n		return result;\n		\n	}\n```\n\n\n\n\n\n## 测试类\n\n```java\npackage com.company.project.hot100;\n\n\npublic class Question08 {\n	public static int myAtoi(String str) {\n		str  = str.trim();\n		\n		boolean flag = false;\n		int result  = 0;\n		int index = 0;\n		int sign = 1;\n		if(str.charAt(index) == \'+\') {\n			index++;\n		}else if(str.charAt(index) == \'-\'){\n			index ++;\n			sign = -1;\n		}\n		\n		while (index < str.length()) {\n			char ch = str.charAt(index);\n			if(ch > \'9\' || ch < \'0\') {\n				break;\n			}\n			\n			if(result > Integer.MAX_VALUE/10 || (result == Integer.MAX_VALUE/10 && (ch - \'0\') > 7)) {\n				return Integer.MAX_VALUE;\n			}\n			if(result < Integer.MIN_VALUE/10 || (result == Integer.MIN_VALUE/10 && (ch - \'0\') > 8 )){\n				return Integer.MIN_VALUE;\n			}\n			\n			result = result * 10 + sign * ( ch - \'0\');\n			index++;\n			\n		}\n		return result;\n		\n	}\n\n	public static void main(String[] args) {\n		String string = \"2147483648\";\n		System.out.println(myAtoi(string));\n	}\n}\n\n```\n\n', 0, 0, '2020-08-06 23:30:17', 2, 0, 1, '问题描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n说明：\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n示例 1:\n输入: \"42\"输出: 42示例 2:\n输入: \"   -42\"输出: -42解释: 第一个非空白字符为 \'-\', 它是一个负号。     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3:\n输入: \"4193 with words\"输出: 4193解释: 转换截止于数字 \'3\' ，因为它的下一个字符不为数字。示例 4:\n输入: \"words and 987\"输出: 0解释: 第一个非空字符是 \'w\', 但它不是数字或正、负号。     因此无法执行有效的转换。示例 5:\n输入: \"-91283472332\"输出: -2147483648解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。      因此返回 INT_MIN (−231) 。解法：\n（1）我们需要去掉字符串前面多余的空格，生成新的字符串\n（2）判断字符串第一个字符是否为 ‘+’ 或 ‘-‘，添加一个符号变量sign来标记整数的正负性。\n（3）然后移动索引，开始取字符，每取一个字符，判断是否为数字，如果为数字，然后计算目前结果值，否则直接返回结果。\n（4）每次取到新字符时，还需要判断一下，这个新字符加入结果会不会超出范围，所以还需要对结果进行判断，结果越界大概会分为下面几种情况：\n①如果n > INTMAX/10,那么n = n * 10 + x%10会溢出 \n②如果 n=INTMAX/10,并且x%10>7,那么n = n * 10 +x%10会溢出 \n③如果 n<INTMIN/10,那么n = n * 10 + x%10会溢出 \n④如果n=INTMIN/10,并且x%10<-8,那么n = n * 10 + x%10会溢出\n如果越界的话，直接返回固定值INTMIN/INTMAX。\n代码：    public int myAtoi(String str) {        str  = str.trim();        boolean flag = false;        int result  = 0;        int index = 0;        int sign = 1;        if(str.charAt(index) == \'+\') {            index++;        }else if(str.charAt(index) == \'-\'){            index ++;            sign = -1;        }        while (index < str.length()) {            char ch = str.charAt(index);            if(ch > \'9\' || ch < \'0\') {                break;            }            if(result > Integer.MAX_VALUE/10 || (result == Integer.MAX_VALUE/10 && (ch - \'0\') > 7)) {                return Integer.MAX_VALUE;            }            if(result < Integer.MIN_VALUE/10 || (result == Integer.MIN_VALUE/10 && (ch - \'0\') > 8 )){                return Integer.MIN_VALUE;            }            result = result * 10 + sign * ( ch - \'0\');            index++;        }        return result;    }\n测试类package com.company.project.hot100;public class Question08 {    public static int myAtoi(String str) {        str  = str.trim();        boolean flag = false;        int result  = 0;        int index = 0;        int sign = 1;        if(str.charAt(index) == \'+\') {            index++;        }else if(str.charAt(index) == \'-\'){            index ++;            sign = -1;        }        while (index < str.length()) {            char ch = str.charAt(index);            if(ch > \'9\' || ch < \'0\') {                break;            }            if(result > Integer.MAX_VALUE/10 || (result == Integer.MAX_VALUE/10 && (ch - \'0\') > 7)) {                return Integer.MAX_VALUE;            }            if(result < Integer.MIN_VALUE/10 || (result == Integer.MIN_VALUE/10 && (ch - \'0\') > 8 )){                return Integer.MIN_VALUE;            }            result = result * 10 + sign * ( ch - \'0\');            index++;        }        return result;    }    public static void main(String[] args) {        String string = \"2147483648\";        System.out.println(myAtoi(string));    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (67, '09. 回文数（难度：简单）', 8, '## 问题描述 \n\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n**示例 1:**\n\n```\n输入: 121\n输出: true\n```\n\n**示例 2:**\n\n```\n输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n```\n\n**示例 3:**\n\n```\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n```\n\n\n\n## 解法一：倒置字符串\n\n思路：先将这个整数转为字符串，然后倒置字符串，再和原字符串进行比较。\n\n```java\n	public static boolean isPalindrome1(int x) {\n		String revstr = new StringBuilder(x + \"\").reverse().toString();\n		String str = x + \"\";\n        return str.equals(revstr);\n    }\n```\n\n\n\n## 解法二：数学解法\n\n**思路：**先判断如何x是负数，直接返回false。\n\n每次取出第一位和最后一位进行比较，当取到一半的时候就不用再继续比较了。\n\n解法：\n\n（1）先算出这个整数有多少位\n\n（2）每次取出最高位和最低位，进行比较，如果不相等，直接返回false，如果相等，那么整数去掉最高位和最低位，继续下一轮循环，直到整数为0。\n\n```java\n	public static boolean isPalindrome2(int x) {\n		if(x<0) {\n			return false;\n		}\n		int digit = 1;\n		while(x / digit >= 10) {\n			digit *= 10;\n		}\n		while(x > 0) {\n			int l = x / digit;\n			int r = x % 10;\n			if(l != r) {\n				return false;\n			}\n			x = (x % digit) /10;\n			digit /= 100;\n		}\n		return true;\n    }\n```\n\n\n\n## 解法三：利用数字对折\n\n思路：我们可以利用回文数的特性，我们可以取出后半段数字然后进行翻转。\n\n但是整数的位数可奇可偶，如果是偶数的话，则两边对折，如果是奇数的话，则去掉中间的一位数字。\n\n算法：\n\n- 准备两个变量，一个存储取出的数字a，另一个存储剩余的数字b\n- 每次取余取出最低位数字，将最低位数字加到a的末尾\n- 每次取完最低位，b都要去掉最低位，即除以10\n- 判断b是否小于a，即判断数字是否已经过半了\n- 判断奇偶情况：如果是偶数，a和b相等，则说明是回文数；如果是奇数，则抛弃中间的一位数字，即a的最低位，将a除以10后再去和a比较\n\n```java\n	public static boolean isPalindrome3(int x) {\n		if(x < 0 || (x % 10 == 0 && x != 0)) {\n			return false;\n		}\n		int b = 0;\n		while(x > b) {\n			b = b * 10 + x % 10;\n			x /= 10;\n		}\n		return x == b || x == b / 10;\n	}\n```\n\n\n\n## 测试类：\n\n```java\npackage com.company.project.hot100;\n\npublic class Question09 {\n	\n	/**\n	 * 解法一：倒置字符串\n	 * @param x\n	 * @return\n	 */\n	public static boolean isPalindrome1(int x) {\n		String revstr = new StringBuilder(x + \"\").reverse().toString();\n		String str = x + \"\";\n        return str.equals(revstr);\n    }\n	\n	/**\n	 * 解法二：数学算法\n	 * @param x\n	 * @return\n	 */\n	public static boolean isPalindrome2(int x) {\n		if(x<0) {\n			return false;\n		}\n		int digit = 1;\n		while(x / digit >= 10) {\n			digit *= 10;\n		}\n		while(x > 0) {\n			int l = x / digit;\n			int r = x % 10;\n			if(l != r) {\n				return false;\n			}\n			x = (x % digit) /10;\n			digit /= 100;\n		}\n		return true;\n    }\n	\n	/**\n	 * 解法三：利用数字对折\n	 * @param x\n	 * @return\n	 */\n	public static boolean isPalindrome3(int x) {\n		if(x < 0 || (x % 10 == 0 && x != 0)) {\n			return false;\n		}\n		int b = 0;\n		while(x > b) {\n			b = b * 10 + x % 10;\n			x /= 10;\n		}\n		return x == b || x == b / 10;\n	}\n	\n	public static void main(String[] args) {\n		System.out.println(isPalindrome2(120021));\n	}\n\n\n}\n```\n\n', 0, 0, '2020-08-06 23:31:18', 2, 0, 1, '问题描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n示例 1:\n输入: 121输出: true示例 2:\n输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3:\n输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。解法一：倒置字符串思路：先将这个整数转为字符串，然后倒置字符串，再和原字符串进行比较。\n    public static boolean isPalindrome1(int x) {        String revstr = new StringBuilder(x + \"\").reverse().toString();        String str = x + \"\";        return str.equals(revstr);    }\n解法二：数学解法思路：先判断如何x是负数，直接返回false。\n每次取出第一位和最后一位进行比较，当取到一半的时候就不用再继续比较了。\n解法：\n（1）先算出这个整数有多少位\n（2）每次取出最高位和最低位，进行比较，如果不相等，直接返回false，如果相等，那么整数去掉最高位和最低位，继续下一轮循环，直到整数为0。\n    public static boolean isPalindrome2(int x) {        if(x<0) {            return false;        }        int digit = 1;        while(x / digit >= 10) {            digit *= 10;        }        while(x > 0) {            int l = x / digit;            int r = x % 10;            if(l != r) {                return false;            }            x = (x % digit) /10;            digit /= 100;        }        return true;    }\n解法三：利用数字对折思路：我们可以利用回文数的特性，我们可以取出后半段数字然后进行翻转。\n但是整数的位数可奇可偶，如果是偶数的话，则两边对折，如果是奇数的话，则去掉中间的一位数字。\n算法：\n\n准备两个变量，一个存储取出的数字a，另一个存储剩余的数字b每次取余取出最低位数字，将最低位数字加到a的末尾每次取完最低位，b都要去掉最低位，即除以10判断b是否小于a，即判断数字是否已经过半了判断奇偶情况：如果是偶数，a和b相等，则说明是回文数；如果是奇数，则抛弃中间的一位数字，即a的最低位，将a除以10后再去和a比较\n    public static boolean isPalindrome3(int x) {        if(x < 0 || (x % 10 == 0 && x != 0)) {            return false;        }        int b = 0;        while(x > b) {            b = b * 10 + x % 10;            x /= 10;        }        return x == b || x == b / 10;    }\n测试类：package com.company.project.hot100;public class Question09 {    /**     * 解法一：倒置字符串     * @param x     * @return     */    public static boolean isPalindrome1(int x) {        String revstr = new StringBuilder(x + \"\").reverse().toString();        String str = x + \"\";        return str.equals(revstr);    }    /**     * 解法二：数学算法     * @param x     * @return     */    public static boolean isPalindrome2(int x) {        if(x<0) {            return false;        }        int digit = 1;        while(x / digit >= 10) {            digit *= 10;        }        while(x > 0) {            int l = x / digit;            int r = x % 10;            if(l != r) {                return false;            }            x = (x % digit) /10;            digit /= 100;        }        return true;    }    /**     * 解法三：利用数字对折     * @param x     * @return     */    public static boolean isPalindrome3(int x) {        if(x < 0 || (x % 10 == 0 && x != 0)) {            return false;        }        int b = 0;        while(x > b) {            b = b * 10 + x % 10;            x /= 10;        }        return x == b || x == b / 10;    }    public static void main(String[] args) {        System.out.println(isPalindrome2(120021));    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (68, '10. 正则表达式匹配（难度：困难）', 8, '## 问题描述 \n\n给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `\'.\'` 和 `\'*\'` 的正则表达式匹配。\n\n```\n\'.\' 匹配任意单个字符\n\'*\' 匹配零个或多个前面的那一个元素\n```\n\n所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。\n\n**说明:**\n\n- `s` 可能为空，且只包含从 `a-z` 的小写字母。\n- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。\n\n**示例 1:**\n\n```\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n```\n\n**示例 2:**\n\n```\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释: 因为 \'*\' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 \'a\'。因此，字符串 \"aa\" 可被视为 \'a\' 重复了一次。\n```\n\n**示例 3:**\n\n```\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个（\'*\'）任意字符（\'.\'）。\n```\n\n**示例 4:**\n\n```\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释: 因为 \'*\' 表示零个或多个，这里 \'c\' 为 0 个, \'a\' 被重复一次。因此可以匹配字符串 \"aab\"。\n```\n\n**示例 5:**\n\n```\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\n```\n\n\n\n## 解法一：回溯法\n\n解题思路：\n\n**1、如果没有\'\\*\'的话**\n\n如果没有\'*\'的话，我们只需要挨个字符串和正则表达式匹配，如果字符串和正则表达式的对应字符相等，或者正则表达式对应字符为\'.\'，都是可以匹配的。如果不匹配直接返回false，若是当前字符匹配，我们只需要将字符串和正则表达式都向后移动一位，继续递归调用该方法。\n\n特殊情况处理（结束条件）：若正则表达式为空，只需要返回字符串是否为空，若字符串也为空，说明正好匹配成功。\n\n**2、加入\'\\*\'的话**\n\n加入\'*\'的话，我们就需要分成两种情况判断一下，两种情况只要符合一种就是通过的。\n\n如果pattern[1]==\'*\'，即遇到\'*\',分如下两种情况处理：\n\n（1）前面字符出现0次 （2）前面字符出现1次或多次\n\n第一种：若当前的\'*\'，代表的是前面的一个字符出现0次，那么我们只需要把正则表达式向后移动2位；\n\n第二种：若当前的\'*\'，代表的是前面的一个字符出现1次或多次，那么我们只需要把字符串向后移1位；\n\n（其中，若\'*\'表示的是前面的字符出现1次，那么它第二次递归到这块，就会符合第一种情况）\n\n若满足最后的结束条件，若正则表达式为空，只需要返回字符串是否为空，若字符串也为空，说明正好匹配成功。\n\n```java\n	public boolean isMatch(String text, String pattern)  {\n		if(pattern.isEmpty()) return text.isEmpty();\n		\n		//判断当前字符是否可以匹配\n		boolean fMatch = (!text.isEmpty() \n				&& (pattern.charAt(0) == text.charAt(0) || (pattern.charAt(0)) == \'.\'));\n		\n		//若遇到*，分两种情况处理\n		if(pattern.length() >=2 && pattern.charAt(1) == \'*\') {\n			return (isMatch(text, pattern.substring(2)) || \n					(fMatch && isMatch(text.substring(1), pattern)));\n					\n		}else {\n			//没有遇到*，就正常对比匹配\n			return fMatch && isMatch(text.substring(1), pattern.substring(1));\n		}\n	}\n```', 0, 0, '2020-08-06 23:32:17', 2, 0, 1, '问题描述给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 \'.\' 和 \'*\' 的正则表达式匹配。\n\'.\' 匹配任意单个字符\'*\' 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n说明:\n\ns 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n示例 1:\n输入:s = \"aa\"p = \"a\"输出: false解释: \"a\" 无法匹配 \"aa\" 整个字符串。示例 2:\n输入:s = \"aa\"p = \"a*\"输出: true解释: 因为 \'*\' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 \'a\'。因此，字符串 \"aa\" 可被视为 \'a\' 重复了一次。示例 3:\n输入:s = \"ab\"p = \".*\"输出: true解释: \".*\" 表示可匹配零个或多个（\'*\'）任意字符（\'.\'）。示例 4:\n输入:s = \"aab\"p = \"c*a*b\"输出: true解释: 因为 \'*\' 表示零个或多个，这里 \'c\' 为 0 个, \'a\' 被重复一次。因此可以匹配字符串 \"aab\"。示例 5:\n输入:s = \"mississippi\"p = \"mis*is*p*.\"输出: false解法一：回溯法解题思路：\n1、如果没有’*‘的话\n如果没有’*’的话，我们只需要挨个字符串和正则表达式匹配，如果字符串和正则表达式的对应字符相等，或者正则表达式对应字符为’.’，都是可以匹配的。如果不匹配直接返回false，若是当前字符匹配，我们只需要将字符串和正则表达式都向后移动一位，继续递归调用该方法。\n特殊情况处理（结束条件）：若正则表达式为空，只需要返回字符串是否为空，若字符串也为空，说明正好匹配成功。\n2、加入’*‘的话\n加入’*’的话，我们就需要分成两种情况判断一下，两种情况只要符合一种就是通过的。\n如果pattern[1]==’‘，即遇到’‘,分如下两种情况处理：\n（1）前面字符出现0次 （2）前面字符出现1次或多次\n第一种：若当前的’*’，代表的是前面的一个字符出现0次，那么我们只需要把正则表达式向后移动2位；\n第二种：若当前的’*’，代表的是前面的一个字符出现1次或多次，那么我们只需要把字符串向后移1位；\n（其中，若’*’表示的是前面的字符出现1次，那么它第二次递归到这块，就会符合第一种情况）\n若满足最后的结束条件，若正则表达式为空，只需要返回字符串是否为空，若字符串也为空，说明正好匹配成功。\n    public boolean isMatch(String text, String pattern)  {        if(pattern.isEmpty()) return text.isEmpty();        //判断当前字符是否可以匹配        boolean fMatch = (!text.isEmpty()                 && (pattern.charAt(0) == text.charAt(0) || (pattern.charAt(0)) == \'.\'));        //若遇到*，分两种情况处理        if(pattern.length() >=2 && pattern.charAt(1) == \'*\') {            return (isMatch(text, pattern.substring(2)) ||                     (fMatch && isMatch(text.substring(1), pattern)));        }else {            //没有遇到*，就正常对比匹配            return fMatch && isMatch(text.substring(1), pattern.substring(1));        }    }\n', 0, 1);
INSERT INTO `t_article` VALUES (69, '11.盛最多水的容器（难度：中等）', 8, '## 问题描述\n\n给你 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。\n\n**说明：**你不能倾斜容器，且 *n* 的值至少为 2。\n\n \n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/question_11.jpg)\n\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n \n\n**示例：**\n\n```\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n```\n\n## 题目分析：\n\n刚开始看题，还有点没看明白，最后看懂了，题目其实很简单，意思就是选取两个挡板，选中后忽略掉其他的挡板，然后计算最大存水面积，即较小的挡板长度乘以两板之间的距离\n\n## 解法一：双指针法\n\n算法思路：\n\n用两个变量分别表示最左边和最右边的数组下标，从最外层开始计算，计算出面积后和当前的最大面积比较是否替换，然后再将较小的板的下标向中心移动，依次循环，直到两个变量指向了同一块板，循环结束输出最大面积。\n\n**复杂度分析**\n\n- 时间复杂度：O(N)*O*(*N*)，双指针总计最多遍历整个数组一次。\n- 空间复杂度：O(1)*O*(1)，只需要额外的常数级别的空间。\n\n```java\npublic int maxArea(int[] height) {\n		int l = 0;\n		int r = height.length-1;\n		int area = 0;\n		int maxArea = 0;\n		\n		while (r>l) {\n			area = Math.min(height[l], height[r])*(r-l);\n			maxArea = area>maxArea?area:maxArea;\n			if(height[l]>=height[r]) {\n				r--;\n			}else {\n				l++;\n			}	\n		}\n		return maxArea;\n	}\n```', 0, 0, '2020-08-06 23:33:27', 2, 0, 1, '问题描述给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n说明：你不能倾斜容器，且 n 的值至少为 2。\n\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n示例：\n输入：[1,8,6,2,5,4,8,3,7]输出：49题目分析：刚开始看题，还有点没看明白，最后看懂了，题目其实很简单，意思就是选取两个挡板，选中后忽略掉其他的挡板，然后计算最大存水面积，即较小的挡板长度乘以两板之间的距离\n解法一：双指针法算法思路：\n用两个变量分别表示最左边和最右边的数组下标，从最外层开始计算，计算出面积后和当前的最大面积比较是否替换，然后再将较小的板的下标向中心移动，依次循环，直到两个变量指向了同一块板，循环结束输出最大面积。\n复杂度分析\n\n时间复杂度：O(N)O(N)，双指针总计最多遍历整个数组一次。空间复杂度：O(1)O(1)，只需要额外的常数级别的空间。\npublic int maxArea(int[] height) {        int l = 0;        int r = height.length-1;        int area = 0;        int maxArea = 0;        while (r>l) {            area = Math.min(height[l], height[r])*(r-l);            maxArea = area>maxArea?area:maxArea;            if(height[l]>=height[r]) {                r--;            }else {                l++;            }            }        return maxArea;    }\n', 0, 1);
INSERT INTO `t_article` VALUES (70, '12.整数转罗马数字（难度：中等）', 8, '## 问题描述\n\n罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n```\n输入: 3\n输出: \"III\"\n```\n\n**示例 2:**\n\n```\n输入: 4\n输出: \"IV\"\n```\n\n**示例 3:**\n\n```\n输入: 9\n输出: \"IX\"\n```\n\n**示例 4:**\n\n```\n输入: 58\n输出: \"LVIII\"\n解释: L = 50, V = 5, III = 3.\n```\n\n**示例 5:**\n\n```\n输入: 1994\n输出: \"MCMXCIV\"\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n```\n\n\n\n## 题目解析：\n\n分析题目，我们不难想到现实中的实例，我们在超市买东西的时候，找钱的时候总是想方设法的给出尽量纸张数目最少的钱币，这道题也是类型，我们可以使用贪心算法，从最大面值的罗马数字开始，依次列出最后的结果。\n\n首先，我们列出所有的罗马数字类型：\n\n```text\n罗马数字	阿拉伯数字\nM	        1000\nCM	        900\nD	        500\nCD	        400\nC	        100\nXC	        90\nL	        50\nXL	        40\nX	        10\nIX	        99\nV	        5\nIV	        4\nI	        1\n```\n\n我们可以使用两个数组，依次表示罗马数字和阿拉伯数字的对应关系依次从大到小排列，然后依次遍历阿拉伯数字，若目标数 >= 阿拉伯数字，则在结果字符串中添加对应的罗马数字，同时 目标数-= 阿拉伯数字，直到 目标数 < 阿拉伯数字，退出内层循环，然后将外出循环的阿拉伯数字换成下一个。直到外循环结束，得到答案。\n\n## 代码：\n\n```java\n	public String intToRoman(int num) {\n		String[] luoma = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n		int [] alabo = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\n		StringBuilder result = new StringBuilder();\n		int i = 0,j =0;\n		int n = 0;\n		while(i<13) {\n			while(num>=alabo[i]) {\n				result.append(luoma[i]);\n				num -= alabo[i];\n			}\n			i++;\n		}\n		return result.toString();\n    }\n```', 0, 0, '2020-08-06 23:34:13', 2, 0, 1, '问题描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n字符          数值I             1V             5X             10L             50C             100D             500M             1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n示例 1:\n输入: 3输出: \"III\"示例 2:\n输入: 4输出: \"IV\"示例 3:\n输入: 9输出: \"IX\"示例 4:\n输入: 58输出: \"LVIII\"解释: L = 50, V = 5, III = 3.示例 5:\n输入: 1994输出: \"MCMXCIV\"解释: M = 1000, CM = 900, XC = 90, IV = 4.题目解析：分析题目，我们不难想到现实中的实例，我们在超市买东西的时候，找钱的时候总是想方设法的给出尽量纸张数目最少的钱币，这道题也是类型，我们可以使用贪心算法，从最大面值的罗马数字开始，依次列出最后的结果。\n首先，我们列出所有的罗马数字类型：\n罗马数字    阿拉伯数字M            1000CM            900D            500CD            400C            100XC            90L            50XL            40X            10IX            99V            5IV            4I            1\n我们可以使用两个数组，依次表示罗马数字和阿拉伯数字的对应关系依次从大到小排列，然后依次遍历阿拉伯数字，若目标数 >= 阿拉伯数字，则在结果字符串中添加对应的罗马数字，同时 目标数-= 阿拉伯数字，直到 目标数 < 阿拉伯数字，退出内层循环，然后将外出循环的阿拉伯数字换成下一个。直到外循环结束，得到答案。\n代码：    public String intToRoman(int num) {        String[] luoma = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};        int [] alabo = {1000,900,500,400,100,90,50,40,10,9,5,4,1};        StringBuilder result = new StringBuilder();        int i = 0,j =0;        int n = 0;        while(i<13) {            while(num>=alabo[i]) {                result.append(luoma[i]);                num -= alabo[i];            }            i++;        }        return result.toString();    }\n', 0, 1);
INSERT INTO `t_article` VALUES (71, '13.罗马数字转整数（难度：简单）', 8, '## 问题描述\n\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n```\n输入: \"III\"\n输出: 3\n```\n\n**示例 2:**\n\n```\n输入: \"IV\"\n输出: 4\n```\n\n**示例 3:**\n\n```\n输入: \"IX\"\n输出: 9\n```\n\n**示例 4:**\n\n```\n输入: \"LVIII\"\n输出: 58\n解释: L = 50, V= 5, III = 3.\n```\n\n**示例 5:**\n\n```\n输入: \"MCMXCIV\"\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n```\n\n解法：\n\n建立HashMap来映射符号和值，然后遍历字符串，判断当前字符是否大于或等于下一个字符，如果是就加上该字符对应的值，如果不是就减去该符号对应的值。\n\n代码：\n\n```java\npackage com.company.project.hot100;\n\nimport java.util.HashMap;\n\npublic class Question13 {\n	public static int romanToInt(String s) {\n		HashMap<Character, Integer> hm = new HashMap<>();\n		hm.put(\'I\', 1);\n		hm.put(\'V\', 5);\n		hm.put(\'X\', 10);\n		hm.put(\'L\', 50);\n		hm.put(\'C\', 100);\n		hm.put(\'D\', 500);\n		hm.put(\'M\', 1000);\n		int result = 0;\n		for (int i = 0; i < s.length() - 1; i++) {\n			if(hm.get(s.charAt(i)) >= hm.get(s.charAt(i + 1)) ) {\n				result += hm.get(s.charAt(i));\n			}\n			else {\n				result -= hm.get(s.charAt(i));\n			}\n		}\n		result += hm.get(s.charAt(s.length() - 1));\n		\n		return result;\n    }\n	\n	public static void main(String[] args) {\n		System.out.println(romanToInt(\"MCMXCIV\"));\n	}\n}\n```\n\n', 0, 0, '2020-08-06 23:35:08', 2, 0, 1, '问题描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n字符          数值I             1V             5X             10L             50C             100D             500M             1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n示例 1:\n输入: \"III\"输出: 3示例 2:\n输入: \"IV\"输出: 4示例 3:\n输入: \"IX\"输出: 9示例 4:\n输入: \"LVIII\"输出: 58解释: L = 50, V= 5, III = 3.示例 5:\n输入: \"MCMXCIV\"输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.解法：\n建立HashMap来映射符号和值，然后遍历字符串，判断当前字符是否大于或等于下一个字符，如果是就加上该字符对应的值，如果不是就减去该符号对应的值。\n代码：\npackage com.company.project.hot100;import java.util.HashMap;public class Question13 {    public static int romanToInt(String s) {        HashMap<Character, Integer> hm = new HashMap<>();        hm.put(\'I\', 1);        hm.put(\'V\', 5);        hm.put(\'X\', 10);        hm.put(\'L\', 50);        hm.put(\'C\', 100);        hm.put(\'D\', 500);        hm.put(\'M\', 1000);        int result = 0;        for (int i = 0; i < s.length() - 1; i++) {            if(hm.get(s.charAt(i)) >= hm.get(s.charAt(i + 1)) ) {                result += hm.get(s.charAt(i));            }            else {                result -= hm.get(s.charAt(i));            }        }        result += hm.get(s.charAt(s.length() - 1));        return result;    }    public static void main(String[] args) {        System.out.println(romanToInt(\"MCMXCIV\"));    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (72, '14.最长公共前缀（难度：简单）', 8, '## 问题描述\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n**示例 1:**\n\n```\n输入: [\"flower\",\"flow\",\"flight\"]\n输出: \"fl\"\n```\n\n**示例 2:**\n\n```\n输入: [\"dog\",\"racecar\",\"car\"]\n输出: \"\"\n解释: 输入不存在公共前缀。\n```\n\n**说明:**\n\n所有输入只包含小写字母 `a-z` 。\n\n\n\n\n\n# 解法一：贪心法\n\n我们看完题后，会发现最终结果一定是从前往后最长的公共子串，而且一定是小于等于任意一个字符串的，看起来像是在说废话，但是注意这个从前往后，我们反其道而行之，先把第一个字符串当成这个字符串数组的公共最长子串，然后和其他的一个一个比，然后削短，最后符合所有字符串的公共前缀，就是最后的结果。\n\n\n\n**代码：**\n\n```java\npublic String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0)\n			return \"\";\n		String prefix = strs[0];\n		for (int i = 1; i < strs.length; i++)\n			while (strs[i].indexOf(prefix) != 0) {\n				prefix = prefix.substring(0, prefix.length() - 1);\n				if (prefix.isEmpty())\n					return \"\";\n			}\n		return prefix;\n }\n```\n\n', 0, 0, '2020-08-06 23:35:50', 2, 0, 1, '问题描述编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 \"\"。\n示例 1:\n输入: [\"flower\",\"flow\",\"flight\"]输出: \"fl\"示例 2:\n输入: [\"dog\",\"racecar\",\"car\"]输出: \"\"解释: 输入不存在公共前缀。说明:\n所有输入只包含小写字母 a-z 。\n解法一：贪心法我们看完题后，会发现最终结果一定是从前往后最长的公共子串，而且一定是小于等于任意一个字符串的，看起来像是在说废话，但是注意这个从前往后，我们反其道而行之，先把第一个字符串当成这个字符串数组的公共最长子串，然后和其他的一个一个比，然后削短，最后符合所有字符串的公共前缀，就是最后的结果。\n代码：\npublic String longestCommonPrefix(String[] strs) {        if (strs.length == 0)            return \"\";        String prefix = strs[0];        for (int i = 1; i < strs.length; i++)            while (strs[i].indexOf(prefix) != 0) {                prefix = prefix.substring(0, prefix.length() - 1);                if (prefix.isEmpty())                    return \"\";            }        return prefix; }\n', 0, 1);
INSERT INTO `t_article` VALUES (73, '15. 三数之和（难度：中等）', 8, '## 问题描述\n\n给你一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有满足条件且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n \n\n**示例：**\n\n```\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n\n\n# 解法一：双指针法\n\n**分析这道题，我们一共需要解决两个问题，一个是找到所有符合条件的数组，第二个是如何去除重复的数组。**\n\n首先我们需要先对数组进行排序，我们可以用变量i遍历数组，nums[i]就是第一个元素，我们可以使用两个指针l和r依次指向i+1和len-1，其中len是nums数组的长度。\n\n- 当i < len 循环i，若nums[i]>0，直接return。因为当nums[i]>0的话，往后面就没有符合条件的。\n  - 当l<r，就一种进行下面循环：\n    - 我们通过计算t = nums[i] + nums[l]+nums[r],\n      - 若t=0，我们就直接他们加入最终结果集；\n      - 若t>0，说明是nums[r]太大了，我们应该将r指针向右移动；\n      - 若t<0，说明是nums[l]太小了，我们应该将l指针向左移动。\n\n- 这道题还有一个难点，就是如何去除重复的结果？\n  * 我们已经对数组进行了排序，所以如果有重复的结果，那么重复结果的下标i或l或r一定是相邻的，所以我们只需要在找到结果的时候，\n        * 判断nums[l+1]是否等于nums[l]，num[r-1]是否等于nums[r]\n             * 若等于，我们直接移动指针，直到不相等。\n       * 还有就是在移动i的时候，我们也需要判断，\n          * 如果nums[i]和nums[i-1]相等，我们就可以直接跳过这次循环，进行下一次循环。\n\n\n\n代码：\n\n```java\n	public static List<List<Integer>> threeSum(int[] nums) {\n		List<List<Integer>> result = new ArrayList<>();\n		Arrays.sort(nums);\n		int len = nums.length;		\n		for(int i =0;i<len;i++) {\n			if(nums[i]>0) {\n				return result;\n			}\n			\n			if(i>0 && nums[i] == nums[i-1]) {\n				continue;\n			}\n			int l = i+1;\n			int r = len -1;		\n			while (l<r) {\n				int t = nums[i] + nums[l]+nums[r];\n				if(t == 0) {\n					List<Integer> list = new ArrayList<>();\n					list.add(nums[i]);\n					list.add(nums[l]);\n					list.add(nums[r]);\n					result.add(list);	\n					\n					while(l < r && nums[l+1] == nums[l]) {\n						l++;\n					}\n					while(l<r && nums[r-1] == nums[r]) {\n						r--;\n					}\n					++l;\n					--r;\n					\n				}else if(t > 0) {\n					r--;\n				}else {\n					l++;\n				}				\n			}\n		}\n		return result;\n    }\n```\n\n', 0, 0, '2020-08-06 23:36:45', 2, 0, 1, '问题描述给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n示例：\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]解法一：双指针法分析这道题，我们一共需要解决两个问题，一个是找到所有符合条件的数组，第二个是如何去除重复的数组。\n首先我们需要先对数组进行排序，我们可以用变量i遍历数组，nums[i]就是第一个元素，我们可以使用两个指针l和r依次指向i+1和len-1，其中len是nums数组的长度。\n\n当i < len 循环i，若nums[i]>0，直接return。因为当nums[i]>0的话，往后面就没有符合条件的。\n\n当l<r，就一种进行下面循环：\n我们通过计算t = nums[i] + nums[l]+nums[r],\n若t=0，我们就直接他们加入最终结果集；若t>0，说明是nums[r]太大了，我们应该将r指针向右移动；若t<0，说明是nums[l]太小了，我们应该将l指针向左移动。\n\n\n这道题还有一个难点，就是如何去除重复的结果？\n\n我们已经对数组进行了排序，所以如果有重复的结果，那么重复结果的下标i或l或r一定是相邻的，所以我们只需要在找到结果的时候，* 判断nums[l+1]是否等于nums[l]，num[r-1]是否等于nums[r]     * 若等于，我们直接移动指针，直到不相等。\n还有就是在移动i的时候，我们也需要判断，\n如果nums[i]和nums[i-1]相等，我们就可以直接跳过这次循环，进行下一次循环。\n\n\n\n代码：\n    public static List<List<Integer>> threeSum(int[] nums) {        List<List<Integer>> result = new ArrayList<>();        Arrays.sort(nums);        int len = nums.length;                for(int i =0;i<len;i++) {            if(nums[i]>0) {                return result;            }            if(i>0 && nums[i] == nums[i-1]) {                continue;            }            int l = i+1;            int r = len -1;                    while (l<r) {                int t = nums[i] + nums[l]+nums[r];                if(t == 0) {                    List<Integer> list = new ArrayList<>();                    list.add(nums[i]);                    list.add(nums[l]);                    list.add(nums[r]);                    result.add(list);                        while(l < r && nums[l+1] == nums[l]) {                        l++;                    }                    while(l<r && nums[r-1] == nums[r]) {                        r--;                    }                    ++l;                    --r;                }else if(t > 0) {                    r--;                }else {                    l++;                }                            }        }        return result;    }\n', 0, 1);
INSERT INTO `t_article` VALUES (74, '16.最接近的三数之和（难度：中等）', 8, '\n\n>题目链接：https://leetcode-cn.com/problems/3sum-closest/\n\n## 问题描述\n\n给定一个包括 *n* 个整数的数组 `nums` 和 一个目标值 `target`。找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n```\n例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.\n\n与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).\n```\n\n\n\n## 解法一：排序+双指针法\n\n首先先对 `nums` 数组排序，然后用变量i变量整个数组，设置指针L指向i+1，指针R指向len-1，计算出`sum = nums[i]+nums[L]+nums[R]`，\n\n- 若 `i < len-2`，进入循环：\n\n  - 若L<R,进入内循环：\n    - 计算`sum = nums[i]+nums[L]+nums[R]`\n    - 若`sum = target`  ，则sum就是距离最近的，直接return sum。\n    - 若`sum < target`，则说明L指针指向的数字太小了，则将L++，向左移动。\n    - 若`sum > target`，则说明R指针指向的数字太大了，则将R--，向右移动。\n\n  依次遍历，直到找到距离最近的sum。\n\n\n\n## 代码：\n\n```java\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n		int l, r, sum;\n		int len = nums.length;\n		int ans = nums[0] + nums[1] + nums[2];\n		if (len <= 3) {\n			return ans;\n		}\n		for (int i = 0; i < len - 2; i++) {\n			l = i + 1;\n			r = len - 1;\n			while (l < r) {\n				sum = nums[l] + nums[r] + nums[i];\n				if (sum == target) {\n					return sum;\n				} else if (sum < target) {\n					l++;\n				} else {\n					r--;\n				}\n				if (Math.abs(ans - target) > Math.abs(sum - target)) {\n					ans = sum;\n				}\n			}\n		}\n		return ans;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:38:07', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/3sum-closest/\n\n问题描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).解法一：排序+双指针法首先先对 nums 数组排序，然后用变量i变量整个数组，设置指针L指向i+1，指针R指向len-1，计算出sum = nums[i]+nums[L]+nums[R]，\n\n若 i < len-2，进入循环：\n\n若L<R,进入内循环：\n计算sum = nums[i]+nums[L]+nums[R]若sum = target  ，则sum就是距离最近的，直接return sum。若sum < target，则说明L指针指向的数字太小了，则将L++，向左移动。若sum > target，则说明R指针指向的数字太大了，则将R—，向右移动。\n\n依次遍历，直到找到距离最近的sum。\n\n代码：class Solution {    public int threeSumClosest(int[] nums, int target) {        Arrays.sort(nums);        int l, r, sum;        int len = nums.length;        int ans = nums[0] + nums[1] + nums[2];        if (len <= 3) {            return ans;        }        for (int i = 0; i < len - 2; i++) {            l = i + 1;            r = len - 1;            while (l < r) {                sum = nums[l] + nums[r] + nums[i];                if (sum == target) {                    return sum;                } else if (sum < target) {                    l++;                } else {                    r--;                }                if (Math.abs(ans - target) > Math.abs(sum - target)) {                    ans = sum;                }            }        }        return ans;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (75, '17.电话号码的字母组合（难度：中等）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/\n\n## 题目描述\n\n给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/17_telephone_keypad.png)\n\n**示例:**\n\n```\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n```\n\n\n\n\n\n\n\n## 解法一：普通的循环(类似于建树的BFS广度优先搜索，层序遍历)\n\n首先建立手机按键与字符的对应关系，利用Map存储。\n我们可以利用遍历digits的每一个字符，依次把当前数字对应的字符串添加到最终的list集合。\n每一拿到一个数字按键，拿到按键对应的字符串s，\n将当前的list集合和字符串按照笛卡尔积的形式拼接，组合形成新的list。\n然后将list返回，进行下一个按键的拼接。\n循环结束，返回结果字符串集合。\n\n 缺点：时间复杂度为O(n^3)  \n 时间复杂度较高，完成leetcode上面的测试需要7ms。\n\n### 代码：\n\n```java\n	public List<String> addLetter(List<String> list, String s) {\n		List<String> newList = new ArrayList<String>();\n		for (int j = 0; j < list.size(); j++) {\n			for (int i = 0; i < s.length(); i++) {\n				newList.add(list.get(j) + s.charAt(i));\n			}\n		}\n		return newList;\n	}\n\n	public List<String> letterCombinations(String digits) {\n		HashMap<String, String> map = new HashMap<>();\n		map.put(\"2\", \"abc\");\n		map.put(\"3\", \"def\");\n		map.put(\"4\", \"ghi\");\n		map.put(\"5\", \"jkl\");\n		map.put(\"6\", \"mno\");\n		map.put(\"7\", \"pqrs\");\n		map.put(\"8\", \"tuv\");\n		map.put(\"9\", \"wxyz\");\n		List<String> result = new ArrayList<>();\n\n		if (digits.length() == 0) {\n			return result;\n		}\n		result.add(\"\");\n		for (int i = 0; i < digits.length(); i++) {\n			result = addLetter(result, map.get(String.valueOf(digits.charAt(i))));\n		}\n\n		return result;\n	}\n\n```\n\n\n\n##  解法二：回溯法(类似于建树的DFS深度优先搜索，深度搜索)\n\n首先建立手机按键与字符的对应关系，利用Map存储。\n我们先建立一个空字符串letter,来临时存储组合的结果字符串\n 我们利用递归，拿出digits中的第一个按键对应的字符串，\n然后遍历字符串中的每一个字符，与当前的字符串letter连接，\n连接后，我们直接递归去找下一个按键，依次拼接\n 最终，当没有新的按键输入，那么当前的字符串letter就是最终字符串，（这也是递归结束的条件，递归的出口）\n将其保存到最终的集合result中，再依次递归\n退出递归后，得到的集合result就是最终结果。\n\n时间复杂度：表面看上去类似于 O(n)。但是如果细究的话肯定不止O(n)。\n\nLeetcode测试案例，运行时间只需要1ms\n\n\n\n### 代码：\n\n```java\n	Map<String, String> phoneMap = new HashMap<String, String>() {\n		{\n			put(\"2\", \"abc\");\n			put(\"3\", \"def\");\n			put(\"4\", \"ghi\");\n			put(\"5\", \"jkl\");\n			put(\"6\", \"mno\");\n			put(\"7\", \"pqrs\");\n			put(\"8\", \"tuv\");\n			put(\"9\", \"wxyz\");\n		}\n	};\n\n	List<String> result = new ArrayList<>();\n\n	public void addLetter2(String letter, String nextLetter) {\n		if (nextLetter.length() == 0) {\n			result.add(letter);\n		} else {\n			String digit = String.valueOf(nextLetter.charAt(0));\n			String letters = phoneMap.get(digit);\n\n			for (int i = 0; i < letters.length(); i++) {\n				String c = String.valueOf(letters.charAt(i));\n				addLetter2(letter + c, nextLetter.substring(1));\n			}\n		}\n	}\n\n	public List<String> letterCombinations2(String digits) {\n		if (digits.length() != 0)\n			addLetter2(\"\", digits);\n		return result;\n	}\n```\n\n', 0, 0, '2020-08-06 23:39:03', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/\n\n题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n示例:\n输入：\"23\"输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].解法一：普通的循环(类似于建树的BFS广度优先搜索，层序遍历)首先建立手机按键与字符的对应关系，利用Map存储。我们可以利用遍历digits的每一个字符，依次把当前数字对应的字符串添加到最终的list集合。每一拿到一个数字按键，拿到按键对应的字符串s，将当前的list集合和字符串按照笛卡尔积的形式拼接，组合形成新的list。然后将list返回，进行下一个按键的拼接。循环结束，返回结果字符串集合。\n 缺点：时间复杂度为O(n^3) 时间复杂度较高，完成leetcode上面的测试需要7ms。\n代码：    public List<String> addLetter(List<String> list, String s) {        List<String> newList = new ArrayList<String>();        for (int j = 0; j < list.size(); j++) {            for (int i = 0; i < s.length(); i++) {                newList.add(list.get(j) + s.charAt(i));            }        }        return newList;    }    public List<String> letterCombinations(String digits) {        HashMap<String, String> map = new HashMap<>();        map.put(\"2\", \"abc\");        map.put(\"3\", \"def\");        map.put(\"4\", \"ghi\");        map.put(\"5\", \"jkl\");        map.put(\"6\", \"mno\");        map.put(\"7\", \"pqrs\");        map.put(\"8\", \"tuv\");        map.put(\"9\", \"wxyz\");        List<String> result = new ArrayList<>();        if (digits.length() == 0) {            return result;        }        result.add(\"\");        for (int i = 0; i < digits.length(); i++) {            result = addLetter(result, map.get(String.valueOf(digits.charAt(i))));        }        return result;    }\n解法二：回溯法(类似于建树的DFS深度优先搜索，深度搜索)首先建立手机按键与字符的对应关系，利用Map存储。我们先建立一个空字符串letter,来临时存储组合的结果字符串 我们利用递归，拿出digits中的第一个按键对应的字符串，然后遍历字符串中的每一个字符，与当前的字符串letter连接，连接后，我们直接递归去找下一个按键，依次拼接 最终，当没有新的按键输入，那么当前的字符串letter就是最终字符串，（这也是递归结束的条件，递归的出口）将其保存到最终的集合result中，再依次递归退出递归后，得到的集合result就是最终结果。\n时间复杂度：表面看上去类似于 O(n)。但是如果细究的话肯定不止O(n)。\nLeetcode测试案例，运行时间只需要1ms\n代码：    Map<String, String> phoneMap = new HashMap<String, String>() {        {            put(\"2\", \"abc\");            put(\"3\", \"def\");            put(\"4\", \"ghi\");            put(\"5\", \"jkl\");            put(\"6\", \"mno\");            put(\"7\", \"pqrs\");            put(\"8\", \"tuv\");            put(\"9\", \"wxyz\");        }    };    List<String> result = new ArrayList<>();    public void addLetter2(String letter, String nextLetter) {        if (nextLetter.length() == 0) {            result.add(letter);        } else {            String digit = String.valueOf(nextLetter.charAt(0));            String letters = phoneMap.get(digit);            for (int i = 0; i < letters.length(); i++) {                String c = String.valueOf(letters.charAt(i));                addLetter2(letter + c, nextLetter.substring(1));            }        }    }    public List<String> letterCombinations2(String digits) {        if (digits.length() != 0)            addLetter2(\"\", digits);        return result;    }\n', 0, 1);
INSERT INTO `t_article` VALUES (76, '18.四数之和（难度：中等）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/4sum/\n\n##问题描述\n\n\n给定一个包含 *n* 个整数的数组 `nums` 和一个目标值 `target`，判断 `nums` 中是否存在四个元素 *a，**b，c* 和 *d* ，使得 *a* + *b* + *c* + *d* 的值与 `target` 相等？找出所有满足条件且不重复的四元组。\n\n**注意：**\n\n答案中不可以包含重复的四元组。\n\n**示例：**\n\n```\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n\n满足要求的四元组集合为：\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n```\n\n\n\n## 解法一：双指针法 + 排序\n\n**解法思路：**\n\n若是做过[15. 三数之和](https://leetcode-cn.com/problems/3sum/)会发现这两个题是一个解题思路。\n\n我们利用一个双重循环a和b来控制四个数中最小的两数，再用双指针l和r来控制另外两数。\n\n计算：sum = nums[a]+nums[b]+nums[l]+nums[r];\n\n若sum == target，则把这四个数添加到结果数组中\n\n若sum > target，则说明r太大了，将r--，将指针r向左移动。\n\n若sum < target，则说明l太大了，将l++，将指针l向右移动。\n\n**解决重复结果问题：**\n\n我们在四层变量值改变的时候，可以判断一下，是否和上一次的值相等，若相等，直接跳过这次循环。\n\n\n\n**时间复杂度优化：**\n\n我们在外两层a和b变量值改变的时候，可以计算一下，他们的最大值和最小值，若最大值比target还小，或者最小值比target还大，都可以直接跳过。\n\n![image-20200522181019333](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200522181019333.png)\n\n\n\n\n\n### 代码:\n\n```java\nclass Solution {\n	public List<List<Integer>> fourSum(int[] nums, int target) {\n		List<List<Integer>> results = new ArrayList<List<Integer>>();\n		int l,r;\n		int sum;\n		int max,min;\n		Arrays.sort(nums);\n		int len = nums.length;\n		\n		for(int a = 0;a<len-3;a++) {\n			//当nums[a] == nums[a-1] 直接跳过\n			if(a>0 && nums[a] == nums[a-1]) {\n				continue;\n			}\n			\n			//获取当前的最大值，如果最大值比目标值还小，直接跳过\n			max = nums[a]+nums[len-3]+nums[len-2]+nums[len-1];\n			if(max<target) {\n				continue;\n			}\n			\n			//获取当前的最小值，如果最小值比目标值还大，直接跳过\n			min = nums[a]+nums[a+1]+nums[a+2]+nums[a+3];\n			if(min>target) {\n				continue;\n			}\n			\n			for(int b = a+1;b<len-2;b++) {\n				//当nums[b] == nums[b-1]直接跳过\n				if(b>a+1 && nums[b] == nums[b-1]) {\n					continue;\n				}\n				l = b+1;\n				r = len-1;\n				\n				//获取当前的最大值，如果最大值比目标值还小，直接跳过\n				max = nums[a]+nums[b]+nums[r-1]+nums[r];\n				if(max<target) {\n					continue;\n				}\n				\n				//获取当前的最小值，如果最小值比目标值还大，直接跳过\n				min = nums[a]+nums[b]+nums[l]+nums[l+1];\n				if(min>target) {\n					continue;\n				}\n				\n				while(l<r) {\n					sum = nums[a]+nums[b]+nums[l]+nums[r];\n					if(sum == target) {\n						results.add(Arrays.asList(nums[a],nums[b],nums[l],nums[r]));\n						l++;\n						r--;\n						\n						//当nums[r]==nums[r+1]直接跳过\n						while(r<len-1 && r>l && nums[r]==nums[r+1]) {\n							r--;\n						}\n						//当nums[l]==nums[l-1]直接跳过\n						while(l>b+1 && r>l && nums[l]==nums[l-1]) {\n							l++;\n						}\n					}else if(sum > target) {\n						r--;\n					}else {\n						l++;\n					}\n				}\n			}\n		}\n		return results;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:41:27', 7, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/4sum/\n\n问题描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，**b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n注意：\n答案中不可以包含重复的四元组。\n示例：\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[  [-1,  0, 0, 1],  [-2, -1, 1, 2],  [-2,  0, 0, 2]]解法一：双指针法 + 排序解法思路：\n若是做过15. 三数之和会发现这两个题是一个解题思路。\n我们利用一个双重循环a和b来控制四个数中最小的两数，再用双指针l和r来控制另外两数。\n计算：sum = nums[a]+nums[b]+nums[l]+nums[r];\n若sum == target，则把这四个数添加到结果数组中\n若sum > target，则说明r太大了，将r—，将指针r向左移动。\n若sum < target，则说明l太大了，将l++，将指针l向右移动。\n解决重复结果问题：\n我们在四层变量值改变的时候，可以判断一下，是否和上一次的值相等，若相等，直接跳过这次循环。\n时间复杂度优化：\n我们在外两层a和b变量值改变的时候，可以计算一下，他们的最大值和最小值，若最大值比target还小，或者最小值比target还大，都可以直接跳过。\n\n代码:class Solution {    public List<List<Integer>> fourSum(int[] nums, int target) {        List<List<Integer>> results = new ArrayList<List<Integer>>();        int l,r;        int sum;        int max,min;        Arrays.sort(nums);        int len = nums.length;        for(int a = 0;a<len-3;a++) {            //当nums[a] == nums[a-1] 直接跳过            if(a>0 && nums[a] == nums[a-1]) {                continue;            }            //获取当前的最大值，如果最大值比目标值还小，直接跳过            max = nums[a]+nums[len-3]+nums[len-2]+nums[len-1];            if(max<target) {                continue;            }            //获取当前的最小值，如果最小值比目标值还大，直接跳过            min = nums[a]+nums[a+1]+nums[a+2]+nums[a+3];            if(min>target) {                continue;            }            for(int b = a+1;b<len-2;b++) {                //当nums[b] == nums[b-1]直接跳过                if(b>a+1 && nums[b] == nums[b-1]) {                    continue;                }                l = b+1;                r = len-1;                //获取当前的最大值，如果最大值比目标值还小，直接跳过                max = nums[a]+nums[b]+nums[r-1]+nums[r];                if(max<target) {                    continue;                }                //获取当前的最小值，如果最小值比目标值还大，直接跳过                min = nums[a]+nums[b]+nums[l]+nums[l+1];                if(min>target) {                    continue;                }                while(l<r) {                    sum = nums[a]+nums[b]+nums[l]+nums[r];                    if(sum == target) {                        results.add(Arrays.asList(nums[a],nums[b],nums[l],nums[r]));                        l++;                        r--;                        //当nums[r]==nums[r+1]直接跳过                        while(r<len-1 && r>l && nums[r]==nums[r+1]) {                            r--;                        }                        //当nums[l]==nums[l-1]直接跳过                        while(l>b+1 && r>l && nums[l]==nums[l-1]) {                            l++;                        }                    }else if(sum > target) {                        r--;                    }else {                        l++;                    }                }            }        }        return results;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (77, '19. 删除链表的倒数第N个节点（难度：中等）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/\n\n## 问题描述\n\n\n给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。\n\n**示例：**\n\n```\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n```\n\n**说明：**\n\n给定的 *n* 保证是有效的。\n\n**进阶：**\n\n你能尝试使用一趟扫描实现吗？\n\n\n\n## 解法一：暴力法(需要遍历两次)\n\n遍历链表，计算出链表长度len，然后计算出需要删除的结点的下标位置tag = len - n;\n\n再遍历链表，让需要删除的结点的上一个结点的next指向需删除结点的next结点。\n\n**复杂度分析**\n\n**时间复杂度：O(L)**，该算法对列表进行了两次遍历，首先计算了列表的长度 L其次找到第 (L - n) 个结点。 操作执行了 2L-n 步，时间复杂度为 O(L)。\n\n**空间复杂度：O(1)**，我们只用了常量级的额外空间。\n\n![image-20200523224459945](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200523224459945.png)\n\n`\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        int len = 1;\n        if(head == null) {\n        	return null;\n        }\n        ListNode node = head;\n		while(node.next!=null) {\n        	len ++;\n        	node = node.next;\n        }\n		node = head;\n		int tag = len - n;\n		if(tag == 0) {\n			return head.next;\n		}\n		while(node.next!=null) {\n			tag--;\n			if(tag == 0) {\n				node.next = node.next.next;\n				break;\n			}\n			node = node.next;\n		}\n		return head;\n    }\n}\n```\n\n`\n\n## 解法二：双指针法(只要一次遍历)\n\n我们可以使用两个指针L和R来遍历数组 , 先让两个结点的距离相聚n-1 , 起初让两个指针都指向头结点 , 然后先让R指针向后移动 n-1个结点。然后同时移动两个指针，当R指针移动到最后一个的时候，L指针指向的刚好是需要删点的结点。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n		ListNode dummy = new ListNode(0);\n		dummy.next = head;\n        ListNode R = dummy;\n        ListNode L = dummy;\n        for(int i = 0;i<n+1;i++) {\n        	R = R.next;\n        }\n\n		while(R!=null) {\n			R = R.next;\n			L = L.next;\n		}\n		L.next = L.next.next;\n		\n		return dummy.next;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:42:35', 7, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/\n\n问题描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n示例：\n给定一个链表: 1->2->3->4->5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1->2->3->5.说明：\n给定的 n 保证是有效的。\n进阶：\n你能尝试使用一趟扫描实现吗？\n解法一：暴力法(需要遍历两次)遍历链表，计算出链表长度len，然后计算出需要删除的结点的下标位置tag = len - n;\n再遍历链表，让需要删除的结点的上一个结点的next指向需删除结点的next结点。\n复杂度分析\n时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L其次找到第 (L - n) 个结点。 操作执行了 2L-n 步，时间复杂度为 O(L)。\n空间复杂度：O(1)，我们只用了常量级的额外空间。\n\n`\n/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode removeNthFromEnd(ListNode head, int n) {        int len = 1;        if(head == null) {            return null;        }        ListNode node = head;        while(node.next!=null) {            len ++;            node = node.next;        }        node = head;        int tag = len - n;        if(tag == 0) {            return head.next;        }        while(node.next!=null) {            tag--;            if(tag == 0) {                node.next = node.next.next;                break;            }            node = node.next;        }        return head;    }}\n`\n解法二：双指针法(只要一次遍历)我们可以使用两个指针L和R来遍历数组 , 先让两个结点的距离相聚n-1 , 起初让两个指针都指向头结点 , 然后先让R指针向后移动 n-1个结点。然后同时移动两个指针，当R指针移动到最后一个的时候，L指针指向的刚好是需要删点的结点。\n/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode removeNthFromEnd(ListNode head, int n) {        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode R = dummy;        ListNode L = dummy;        for(int i = 0;i<n+1;i++) {            R = R.next;        }        while(R!=null) {            R = R.next;            L = L.next;        }        L.next = L.next.next;        return dummy.next;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (78, '20. 有效的括号（难度：简单）', 8, '\n\n> 题目链接：https://leetcode-cn.com/problems/valid-parentheses/\n\n## 问题描述\n\n给定一个只包括 `\'(\'`，`\')\'`，`\'{\'`，`\'}\'`，`\'[\'`，`\']\'` 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n1. 左括号必须用相同类型的右括号闭合。\n2. 左括号必须以正确的顺序闭合。\n\n注意空字符串可被认为是有效字符串。\n\n**示例 1:**\n\n```\n输入: \"()\"\n输出: true\n```\n\n**示例 2:**\n\n```\n输入: \"()[]{}\"\n输出: true\n```\n\n**示例 3:**\n\n```\n输入: \"(]\"\n输出: false\n```\n\n**示例 4:**\n\n```\n输入: \"([)]\"\n输出: false\n```\n\n**示例 5:**\n\n```\n输入: \"{[]}\"\n输出: true\n```\n\n\n\n## 解法一：\n\n可以利用栈的概念，遍历字符串s，\n\n每次获取一个字符，\n\n- 如果为上括号直接入栈；\n- 如果为下括号，判断栈顶元素是否为该字符对应的上括号，\n  - 若是，则把栈顶元素出栈；\n  - 若不是，直接返回flase。\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        boolean flag = true;\n		Stack<Character> stack = new Stack<>();\n		\n		Map<Character, Character> map = new HashMap<Character, Character>(){\n			{\n				put(\'}\', \'{\');\n				put(\')\', \'(\');\n				put(\']\', \'[\');\n			}\n		};\n		if(s.length()==0) {\n			return true;\n		}\n		\n		for(int i = 0;i<s.length();i++) {\n			\n			if(!stack.isEmpty() && map.get(s.charAt(i))==stack.lastElement()) {\n				stack.pop();\n			}else {\n				stack.push(s.charAt(i));\n			}\n		}\n		flag = stack.isEmpty();\n		\n		return flag;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:43:32', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/valid-parentheses/\n\n问题描述给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。\n注意空字符串可被认为是有效字符串。\n示例 1:\n输入: \"()\"输出: true示例 2:\n输入: \"()[]{}\"输出: true示例 3:\n输入: \"(]\"输出: false示例 4:\n输入: \"([)]\"输出: false示例 5:\n输入: \"{[]}\"输出: true解法一：可以利用栈的概念，遍历字符串s，\n每次获取一个字符，\n\n如果为上括号直接入栈；如果为下括号，判断栈顶元素是否为该字符对应的上括号，\n若是，则把栈顶元素出栈；若不是，直接返回flase。\n\nclass Solution {    public boolean isValid(String s) {        boolean flag = true;        Stack<Character> stack = new Stack<>();        Map<Character, Character> map = new HashMap<Character, Character>(){            {                put(\'}\', \'{\');                put(\')\', \'(\');                put(\']\', \'[\');            }        };        if(s.length()==0) {            return true;        }        for(int i = 0;i<s.length();i++) {            if(!stack.isEmpty() && map.get(s.charAt(i))==stack.lastElement()) {                stack.pop();            }else {                stack.push(s.charAt(i));            }        }        flag = stack.isEmpty();        return flag;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (79, '21. 合并两个有序链表（难度：简单）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/\n\n## 问题描述\n\n\n将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n**示例：**\n\n```\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n```\n\n\n\n## 解法一：\n\n创建一个新链表`result`，然后用指针`l1`和`l2`遍历这两个链表，比较遍历到的元素，把小的添加到新链表，然后把指针向后移动。直到有一个指针遍历完了整个链表，则将另一个链表的剩余元素直接补到`result`后面。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head = new ListNode(0);\n		ListNode result = head;\n		if(l1 == null) {\n			return l2;\n		}\n		if(l2 == null) {\n			return l1;\n		}\n		\n		while(l1 != null && l2 != null) {\n			if(l1.val < l2.val) {\n				head.next = l1;\n				l1 = l1.next;\n			}else {\n				head.next = l2;\n				l2 = l2.next;\n			}\n			head = head.next;\n		}\n		\n		if(l1!=null) {\n			head.next = l1;\n		}\n		if(l2!=null) {\n			head.next = l2;\n		}\n		return result.next;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:44:18', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/\n\n问题描述将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n示例：\n输入：1->2->4, 1->3->4输出：1->1->2->3->4->4解法一：创建一个新链表result，然后用指针l1和l2遍历这两个链表，比较遍历到的元素，把小的添加到新链表，然后把指针向后移动。直到有一个指针遍历完了整个链表，则将另一个链表的剩余元素直接补到result后面。\n/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        ListNode head = new ListNode(0);        ListNode result = head;        if(l1 == null) {            return l2;        }        if(l2 == null) {            return l1;        }        while(l1 != null && l2 != null) {            if(l1.val < l2.val) {                head.next = l1;                l1 = l1.next;            }else {                head.next = l2;                l2 = l2.next;            }            head = head.next;        }        if(l1!=null) {            head.next = l1;        }        if(l2!=null) {            head.next = l2;        }        return result.next;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (80, '22. 括号生成（难度：中等）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/generate-parentheses/\n\n## 问题描述\n\n\n数字 *n* 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。\n\n \n\n**示例：**\n\n```\n输入：n = 3\n输出：[\n       \"((()))\",\n       \"(()())\",\n       \"(())()\",\n       \"()(())\",\n       \"()()()\"\n     ]\n```\n\n\n\n# 解法一：暴力法\n\n由题意得，一个有n对括号，那么所有字符一共就是`2n`个，我们可以暴力`2n`个括号的所有组合，然后筛选出符合条件的。\n\n筛选条件：遍历生成字符串，	\n\n- 碰到左括号，就给lNum ++；\n- 碰到右括号，就给lNum --；\n- 若右括号数量大于左括号直接返回false；\n- 遍历完，判断 lNum是否等于0；\n  - INum不等于0，返回false；\n  - INum等于0，返回true；\n\n\n\n代码：\n\n```java\nclass Solution {\n    	public List<String> generateParenthesis(int n) {\n        List<String> combinations = new ArrayList();\n        generateAll(new char[2 * n], 0, combinations);\n        return combinations;\n    }\n\n    public void generateAll(char[] current, int pos, List<String> result) {\n        if (pos == current.length) {\n            if (valid(current))\n                result.add(new String(current));\n        } else {\n            current[pos] = \'(\';\n            generateAll(current, pos+1, result);\n            current[pos] = \')\';\n            generateAll(current, pos+1, result);\n        }\n    }\n\n    public boolean valid(char[] current) {\n        int balance = 0;\n        for (char c: current) {\n            if (c == \'(\') balance++;\n            else balance--;\n            if (balance < 0) return false;\n        }\n        return (balance == 0);\n    }\n}\n```\n\n\n\n\n\n## 解法二：回溯法\n\n我们可以利用，上述递归方法，进行剪枝，剪掉不符合条件的分支。\n\n**剪枝条件：**\n\n- 若添加的右括号数目大于左括号，那么直接剪掉；\n- 若左括号数目大于n直接剪掉。\n\n即：\n\n- 当左括号数目小于n时，我们可以添加左括号\n- 当右括号数目小于左括号时，我们可以添加右括号\n\n\n\n```java\nclass Solution {\n    public List<String> generateParenthesis(int n){\n    	List<String> result = new ArrayList();\n    	createStr(0,0,n,new StringBuilder(),result);\n        return result;\n    }\n    \n    public void createStr(int l,int r,int n, StringBuilder str,List<String> result) {\n		if(str.length() == n*2) {\n			result.add(str.toString());\n			return;\n		}\n		if(l<n) {\n			str.append(\"(\");\n			createStr(l+1, r, n, str, result);\n			str.deleteCharAt(str.length()-1);\n		}\n		if(r<l) {\n			str.append(\")\");\n			createStr(l, r+1, n, str, result);\n			str.deleteCharAt(str.length()-1);\n		}\n	}\n}\n```\n\n', 0, 0, '2020-08-06 23:45:23', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/generate-parentheses/\n\n问题描述数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n示例：\n输入：n = 3输出：[       \"((()))\",       \"(()())\",       \"(())()\",       \"()(())\",       \"()()()\"     ]解法一：暴力法由题意得，一个有n对括号，那么所有字符一共就是2n个，我们可以暴力2n个括号的所有组合，然后筛选出符合条件的。\n筛选条件：遍历生成字符串，    \n\n碰到左括号，就给lNum ++；碰到右括号，就给lNum —；若右括号数量大于左括号直接返回false；遍历完，判断 lNum是否等于0；\nINum不等于0，返回false；INum等于0，返回true；\n\n代码：\nclass Solution {        public List<String> generateParenthesis(int n) {        List<String> combinations = new ArrayList();        generateAll(new char[2 * n], 0, combinations);        return combinations;    }    public void generateAll(char[] current, int pos, List<String> result) {        if (pos == current.length) {            if (valid(current))                result.add(new String(current));        } else {            current[pos] = \'(\';            generateAll(current, pos+1, result);            current[pos] = \')\';            generateAll(current, pos+1, result);        }    }    public boolean valid(char[] current) {        int balance = 0;        for (char c: current) {            if (c == \'(\') balance++;            else balance--;            if (balance < 0) return false;        }        return (balance == 0);    }}\n解法二：回溯法我们可以利用，上述递归方法，进行剪枝，剪掉不符合条件的分支。\n剪枝条件：\n\n若添加的右括号数目大于左括号，那么直接剪掉；若左括号数目大于n直接剪掉。\n即：\n\n当左括号数目小于n时，我们可以添加左括号当右括号数目小于左括号时，我们可以添加右括号\nclass Solution {    public List<String> generateParenthesis(int n){        List<String> result = new ArrayList();        createStr(0,0,n,new StringBuilder(),result);        return result;    }    public void createStr(int l,int r,int n, StringBuilder str,List<String> result) {        if(str.length() == n*2) {            result.add(str.toString());            return;        }        if(l<n) {            str.append(\"(\");            createStr(l+1, r, n, str, result);            str.deleteCharAt(str.length()-1);        }        if(r<l) {            str.append(\")\");            createStr(l, r+1, n, str, result);            str.deleteCharAt(str.length()-1);        }    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (81, '23. 合并K个排序链表（难度：困难）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/merge-k-sorted-lists/\n\n## 问题描述\n\n合并 *k* 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n\n**示例:**\n\n```\n输入:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n输出: 1->1->2->3->4->4->5->6\n```\n\n\n\n## 解法一：暴力法\n\n创建一个数组，把所有链表的结点的val放进去，然后排序，再重组新的链表。\n\n![image-20200525204038844](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200525204038844.png)\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n		ListNode result = new ListNode(0);\n		List<Integer> aList = new ArrayList<Integer>();\n		ListNode temp =  result;\n		for(int i = 0;i<lists.length;i++) {\n			while(lists[i]!=null) {\n				aList.add(lists[i].val);\n				lists[i] = lists[i].next;\n			}\n		}\n		Collections.sort(aList);\n		\n		for (Integer integer : aList) {\n			ListNode node = new ListNode(integer);\n			temp.next = node;\n			temp = temp.next;\n		}\n		\n		return result.next;\n	}\n}\n```\n\n\n\n## 解法二：优化队列+一次遍历\n\n我们可以创建一个优化队列，首先把所有链表的头结点放入，然后每次拿出队列中最小的结点（即队首元素），让该结点出队，加入结果链表，并判断该结点是否还有next结点，若有，则把next结点继续入队，这样直到队列为空，就会得到结果链表。\n\n![image-20200525203957138](image/image-20200525203957138.png)\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n		ListNode result = new ListNode(0);\n		ListNode temp = result;\n		PriorityQueue<ListNode> queue = new PriorityQueue<>(new Comparator<ListNode>() {\n			@Override\n			public int compare(ListNode o1, ListNode o2) {			\n				return o1.val-o2.val;\n			}\n		});\n		\n		for(ListNode node:lists ) {\n			if(node!=null) {\n				queue.add(node);\n			}\n		}\n		\n		while(!queue.isEmpty()) {\n			ListNode node =  queue.poll();\n			temp.next = node;\n			temp = temp.next;\n			if(node.next!=null) {\n				queue.add(node.next);\n			}\n		}\n		\n		return result.next;\n	}\n}\n```\n\n\n\n## 解法三：分治法\n\n我们可以把 k个链表分解为 k/2 组 两个链表的合并，然后再把 合并后的 k/2 个链表看成是 k/4 组两个链表的合并，然后 k/8,k/16……\n\n直到最后合并成一个链表。\n\n两个链表的合并可以参照我们之前的 21.合并两个有序链表 的解法。\n\n![image-20200525203455413](image/image-20200525203455413.png)\n\n\n\n代码：\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n		if (lists.length == 0) {\n			return null;\n		}\n		return divideRule(lists, 0, lists.length - 1);\n	}\n\n	public ListNode divideRule(ListNode[] lists, int l, int r) {\n		if (l == r) {\n			return lists[l];\n		}\n		int mid = l + (r - l) / 2;\n		ListNode l1 = divideRule(lists, l, mid);\n		ListNode r1 = divideRule(lists, mid + 1, r);\n		return mergeTwoLists(l1, r1);\n	}\n\n	// 合并两个有序链表\n	public ListNode mergeTwoLists(ListNode a, ListNode b) {\n		if (a == null || b == null) {\n			return (a == null) ? b : a;\n		}\n		if (a.val <= b.val) {\n			a.next = mergeTwoLists(a.next, b);\n			return a;\n		} else {\n			b.next = mergeTwoLists(a, b.next);\n			return b;\n		}\n	}\n}\n```\n\n', 0, 0, '2020-08-06 23:46:07', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/merge-k-sorted-lists/\n\n问题描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n示例:\n输入:[  1->4->5,  1->3->4,  2->6]输出: 1->1->2->3->4->4->5->6解法一：暴力法创建一个数组，把所有链表的结点的val放进去，然后排序，再重组新的链表。\n\n/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode mergeKLists(ListNode[] lists) {        ListNode result = new ListNode(0);        List<Integer> aList = new ArrayList<Integer>();        ListNode temp =  result;        for(int i = 0;i<lists.length;i++) {            while(lists[i]!=null) {                aList.add(lists[i].val);                lists[i] = lists[i].next;            }        }        Collections.sort(aList);        for (Integer integer : aList) {            ListNode node = new ListNode(integer);            temp.next = node;            temp = temp.next;        }        return result.next;    }}\n解法二：优化队列+一次遍历我们可以创建一个优化队列，首先把所有链表的头结点放入，然后每次拿出队列中最小的结点（即队首元素），让该结点出队，加入结果链表，并判断该结点是否还有next结点，若有，则把next结点继续入队，这样直到队列为空，就会得到结果链表。\n\n/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode mergeKLists(ListNode[] lists) {        ListNode result = new ListNode(0);        ListNode temp = result;        PriorityQueue<ListNode> queue = new PriorityQueue<>(new Comparator<ListNode>() {            @Override            public int compare(ListNode o1, ListNode o2) {                            return o1.val-o2.val;            }        });        for(ListNode node:lists ) {            if(node!=null) {                queue.add(node);            }        }        while(!queue.isEmpty()) {            ListNode node =  queue.poll();            temp.next = node;            temp = temp.next;            if(node.next!=null) {                queue.add(node.next);            }        }        return result.next;    }}\n解法三：分治法我们可以把 k个链表分解为 k/2 组 两个链表的合并，然后再把 合并后的 k/2 个链表看成是 k/4 组两个链表的合并，然后 k/8,k/16……\n直到最后合并成一个链表。\n两个链表的合并可以参照我们之前的 21.合并两个有序链表 的解法。\n\n代码：\n/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode mergeKLists(ListNode[] lists) {        if (lists.length == 0) {            return null;        }        return divideRule(lists, 0, lists.length - 1);    }    public ListNode divideRule(ListNode[] lists, int l, int r) {        if (l == r) {            return lists[l];        }        int mid = l + (r - l) / 2;        ListNode l1 = divideRule(lists, l, mid);        ListNode r1 = divideRule(lists, mid + 1, r);        return mergeTwoLists(l1, r1);    }    // 合并两个有序链表    public ListNode mergeTwoLists(ListNode a, ListNode b) {        if (a == null || b == null) {            return (a == null) ? b : a;        }        if (a.val <= b.val) {            a.next = mergeTwoLists(a.next, b);            return a;        } else {            b.next = mergeTwoLists(a, b.next);            return b;        }    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (82, '24. 两两交换链表中的节点（难度：中等）', 8, '\n题目链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n## 问题描述\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\n\n \n\n**示例:**\n\n```\n给定 1->2->3->4, 你应该返回 2->1->4->3.\n```\n\n\n\n## 解法一：利用单指针操作\n\n### **算法思路：**\n\n（1）创建初始化结果链表result，并创建临时指针指向result\n\n（2）若head!=null 并且 head.next !=null，则进入循环\n\n（3）创建临时指针t指向head.next.next\n\n（4）re.next = head.next\n\n（5）re = re.next\n\n（6）re.next = head\n\n（7）re.next.next = t\n\n（8）re = re.next\n\n（9）head = t\n\n（10）本轮循环结束，继续下一轮循环，从第（2）步开始\n\n（11）循环结束，re连接起来的路径，即result链表就是最后的结果链表\n\n\n\n### 图解：\n\n注释：	（1）粉色的路径为result链表\n\n​				（2）红色的线条为当前步骤进行的改动\n\n​				（3）蓝色的字体为当前步骤的备注\n\n​				（4）红色字体为当前步骤\n\n**（1）**\n\n![1](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/1-1591953266803.jpg)\n\n\n\n（2）![2](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/2.jpg)\n\n\n\n（3）![3](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/3.jpg)\n\n（4）\n\n![4](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/4.jpg)\n\n\n\n（5）\n\n![5](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/5.jpg)\n\n\n\n（6）\n\n![6](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/6.jpg)\n\n（7）\n\n![7](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/7.jpg)\n\n\n\n### 代码实现：\n\n\n\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) {\n			return head;\n		}\n		\n		ListNode result = new ListNode(0);\n		ListNode re = result;\n		\n		while(head!=null && head.next!= null) {\n			ListNode t = head.next.next;\n			re.next = head.next;\n			re = re.next;\n			re.next = head;\n			re = re.next;\n			re.next = t;\n			head = t;\n		}\n		\n		return result.next;	\n    }\n}\n```\n\n\n\n', 0, 0, '2020-08-06 23:46:44', 2, 0, 1, '题目链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/\n问题描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例:\n给定 1->2->3->4, 你应该返回 2->1->4->3.解法一：利用单指针操作算法思路：（1）创建初始化结果链表result，并创建临时指针指向result\n（2）若head!=null 并且 head.next !=null，则进入循环\n（3）创建临时指针t指向head.next.next\n（4）re.next = head.next\n（5）re = re.next\n（6）re.next = head\n（7）re.next.next = t\n（8）re = re.next\n（9）head = t\n（10）本轮循环结束，继续下一轮循环，从第（2）步开始\n（11）循环结束，re连接起来的路径，即result链表就是最后的结果链表\n图解：注释：    （1）粉色的路径为result链表\n​                （2）红色的线条为当前步骤进行的改动\n​                （3）蓝色的字体为当前步骤的备注\n​                （4）红色字体为当前步骤\n（1）\n\n（2）\n（3）\n（4）\n\n（5）\n\n（6）\n\n（7）\n\n代码实现：/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode swapPairs(ListNode head) {        if(head == null || head.next == null) {            return head;        }        ListNode result = new ListNode(0);        ListNode re = result;        while(head!=null && head.next!= null) {            ListNode t = head.next.next;            re.next = head.next;            re = re.next;            re.next = head;            re = re.next;            re.next = t;            head = t;        }        return result.next;        }}\n', 0, 1);
INSERT INTO `t_article` VALUES (83, '25. K 个一组翻转链表（难度：困难）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\n\n\n\n## 题目描述：\n\n给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。\n\n*k* 是一个正整数，它的值小于或等于链表的长度。\n\n如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n \n\n**示例：**\n\n给你这个链表：`1->2->3->4->5`\n\n当 *k* = 2 时，应当返回: `2->1->4->3->5`\n\n当 *k* = 3 时，应当返回: `3->2->1->4->5`\n\n \n\n**说明：**\n\n- 你的算法只能使用常数的额外空间。\n- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。\n\n\n\n## 解题思路：\n\n由题意可知，我们需要把链表按照K个结点一组进行分组，然后再给每组进行倒置，然后再连起来。\n\n因此，问题就分为了，两个子问题：\n\n（1）把链表按照K个结点一组分组，并记录头结点head和尾结点tail。\n\n（2）根据子链表的head和tail结点，将子链表进行倒置，并且返回head和tail指针。\n\n\n\n### 1、解决对任意长度链表的倒置：\n\n#### 思路：\n\n（1）特殊情况处理，若链表为null或者只有一个结点，我们直接把原链表返回。\n\n（2）我们可以利用头插法的思想，对链表进行操作，这块的头插法是把尾部最后一个结点当成头的。\n\n（3）我们利用一个指针temp起初指向head结点，用temp遍历整个子链表，若temp指向了tail结点，则退出循环\n\n（4）我们通过temp每次从头部head拿到一个结点，把他插到尾部结点tail和tail.next的之间，这也就是我所说的头插法。\n\n\n\n#### 图解：\n\n（1）![1](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/1-1590576834298.jpg)\n\n（2）![2](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/2-1590576836665.jpg)\n\n（3）![3](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/3-1590576840252.jpg)\n\n（4）![4](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/4-1590576842817.jpg)\n\n（5）![5](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/5-1590576844662.jpg)\n\n（6）![6](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/6-1590576846943.jpg)\n\n\n\n#### 代码：\n\n```java\npublic ListNode[] reversalList(ListNode head,ListNode tail) {\n		ListNode[] result =  {head,tail};\n		if(head == null || head == tail) {\n			\n			return result;\n		}\n		ListNode temp = head;\n		while(temp!=tail) {\n			ListNode t = tail.next;\n			tail.next = temp;\n			ListNode n = temp.next;\n			temp.next = t;\n			temp = n;\n		}\n		return result;\n	}\n```\n\n\n\n### 2、K 个一组翻转链表\n\n#### 思路：\n\n我们可以使用两指针head和tail来记录子链表，利用tail指针遍历链表，先让head和tail都指向头结点，再使用一个计数器i来记录当前的结点在链表中的位置，当`i % k == 0`时，head和tail之间的链表就是截取的子链表，然后我们将它进行倒置，然后再连接到结果链表result上面，当遍历完整个链表，就拿到了最终结果。\n\n\n\n代码：\n\n```java\npublic ListNode reverseKGroup(ListNode head, int k) {\n		ListNode result = new ListNode(0);\n		ListNode re = result;\n		ListNode tail = head;\n		int i = 0;\n		while( tail!= null) {		\n			i++;\n			if( i%k == 0) {\n				ListNode tailNext = tail.next;\n				ListNode[] temp = reversalList(head, tail);\n				re.next = temp[1];\n				re = temp[0];\n				re.next = tailNext;\n				head = tailNext;\n				tail = re;\n			}\n			tail = tail.next;\n		}\n		return result.next;\n    }\n```\n\n\n\n\n\n## 整体代码：\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    	public ListNode reverseKGroup(ListNode head, int k) {\n		ListNode result = new ListNode(0);\n		ListNode re = result;\n		ListNode tail = head;\n		int i = 0;\n		while( tail!= null) {		\n			i++;\n			if( i%k == 0) {\n				ListNode tailNext = tail.next;\n				ListNode[] temp = reversalList(head, tail);\n				re.next = temp[1];\n				re = temp[0];\n				re.next = tailNext;\n				head = tailNext;\n				tail = re;\n			}\n			tail = tail.next;\n		}\n		return result.next;\n    }\n	\n	public ListNode[] reversalList(ListNode head,ListNode tail) {\n		ListNode[] result =  {head,tail};\n		if(head == null || head == tail) {\n			\n			return result;\n		}\n		ListNode temp = head;\n		while(temp!=tail) {\n			ListNode t = tail.next;\n			tail.next = temp;\n			ListNode n = temp.next;\n			temp.next = t;\n			temp = n;\n		}\n		return result;\n	}\n}\n```\n\n\n\n\n\n\n\n### 测试代码：\n\n```java\npackage com.company.project.hot100;\n\npublic class Question25 {\n	public class ListNode {\n		 int val;\n		 ListNode next;\n		 ListNode(int x) { val = x; }\n	}\n	\n	\n	public ListNode reverseKGroup(ListNode head, int k) {\n		ListNode result = new ListNode(0);\n		ListNode re = result;\n		ListNode tail = head;\n		int i = 0;\n		while( tail!= null) {		\n			i++;\n			if( i%k == 0) {\n				ListNode tailNext = tail.next;\n				ListNode[] temp = reversalList(head, tail);\n				re.next = temp[1];\n				re = temp[0];\n				re.next = tailNext;\n				head = tailNext;\n				tail = re;\n			}\n			tail = tail.next;\n		}\n		return result.next;\n    }\n	\n	public ListNode[] reversalList(ListNode head,ListNode tail) {\n		ListNode[] result =  {head,tail};\n		if(head == null || head == tail) {\n			\n			return result;\n		}\n		ListNode temp = head;\n		while(temp!=tail) {\n			ListNode t = tail.next;\n			tail.next = temp;\n			ListNode n = temp.next;\n			temp.next = t;\n			temp = n;\n		}\n		return result;\n	}\n	\n	public static void main(String[] args) {\n		Question25 question25 = new Question25();\n		ListNode a = question25.new ListNode(1);\n		ListNode b = question25.new ListNode(2);\n		ListNode c = question25.new ListNode(3);\n		ListNode d = question25.new ListNode(4);\n		ListNode e = question25.new ListNode(5);\n		a.next = b;\n		b.next = c;\n		c.next = d;\n		d.next = e;\n		e.next = null;\n		\n		\n\n		//测试翻转链表方法\n//		ListNode[] result = question25.reversalList(a, e);\n//		ListNode head = result[0];\n//		ListNode tail = result[1];\n//		ListNode r = question25.new ListNode(0);\n//		r.next = tail;\n//		do {\n//			System.out.println(r.next.val);\n//			r = r.next;\n//		} while (r != head);\n		\n		ListNode result = question25.reverseKGroup(a, 3);\n		\n		while (result != null) {\n			System.out.println(result.val);\n			result = result.next;\n		}		\n	}\n		\n}\n\n```\n\n\n\n#### 复杂度分析：\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n', 0, 0, '2020-08-06 23:47:27', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\n\n题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。\n如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n示例：\n给你这个链表：1->2->3->4->5\n当 k = 2 时，应当返回: 2->1->4->3->5\n当 k = 3 时，应当返回: 3->2->1->4->5\n说明：\n\n你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n解题思路：由题意可知，我们需要把链表按照K个结点一组进行分组，然后再给每组进行倒置，然后再连起来。\n因此，问题就分为了，两个子问题：\n（1）把链表按照K个结点一组分组，并记录头结点head和尾结点tail。\n（2）根据子链表的head和tail结点，将子链表进行倒置，并且返回head和tail指针。\n1、解决对任意长度链表的倒置：思路：（1）特殊情况处理，若链表为null或者只有一个结点，我们直接把原链表返回。\n（2）我们可以利用头插法的思想，对链表进行操作，这块的头插法是把尾部最后一个结点当成头的。\n（3）我们利用一个指针temp起初指向head结点，用temp遍历整个子链表，若temp指向了tail结点，则退出循环\n（4）我们通过temp每次从头部head拿到一个结点，把他插到尾部结点tail和tail.next的之间，这也就是我所说的头插法。\n图解：（1）\n（2）\n（3）\n（4）\n（5）\n（6）\n代码：public ListNode[] reversalList(ListNode head,ListNode tail) {        ListNode[] result =  {head,tail};        if(head == null || head == tail) {            return result;        }        ListNode temp = head;        while(temp!=tail) {            ListNode t = tail.next;            tail.next = temp;            ListNode n = temp.next;            temp.next = t;            temp = n;        }        return result;    }\n2、K 个一组翻转链表思路：我们可以使用两指针head和tail来记录子链表，利用tail指针遍历链表，先让head和tail都指向头结点，再使用一个计数器i来记录当前的结点在链表中的位置，当i % k == 0时，head和tail之间的链表就是截取的子链表，然后我们将它进行倒置，然后再连接到结果链表result上面，当遍历完整个链表，就拿到了最终结果。\n代码：\npublic ListNode reverseKGroup(ListNode head, int k) {        ListNode result = new ListNode(0);        ListNode re = result;        ListNode tail = head;        int i = 0;        while( tail!= null) {                    i++;            if( i%k == 0) {                ListNode tailNext = tail.next;                ListNode[] temp = reversalList(head, tail);                re.next = temp[1];                re = temp[0];                re.next = tailNext;                head = tailNext;                tail = re;            }            tail = tail.next;        }        return result.next;    }\n整体代码：/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {        public ListNode reverseKGroup(ListNode head, int k) {        ListNode result = new ListNode(0);        ListNode re = result;        ListNode tail = head;        int i = 0;        while( tail!= null) {                    i++;            if( i%k == 0) {                ListNode tailNext = tail.next;                ListNode[] temp = reversalList(head, tail);                re.next = temp[1];                re = temp[0];                re.next = tailNext;                head = tailNext;                tail = re;            }            tail = tail.next;        }        return result.next;    }    public ListNode[] reversalList(ListNode head,ListNode tail) {        ListNode[] result =  {head,tail};        if(head == null || head == tail) {            return result;        }        ListNode temp = head;        while(temp!=tail) {            ListNode t = tail.next;            tail.next = temp;            ListNode n = temp.next;            temp.next = t;            temp = n;        }        return result;    }}\n测试代码：package com.company.project.hot100;public class Question25 {    public class ListNode {         int val;         ListNode next;         ListNode(int x) { val = x; }    }    public ListNode reverseKGroup(ListNode head, int k) {        ListNode result = new ListNode(0);        ListNode re = result;        ListNode tail = head;        int i = 0;        while( tail!= null) {                    i++;            if( i%k == 0) {                ListNode tailNext = tail.next;                ListNode[] temp = reversalList(head, tail);                re.next = temp[1];                re = temp[0];                re.next = tailNext;                head = tailNext;                tail = re;            }            tail = tail.next;        }        return result.next;    }    public ListNode[] reversalList(ListNode head,ListNode tail) {        ListNode[] result =  {head,tail};        if(head == null || head == tail) {            return result;        }        ListNode temp = head;        while(temp!=tail) {            ListNode t = tail.next;            tail.next = temp;            ListNode n = temp.next;            temp.next = t;            temp = n;        }        return result;    }    public static void main(String[] args) {        Question25 question25 = new Question25();        ListNode a = question25.new ListNode(1);        ListNode b = question25.new ListNode(2);        ListNode c = question25.new ListNode(3);        ListNode d = question25.new ListNode(4);        ListNode e = question25.new ListNode(5);        a.next = b;        b.next = c;        c.next = d;        d.next = e;        e.next = null;        //测试翻转链表方法//        ListNode[] result = question25.reversalList(a, e);//        ListNode head = result[0];//        ListNode tail = result[1];//        ListNode r = question25.new ListNode(0);//        r.next = tail;//        do {//            System.out.println(r.next.val);//            r = r.next;//        } while (r != head);        ListNode result = question25.reverseKGroup(a, 3);        while (result != null) {            System.out.println(result.val);            result = result.next;        }            }}\n复杂度分析：时间复杂度：O(n)\n空间复杂度：O(1)\n', 0, 1);
INSERT INTO `t_article` VALUES (84, '26. 删除排序数组中的重复项（难度：简单）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n\n##问题描述\n给定一个排序数组，你需要在**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。\n\n \n\n**示例 1:**\n\n```\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2:**\n\n```\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n \n\n**说明:**\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n\n\n\n\n## 解法一：\n\n利用两个变量`result`和`i`来遍历`nums数组`，`i`用来遍历数组，`result`来记录不重复的元素个数，同时也是最终数组的最后一个元素的下标。\n\n判断重复的条件：\n\n- 如果 `nums[result] = nums[i]`，说明重复了，直接跳过，`i++`，进行下一轮循环。\n- 如果`nums[result] != nums[i]`，说明没有重复，让`resullt++`，然后`nums[result] = nums[i]`\n\n等到i遍历完整个数组，`result`的数值就是结果数组的最后一个元素，`result+1`就是数组长度。\n\n题目非常简单！！！\n\n![1](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/1-1590656292441.jpg)\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n		if(nums.length==0) {\n			return 0;\n		}\n		int result = 0;\n		for(int i=0;i<nums.length;i++) {\n			if(nums[result] != nums[i]) {\n				result++;\n				nums[result] = nums[i];\n			}\n		}\n		return result+1;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:48:04', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n\n问题描述给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n示例 1:\n给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。示例 2:\n给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i < len; i++) {    print(nums[i]);}解法一：利用两个变量result和i来遍历nums数组，i用来遍历数组，result来记录不重复的元素个数，同时也是最终数组的最后一个元素的下标。\n判断重复的条件：\n\n如果 nums[result] = nums[i]，说明重复了，直接跳过，i++，进行下一轮循环。如果nums[result] != nums[i]，说明没有重复，让resullt++，然后nums[result] = nums[i]\n等到i遍历完整个数组，result的数值就是结果数组的最后一个元素，result+1就是数组长度。\n题目非常简单！！！\n\nclass Solution {    public int removeDuplicates(int[] nums) {        if(nums.length==0) {            return 0;        }        int result = 0;        for(int i=0;i<nums.length;i++) {            if(nums[result] != nums[i]) {                result++;                nums[result] = nums[i];            }        }        return result+1;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (85, '27. 移除元素（难度：简单）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/remove-element/\n\n## 问题描述\n\n给你一个数组 *nums* 和一个值 *val*，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 *val* 的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n \n\n**示例 1:**\n\n```\n给定 nums = [3,2,2,3], val = 3,\n\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2:**\n\n```\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n\n注意这五个元素可为任意顺序。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n \n\n**说明:**\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n\n\n## 解法一：\n\n利用两个变量`result`和`i`来遍历`nums数组`，`i`用来遍历数组，`result`来记录最终数组的最后一个元素的下标。\n\n判断是否为`val`的条件：\n\n- 如果 `nums[i] = val`，说明需要舍弃，直接跳过，`i++`，进行下一轮循环。\n- 如果`nums[i] != val`，说明需要添加，让`resullt++`，然后`nums[result] = nums[i]`\n\n等到i遍历完整个数组，`result`的数值就是结果数组的最后一个元素，`result+1`就是数组长度。\n\n题目和上一道题一样，非常简单！！！\n\n![2](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/2-1590657097841.jpg)\n\n\n\n### 代码：\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n		if(nums.length==0) {\n			return 0;\n		}\n		int result = 0;\n		for(int i=0;i<nums.length;i++) {\n			if(nums[i] != val) {		\n				nums[result] = nums[i];\n				result++;\n			}\n		}\n		return result;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:48:56', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/remove-element/\n\n问题描述给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1:\n给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。示例 2:\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i < len; i++) {    print(nums[i]);}解法一：利用两个变量result和i来遍历nums数组，i用来遍历数组，result来记录最终数组的最后一个元素的下标。\n判断是否为val的条件：\n\n如果 nums[i] = val，说明需要舍弃，直接跳过，i++，进行下一轮循环。如果nums[i] != val，说明需要添加，让resullt++，然后nums[result] = nums[i]\n等到i遍历完整个数组，result的数值就是结果数组的最后一个元素，result+1就是数组长度。\n题目和上一道题一样，非常简单！！！\n\n代码：class Solution {    public int removeElement(int[] nums, int val) {        if(nums.length==0) {            return 0;        }        int result = 0;        for(int i=0;i<nums.length;i++) {            if(nums[i] != val) {                        nums[result] = nums[i];                result++;            }        }        return result;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (86, '28. 实现 strStr()（难度：简单）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/implement-strstr/\n\n## 问题描述\n\n实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。\n\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 **-1**。\n\n**示例 1:**\n\n```\n输入: haystack = \"hello\", needle = \"ll\"\n输出: 2\n```\n\n**示例 2:**\n\n```\n输入: haystack = \"aaaaa\", needle = \"bba\"\n输出: -1\n```\n\n**说明:**\n\n当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n\n对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与C语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。\n\n\n\n### 解法一：暴力法\n\n利用双重循环，外层循环遍历haystack 字符串，如果找到与needle [0]相同的字符，然后进行内层循环，依次比对，若有不相同的元素，直接退出内循环，若最后内层循环完整遍历完成，则说明找到了第一个needle出现的位置。\n\n#### 代码：\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n		int j = 0;\n		if(needle.length()==0) {\n			return  0;\n		}\n		for(int i = 0;i<haystack.length()-needle.length()+1;i++) {\n			if(haystack.charAt(i) == needle.charAt(0)) {\n				for(j = 0;j<needle.length();j++) {\n					if(haystack.charAt(i) != needle.charAt(j)) {\n						break;\n					}\n					i++;\n				}\n\n				if(j == needle.length()) {\n					return i-j;\n				}else {\n					i = i-j;\n					j = 0;\n				}\n			}\n		}\n		return -1;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:49:52', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/implement-strstr/\n\n问题描述实现 strStr() 函数。\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。\n示例 1:\n输入: haystack = \"hello\", needle = \"ll\"输出: 2示例 2:\n输入: haystack = \"aaaaa\", needle = \"bba\"输出: -1说明:\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf()) 定义相符。\n解法一：暴力法利用双重循环，外层循环遍历haystack 字符串，如果找到与needle [0]相同的字符，然后进行内层循环，依次比对，若有不相同的元素，直接退出内循环，若最后内层循环完整遍历完成，则说明找到了第一个needle出现的位置。\n代码：class Solution {    public int strStr(String haystack, String needle) {        int j = 0;        if(needle.length()==0) {            return  0;        }        for(int i = 0;i<haystack.length()-needle.length()+1;i++) {            if(haystack.charAt(i) == needle.charAt(0)) {                for(j = 0;j<needle.length();j++) {                    if(haystack.charAt(i) != needle.charAt(j)) {                        break;                    }                    i++;                }                if(j == needle.length()) {                    return i-j;                }else {                    i = i-j;                    j = 0;                }            }        }        return -1;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (87, '29. 两数相除（难度：中等）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/divide-two-integers/\n\n## 问题描述\n\n给定两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求不使用乘法、除法和 mod 运算符。\n\n返回被除数 `dividend` 除以除数 `divisor` 得到的商。\n\n整数除法的结果应当截去（`truncate`）其小数部分，例如：`truncate(8.345) = 8` 以及 `truncate(-2.7335) = -2`\n\n \n\n**示例 1:**\n\n```\n输入: dividend = 10, divisor = 3\n输出: 3\n解释: 10/3 = truncate(3.33333..) = truncate(3) = 3\n```\n\n**示例 2:**\n\n```\n输入: dividend = 7, divisor = -3\n输出: -2\n解释: 7/-3 = truncate(-2.33333..) = -2\n```\n\n \n\n**提示：**\n\n- 被除数和除数均为 32 位有符号整数。\n- 除数不为 0。\n- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。\n\n \n\n## 解法一：递归法（小学都会用的除法）\n\n首先，我们需要先把几种特殊情况进行处理：\n\n（1）当被除数为0或者除数为1时，直接 return 被除数。\n\n（2）当被除数为Integer.MAX_VALUE时，如果除数为-1，那么得到的结果就会越界。\nInteger的范围是 -2147483648~2147483647 ，若出现上述情况，结果为 2147483648，会超出Integer的范围，题目说越界的返回 Integer.MAX_VALUE。\n\n**算法思想：**\n\n下来我们对我们的算法进行分析，我们是利用一种递归的思想：\n\n如果被除数比除数大，那么结果最小为1，然后我们让除数翻一倍，然后再去比较，如果被除数还是比除数大，那么结果翻一倍；除数再翻一倍，然后再去比较，如果被除数还是比除数大，那么结果再翻一倍。直到 被除数<除数 ，那么就继续递归 ，将被`除数=被除数-除数`，\n`除数= 原先的除数`，然后上一层的递归结果+这一次的递归结果。\n\n其中 被除数<除数是递归的出口。\n\n**举个栗子：11 除以 3 。**\n\n首先11比3 大，那么结果result最小为1，然后让3翻倍得到6，再去和11比较，11>6，那么结果result翻倍为2；再让6去翻倍得到12，再去和11比较，11<12，这次不满足条件了，说明答案就在2和4之间，本次递归结果为2；那么我们让11-6 = 5，拿着5再和3去计算商。\n\n首先5比3大，那么那么结果result最小为1，然后让3翻倍得到6，再去和5比较，5<6，不满足条件，本次递归结果为1；那么我们让5-3 = 2，拿着2在和3去计算商。\n\n因为2<3，不能再除法了，那么本次递归结果为0；\n\n最后我们只要把每一次递归的结果都加起来就是最终结果了。\n\n那么我们只要将结果的正负先拿出来，直接用被除数和除数的绝对值去进行上述计算，最后再把正负号填上就是最终结果。\n\n算法设计就是这样，但是我们还是会发现，\n\n**一些特殊情况依然会出问题**：\n\n（1）如果被除数或者除数是`Integer.MIN_VALUE`，我们给它取绝对值，就会越界，得到0。\n\n然后就奇思妙想，那么如果我们把被除数和除数都换为负数，就不会出现越界情况了。\n\n（2）还有一些边界的判断，如果我们的被除数为`Integer.MIN_VALUE`，那么我们再计算过程中，可能会出现两个很大的负数相加，最后结果越界，会把两个负数之后变成正数，这样就会进入死循环。于是我们需要加入一些边界判断就ok了。\n\n![1](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/1-1590750670610.jpg)\n\n### 代码：\n\n```java\nclass Solution {\n    public int divide(int dividend, int divisor) {\n		if(dividend == 0 || divisor == 1) {\n			return dividend;\n		}\n		if(divisor == -1) {\n			if(dividend == Integer.MIN_VALUE) {\n				return Integer.MAX_VALUE;\n			}else {\n				return -dividend;\n			}\n		}\n		\n		int sign = (dividend^divisor)>=0?1:-1;\n		int a = (dividend<0)?dividend:-dividend;\n		int b = (divisor<0)?divisor:-divisor;\n		int result = div(a, b);\n		return sign>0?result:-result;\n    }\n	\n	/**\n	 * 递归计算a/b的值，a和b都是负整数\n	 * @param a 被除数\n	 * @param b 除数\n	 * @return 商\n	 */\n	public int div(int a,int b) {\n		if(a > b) return 0;\n		int temp = b;\n		int result = 1;\n		while(a< temp + temp && (temp + temp < 0)) {\n			temp = temp + temp;\n			result = result + result;\n		}\n		return result+div(a-temp, b);\n	}\n}\n```\n\n', 0, 0, '2020-08-06 23:50:40', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/divide-two-integers/\n\n问题描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。\n返回被除数 dividend 除以除数 divisor 得到的商。\n整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2\n示例 1:\n输入: dividend = 10, divisor = 3输出: 3解释: 10/3 = truncate(3.33333..) = truncate(3) = 3示例 2:\n输入: dividend = 7, divisor = -3输出: -2解释: 7/-3 = truncate(-2.33333..) = -2提示：\n\n被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。\n解法一：递归法（小学都会用的除法）首先，我们需要先把几种特殊情况进行处理：\n（1）当被除数为0或者除数为1时，直接 return 被除数。\n（2）当被除数为Integer.MAX_VALUE时，如果除数为-1，那么得到的结果就会越界。Integer的范围是 -2147483648~2147483647 ，若出现上述情况，结果为 2147483648，会超出Integer的范围，题目说越界的返回 Integer.MAX_VALUE。\n算法思想：\n下来我们对我们的算法进行分析，我们是利用一种递归的思想：\n如果被除数比除数大，那么结果最小为1，然后我们让除数翻一倍，然后再去比较，如果被除数还是比除数大，那么结果翻一倍；除数再翻一倍，然后再去比较，如果被除数还是比除数大，那么结果再翻一倍。直到 被除数<除数 ，那么就继续递归 ，将被除数=被除数-除数，除数= 原先的除数，然后上一层的递归结果+这一次的递归结果。\n其中 被除数<除数是递归的出口。\n举个栗子：11 除以 3 。\n首先11比3 大，那么结果result最小为1，然后让3翻倍得到6，再去和11比较，11>6，那么结果result翻倍为2；再让6去翻倍得到12，再去和11比较，11<12，这次不满足条件了，说明答案就在2和4之间，本次递归结果为2；那么我们让11-6 = 5，拿着5再和3去计算商。\n首先5比3大，那么那么结果result最小为1，然后让3翻倍得到6，再去和5比较，5<6，不满足条件，本次递归结果为1；那么我们让5-3 = 2，拿着2在和3去计算商。\n因为2<3，不能再除法了，那么本次递归结果为0；\n最后我们只要把每一次递归的结果都加起来就是最终结果了。\n那么我们只要将结果的正负先拿出来，直接用被除数和除数的绝对值去进行上述计算，最后再把正负号填上就是最终结果。\n算法设计就是这样，但是我们还是会发现，\n一些特殊情况依然会出问题：\n（1）如果被除数或者除数是Integer.MIN_VALUE，我们给它取绝对值，就会越界，得到0。\n然后就奇思妙想，那么如果我们把被除数和除数都换为负数，就不会出现越界情况了。\n（2）还有一些边界的判断，如果我们的被除数为Integer.MIN_VALUE，那么我们再计算过程中，可能会出现两个很大的负数相加，最后结果越界，会把两个负数之后变成正数，这样就会进入死循环。于是我们需要加入一些边界判断就ok了。\n\n代码：class Solution {    public int divide(int dividend, int divisor) {        if(dividend == 0 || divisor == 1) {            return dividend;        }        if(divisor == -1) {            if(dividend == Integer.MIN_VALUE) {                return Integer.MAX_VALUE;            }else {                return -dividend;            }        }        int sign = (dividend^divisor)>=0?1:-1;        int a = (dividend<0)?dividend:-dividend;        int b = (divisor<0)?divisor:-divisor;        int result = div(a, b);        return sign>0?result:-result;    }    /**     * 递归计算a/b的值，a和b都是负整数     * @param a 被除数     * @param b 除数     * @return 商     */    public int div(int a,int b) {        if(a > b) return 0;        int temp = b;        int result = 1;        while(a< temp + temp && (temp + temp < 0)) {            temp = temp + temp;            result = result + result;        }        return result+div(a-temp, b);    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (88, '30. 串联所有单词的子串（难度：困难）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/\n\n##问题描述\n给定一个字符串 **s** 和一些长度相同的单词 **words。**找出 **s** 中恰好可以由 **words** 中所有单词串联形成的子串的起始位置。\n\n注意子串要与 **words** 中的单词完全匹配，中间不能有其他字符，但不需要考虑 **words** 中单词串联的顺序。\n\n \n\n**示例 1：**\n\n```\n输入：\n  s = \"barfoothefoobarman\",\n  words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n```\n\n**示例 2：**\n\n```\n输入：\n  s = \"wordgoodgoodgoodbestword\",\n  words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]\n```\n\n\n\n## 解法一：暴力法（借用HashMap）\n\n这个解法的巧妙之处就在于使用HashMap 来存放，字符串和数量的匹配关系。\n\n先创建wMap ，利用key存放words[i] 的字符串，value来存放words [i]对应的数量。\n\n然后，我们再利用变量 i 依次遍历整个s字符串，每次截取子串p，长度为words的字符串之和长度（题目要求的子串长度，`words[0].length() * words.length`）,即子串p下标`[i , i + words[0].length() * words.length ]`;\n\n因为子串p的长度是和words的所有字符串长度之和相同的。\n\n所以，我们利用变量 j，每次从子串p中截取`words[0].length()`长度的子串son，即下标为\n`[ i+j*wordLen , i+(j+1)  * wordLen  ]`\n\n再创建sMap，利用key存放son的字符串，value来存放son对应的数量。\n\n最后，只需要判断，两个HashMap的键值对是否都相等。\n\n\n\n优化：\n\n（1）若截取的字符串在wMap 没有，说明该子串一定不符合条件，可以跳出这次判断。\n\n（2）若截取的子串，在sMap中的value大于在wMap中的value，说明数量超出了范围，一定不符合条件，可以跳出。\n\n（3）若是正常退出内层循环，即正常的判断遍历完 p子串，说明符合条件，可以加入结果列表中。\n\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> result = new ArrayList<Integer>();\n		if(words.length == 0) {\n			return result;\n		}\n		\n		Map<String, Integer> wMap = new HashMap<String, Integer>();\n		Map<String, Integer> sMap = new HashMap<String, Integer>();\n		int num = words.length;\n		int wordLen = words[0].length();\n		int len = wordLen*num;\n		\n		for(String w : words) {\n			int value = wMap.getOrDefault(w, 0);\n			wMap.put(w, value+1);\n		}\n		\n		\n		for(int i = 0;i<s.length()-len+1;i++) {\n			sMap = new HashMap<String, Integer>();\n			int j = 0;\n			while (j<num) {\n				String son = s.substring(i+j*wordLen,i+(j+1)*wordLen );\n				if(!wMap.containsKey(son)) {\n					break;\n				}else {\n					int value = sMap.getOrDefault(son, 0);\n					sMap.put(son, value+1);\n					if(sMap.get(son)>wMap.get(son)) {\n						break;\n					}\n				}\n                j++;\n			}	\n					\n			//如果是正常退出循环，说明符合条件\n			if(j == num) {\n				result.add(i);\n			}\n			\n		}\n		return result;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:51:28', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/\n\n问题描述给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。\n注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。\n示例 1：\n输入：  s = \"barfoothefoobarman\",  words = [\"foo\",\"bar\"]输出：[0,9]解释：从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。输出的顺序不重要, [9,0] 也是有效答案。示例 2：\n输入：  s = \"wordgoodgoodgoodbestword\",  words = [\"word\",\"good\",\"best\",\"word\"]输出：[]解法一：暴力法（借用HashMap）这个解法的巧妙之处就在于使用HashMap 来存放，字符串和数量的匹配关系。\n先创建wMap ，利用key存放words[i] 的字符串，value来存放words [i]对应的数量。\n然后，我们再利用变量 i 依次遍历整个s字符串，每次截取子串p，长度为words的字符串之和长度（题目要求的子串长度，words[0].length() * words.length）,即子串p下标[i , i + words[0].length() * words.length ];\n因为子串p的长度是和words的所有字符串长度之和相同的。\n所以，我们利用变量 j，每次从子串p中截取words[0].length()长度的子串son，即下标为[ i+j*wordLen , i+(j+1)  * wordLen  ]\n再创建sMap，利用key存放son的字符串，value来存放son对应的数量。\n最后，只需要判断，两个HashMap的键值对是否都相等。\n优化：\n（1）若截取的字符串在wMap 没有，说明该子串一定不符合条件，可以跳出这次判断。\n（2）若截取的子串，在sMap中的value大于在wMap中的value，说明数量超出了范围，一定不符合条件，可以跳出。\n（3）若是正常退出内层循环，即正常的判断遍历完 p子串，说明符合条件，可以加入结果列表中。\nclass Solution {    public List<Integer> findSubstring(String s, String[] words) {        List<Integer> result = new ArrayList<Integer>();        if(words.length == 0) {            return result;        }        Map<String, Integer> wMap = new HashMap<String, Integer>();        Map<String, Integer> sMap = new HashMap<String, Integer>();        int num = words.length;        int wordLen = words[0].length();        int len = wordLen*num;        for(String w : words) {            int value = wMap.getOrDefault(w, 0);            wMap.put(w, value+1);        }        for(int i = 0;i<s.length()-len+1;i++) {            sMap = new HashMap<String, Integer>();            int j = 0;            while (j<num) {                String son = s.substring(i+j*wordLen,i+(j+1)*wordLen );                if(!wMap.containsKey(son)) {                    break;                }else {                    int value = sMap.getOrDefault(son, 0);                    sMap.put(son, value+1);                    if(sMap.get(son)>wMap.get(son)) {                        break;                    }                }                j++;            }                //如果是正常退出循环，说明符合条件            if(j == num) {                result.add(i);            }        }        return result;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (89, '31. 下一个排列（难度：中等）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/next-permutation/\n\n## 问题描述\n\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n必须**[原地](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。\n\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n`1,2,3` → `1,3,2`\n`3,2,1` → `1,2,3`\n`1,1,5` → `1,5,1`\n\n\n\n## 解法一：\n\n“下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n\n我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。\n\n### 算法思路：\n\n（1）如果要找到一个比目前数字大的数，一定是把一个比较靠后位置的`大数`和前面的一个`小数`进行了交换。\n\n（2）如果要找到一个`下一个排列`，那么这个`小数`的位置`i`尽可能的靠后，那么我们就需要从后往前找，找到这个尽可能小的`小数`下标为`i`后；\n\n（3）再找个尽可能小的`大数`，最终为了满足条件，这个`大数`也要尽可能靠后，所以我们也从后往前找，找到那个刚好比`小数`大的`大数`，`大数`的下标为`j`。\n\n（4）交换后，这个数字就会比之前的数字大，但是还不是最佳的，我们上述得到的数字，从下标`i`以后的数字（不包括i），一定是降序排列的，因为上述的推理，类似于冒泡排序，所以，我们只要把 `[i+1,len-1]`，即下标i以后的数组进行倒置，变成升序，就是最后的结果了。\n\n### 算法设计：\n\n（1）从后往前找，找到第一个升序的元素 `[i,i+1]`，满足`nums[i]<nums[i+1]`，此时`[i+1,len-1]`一定是降序的。\n\n（2）从后往前找，找到第一个大于元素`nums[i]`的下标`k`，即满足`nums[i]<nums[k]`，`nums[i]`就是所说的`小数`，   `nums[j]`就是所说的`大数`。\n\n（3）将 `nums[i]`  和`nums[j]`进行交换\n\n（4）再将下标为`[i+1,len-1]`进行倒置，即将`i+1`往后的元素进行倒置。\n\n（5）如果没有找到那个`小数`，那么说明目前的数字是最大的，那么我们就需要返回最小数，即将整个数组倒置，即进行第(4)步。\n\n\n\n![1](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/1-1590927216618.jpg)\n\n### 代码：\n\n```java\nclass Solution {\n    	public void nextPermutation(int[] nums) {\n		if (nums.length == 0 || nums.length == 1) {\n			return;\n		}\n\n		int i = 0;\n		for (i = nums.length - 2; i >= 0; i--) {\n			if (nums[i] < nums[i + 1]) {\n				break;\n			}\n		}\n		if (i >= 0) {\n			int j = nums.length - 1;\n			while (j > i) {\n				if (nums[i] < nums[j]) {\n					int temp = nums[i];\n					nums[i] = nums[j];\n					nums[j] = temp;\n					break;\n				}\n				j--;\n			}\n		}\n\n		for (int k = i + 1; k <= (nums.length + i) / 2; k++) {\n			int temp = nums[k];\n			nums[k] = nums[nums.length - (k - i)];\n			nums[nums.length - (k - i)] = temp;\n		}\n	}\n}\n```\n\n', 0, 0, '2020-08-06 23:52:33', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/next-permutation/\n\n问题描述实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n必须原地修改，只允许使用额外常数空间。\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1\n解法一：“下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。\n算法思路：（1）如果要找到一个比目前数字大的数，一定是把一个比较靠后位置的大数和前面的一个小数进行了交换。\n（2）如果要找到一个下一个排列，那么这个小数的位置i尽可能的靠后，那么我们就需要从后往前找，找到这个尽可能小的小数下标为i后；\n（3）再找个尽可能小的大数，最终为了满足条件，这个大数也要尽可能靠后，所以我们也从后往前找，找到那个刚好比小数大的大数，大数的下标为j。\n（4）交换后，这个数字就会比之前的数字大，但是还不是最佳的，我们上述得到的数字，从下标i以后的数字（不包括i），一定是降序排列的，因为上述的推理，类似于冒泡排序，所以，我们只要把 [i+1,len-1]，即下标i以后的数组进行倒置，变成升序，就是最后的结果了。\n算法设计：（1）从后往前找，找到第一个升序的元素 [i,i+1]，满足nums[i]<nums[i+1]，此时[i+1,len-1]一定是降序的。\n（2）从后往前找，找到第一个大于元素nums[i]的下标k，即满足nums[i]<nums[k]，nums[i]就是所说的小数，   nums[j]就是所说的大数。\n（3）将 nums[i]  和nums[j]进行交换\n（4）再将下标为[i+1,len-1]进行倒置，即将i+1往后的元素进行倒置。\n（5）如果没有找到那个小数，那么说明目前的数字是最大的，那么我们就需要返回最小数，即将整个数组倒置，即进行第(4)步。\n\n代码：class Solution {        public void nextPermutation(int[] nums) {        if (nums.length == 0 || nums.length == 1) {            return;        }        int i = 0;        for (i = nums.length - 2; i >= 0; i--) {            if (nums[i] < nums[i + 1]) {                break;            }        }        if (i >= 0) {            int j = nums.length - 1;            while (j > i) {                if (nums[i] < nums[j]) {                    int temp = nums[i];                    nums[i] = nums[j];                    nums[j] = temp;                    break;                }                j--;            }        }        for (int k = i + 1; k <= (nums.length + i) / 2; k++) {            int temp = nums[k];            nums[k] = nums[nums.length - (k - i)];            nums[nums.length - (k - i)] = temp;        }    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (90, '32. 最长有效括号（难度：困难）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/longest-valid-parentheses/\n\n\n##问题描述\n\n给定一个只包含 `\'(\'` 和 `\')\'` 的字符串，找出最长的包含有效括号的子串的长度。\n\n**示例 1:**\n\n```\n输入: \"(()\"\n输出: 2\n解释: 最长有效括号子串为 \"()\"\n```\n\n**示例 2:**\n\n```\n输入: \")()())\"\n输出: 4\n解释: 最长有效括号子串为 \"()()\"\n```\n\n\n\n## 解法一：暴力法\n\n根据题目意思，我们需要找到最长的包含有效括号的子串的长度，那么意味着，我们的最长子串不一定是原字符串的首元素开始的。\n\n但是如果我们的最长子串都是从首元素开始的，那么这道题就会变得非常简单。我们只需要利用一个循环，挨个从0，1，……为首元素，开始截取字符串，然后在判断这个子串的最长有效长度，最后拿出最大值即可。\n\n**如何判断计算一个字符串从首元素开始的最长有效长度？**\n\n我们可以利用栈的思想，但是没必要使用栈数据结构，利用一个int变量temp（初始值为0）就可以代替：\n\n（1）我们遍历字符串，若遇到 \' ( \' 就给temp++；若遇到 \' ) \' 就给temp--;\n\n（2）若遇到 temp = 0,说明前面的字符串刚好满足条件，我们可以更新当前这次遍历的最大长度maxLen = i +1;\n\n（3）若遇到 temp <  0,说明前面的字符串已经不满足条件了，就可以直接return maxLen。\n\n**优化：**\n\n我们既然要先遍历截取子串，那么\' ) \'开始的子串一定是不满足条件的，可以直接跳过。\n\n![1](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/1-1591081943274.jpg)\n\n该方法用时是非常高的，在死亡的边缘徘徊！！！\n\n\n\n代码：\n\n```java\npublic class Solution {\n	public int longestValidParentheses(String s) {\n		int result = 0;\n		if(s.length()==0 && s.length()==1) {\n			return 0;\n		}\n		for(int i = 0;i<s.length();i++) {\n			if(s.charAt(i) == \')\') {\n				continue;\n			}\n			int maxLen = maxValid(s.substring(i));\n			if(result < maxLen) {\n				result = maxLen;\n			}\n		}	\n		return result;\n    }\n	\n	//计算从字符串串首开始计算最长有效的子串长度\n	public int maxValid(String s) {\n		int temp = 0;\n		int maxLen = 0;\n		for(int i = 0;i<s.length();i++) {\n			if(s.charAt(i) == \'(\') {\n				temp ++;\n				\n			}else {\n				temp --;\n				if(temp<0) {\n					return maxLen;\n				}\n				if(temp == 0) {\n					maxLen = i+1;\n				}\n			}\n		}\n		return maxLen;\n	}\n}\n```\n\n**复杂度分析**：\n\n- 时间复杂度： O(n^2) \n- 空间复杂度：O(n)\n\n\n\n\n\n## 解法二：动态规划法\n\n这道问题可以使用动态规划法，问题要求的是`s[0,length-1]`的最长有效子串长度，我们可以用dt[length]数组来统计，dt[]数组的默认值为0，**dt[i]表示以i元素结尾的最长子串长度**，那么s[i]一定为 \')\' 。\n\n在统计过程中，会出现如下几种情况：\n\n（1）当 `s[i]== \')\' `，`s[i-1] ==\'(\'`时，例如：\"……()\"，符合条件，我们只需要更新`dt[i] = dt[i-2] +2`，当然如果	`i-2<0`的话，直接赋值`dt[i]=2`；\n\n（2）当`s[i] == \')\'`，`s[i-1] == \')\'`时，例如：\"……))\"，如果`s[i-dt[i-1]-1] = \'(\'`，\n\n那么\n$$\ndt[i]=dt[i−1]+dt[i−dt[i−1]−2]+2\n$$\n解释：\n\n如果最后一个元素为\' ) \'是有效子串的一部分，那么他一定有一个对应的\' ( \' 在倒数第二个 \')\' 所在的有效子字符串的前面，如图所示：\n\n![3](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/3-1591086047139.jpg)\n\n\n\n![2](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/2-1591086156227.jpg)\n\n**代码：**\n\n```java\npublic class Solution {\n	public int longestValidParentheses(String s) {\n		if(s.length()==0 || s.length()==1) {\n			return 0;\n		}\n		int[] dt = new int[s.length()];\n		int result = 0;\n		for(int i = 1;i<s.length();i++) {\n			if(s.charAt(i)==\')\') {\n				if(s.charAt(i-1)==\'(\') {\n					dt[i] = (i>=2?dt[i-2]:0) + 2;\n				}else if(i>dt[i-1] && s.charAt(i-dt[i-1]-1)==\'(\' ){\n					dt[i] = dt[i-1] + 2 + ((i-dt[i-1]-2)>=0?dt[i-dt[i-1]-2]:0);\n				}\n			}\n			result = Math.max(result, dt[i]);\n		}\n		return result;\n    }\n}    \n```\n\n**复杂度分析：**\n\n- 时间复杂度： O(n) \n- 空间复杂度： O(n)\n\n\n\n## 解法三：栈操作\n\n算法思路：\n\n我们利用一个栈，里面先存入一个-1，方便后面计算有效子串长度，**我们栈中的栈首元素是为后面计算有效长度做标记**。\n\n遍历字符串，\n\n- 若遇到\'(\'，就把下标入栈；\n- 若遇到\')\'，就出栈；\n  - 若栈为空，说明该子串无效，因为我们的栈首存放的是标记位，并非\'(\'的下标，那么我们就把当前的i入栈，作为新子串的标记位；\n  - 若栈不为空，说明该字串有效，那么更新最长子串长度result = Math.max(result, i-stack.peek());\n\n该算法的巧妙之处，正是栈首存放的是标记位，而非记录\'(\'的下标。\n\n![4](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/4-1591087904171.jpg)\n\n代码：\n\n```java\npublic class Solution {\n	public int longestValidParentheses(String s) {\n		Stack<Integer> stack = new Stack<>();\n		int result = 0;\n		int len = 0;\n		stack.add(-1);\n		for(int i = 0;i<s.length();i++) {\n			if(s.charAt(i)==\'(\') {\n				stack.add(i);\n			}else {\n				stack.pop();\n				if(stack.isEmpty()) {\n					stack.push(i);\n				}else {\n					result = Math.max(result, i-stack.peek());\n				}\n			}\n		}\n		return result;\n    }\n}\n```\n\n**复杂度分析：**\n\n- 时间复杂度： O(n) \n- 空间复杂度： O(n)', 0, 0, '2020-08-06 23:53:31', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/longest-valid-parentheses/\n\n问题描述给定一个只包含 \'(\' 和 \')\' 的字符串，找出最长的包含有效括号的子串的长度。\n示例 1:\n输入: \"(()\"输出: 2解释: 最长有效括号子串为 \"()\"示例 2:\n输入: \")()())\"输出: 4解释: 最长有效括号子串为 \"()()\"解法一：暴力法根据题目意思，我们需要找到最长的包含有效括号的子串的长度，那么意味着，我们的最长子串不一定是原字符串的首元素开始的。\n但是如果我们的最长子串都是从首元素开始的，那么这道题就会变得非常简单。我们只需要利用一个循环，挨个从0，1，……为首元素，开始截取字符串，然后在判断这个子串的最长有效长度，最后拿出最大值即可。\n如何判断计算一个字符串从首元素开始的最长有效长度？\n我们可以利用栈的思想，但是没必要使用栈数据结构，利用一个int变量temp（初始值为0）就可以代替：\n（1）我们遍历字符串，若遇到 ‘ ( ‘ 就给temp++；若遇到 ‘ ) ‘ 就给temp—;\n（2）若遇到 temp = 0,说明前面的字符串刚好满足条件，我们可以更新当前这次遍历的最大长度maxLen = i +1;\n（3）若遇到 temp <  0,说明前面的字符串已经不满足条件了，就可以直接return maxLen。\n优化：\n我们既然要先遍历截取子串，那么’ ) ‘开始的子串一定是不满足条件的，可以直接跳过。\n\n该方法用时是非常高的，在死亡的边缘徘徊！！！\n代码：\npublic class Solution {    public int longestValidParentheses(String s) {        int result = 0;        if(s.length()==0 && s.length()==1) {            return 0;        }        for(int i = 0;i<s.length();i++) {            if(s.charAt(i) == \')\') {                continue;            }            int maxLen = maxValid(s.substring(i));            if(result < maxLen) {                result = maxLen;            }        }            return result;    }    //计算从字符串串首开始计算最长有效的子串长度    public int maxValid(String s) {        int temp = 0;        int maxLen = 0;        for(int i = 0;i<s.length();i++) {            if(s.charAt(i) == \'(\') {                temp ++;            }else {                temp --;                if(temp<0) {                    return maxLen;                }                if(temp == 0) {                    maxLen = i+1;                }            }        }        return maxLen;    }}\n复杂度分析：\n\n时间复杂度： O(n^2) 空间复杂度：O(n)\n解法二：动态规划法这道问题可以使用动态规划法，问题要求的是s[0,length-1]的最长有效子串长度，我们可以用dt[length]数组来统计，dt[]数组的默认值为0，dt[i]表示以i元素结尾的最长子串长度，那么s[i]一定为 ‘)’ 。\n在统计过程中，会出现如下几种情况：\n（1）当 s[i]== \')\'，s[i-1] ==\'(\'时，例如：”……()”，符合条件，我们只需要更新dt[i] = dt[i-2] +2，当然如果    i-2<0的话，直接赋值dt[i]=2；\n（2）当s[i] == \')\'，s[i-1] == \')\'时，例如：”……))”，如果s[i-dt[i-1]-1] = \'(\'，\n那么dt[i]=dt[i−1]+dt[i−dt[i−1]−2]+2解释：\n如果最后一个元素为’ ) ‘是有效子串的一部分，那么他一定有一个对应的’ ( ‘ 在倒数第二个 ‘)’ 所在的有效子字符串的前面，如图所示：\n\n\n代码：\npublic class Solution {    public int longestValidParentheses(String s) {        if(s.length()==0 || s.length()==1) {            return 0;        }        int[] dt = new int[s.length()];        int result = 0;        for(int i = 1;i<s.length();i++) {            if(s.charAt(i)==\')\') {                if(s.charAt(i-1)==\'(\') {                    dt[i] = (i>=2?dt[i-2]:0) + 2;                }else if(i>dt[i-1] && s.charAt(i-dt[i-1]-1)==\'(\' ){                    dt[i] = dt[i-1] + 2 + ((i-dt[i-1]-2)>=0?dt[i-dt[i-1]-2]:0);                }            }            result = Math.max(result, dt[i]);        }        return result;    }}\n复杂度分析：\n\n时间复杂度： O(n) 空间复杂度： O(n)\n解法三：栈操作算法思路：\n我们利用一个栈，里面先存入一个-1，方便后面计算有效子串长度，我们栈中的栈首元素是为后面计算有效长度做标记。\n遍历字符串，\n\n若遇到’(‘，就把下标入栈；若遇到’)’，就出栈；\n若栈为空，说明该子串无效，因为我们的栈首存放的是标记位，并非’(‘的下标，那么我们就把当前的i入栈，作为新子串的标记位；若栈不为空，说明该字串有效，那么更新最长子串长度result = Math.max(result, i-stack.peek());\n\n该算法的巧妙之处，正是栈首存放的是标记位，而非记录’(‘的下标。\n\n代码：\npublic class Solution {    public int longestValidParentheses(String s) {        Stack<Integer> stack = new Stack<>();        int result = 0;        int len = 0;        stack.add(-1);        for(int i = 0;i<s.length();i++) {            if(s.charAt(i)==\'(\') {                stack.add(i);            }else {                stack.pop();                if(stack.isEmpty()) {                    stack.push(i);                }else {                    result = Math.max(result, i-stack.peek());                }            }        }        return result;    }}\n复杂度分析：\n\n时间复杂度： O(n) 空间复杂度： O(n)\n', 0, 1);
INSERT INTO `t_article` VALUES (91, '33. 搜索旋转排序数组（难度：中等）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\n\n##问题描述\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n\n( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。\n\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。\n\n你可以假设数组中不存在重复的元素。\n\n你的\n\n**示例 1:**\n\n```\n输入: nums = [4,5,6,7,0,1,2], target = 0\n输出: 4\n```\n\n**示例 2:**\n\n```\n输入: nums = [4,5,6,7,0,1,2], target = 3\n输出: -1\n```\n\n\n\n## 解法一：二分查找法\n\n### 算法思路：\n\n看见题目要求算法时间复杂度必须是 *O*(log *n*) 级别，那么一定会想到**二分查找法**。\n\n首先二分查找法，只能在有序的数组内进行使用，如何在这道题中得到有序的数组呢？\n\n**不妨，其实在这数组里面，任意一个节点把数组分成两部分，其中的有一部分一定是有序的，那么我们就用二分查找法中的mid节点进行切分，若那部分是有序的，我们再在有序的部分进行二分查找，直到出现结果。**\n\n**如何判断那一部分是有序的？**\n\n其实很简单，我们只需要判断nums[0] <= nums[mid]，说明前半部分有序，否则后半部分有序。\n\n![5](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/5-1591180866858.jpg)\n\n### 代码：\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n		int len = nums.length;\n		if(len == 0) {\n			return -1;\n		}\n		if(len == 1) {\n			return target == nums[0]?0:-1;\n		}\n		\n		int l=0,r=len-1;\n		while(r>=l) {\n			int mid = (l+r)/2;\n			if(nums[mid] == target) return mid;\n			if(nums[0]<=nums[mid]) {\n				if(target>=nums[0]&&target<nums[mid]) {\n					r= mid-1;\n				}else {\n					l=mid+1;\n				}\n			}else {\n				if(target>nums[mid]&&target<=nums[len-1]) {\n					l = mid+1;\n				}else {\n					r=mid-1;\n				}\n			}\n		}\n		return -1;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:54:49', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\n\n问题描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。\n( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。\n搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\n你可以假设数组中不存在重复的元素。\n你的\n示例 1:\n输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2:\n输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1解法一：二分查找法算法思路：看见题目要求算法时间复杂度必须是 O(log n) 级别，那么一定会想到二分查找法。\n首先二分查找法，只能在有序的数组内进行使用，如何在这道题中得到有序的数组呢？\n不妨，其实在这数组里面，任意一个节点把数组分成两部分，其中的有一部分一定是有序的，那么我们就用二分查找法中的mid节点进行切分，若那部分是有序的，我们再在有序的部分进行二分查找，直到出现结果。\n如何判断那一部分是有序的？\n其实很简单，我们只需要判断nums[0] <= nums[mid]，说明前半部分有序，否则后半部分有序。\n\n代码：class Solution {    public int search(int[] nums, int target) {        int len = nums.length;        if(len == 0) {            return -1;        }        if(len == 1) {            return target == nums[0]?0:-1;        }        int l=0,r=len-1;        while(r>=l) {            int mid = (l+r)/2;            if(nums[mid] == target) return mid;            if(nums[0]<=nums[mid]) {                if(target>=nums[0]&&target<nums[mid]) {                    r= mid-1;                }else {                    l=mid+1;                }            }else {                if(target>nums[mid]&&target<=nums[len-1]) {                    l = mid+1;                }else {                    r=mid-1;                }            }        }        return -1;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (92, '34. 在排序数组中查找元素的第一个和最后一个位置（难度：中等）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\n\n\n## 题目描述：\n\n给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。\n\n你的算法时间复杂度必须是 *O*(log *n*) 级别。\n\n如果数组中不存在目标值，返回 `[-1, -1]`。\n\n**示例 1:**\n\n```\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]\n```\n\n**示例 2:**\n\n```\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]\n```\n\n\n\n## 解题思路：\n\n这道题非常简单，看见算法时间复杂度必须是 *O*(log *n*) 级别，那一定是想到二分查找法。\n\n我们先利用二分查找，先找到等于目标值`target`的下标，再向左右挨个遍历，找到第一个和最后一个等于目标值的下标。\n\n这道题过于简单，就不做过多的描述了。\n\n![1](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/1.jpg)\n\n## 代码：\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n		int l = 0;\n		int r = nums.length-1;\n		int mid = 0;\n		while(l<=r) {\n			mid = (l+r)/2;\n			if(nums[mid] == target) {\n				l = mid;\n				r = mid;\n				while(l-1>=0 && nums[l-1] == target) {\n					l = l - 1;\n				}\n				while(r+1<nums.length && nums[r+1] == target) {\n					r = r + 1;\n				}\n				break;\n			} else if(nums[mid] > target) {\n				r = mid - 1;\n				\n			} else {\n				l = mid + 1;\n			}\n		}\n		if(l>r) {\n			l = -1;\n			r = -1;\n		}\n		int[] result = {l,r};\n		return result;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:55:24', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\n\n题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n你的算法时间复杂度必须是 O(log n) 级别。\n如果数组中不存在目标值，返回 [-1, -1]。\n示例 1:\n输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4]示例 2:\n输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1]解题思路：这道题非常简单，看见算法时间复杂度必须是 O(log n) 级别，那一定是想到二分查找法。\n我们先利用二分查找，先找到等于目标值target的下标，再向左右挨个遍历，找到第一个和最后一个等于目标值的下标。\n这道题过于简单，就不做过多的描述了。\n\n代码：class Solution {    public int[] searchRange(int[] nums, int target) {        int l = 0;        int r = nums.length-1;        int mid = 0;        while(l<=r) {            mid = (l+r)/2;            if(nums[mid] == target) {                l = mid;                r = mid;                while(l-1>=0 && nums[l-1] == target) {                    l = l - 1;                }                while(r+1<nums.length && nums[r+1] == target) {                    r = r + 1;                }                break;            } else if(nums[mid] > target) {                r = mid - 1;            } else {                l = mid + 1;            }        }        if(l>r) {            l = -1;            r = -1;        }        int[] result = {l,r};        return result;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (93, '35. 搜索插入位置（难度：简单）', 8, '\n> 题目链接：https://leetcode-cn.com/problems/search-insert-position/\n\n\n## 问题描述：\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n**示例 1:**\n\n```\n输入: [1,3,5,6], 5\n输出: 2\n```\n\n**示例 2:**\n\n```\n输入: [1,3,5,6], 2\n输出: 1\n```\n\n**示例 3:**\n\n```\n输入: [1,3,5,6], 7\n输出: 4\n```\n\n**示例 4:**\n\n```\n输入: [1,3,5,6], 0\n输出: 0\n```\n\n\n\n## 解法一：二分查找法\n\n这是一定很简单的题，直接使用二分查找法，如果找到目标值，就直接return 下标，如果没找到，l和r指针就会在将要插入位置的右边和左边，那么l指针就是需要插入的位置。\n\n![5](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/5-1592034199823.jpg)\n\n\n\n代码：\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n		int l = 0;\n		int r = nums.length-1;\n		int mid = 0;\n		while(l<=r) {\n			mid = (l+r)/2;\n			if(nums[mid] == target) {\n				return mid;\n			} else if(nums[mid] > target) {\n				r = mid - 1;\n				\n			} else {\n				l = mid + 1;\n				\n			}\n		}\n		return l;\n    }\n}\n```\n\n', 0, 0, '2020-08-06 23:56:00', 2, 0, 1, '\n题目链接：https://leetcode-cn.com/problems/search-insert-position/\n\n问题描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n你可以假设数组中无重复元素。\n示例 1:\n输入: [1,3,5,6], 5输出: 2示例 2:\n输入: [1,3,5,6], 2输出: 1示例 3:\n输入: [1,3,5,6], 7输出: 4示例 4:\n输入: [1,3,5,6], 0输出: 0解法一：二分查找法这是一定很简单的题，直接使用二分查找法，如果找到目标值，就直接return 下标，如果没找到，l和r指针就会在将要插入位置的右边和左边，那么l指针就是需要插入的位置。\n\n代码：\nclass Solution {    public int searchInsert(int[] nums, int target) {        int l = 0;        int r = nums.length-1;        int mid = 0;        while(l<=r) {            mid = (l+r)/2;            if(nums[mid] == target) {                return mid;            } else if(nums[mid] > target) {                r = mid - 1;            } else {                l = mid + 1;            }        }        return l;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (94, '36. 有效的数独（难度：中等）', 8, '\n题目链接：https://leetcode-cn.com/problems/valid-sudoku/\n\n## 题目描述：\n\n判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。\n\n1. 数字 `1-9` 在每一行只能出现一次。\n2. 数字 `1-9` 在每一列只能出现一次。\n3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/250px-Sudoku-by-L2G-20050714.svg.png)\n\n上图是一个部分填充的有效的数独。\n\n数独部分空格内已填入了数字，空白格用 `\'.\'` 表示。\n\n**示例 1:**\n\n```\n输入:\n[\n  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\n输出: true\n```\n\n**示例 2:**\n\n```\n输入:\n[\n  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\n输出: false\n解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。\n     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。\n```\n\n**说明:**\n\n- 一个有效的数独（部分已被填充）不一定是可解的。\n- 只需要根据以上规则，验证已经填入的数字是否有效即可。\n- 给定数独序列只包含数字 `1-9` 和字符 `\'.\'` 。\n- 给定数独永远是 `9x9` 形式的。\n\n\n\n## 解法一：\n\n我们可以分别用三个二维数组来标记每一个数独数字在每一行、每一列、每一个以粗实线分隔的 `3x3` 宫内是否出现过，我们用二维数组的第一维来表示每一组的组数，三种情况都是9组。\n\n若使用`num = board[i][i]`来遍历，若`num != \'.\'`，那么\n\n- 行级数独的标记就是`row[i][num]`；\n- 列级数独的标记就是`col[j][num]`；\n- 块级数独的标记就是` lump[lumpNum][num]`，其中lumpNum表示块的序号，从左到右，从上到下分成9块，`lumpNum=i / 3 * 3 + j / 3 `。\n\n我们每遍历一个数独，只需要判断该数独在上述的三种情况是否重复出现即可。\n\n![QQ截图20200719105414](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/QQ截图20200719105414.png)\n\n### 代码：\n\n```java\nclass Solution {\n	public boolean isValidSudoku(char[][] board) {\n		// 记录每一行的数独\n		boolean[][] row = new boolean[9][9];\n		// 记录每一列的数独\n		boolean[][] col = new boolean[9][9];\n		// 记录每一方块的数据\n		boolean[][] lump = new boolean[9][9];\n\n		for (int i = 0; i < 9; i++) {\n			for (int j = 0; j < 9; j++) {\n				char num = board[i][j];\n				if (num != \'.\') {\n					num -= \'1\';\n					int lumpNum = i / 3 * 3 + j / 3;\n					if (row[i][num] || col[j][num] || lump[lumpNum][num]) {\n						return false;\n					} else {\n						row[i][num] = true;\n						col[j][num] = true;\n						lump[lumpNum][num] = true;\n					}\n				}\n			}\n		}\n		return true;\n	}\n}\n```\n\n', 0, 0, '2020-08-06 23:57:29', 2, 0, 1, '题目链接：https://leetcode-cn.com/problems/valid-sudoku/\n题目描述：判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。\n\n数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n\n上图是一个部分填充的有效的数独。\n数独部分空格内已填入了数字，空白格用 \'.\' 表示。\n示例 1:\n输入:[  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]输出: true示例 2:\n输入:[  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。说明:\n\n一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。给定数独序列只包含数字 1-9 和字符 \'.\' 。给定数独永远是 9x9 形式的。\n解法一：我们可以分别用三个二维数组来标记每一个数独数字在每一行、每一列、每一个以粗实线分隔的 3x3 宫内是否出现过，我们用二维数组的第一维来表示每一组的组数，三种情况都是9组。\n若使用num = board[i][i]来遍历，若num != \'.\'，那么\n\n行级数独的标记就是row[i][num]；列级数独的标记就是col[j][num]；块级数独的标记就是lump[lumpNum][num]，其中lumpNum表示块的序号，从左到右，从上到下分成9块，lumpNum=i / 3 * 3 + j / 3。\n我们每遍历一个数独，只需要判断该数独在上述的三种情况是否重复出现即可。\n\n代码：class Solution {    public boolean isValidSudoku(char[][] board) {        // 记录每一行的数独        boolean[][] row = new boolean[9][9];        // 记录每一列的数独        boolean[][] col = new boolean[9][9];        // 记录每一方块的数据        boolean[][] lump = new boolean[9][9];        for (int i = 0; i < 9; i++) {            for (int j = 0; j < 9; j++) {                char num = board[i][j];                if (num != \'.\') {                    num -= \'1\';                    int lumpNum = i / 3 * 3 + j / 3;                    if (row[i][num] || col[j][num] || lump[lumpNum][num]) {                        return false;                    } else {                        row[i][num] = true;                        col[j][num] = true;                        lump[lumpNum][num] = true;                    }                }            }        }        return true;    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (95, '37. 解数独（难度：困难）', 8, '\n\n> 题目链接：https://leetcode-cn.com/problems/sudoku-solver/\n\n##问题描述\n\n编写一个程序，通过已填充的空格来解决数独问题。\n\n一个数独的解法需**遵循如下规则**：\n\n1. 数字 `1-9` 在每一行只能出现一次。\n2. 数字 `1-9` 在每一列只能出现一次。\n3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。\n\n空白格用 `\'.\'` 表示。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/250px-Sudoku-by-L2G-20050714.svg.png)\n\n一个数独。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/250px-Sudoku-by-L2G-20050714.svg.png)\n\n答案被标成红色。\n\n**Note:**\n\n- 给定的数独序列只包含数字 `1-9` 和字符 `\'.\'` 。\n- 你可以假设给定的数独只有唯一解。\n- 给定数独永远是 `9x9` 形式的。\n\n\n\n## 解法一：回溯法\n\n该算法思想比较简单，给每个方块都设置约束，在数独上面放入一个数字，则这行、这列、这块（3*3）的元素都不能对这个数字再进行使用。从而减少回溯遍历的次数。\n\n我们只需要，逐行逐列的对每一个需要填写的数独赋以值，若当前正确，那么就进行下个数独的赋值；若出现了冲突，则开始回溯，尝试另一个可以的赋值。如果还是不行，那就再次回退。\n\n**如何查看是否冲突？**\n\n- 对该行进行遍历，查看是否有与新值相同的，即判断\n  `board[row][i] == ch`\n- 对该列进行遍历，查看是否有与新值相同的，即判断\n  `board[i][col] == ch`\n- 对该块进行遍历，查看是否有与新值相同的，即判断\n  `board[lumpRow][lumpCol] == ch`\n  - 其中lumpRow是指当前数独位置对应的块序号，\n    `lumpRow = (row / 3) * 3 + j / 3`\n  - 其中lumpCol是指当前数独位置在对应的块中的下标，即从左到右，从上到下依次排列的序号，\n    `lumpRow = (row / 3) * 3 + j / 3`\n\n![36_boxes_2.png](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/5a7856c3c2a2185600b7cb5cd3fd50101281af7391a70a63293d82d62873aadd-36_boxes_2.png)\n\n算法思想：\n\n（1）从左上角开始 `row = 0,col = 0`。直到到达第一个空方格。\n\n（2）从 1 到 9 之间的数字d 依次尝试放入[row,col] 格子\n\n（3）若 d 没有出现在当前行，列，方块中，则放入该方格中，进行下一个方格的尝试。\n\n（4）若d出现在当前行或列或方块中，则回到到第（2）步，尝试下一个d。\n\n（5）若所有的d都尝试完，仍然没有满足的，则回溯到上一步，即上一个方格的赋值进行更改，然后重复（2）以后的操作。\n\n\n\n### 代码：\n\n![image-20200719204820419](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200719204820419.png)\n\n```java\nclass Solution {\n	public void solveSudoku(char[][] board) {\n		sudaoKu(board, 0, 0);\n	}\n\n	private boolean sudaoKu(char[][] board, int row, int col) {\n		int n = board.length; // 9\n\n		// 若一行满了，跳转到下一行\n		if (col == n) {\n			return sudaoKu(board, row + 1, 0);\n		}\n\n		/*\n		 * 当到最后一个数独board[8][8]，\n		 * 若验证成功， 下来是board[8][9],满足上面条件，\n		 * 会到board[9][0], \n		 * 当到这块说明数独找到解法了,\n		 * 此处是整个回溯算法的出口\n		 */\n		if (row == n) {\n			return true;\n		}\n\n		// 当该位置已经有数字，直接去找下一个未填数的位置\n		if (board[row][col] != \'.\') {\n			return sudaoKu(board, row, col + 1);\n		}\n\n		// 遍历填数\n		for (char i = \'1\'; i <= \'9\'; i++) {\n			// 验证放入i是否满足条件\n			if (!verify(board, row, col, i)) {\n				continue;\n			}else {\n				//将i放入该位置\n				board[row][col] = i;\n				//接着递归判断下一列元素\n				//若成功找到解法，则返回true\n				if(sudaoKu(board,row,col+1)) {\n					return true;\n				}else {\n					//否则，回溯\n					board[row][col] = \'.\';\n				}\n			}\n		}\n		return false;\n	}\n\n	/*\n	 * 验证在[row,col]位置插入i，是否满足条件 只需验证同一行、同一列、同一方块是否存在重复\n	 * \n	 */\n	private boolean verify(char[][] board, int row, int col, char i) {\n\n		for (int j = 0; j < 9; j++) {		\n			// 根据j来遍历所在块，计算出该块中每个数独的位置，在整个board中的位置坐标。\n			int lumpRow = (row / 3) * 3 + j / 3;\n			int lumpCol = (col / 3) * 3 + j % 3;\n			//判断所在行是否存在重复\n			if(board[row][j] == i) return false;\n			//判断所在列是否存在重复\n			if(board[j][col] == i) return false;\n			//判断所在块是否存在重复\n			if(board[lumpRow][lumpCol] == i) return false;\n		}\n		return true;\n	}\n}\n```\n\n\n\n## 解法二：回溯法+状态压缩\n\n### 思路：\n\n#### 1、状态压缩\n\n（1）我们可以对每一行、每一列、每个`3*3`方块使用一个int数字来压缩存储他们中出现的数字。\n\n（2）然后我们可以得到每一个方格都有对应的行、列、方块中已经出现的数字，从而可以得到没有出现的数字，也就是可以供选择填入的数字，这样我们就可以大大提高效率。\n\n（3）我们可以选择约束最多的方格开始尝试赋值，这样可以大大减少我们回溯的次数，约束最多也就是指的在该方格的行和列以及`3*3`方块中出现不同数字的次数最多。\n\n（4）在每次填入数字之后，对压缩存储信息的数组进行更新。\n\n（5）根据压缩存储信息的更新，然后重新计算可以填入的数字。\n\n**那么我们如何使用一个int数字来压缩表示他们中出现的数字？**\n\n我们可以把每一个int 数字都想象成他的二进制形式。因为java中一个int类型的数字是32位，而我们若用每位来表示0-9之间的数字是否存在，只需要使用低位的9位。所以下面我只罗列地位的九位。\n\n若我们使用171来表示一个压缩存储信息：\n\n![image-20200719210525661](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200719210525661.png)\n\n（1）在我们存储信息的时候，只需要对每一行、每一列、每个`3*3`方块 的int数字 进行或运算，即 `rows[x] = rows[x] | 1<<n`\n\n（2）我们想要知道某个方格对应的行、列、方块已经存在的数字，只需要对他们进行或运算，即`rows[x] | cols[y] | cells[x/3][y/3]`;\n\n（3）若想拿到该方格可以填入的数字，只需要对上面表达式取反，即`~(rows[x] | cols[y] | cells[x/3][y/3])`;\n\n（4）若想知道那个方格的约束最多，只需要对上述计算的已经存在的数字，计算出其二进制的1的个数，个数最多的表示约束最多。\n我们可以利用Integer.bitCount() 方法刚好可以得到1的个数。\n\n\n\n下图，不是自己做的，直接使用大佬的图：\n\n![1fb1c64cfddb5c66b61bd769224724a05027172d6486feb19b3a16d9473372ee-图片](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/1fb1c64cfddb5c66b61bd769224724a05027172d6486feb19b3a16d9473372ee-图片.png)\n\n\n\n\n\n### 代码：\n\n![QQ截图20200719193327](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/QQ截图20200719193327.png)\n\n```java\nclass Solution {\n    	//解法二\n	/* rows,cols,cells分别表示在某行、某列、某块已经出现的数字\n	 * 使用二进制表示\n	 * 如：	 100010010\n	 * 对应：  987654321\n	 * 已经存在的数字：9,5,2\n	 */\n	\n	int rows[] = new int[9];\n	int cols[] = new int[9];\n	int cells[][] = new int[3][3];\n	\n	/*计算出[x,y]坐标可以填的数，用二进制表示可以填写的数\n	 * 如      100100010\n	 * 对应  987654321\n	 * 可以填写是数字为9,6,2\n	 */\n	private int getPossibleStatus(int x,int y) {\n		return ~(rows[x] | cols[y] | cells[x/3][y/3]);\n	}\n	\n	/*\n	 * 找到能够填写数字的个数最小的那个位置，\n	 * 即通过getPossibleStatus方法得到的数字，转为二进制\n	 * 其中1的个数最小的那个位置\n	 */\n	private Map<Integer, Integer> getNext(char[][] board) {\n		Map<Integer, Integer> map = new HashMap<>();\n		int min = 33;\n		int r = 0,c =0;\n		for(int i = 0;i<9;i++) {\n			for(int j = 0;j<9;j++) {\n				if(board[i][j] != \'.\') continue;\n				int temp = getPossibleStatus(i, j);\n				//计算其中包含1的个数，即可以填写的数字的个数\n				int tempNum = Integer.bitCount(temp);\n				if(tempNum >= min) continue;\n				r = i;\n				c = j;\n				min = tempNum;\n			}\n		}\n		map.put(r, c);\n		return map;\n	}\n	\n	/**\n	 * 更新三个数组的数据\n	 * flag若为true，则是更新指定位置的数为1，\n	 * 若为false则是，回调，将指定位置的数改为0.\n	 * @param x\n	 * @param y\n	 * @param n\n	 */\n	private void fillNum(int x,int y,int n,boolean flag) {\n		rows[x] = (flag)?(rows[x] | 1<<n):(rows[x] & (~(1<<n)) );\n		cols[y] = (flag)?(cols[y] | 1<<n):(cols[y] & (~(1<<n)) );\n		cells[x/3][y/3] = (flag)?(cells[x/3][y/3] | 1<<n):(cells[x/3][y/3] & (~(1<<n)) );\n	}\n	\n	/**\n	 * 回溯方法\n	 * @param board\n	 * @param cnt\n	 * @return\n	 */\n	boolean dfs(char[][] board,int cnt) {\n		if(cnt == 0) {\n			return true;\n		}\n		\n		//计算出可填的数字个数最小的坐标\n		Map<Integer, Integer> map = getNext(board);\n		\n		int x = 0,y = 0;\n		//拿到x,y坐标\n		for(Map.Entry<Integer, Integer> entry : map.entrySet()){\n		    x = entry.getKey();\n		    y = entry.getValue();\n		}\n		\n		//拿到可以填写的数字\n		int bits = getPossibleStatus(x, y);\n		\n		//在指定位置填数\n		for(int n = 0;n<9;n++) {\n			//找到可以填的数字（挨个试）\n			//若不是可以填写的数字则跳过\n			if((bits & (1<<n)) == 0) continue;\n			fillNum(x, y, n, true);\n			board[x][y] = (char) (n + \'1\');\n			if(dfs(board, cnt - 1)) \n				return true;\n			//如若不能找到最终结果，则回调\n			board[x][y] = \'.\';\n			fillNum(x, y, n, false);\n		} \n		return false;\n	}\n	\n	\n	public void solveSudoku(char[][] board) {\n		//计算\'.\'的个数，即需要补空的个数\n		int cnt = 0;\n		\n		for (int i = 0; i < board.length; i++) {\n			for (int j = 0; j < board[i].length; j++) {\n				cnt += (board[i][j] == \'.\'? 1:0);\n				if(board[i][j] == \'.\')\n					continue;\n				int n = board[i][j] -\'1\';\n				fillNum(i,j,n,true);\n			}\n		}\n		dfs(board, cnt);\n	}	\n}\n```\n\n', 0, 0, '2020-08-08 20:41:48', 11, 1, 1, '\n题目链接：https://leetcode-cn.com/problems/sudoku-solver/\n\n问题描述编写一个程序，通过已填充的空格来解决数独问题。\n一个数独的解法需遵循如下规则：\n\n数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n空白格用 \'.\' 表示。\n\n一个数独。\n\n答案被标成红色。\nNote:\n\n给定的数独序列只包含数字 1-9 和字符 \'.\' 。你可以假设给定的数独只有唯一解。给定数独永远是 9x9 形式的。\n解法一：回溯法该算法思想比较简单，给每个方块都设置约束，在数独上面放入一个数字，则这行、这列、这块（3*3）的元素都不能对这个数字再进行使用。从而减少回溯遍历的次数。\n我们只需要，逐行逐列的对每一个需要填写的数独赋以值，若当前正确，那么就进行下个数独的赋值；若出现了冲突，则开始回溯，尝试另一个可以的赋值。如果还是不行，那就再次回退。\n如何查看是否冲突？\n\n对该行进行遍历，查看是否有与新值相同的，即判断board[row][i] == ch对该列进行遍历，查看是否有与新值相同的，即判断board[i][col] == ch对该块进行遍历，查看是否有与新值相同的，即判断board[lumpRow][lumpCol] == ch\n其中lumpRow是指当前数独位置对应的块序号，lumpRow = (row / 3) * 3 + j / 3其中lumpCol是指当前数独位置在对应的块中的下标，即从左到右，从上到下依次排列的序号，lumpRow = (row / 3) * 3 + j / 3\n\n\n算法思想：\n（1）从左上角开始 row = 0,col = 0。直到到达第一个空方格。\n（2）从 1 到 9 之间的数字d 依次尝试放入[row,col] 格子\n（3）若 d 没有出现在当前行，列，方块中，则放入该方格中，进行下一个方格的尝试。\n（4）若d出现在当前行或列或方块中，则回到到第（2）步，尝试下一个d。\n（5）若所有的d都尝试完，仍然没有满足的，则回溯到上一步，即上一个方格的赋值进行更改，然后重复（2）以后的操作。\n代码：\nclass Solution {    public void solveSudoku(char[][] board) {        sudaoKu(board, 0, 0);    }    private boolean sudaoKu(char[][] board, int row, int col) {        int n = board.length; // 9        // 若一行满了，跳转到下一行        if (col == n) {            return sudaoKu(board, row + 1, 0);        }        /*         * 当到最后一个数独board[8][8]，         * 若验证成功， 下来是board[8][9],满足上面条件，         * 会到board[9][0],          * 当到这块说明数独找到解法了,         * 此处是整个回溯算法的出口         */        if (row == n) {            return true;        }        // 当该位置已经有数字，直接去找下一个未填数的位置        if (board[row][col] != \'.\') {            return sudaoKu(board, row, col + 1);        }        // 遍历填数        for (char i = \'1\'; i <= \'9\'; i++) {            // 验证放入i是否满足条件            if (!verify(board, row, col, i)) {                continue;            }else {                //将i放入该位置                board[row][col] = i;                //接着递归判断下一列元素                //若成功找到解法，则返回true                if(sudaoKu(board,row,col+1)) {                    return true;                }else {                    //否则，回溯                    board[row][col] = \'.\';                }            }        }        return false;    }    /*     * 验证在[row,col]位置插入i，是否满足条件 只需验证同一行、同一列、同一方块是否存在重复     *      */    private boolean verify(char[][] board, int row, int col, char i) {        for (int j = 0; j < 9; j++) {                    // 根据j来遍历所在块，计算出该块中每个数独的位置，在整个board中的位置坐标。            int lumpRow = (row / 3) * 3 + j / 3;            int lumpCol = (col / 3) * 3 + j % 3;            //判断所在行是否存在重复            if(board[row][j] == i) return false;            //判断所在列是否存在重复            if(board[j][col] == i) return false;            //判断所在块是否存在重复            if(board[lumpRow][lumpCol] == i) return false;        }        return true;    }}\n解法二：回溯法+状态压缩思路：1、状态压缩（1）我们可以对每一行、每一列、每个3*3方块使用一个int数字来压缩存储他们中出现的数字。\n（2）然后我们可以得到每一个方格都有对应的行、列、方块中已经出现的数字，从而可以得到没有出现的数字，也就是可以供选择填入的数字，这样我们就可以大大提高效率。\n（3）我们可以选择约束最多的方格开始尝试赋值，这样可以大大减少我们回溯的次数，约束最多也就是指的在该方格的行和列以及3*3方块中出现不同数字的次数最多。\n（4）在每次填入数字之后，对压缩存储信息的数组进行更新。\n（5）根据压缩存储信息的更新，然后重新计算可以填入的数字。\n那么我们如何使用一个int数字来压缩表示他们中出现的数字？\n我们可以把每一个int 数字都想象成他的二进制形式。因为java中一个int类型的数字是32位，而我们若用每位来表示0-9之间的数字是否存在，只需要使用低位的9位。所以下面我只罗列地位的九位。\n若我们使用171来表示一个压缩存储信息：\n\n（1）在我们存储信息的时候，只需要对每一行、每一列、每个3*3方块 的int数字 进行或运算，即 rows[x] = rows[x] | 1<<n\n（2）我们想要知道某个方格对应的行、列、方块已经存在的数字，只需要对他们进行或运算，即rows[x] | cols[y] | cells[x/3][y/3];\n（3）若想拿到该方格可以填入的数字，只需要对上面表达式取反，即~(rows[x] | cols[y] | cells[x/3][y/3]);\n（4）若想知道那个方格的约束最多，只需要对上述计算的已经存在的数字，计算出其二进制的1的个数，个数最多的表示约束最多。我们可以利用Integer.bitCount() 方法刚好可以得到1的个数。\n下图，不是自己做的，直接使用大佬的图：\n\n代码：\nclass Solution {        //解法二    /* rows,cols,cells分别表示在某行、某列、某块已经出现的数字     * 使用二进制表示     * 如：     100010010     * 对应：  987654321     * 已经存在的数字：9,5,2     */    int rows[] = new int[9];    int cols[] = new int[9];    int cells[][] = new int[3][3];    /*计算出[x,y]坐标可以填的数，用二进制表示可以填写的数     * 如      100100010     * 对应  987654321     * 可以填写是数字为9,6,2     */    private int getPossibleStatus(int x,int y) {        return ~(rows[x] | cols[y] | cells[x/3][y/3]);    }    /*     * 找到能够填写数字的个数最小的那个位置，     * 即通过getPossibleStatus方法得到的数字，转为二进制     * 其中1的个数最小的那个位置     */    private Map<Integer, Integer> getNext(char[][] board) {        Map<Integer, Integer> map = new HashMap<>();        int min = 33;        int r = 0,c =0;        for(int i = 0;i<9;i++) {            for(int j = 0;j<9;j++) {                if(board[i][j] != \'.\') continue;                int temp = getPossibleStatus(i, j);                //计算其中包含1的个数，即可以填写的数字的个数                int tempNum = Integer.bitCount(temp);                if(tempNum >= min) continue;                r = i;                c = j;                min = tempNum;            }        }        map.put(r, c);        return map;    }    /**     * 更新三个数组的数据     * flag若为true，则是更新指定位置的数为1，     * 若为false则是，回调，将指定位置的数改为0.     * @param x     * @param y     * @param n     */    private void fillNum(int x,int y,int n,boolean flag) {        rows[x] = (flag)?(rows[x] | 1<<n):(rows[x] & (~(1<<n)) );        cols[y] = (flag)?(cols[y] | 1<<n):(cols[y] & (~(1<<n)) );        cells[x/3][y/3] = (flag)?(cells[x/3][y/3] | 1<<n):(cells[x/3][y/3] & (~(1<<n)) );    }    /**     * 回溯方法     * @param board     * @param cnt     * @return     */    boolean dfs(char[][] board,int cnt) {        if(cnt == 0) {            return true;        }        //计算出可填的数字个数最小的坐标        Map<Integer, Integer> map = getNext(board);        int x = 0,y = 0;        //拿到x,y坐标        for(Map.Entry<Integer, Integer> entry : map.entrySet()){            x = entry.getKey();            y = entry.getValue();        }        //拿到可以填写的数字        int bits = getPossibleStatus(x, y);        //在指定位置填数        for(int n = 0;n<9;n++) {            //找到可以填的数字（挨个试）            //若不是可以填写的数字则跳过            if((bits & (1<<n)) == 0) continue;            fillNum(x, y, n, true);            board[x][y] = (char) (n + \'1\');            if(dfs(board, cnt - 1))                 return true;            //如若不能找到最终结果，则回调            board[x][y] = \'.\';            fillNum(x, y, n, false);        }         return false;    }    public void solveSudoku(char[][] board) {        //计算\'.\'的个数，即需要补空的个数        int cnt = 0;        for (int i = 0; i < board.length; i++) {            for (int j = 0; j < board[i].length; j++) {                cnt += (board[i][j] == \'.\'? 1:0);                if(board[i][j] == \'.\')                    continue;                int n = board[i][j] -\'1\';                fillNum(i,j,n,true);            }        }        dfs(board, cnt);    }    }\n', 0, 1);
INSERT INTO `t_article` VALUES (96, '01. Linux查看CPU内存和系统版本', 8, '\n## 1. 查看CPU信息\n\n\n\n### 1.1 查看CPU基本硬件信息\n\n命令：\n\n```\ncat /proc/cpuinfo\n```\n\n![image-20200807000748700](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807000748700.png)\n\n\n\n### 1.2 查看CPU使用状态信息\n\n命令：\n\n方法一：静态获取CPU信息\n\n```\ntop\n```\n\n![image-20200807000825798](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807000825798.png)\n\n\n\n方法二：动态获取CPU使用情况\n\n```\ndstat\n```\n\n![image-20200807001002975](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001002975.png)\n\n如果计算机没有安装这个插件，可以使用如下命令安装：\n\n```\nyum install dstat\n```\n\n\n\n## 2. 查看内存信息\n\n### 2.1 **查看内存基本容量信息**\n\n命令：\n\n```\ncat /proc/meminfo\n```\n\n![image-20200807001048081](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001048081.png)\n\n\n\n### **2.2 查看内存运行空间信息**\n\n命令：\n\n```\nfree\n```\n\n![image-20200807001109454](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001109454.png)\n\n参数：\n\n- -k     以KB为单位显示\n- -m   以MB为单位显示\n\n\n\n## 3. **查看Linux 查看系统版本**\n\n命令：\n\n```\nuname -a\n```\n\n![image-20200807001128678](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001128678.png)', 0, 0, '2020-08-07 00:16:51', 7, 0, 1, '1. 查看CPU信息1.1 查看CPU基本硬件信息命令：\ncat /proc/cpuinfo\n1.2 查看CPU使用状态信息命令：\n方法一：静态获取CPU信息\ntop\n方法二：动态获取CPU使用情况\ndstat\n如果计算机没有安装这个插件，可以使用如下命令安装：\nyum install dstat2. 查看内存信息2.1 查看内存基本容量信息命令：\ncat /proc/meminfo\n2.2 查看内存运行空间信息命令：\nfree\n参数：\n\n-k     以KB为单位显示-m   以MB为单位显示\n3. 查看Linux 查看系统版本命令：\nuname -a\n', 0, 1);
INSERT INTO `t_article` VALUES (97, '02. Linux命令之查看网络连接', 8, '\n## 1. 查看网络连接数和端口\n\n使用 **netstat** 命令查看网络连接情况\n\n```\nnetstat -anp\n```\n\n![image-20200807001308156](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001308156.png)\n\n\n\n### **参数：**\n\n- -a 显示所有选项\n- -t (tcp)仅显示tcp相关选项\n- -u (udp)仅显示udp相关选项\n- -n 拒绝显示别名，能显示数字的全部转化成数字。\n- -p 显示建立相关链接的程序名\n\n\n\n### **关键列解释:**\n\n- Proto 表示协议类型\n- LocalAddress 表示本地地址\n- ForeignAddress 表示对端地址\n- State 表示状态(对于 TCP 有效, UDP 没有状态概念)\n- PID/Program name 表示对应的进程id和进程名\n\n可以使用筛选拿到想要信息：\n\n**（1）查看111端口被那个进程调用**\n\n```\nnetstat -anp | grep 111\n```\n\n![image-20200807001342190](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001342190.png)\n\n**（2）查看进程名为firefox的连接**\n\n```\nnetstat -anp | grep firefox\n```\n\n![image-20200807001537466](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001537466.png)\n\n\n\n## 2. 查看进程信息\n\n使用 **top** 命令可以查看进程信息\n\n```\ntop\n```\n\n![image-20200807001606773](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001606773.png)\n\n\n\n### 结果解释:\n\n\n\n#### **前 5 行是统计信息区**\n\n\n\n- 第一行是任务队列信息，同 uptime 命令的执行结果。其中 load 表示系统负载(任务队列的平均长度)，值越大表示当前系统就越繁忙\n\n- 第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行\n\n- 第四、五行尾内存信息\n\n- 第四行 Mem: total 物理内存总量，used 使用的物理内存总量，free 空闲内存总量，buffers 用作内核缓存的内存量\n\n- 第五行 表示 Swap 分区的使用情况\n\n  \n\n**接下来是进程列表**。默认按照 CPU 占用情况降序排序(第一行就是当前占用 CPU 最多的进程)\n\n\n\n#### **常用列解释:**\n\n- PID 表示进程 id\n- USER 表示进程拥有者的用户id\n- PR 表示进程优先级\n- NI 表示 nice 值，和 PR 搭配使用\n- VIRT 表示虚拟内存使用情况\n- RES 表示物理内存使用情况(如果进程使用的物理内存的和接近机器的物理内存总量, 就会出现内存不够用的情况)\n- %CPU 表示该进程占用 CPU 的百分比(多核机器这个值可以超过 100%)\n- COMMAND 对应到这个进程启动的命令\n\n\n\n#### **top 的一些常见用法**:\n\n1) 查看占用内存最多的前 N 个进程\n\n- 先执行 top 命令, 再使用快捷键 M 即可按内存占用降序排序\n\n2) 查看 CPU 占用最多的前 N 个进程\n\n- 先执行 top 命令, 再使用快捷键 P 即可按照 CPU 占用降序排序\n\n3) 查看某个进程中的线程情况\n\n```\ntop -p [pid]\n```\n\n\n\n## 3. 查看ip地址\n\n命令：\n\n```\nifconfig\n```\n\n![image-20200807001636749](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001636749.png)\n\n由于一台主机可能同时具备多个网络接口, 查看到的 ip 地址也就可能有多个。\n\n网络接口对应到主机的网卡或者虚拟网卡设备. 一台主机可以具有多个网卡, 也就可以有多个 IP 地址。', 0, 0, '2020-08-07 00:17:22', 2, 0, 1, '1. 查看网络连接数和端口使用 netstat 命令查看网络连接情况\nnetstat -anp\n参数：\n-a 显示所有选项-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-p 显示建立相关链接的程序名\n关键列解释:\nProto 表示协议类型LocalAddress 表示本地地址ForeignAddress 表示对端地址State 表示状态(对于 TCP 有效, UDP 没有状态概念)PID/Program name 表示对应的进程id和进程名\n可以使用筛选拿到想要信息：\n（1）查看111端口被那个进程调用\nnetstat -anp | grep 111\n（2）查看进程名为firefox的连接\nnetstat -anp | grep firefox\n2. 查看进程信息使用 top 命令可以查看进程信息\ntop\n结果解释:前 5 行是统计信息区\n第一行是任务队列信息，同 uptime 命令的执行结果。其中 load 表示系统负载(任务队列的平均长度)，值越大表示当前系统就越繁忙\n第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行\n第四、五行尾内存信息\n第四行 Mem: total 物理内存总量，used 使用的物理内存总量，free 空闲内存总量，buffers 用作内核缓存的内存量\n第五行 表示 Swap 分区的使用情况\n\n接下来是进程列表。默认按照 CPU 占用情况降序排序(第一行就是当前占用 CPU 最多的进程)\n常用列解释:\nPID 表示进程 idUSER 表示进程拥有者的用户idPR 表示进程优先级NI 表示 nice 值，和 PR 搭配使用VIRT 表示虚拟内存使用情况RES 表示物理内存使用情况(如果进程使用的物理内存的和接近机器的物理内存总量, 就会出现内存不够用的情况)%CPU 表示该进程占用 CPU 的百分比(多核机器这个值可以超过 100%)COMMAND 对应到这个进程启动的命令\ntop 的一些常见用法:1) 查看占用内存最多的前 N 个进程\n\n先执行 top 命令, 再使用快捷键 M 即可按内存占用降序排序\n2) 查看 CPU 占用最多的前 N 个进程\n\n先执行 top 命令, 再使用快捷键 P 即可按照 CPU 占用降序排序\n3) 查看某个进程中的线程情况\ntop -p [pid]3. 查看ip地址命令：\nifconfig\n由于一台主机可能同时具备多个网络接口, 查看到的 ip 地址也就可能有多个。\n网络接口对应到主机的网卡或者虚拟网卡设备. 一台主机可以具有多个网卡, 也就可以有多个 IP 地址。\n', 0, 1);
INSERT INTO `t_article` VALUES (98, '03. Linux命令之查看硬盘空间使用情况 ', 8, '\n## 1. 查看磁盘空间\n\n命令：\n\n```\ndf\n```\n\n![image-20200807001757407](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001757407.png)\n\n**简述：df 命令以磁盘分区为单位查看文件系统中磁盘空间的使用情况**\n\n选项：\n\n- -h   或  --human-readable\n\n  - 将信息以人类可读的形式打印\n    ![image-20200807001826271](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001826271.png)\n\n- -i  或   --inode\n\n  - 查看分区inode使用情况\n    !![image-20200807001844402](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001844402.png)\n\n    一般，如果inode分配不合理，会导致空间没使用完，但是没有inode号了,所以这个参数需要重点关注哦！别到时候，人死了，钱没花了~~\n\n\n\n## 2.  查看磁盘空间\n\n目录容量 = 目录本身的大小 + 目录下所有文件(包括子目录和普通文件)的总大小。\n\n命令：\n\n```\ndu\n```\n\n![image-20200807001926498](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807001926498.png)\n\n**df 和 du 命令的区别：**\n\n- du 命令是统计文件或目录及其子目录的硬盘空间使用情况，一般可以帮我们快速定位目录下是否存在超大文件或其他特殊大小的文件。\n- df 命令是统计磁盘分区整体的使用情况。\n- du 命令会直接到特定目录内查找所有文件数据，并统计累加，所以命令执行时会耗费一点儿时间。\n- df 命令直接从文件系统中提取信息，所以比较快速。\n\n\n\n**命令使用格式：**\n\n```\ndu 选项 文件/目录\n```\n\n\n\n**选项：**\n\n- -a或--all             \n  - 列出所有的文件和目录容量大小而不仅仅列出目录容量大小\n- -s或--summarize      \n  -  仅显示总计，只列出最后加总的值\n- -h或--human-readable  \n  - 以K，M，G为单位，提高信息的可读性\n- -c或- -total           \n  - 除了列出文件和目录的容量大小外，最后在列出总容量\n- --max-depth=N         \n  - 递归显示(仅仅是显示)时的递归深度小于等于N。--max-depth=0相当于-s参数', 0, 0, '2020-08-07 00:22:24', 2, 0, 1, '1. 查看磁盘空间命令：\ndf\n简述：df 命令以磁盘分区为单位查看文件系统中磁盘空间的使用情况\n选项：\n\n-h   或  —human-readable\n\n将信息以人类可读的形式打印\n-i  或   —inode\n\n查看分区inode使用情况!\n一般，如果inode分配不合理，会导致空间没使用完，但是没有inode号了,所以这个参数需要重点关注哦！别到时候，人死了，钱没花了~~\n\n\n2.  查看磁盘空间目录容量 = 目录本身的大小 + 目录下所有文件(包括子目录和普通文件)的总大小。\n命令：\ndu\ndf 和 du 命令的区别：\n\ndu 命令是统计文件或目录及其子目录的硬盘空间使用情况，一般可以帮我们快速定位目录下是否存在超大文件或其他特殊大小的文件。df 命令是统计磁盘分区整体的使用情况。du 命令会直接到特定目录内查找所有文件数据，并统计累加，所以命令执行时会耗费一点儿时间。df 命令直接从文件系统中提取信息，所以比较快速。\n命令使用格式：\ndu 选项 文件/目录选项：\n\n-a或—all             \n列出所有的文件和目录容量大小而不仅仅列出目录容量大小\n-s或—summarize      \n仅显示总计，只列出最后加总的值\n-h或—human-readable  \n以K，M，G为单位，提高信息的可读性\n-c或- -total           \n除了列出文件和目录的容量大小外，最后在列出总容量\n—max-depth=N         \n递归显示(仅仅是显示)时的递归深度小于等于N。—max-depth=0相当于-s参数\n\n', 0, 1);
INSERT INTO `t_article` VALUES (99, '04.Linux命令之文件权限', 8, '\n## 1、文件权限信息的查看-ll\n\n命令： ll 或 ls -l\n\n```\n[86god@localhost 桌面]$ ll\n总用量 0\n-rw-rw-r--. 1 86god 86god 0 6月  10 01:18 t1.txt\n-rw-rw-r--. 1 86god 86god 0 6月  10 01:19 t2.txt\n\n[86god@localhost 桌面]$ ls -l\n总用量 0\n-rw-rw-r--. 1 86god 86god 0 6月  10 01:18 t1.txt\n-rw-rw-r--. 1 86god 86god 0 6月  10 01:19 t2.txt\n```\n\n## 2、文件权限信息的认识\n\n首先，在Linux系统中文件的访问权限对文件的访问者进行了分类：文件所有者、文件所属组、其它用户。\n\n![image-20200807002649376](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807002649376.png)\n\n\n\n如上图所示：\n\n第1位：文件类型，当为文件夹时，是d\n\n第2-10位：文件权限\n\n| r    | w    | x      |\n| ---- | ---- | ------ |\n| 可读 | 可写 | 可执行 |\n\n文件权限还可以使用二进制数表示\n\n如：\n\n| 权限   | rw-  | rw-  | r--  |\n| ------ | ---- | ---- | ---- |\n| 二进制 | 110  | 110  | 100  |\n| 八进制 | 6    | 6    | 4    |\n\n所以上述权限，还可以使用664来表示！！！\n\n\n\n## 3、文件默认创建权限掩码设置-umask\n\n在shell中创建一个文件，虽然没有指定文件的权限，但是文件被创建成功后，默认会具有一个权限，这是因为文件创建之时的权限会受到系统中文件创建权限掩码的影响。\n\numask 命令可以查看系统中当前默认的权限掩码信息。\n\n命令：\n\n```\n[86god@localhost 桌面]$ umask\n0002\n[86god@localhost 桌面]$ umask -S\nu=rwx,g=rwx,o=rx\n```\n\n其中，u指的是文件所有者，g 指的是文件所属组， o 指的是其它用户\n\n同时，也可以使用umask 命令来设置默认的权限掩码信息\n\n命令：\n\n```\n[86god@localhost 桌面]$ umask 0000\n[86god@localhost 桌面]$ umask\n0000\n```\n\n\n\n## 4、文件访问权限的修改-chmod\n\numask 决定的是文件创建出来的默认权限，然而大多时候我们需要修改一个已经存在的文件权限，这时候就需要使用chmod命令（ps:全称change mode）完成。\n\n命令：\n\n```\nchmod [u,g,o][+,-,=][r,w,x]/[0-7] 文件名 \n\n-R 或 --recursive 　  #递归处理，将指定目录下的所有文件及子目录一并处理\n```\n\n\n\n注意：\n\n- [u,g,o]：u指的是文件所有者，g 指的是文件所属组， o 指的是其它用户\n- [+,-,=]：+代属性码添加权限，-取消权限，=将权限修改\n- [r,w,x]/[0-7]：权限的设置，可以为rwx的组合或者8进制数字。\n\n示例：\n\n```\n[86god@localhost 桌面]$ ll t1.txt\n-rw-rw-r--. 1 86god 86god 0 6月  10 01:18 t1.txt\n[86god@localhost 桌面]$ chmod u+x t1.txt\n[86god@localhost 桌面]$ ll t1.txt\n-rwxrw-r--. 1 86god 86god 0 6月  10 01:18 t1.txt\n\n\n[86god@localhost 桌面]$ chmod 777 t1.txt\n[86god@localhost 桌面]$ ll t1.txt\n-rwxrwxrwx. 1 86god 86god 0 6月  10 01:18 t1.txt\n```\n\n\n\n**chmod -R 选项**\n\n递归处理，将指定目录下的所有文件及子目录一并处理\n\n```\n[86god@localhost 桌面]$ tree d1\nd1\n├── t1.txt\n├── t2.txt\n└── t3.txt\n[86god@localhost 桌面]$ ll d1\n总用量 0\n-rw-rw-r--. 1 86god 86god 0 6月  10 02:08 t1.txt\n-rw-rw-r--. 1 86god 86god 0 6月  10 02:08 t2.txt\n-rw-rw-r--. 1 86god 86god 0 6月  10 02:08 t3.txt\n[86god@localhost 桌面]$ chmod -R 777 d1\n[86god@localhost 桌面]$ ll d1\n总用量 0\n-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t1.txt\n-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t2.txt\n-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t3.txt\n\n```\n\n\n\n## 5、文件所有者的修改-chown\n\n文件的所有者拥有对文件的权限进行修改的权力，但是若我们想要将这个权力交给另一个用户，也就是修改一个文件的所有者，那么就需要使用chown命令（ps:全称change owner）。\n\n命令：\n\n```\nchown 用户 文件名    #chown命令更改文件的所属用户\n-R         			#对目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更)\n```\n\n\n\n**chown命令示例：**\n\n```\n[86god@localhost 桌面]$ ll t1.txt\n-rwxrwxrwx. 1 86god 86god 0 6月  10 01:18 t1.txt\n[root@localhost 桌面]# chown root t1.txt\n[root@localhost 桌面]# ll t1.txt\n-rwxrwxrwx. 1 root 86god 0 6月  10 01:18 t1.txt\n```\n\n注意：\n\n- 修改文件的所有者，只能是root用户才有这权力。\n- 默认情况下只能修改文件的所有者，而对于目中的子文件却是没有任何影响。\n\n**chown -R命令示例：**\n\n递归修改文件夹内所有文件的所有者\n\n```\n[root@localhost 桌面]# ll d1\n总用量 0\n-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t1.txt\n-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t2.txt\n-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t3.txt\n[root@localhost 桌面]# chown -R root d1\n[root@localhost 桌面]# ll d1\n总用量 0\n-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t1.txt\n-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t2.txt\n-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t3.txt\n```\n\n\n\n## 6、文件所属组的修改-chgrp\n\n文件所属组中成员，具备对一个文件对应所属组的访问权限，若要将这个权力移交到另一个用户组中则需要使用chgrp命令（ps:全称change group）。\n\n**命令：**\n\n```\nchgrp 组名 文件名    #chgrp修改文件的所属组\n-R或--recursive 　  #递归处理，将指定目录下的所有文件及子目录一并处理。\n```\n\n**chgrp命令示例：**\n\n```\n[root@localhost 桌面]# ll t1.txt\n-rwxrwxrwx. 1 root 86god 0 6月  10 01:18 t1.txt\n[root@localhost 桌面]# chgrp root t1.txt\n[root@localhost 桌面]# ll t1.txt\n-rwxrwxrwx. 1 root root 0 6月  10 01:18 t1.txt\n```\n\n注意：\n\n- 修改文件的所属组，只能是root用户才有这权力。\n- 默认情况下只能修改文件的所属组，而对于目中的子文件却是没有任何影响。\n\n**chgrp -R选项：**\n\n递归修改文件夹内所有文件的所属组\n\n```\n[root@localhost 桌面]# ll d1\n总用量 0\n-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t1.txt\n-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t2.txt\n-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t3.txt\n[root@localhost 桌面]# chgrp -R root d1\n[root@localhost 桌面]# ll d1\n总用量 0\n-rwxrwxrwx. 1 root root 0 6月  10 02:08 t1.txt\n-rwxrwxrwx. 1 root root 0 6月  10 02:08 t2.txt\n-rwxrwxrwx. 1 root root 0 6月  10 02:08 t3.txt\n```\n\n## 7、总结\n\n![image-20200807002525416](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807002525416.png)', 0, 0, '2020-08-07 00:27:55', 2, 0, 1, '1、文件权限信息的查看-ll命令： ll 或 ls -l\n[86god@localhost 桌面]$ ll总用量 0-rw-rw-r--. 1 86god 86god 0 6月  10 01:18 t1.txt-rw-rw-r--. 1 86god 86god 0 6月  10 01:19 t2.txt[86god@localhost 桌面]$ ls -l总用量 0-rw-rw-r--. 1 86god 86god 0 6月  10 01:18 t1.txt-rw-rw-r--. 1 86god 86god 0 6月  10 01:19 t2.txt2、文件权限信息的认识首先，在Linux系统中文件的访问权限对文件的访问者进行了分类：文件所有者、文件所属组、其它用户。\n\n如上图所示：\n第1位：文件类型，当为文件夹时，是d\n第2-10位：文件权限\n\n\n\nr\nw\nx\n\n\n\n\n可读\n可写\n可执行\n\n\n\n文件权限还可以使用二进制数表示\n如：\n\n\n\n权限\nrw-\nrw-\nr—\n\n\n\n\n二进制\n110\n110\n100\n\n\n八进制\n6\n6\n4\n\n\n\n所以上述权限，还可以使用664来表示！！！\n3、文件默认创建权限掩码设置-umask在shell中创建一个文件，虽然没有指定文件的权限，但是文件被创建成功后，默认会具有一个权限，这是因为文件创建之时的权限会受到系统中文件创建权限掩码的影响。\numask 命令可以查看系统中当前默认的权限掩码信息。\n命令：\n[86god@localhost 桌面]$ umask0002[86god@localhost 桌面]$ umask -Su=rwx,g=rwx,o=rx其中，u指的是文件所有者，g 指的是文件所属组， o 指的是其它用户\n同时，也可以使用umask 命令来设置默认的权限掩码信息\n命令：\n[86god@localhost 桌面]$ umask 0000[86god@localhost 桌面]$ umask00004、文件访问权限的修改-chmodumask 决定的是文件创建出来的默认权限，然而大多时候我们需要修改一个已经存在的文件权限，这时候就需要使用chmod命令（ps:全称change mode）完成。\n命令：\nchmod [u,g,o][+,-,=][r,w,x]/[0-7] 文件名 -R 或 --recursive 　  #递归处理，将指定目录下的所有文件及子目录一并处理注意：\n\n[u,g,o]：u指的是文件所有者，g 指的是文件所属组， o 指的是其它用户[+,-,=]：+代属性码添加权限，-取消权限，=将权限修改[r,w,x]/[0-7]：权限的设置，可以为rwx的组合或者8进制数字。\n示例：\n[86god@localhost 桌面]$ ll t1.txt-rw-rw-r--. 1 86god 86god 0 6月  10 01:18 t1.txt[86god@localhost 桌面]$ chmod u+x t1.txt[86god@localhost 桌面]$ ll t1.txt-rwxrw-r--. 1 86god 86god 0 6月  10 01:18 t1.txt[86god@localhost 桌面]$ chmod 777 t1.txt[86god@localhost 桌面]$ ll t1.txt-rwxrwxrwx. 1 86god 86god 0 6月  10 01:18 t1.txtchmod -R 选项\n递归处理，将指定目录下的所有文件及子目录一并处理\n[86god@localhost 桌面]$ tree d1d1├── t1.txt├── t2.txt└── t3.txt[86god@localhost 桌面]$ ll d1总用量 0-rw-rw-r--. 1 86god 86god 0 6月  10 02:08 t1.txt-rw-rw-r--. 1 86god 86god 0 6月  10 02:08 t2.txt-rw-rw-r--. 1 86god 86god 0 6月  10 02:08 t3.txt[86god@localhost 桌面]$ chmod -R 777 d1[86god@localhost 桌面]$ ll d1总用量 0-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t1.txt-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t2.txt-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t3.txt5、文件所有者的修改-chown文件的所有者拥有对文件的权限进行修改的权力，但是若我们想要将这个权力交给另一个用户，也就是修改一个文件的所有者，那么就需要使用chown命令（ps:全称change owner）。\n命令：\nchown 用户 文件名    #chown命令更改文件的所属用户-R                     #对目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更)chown命令示例：\n[86god@localhost 桌面]$ ll t1.txt-rwxrwxrwx. 1 86god 86god 0 6月  10 01:18 t1.txt[root@localhost 桌面]# chown root t1.txt[root@localhost 桌面]# ll t1.txt-rwxrwxrwx. 1 root 86god 0 6月  10 01:18 t1.txt注意：\n\n修改文件的所有者，只能是root用户才有这权力。默认情况下只能修改文件的所有者，而对于目中的子文件却是没有任何影响。\nchown -R命令示例：\n递归修改文件夹内所有文件的所有者\n[root@localhost 桌面]# ll d1总用量 0-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t1.txt-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t2.txt-rwxrwxrwx. 1 86god 86god 0 6月  10 02:08 t3.txt[root@localhost 桌面]# chown -R root d1[root@localhost 桌面]# ll d1总用量 0-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t1.txt-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t2.txt-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t3.txt6、文件所属组的修改-chgrp文件所属组中成员，具备对一个文件对应所属组的访问权限，若要将这个权力移交到另一个用户组中则需要使用chgrp命令（ps:全称change group）。\n命令：\nchgrp 组名 文件名    #chgrp修改文件的所属组-R或--recursive 　  #递归处理，将指定目录下的所有文件及子目录一并处理。chgrp命令示例：\n[root@localhost 桌面]# ll t1.txt-rwxrwxrwx. 1 root 86god 0 6月  10 01:18 t1.txt[root@localhost 桌面]# chgrp root t1.txt[root@localhost 桌面]# ll t1.txt-rwxrwxrwx. 1 root root 0 6月  10 01:18 t1.txt注意：\n\n修改文件的所属组，只能是root用户才有这权力。默认情况下只能修改文件的所属组，而对于目中的子文件却是没有任何影响。\nchgrp -R选项：\n递归修改文件夹内所有文件的所属组\n[root@localhost 桌面]# ll d1总用量 0-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t1.txt-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t2.txt-rwxrwxrwx. 1 root 86god 0 6月  10 02:08 t3.txt[root@localhost 桌面]# chgrp -R root d1[root@localhost 桌面]# ll d1总用量 0-rwxrwxrwx. 1 root root 0 6月  10 02:08 t1.txt-rwxrwxrwx. 1 root root 0 6月  10 02:08 t2.txt-rwxrwxrwx. 1 root root 0 6月  10 02:08 t3.txt7、总结\n', 0, 1);
INSERT INTO `t_article` VALUES (100, '05.Linux命令之find命令', 8, '\n## 1、概述\n\nfind命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\n\n\n\n### 2、高频选项\n\n- -name filename : 文件名称符合 filename 的文件 , 大小写敏感\n- -iname filname : 文件名称符合 name 的文件，忽略大小写\n- -empty : 空文件\n- -size：指定文件大小\n\n\n\n## 3、find命令\n\n```\n[86god@localhost 桌面]$ find ~ -name t1.txt\n/home/86god/桌面/t1.txt\n/home/86god/桌面/d1/t1.txt\n```\n\nfind：find命令使用之起手式\n\n- ~：在当前用户的家目录下进行搜索，也可以传入不同的目录\n- -name：find命令之-name命令行参数\n- t1.txt：带查找的文件名称\n- /home/86god/桌面/d1/t1.txt：查找到在当前86god用户家目录下存在的t1.txt文件\n\n## 4、find [path] -iname [filename] 命令\n\n```\n[86god@localhost 桌面]$ find ~ -iname t1.txt\n/home/86god/桌面/t1.txt\n/home/86god/桌面/d1/t1.txt\n/home/86god/桌面/T1.txt\n```\n\n- -iname：find命令之-iname命令行参数，iname在使用的时候，对大小写不敏感。\n- 所有的t1.txt 和 T1.txt 都被搜索出来\n\n\n\n## 5、find [path] -empty命令\n\n```\n[86god@localhost 桌面]$ find . -empty \n./t2.txt\n./t3.class\n./t4.c\n./d1/t1.txt\n./d1/t2.txt\n./d1/t3.txt\n./T1.txt\n```\n\n- -empty：find命令之-empty命令行参数，使用该命令会罗列出指定目录以及子目录下的所有的空文件\n- . ：当前目录\n\n\n\n## 6、find [path] -size [filesize]命令\n\n```\n[86god@localhost 桌面]$ find -size 0k\n./t2.txt\n./t3.class\n./t4.c\n./d1/t1.txt\n./d1/t2.txt\n./d1/t3.txt\n./T1.txt\n```\n\n- *-size 0k*：查找文件大小为0k的文件\n\n\n\n```\n[86god@localhost 桌面]$ find -size +2k\n./t1.txt\n\n[86god@localhost 桌面]$ find -size -3k\n.\n./t2.txt\n./t3.class\n./t4.c\n./d1\n./d1/t1.txt\n./d1/t2.txt\n./d1/t3.txt\n./T1.txt\n\n\n[86god@localhost 桌面]$ find -size +2k -size -4k\n./t1.txt\n```\n\n- -size +2k：文件大小大于2k\n- -size -3k：文件大小小于3k\n- -size +2k -size -4k：文件大小大于2k小于4k\n\n\n\n## 7、总结\n\n\n\n- find [path] -name [filename]：在path目录下查找文件名成为filename的文件，大小写敏感\n- find [path] -iname [filename]：在path目录下查找文件名成为filename的文件，大小写不敏感\n- find [path] -empty：在path目录下查找文件大小为空的文件\n- find [path] -size [fileszie] ：查找定长的文件\n- find [path] -size +[filesize]：查找大于filesize的文件\n- find [path] -size -[filesize] ：查找小于filesize的文件\n- find [path] -size +[filesize1] -size -[filesize2] ：查找大于filesize1的文件并且小于filesize2的文件\n\n\n\n![image-20200807002854330](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807002854330.png)', 0, 0, '2020-08-07 00:29:30', 2, 0, 1, '1、概述find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\n2、高频选项\n-name filename : 文件名称符合 filename 的文件 , 大小写敏感-iname filname : 文件名称符合 name 的文件，忽略大小写-empty : 空文件-size：指定文件大小\n3、find命令[86god@localhost 桌面]$ find ~ -name t1.txt/home/86god/桌面/t1.txt/home/86god/桌面/d1/t1.txtfind：find命令使用之起手式\n\n~：在当前用户的家目录下进行搜索，也可以传入不同的目录-name：find命令之-name命令行参数t1.txt：带查找的文件名称/home/86god/桌面/d1/t1.txt：查找到在当前86god用户家目录下存在的t1.txt文件\n4、find [path] -iname [filename] 命令[86god@localhost 桌面]$ find ~ -iname t1.txt/home/86god/桌面/t1.txt/home/86god/桌面/d1/t1.txt/home/86god/桌面/T1.txt\n-iname：find命令之-iname命令行参数，iname在使用的时候，对大小写不敏感。所有的t1.txt 和 T1.txt 都被搜索出来\n5、find [path] -empty命令[86god@localhost 桌面]$ find . -empty ./t2.txt./t3.class./t4.c./d1/t1.txt./d1/t2.txt./d1/t3.txt./T1.txt\n-empty：find命令之-empty命令行参数，使用该命令会罗列出指定目录以及子目录下的所有的空文件. ：当前目录\n6、find [path] -size [filesize]命令[86god@localhost 桌面]$ find -size 0k./t2.txt./t3.class./t4.c./d1/t1.txt./d1/t2.txt./d1/t3.txt./T1.txt\n-size 0k：查找文件大小为0k的文件\n[86god@localhost 桌面]$ find -size +2k./t1.txt[86god@localhost 桌面]$ find -size -3k../t2.txt./t3.class./t4.c./d1./d1/t1.txt./d1/t2.txt./d1/t3.txt./T1.txt[86god@localhost 桌面]$ find -size +2k -size -4k./t1.txt\n-size +2k：文件大小大于2k-size -3k：文件大小小于3k-size +2k -size -4k：文件大小大于2k小于4k\n7、总结\nfind [path] -name [filename]：在path目录下查找文件名成为filename的文件，大小写敏感find [path] -iname [filename]：在path目录下查找文件名成为filename的文件，大小写不敏感find [path] -empty：在path目录下查找文件大小为空的文件find [path] -size [fileszie] ：查找定长的文件find [path] -size +[filesize]：查找大于filesize的文件find [path] -size -[filesize] ：查找小于filesize的文件find [path] -size +[filesize1] -size -[filesize2] ：查找大于filesize1的文件并且小于filesize2的文件\n\n', 0, 1);
INSERT INTO `t_article` VALUES (101, '06.Linux命令之grep命令', 8, '\n## 1、grep是什么？\n\ngrep是一个文本过滤器，作用是在文件中查找符合我们要求的内容。\n\n\n\n## 2、命令格式\n\n**形式一**，从指定的文件中找出匹配pattern的行：\n\ngrep [option] pattern [file1,file2,...]\n\n**形式二**，从管道中找出匹配pattern的行：\n\ncmd | grep [option] pattern\n\n说明：pattern是由正则表达式字符及文本字符所编写的过滤条件。\n\n\n\n## 3、常见选项\n\n| 选项 | 含义                                                       |\n| ---- | ---------------------------------------------------------- |\n| -v   | 在指定文本**反向**搜索指定内容，打印**不包含**指定内容的行 |\n| -i   | 在指定文本搜索以指定内容结束的行,指定内容**不区分大小写**  |\n| -n   | 在指定文本搜索指定内容，若找到，则返回**内容行及行号**。   |\n| -r   | 递归搜索                                                   |\n| -E   | 支持扩展正则表达式                                         |\n| -F   | 不按正则表达式匹配，按字符串的字面意思匹配                 |\n| -c   | 只输出匹配行的数量，不显示具体内容                         |\n| -o   | 只显示模式匹配的字符串                                     |\n\n## 4、代码示例\n\n（1）无附加选项\n\n```\n[86god@localhost 桌面]$ grep love t2.txt\nI love you\nI love you\nI love you\nI love you\n```\n\n（2）-v 选项，反向匹配：\n\n```\n[86god@localhost 桌面]$ grep -v love t2.txt\nI LOVE YOU\nI Love You\nI LOVE YOU\nI Love You\nI LOVE YOU\nI Love You\nI LOVE YOU\nI Love You\nI l* you\n```\n\n（3）-i 选项，忽略大小写：\n\n```\n[86god@localhost 桌面]$ grep -i \"LOVE\" t2.txt\nI love you\nI LOVE YOU\nI Love You\nI love you\nI LOVE YOU\nI Love You\nI love you\nI LOVE YOU\nI Love You\nI love you\nI LOVE YOU\nI Love You\n```\n\n（4）-n 选项，显示匹配行的行号：\n\n```\n[86god@localhost 桌面]$ grep -n love t2.txt\n1:I love you\n4:I love you\n7:I love you\n10:I love you\n```\n\n（5）-E 支持扩展正则，| 是扩展正则中的特殊含义的符号，代表任意一个匹配（不是管道哦）：\n\n```\n[86god@localhost 桌面]$ grep -E \'love|LOVE\' t2.txt\nI love you\nI LOVE YOU\nI love you\nI LOVE YOU\nI love you\nI LOVE YOU\nI love you\nI LOVE YOU\n```\n\n（6）-F 不要按正则来解析，就要字符串本身:\n\n```\n[86god@localhost 桌面]$ grep -F  \"l*\" t2.txt\nI l* you\n```\n\n（7）-c 只显示匹配的行数：\n\n```\n[86god@localhost 桌面]$ grep -c love t2.txt\n4\n```\n\n\n\n## 5、总结\n\n![image-20200807003010540](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807003010540.png)', 0, 0, '2020-08-07 00:30:39', 2, 0, 1, '1、grep是什么？grep是一个文本过滤器，作用是在文件中查找符合我们要求的内容。\n2、命令格式形式一，从指定的文件中找出匹配pattern的行：\ngrep [option] pattern [file1,file2,…]\n形式二，从管道中找出匹配pattern的行：\ncmd | grep [option] pattern\n说明：pattern是由正则表达式字符及文本字符所编写的过滤条件。\n3、常见选项\n\n\n选项\n含义\n\n\n\n\n-v\n在指定文本反向搜索指定内容，打印不包含指定内容的行\n\n\n-i\n在指定文本搜索以指定内容结束的行,指定内容不区分大小写\n\n\n-n\n在指定文本搜索指定内容，若找到，则返回内容行及行号。\n\n\n-r\n递归搜索\n\n\n-E\n支持扩展正则表达式\n\n\n-F\n不按正则表达式匹配，按字符串的字面意思匹配\n\n\n-c\n只输出匹配行的数量，不显示具体内容\n\n\n-o\n只显示模式匹配的字符串\n\n\n\n4、代码示例（1）无附加选项\n[86god@localhost 桌面]$ grep love t2.txtI love youI love youI love youI love you（2）-v 选项，反向匹配：\n[86god@localhost 桌面]$ grep -v love t2.txtI LOVE YOUI Love YouI LOVE YOUI Love YouI LOVE YOUI Love YouI LOVE YOUI Love YouI l* you（3）-i 选项，忽略大小写：\n[86god@localhost 桌面]$ grep -i \"LOVE\" t2.txtI love youI LOVE YOUI Love YouI love youI LOVE YOUI Love YouI love youI LOVE YOUI Love YouI love youI LOVE YOUI Love You（4）-n 选项，显示匹配行的行号：\n[86god@localhost 桌面]$ grep -n love t2.txt1:I love you4:I love you7:I love you10:I love you（5）-E 支持扩展正则，| 是扩展正则中的特殊含义的符号，代表任意一个匹配（不是管道哦）：\n[86god@localhost 桌面]$ grep -E \'love|LOVE\' t2.txtI love youI LOVE YOUI love youI LOVE YOUI love youI LOVE YOUI love youI LOVE YOU（6）-F 不要按正则来解析，就要字符串本身:\n[86god@localhost 桌面]$ grep -F  \"l*\" t2.txtI l* you（7）-c 只显示匹配的行数：\n[86god@localhost 桌面]$ grep -c love t2.txt45、总结\n', 0, 1);
INSERT INTO `t_article` VALUES (102, 'Linux常用指令', 8, '\nLinux 命令格式：\n\n- cmd -option parameter\n  - cmd 是命令，option 就是一个操作，parameter 操作的对象\n\n## cd命令：\n\n- cd 桌面：进入\"桌面\"目录\n- cd .. ：返回上级目录\n- cd ~:返回当前用户的 home 目录\n- cd ~用户名：返回之前用户的 home 目录\n- cd -: 和上一次打开的文件夹来回切换\n- cd . : 当前的文件夹\n\n\n\n## clear 命令：\n\n- clear: 清空终端界面\n\n\n\n## pwd命令：\n\n- pwd:显示当前的路径\n\n## ls命令：\n\n- ls:查看文件目录\n- ls -f:查看目录中的文件\n- ls -a:查看隐藏文件\n- ls -l :查看文件和目录的详细资料，可查看文件权限\n- ls -i:查看文件和文件夹id\n- ll :查看文件和目录的详细资料，类似与ls -l，多了一个 ./ 当前目录和 ../ 上级了目录\n- 过滤搜索：\n  - [abc] ：文件夹或文件包含abc任意一个            \n    - 例如： ls [abc].txt   ---> a.txt             \n  - *：文件夹或文件包含一个或多个字符 \n    - 例如： ls  *.txt         ---> a.txt    b.txt  aaa.txt\n  - ?:        文件夹或文件包含某个字符                  \n    - 例如：  ls ????.js     --->alog.js   link.js\n\n## chmod 命令：\n\n- chmod [ugoa] [+-=] [rwxX] 文件名：\n  - u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 \n  - \\+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 \n  - r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 \n  - 例如：chmod u+w /etc/sudoers\n    - 将sudoers文件添加可写的权限\n  - 例如：chmod u-wr,g-rw t1.txt \n    - 将t1.txt 的用户和分组的可读可写权限去掉\n- chmod [ugoa] [+-=] [数字] 文件名：\n  - r--4 , w--2 , x--1 \n  - 用数字的和代表权限\n    - 例如：chmod 777 t1.txt\n      - 将t1.txt 文件的用户权限、分组权限、其他用户权限全部设为可读可写可执行\n    - 例如：chmod 467 t1.txt\n      - 将t1.txt 文件的用户权限设为可读，分组权限设为可读可写，其他用户权限设为可读可写可执行\n\n## chown 命令：\n\n- chown 用户名 文件名：修改文件的所属者\n  - 例如：chown user3 t1.txt\n    - 修改t1.txt 的所有者为user3\n- chown -R 用户名 文件夹名：递归修改文件夹中所有文件的所属者\n  - 例如：chown -R user3 dd\n    - 递归修改dd文件夹中所有文件的所属者为user3 \n\n\n\n## chgrp 命令：\n\n- chgrp 组名 文件名：修改文件的所属组\n  - 例如：chgrp user2 t1.txt\n    - 修改t1.txt 的所有组为user2\n- chgrp -R 组名 文件夹名：递归修改文件夹中所有文件的所属组\n  - 例如：chgrp -R user2 dd\n    - 递归修改dd文件夹中所有文件的所属组为user2\n\n\n\n## touch 命令：	\n\n- touch 文件名.txt :  创建txt 文本文件（有txt后缀名）\n  - 例如：touch hello.txt\n- touch 文件名：     创建txt 文本文件（没有txt后缀名）\n  - 例如：touch hello\n\n\n\n## mkdir 命令：\n\n- mkdir 文件夹名： 创建文件夹\n  - 例如：mkdir 我的文件夹\n\n\n\n## rm 命令：\n\n- rm 文件名 :            删除文件\n  - 例如：rm T1.txt\n- rm -d 文件夹名：   删除文件夹，删除空文件夹\n  - 例如：rm -d 我的文件夹     其中我的文件夹为空文件夹\n- rm -r 文件夹名：   删除文件夹，删除文件夹以及里面的内容\n  - 例如：rm -r aa       其中aa为非空文件夹\n\n\n\n## mv命令：\n\n- mv 文件 文件夹：       移动文件到文件夹    \n  - 例如：mv test.txt bb    mv test2.txt /home/86god/桌面/bb\n- mv 文件夹1 文件夹2：    移动文件夹1到文件夹2，若文件夹2不存在，相当于重命名   \n  - 例如：mv aa cc         mv aa ../\n- mv 文件  当前目录/名字： 相当于重命名       \n  -  例如：mv test1.txt  ./test3.txt\n- mv 文件  指定目录/名字： 移动并重命名        \n  - 例如：mv test1.txt  ./test3.txt\n\n\n\n## cp 命令：\n\n- cp 文件 文件夹：       复制文件到文件夹   \n  - 例如：cp test.txt bb    cp test2.txt /home/86god/桌面/bb\n- cp -r 文件夹1 文件夹2：    复制文件夹1到文件夹2，若文件夹2不存在相当于复制并重命名   \n  - 例如：cp -r aa cc     将aa复制到cc中\n- cp 文件  当前目录/名字： 相当于重命名      \n  - 例如：cp test1.txt  ./test3.txt\n- cp  -r 文件  指定目录/名字： 移动并重命名        \n  - 例如：mv test1.txt  ./test3.txt\n\n\n\n## help和man命令：（查看帮助文档）\n\n- 命令 --help ：查看帮助文档   \n  - 例如 ：ls --help\n- man 命令: 查看帮助文档，分页，比较清晰\n  - 例如： man ls\n\n## which 命令：\n\n- which 命令  : 可以查看命令的文件位置\n  - 例如：which ls\n\n## find命令：\n\n- find 路径 -name 文件名字  ：可以在指定目录下搜索文件，输出文件路径\n  - 例如：find /home/86god/桌面 -name t1.txt\n  - 例如：find /home/86god/桌面 -name  \'t*\'         模糊搜索要加单引号。\n- find 路径 -iname 文件名字  ：可以在指定目录下搜索文件，输出文件路径，-i是忽略大小写\n  - 例如：find /home/86god/桌面 -iname t1.txt\n- find 路径 -size +块数 ：在指定目录下，查找大于指定块数的文件，注意：一块是512KB。\n  - 例如：find /home/86god/桌面 -size +1\n- find 路径 -size -块数 ：在指定目录下，查找小于指定块数的文件，注意：一块是512KB。\n  - 例如：find /home/86god/桌面 -size -2\n- find 路径 -size 块数 ：在指定目录下，查找等于指定块数的文件，文件的大小为向上取整，4.5数据块会取5数据块，注意：一块是512KB。\n  - 例如：find /home/86god/桌面 -size 2\n- find 路径 -user 用户名：在指定目录下，查找属于指定用户的文件\n  - 例如：find /home/86god/桌面 -user 86god\n- find 路径 -mmin -分钟数：在指定目录下，查找在几分钟内被修改过的文件\n  - 例如：find /home/86god/桌面 -mmin -5\n    - 后面数字的单位是分钟，在5分钟以内被修改的文件\n- find 路径 -mmin +分钟数：在指定目录下，查找在大于几分钟被修改过的文件\n  - 例如：find /home/86god/桌面 -mmin +5\n    - 后面数字的单位是分钟，在5分钟以外被修改的文件\n  - 类似的还有：\n    - amin:上次文件被访问的时间\n    - cmin:上次文件属性（文件权限）被修改的时间\n- find 路径 -type  f  : 在指定目录下，查找所有文件\n  - 例如：find /home/86god/桌面 -type f\n- find 路径 -type  d : 在指定目录下，查找所有文件夹\n  - 例如：find /home/86god/桌面 -type d\n- find 路径 -type  l : 在指定目录下，查找所有链接\n  - 例如：find /home/86god/桌面 -type l\n- find 路径 -inum  id编号 : 在指定目录下，查找指定id的对象\n  - 例如：find /home -inum 34975432\n\n\n\n## locate 命令：（搜索速度很快，比find快）\n\n- locate 文件名：在全局搜索文件\n  - 例如：locate t1.txt\n- locate 文件夹名：打印文件夹中的所有对象\n  - 例如：locate cc\n- updatedb:更新locate的索引库\n  - 例如：updatedb\n\n\n\n## cat 命令：\n\n> 用法：cat [选项]... [文件]...\n> 将[文件]或标准输入组合输出到标准输出。\n>\n> -A, --show-all           等于-vET\n> -b, --number-nonblank    对非空输出行编号\n> -e                       等于-vE\n> -E, --show-ends          在每行结束处显示\"$\"\n> -n, --number             对输出的所有行编号\n> -s, --squeeze-blank      不输出多行空行\n> -t                       与-vT 等价\n> -T, --show-tabs          将跳格字符显示为^I\n> -u                       (被忽略)\n> -v, --show-nonprinting   使用^ 和M- 引用，除了LFD和 TAB 之外\n>    --help		显示此帮助信息并退出\n>    --version		显示版本信息并退出\n>\n> 如果没有指定文件，或者文件为\"-\"，则从标准输入读取。\n>\n> 示例：\n> cat f - g  先输出f 的内容，然后输出标准输入的内容，最后输出g 的内容。\n> cat        将标准输入的内容复制到标准输出。\n\n- cat 文本文件名：一次性打印文本文件的内容\n  - 例如：cat T1.txt\n- cat -b 文本文件名：一次性打印文本文件的内容，并对非空行编行号\n  - 例如：cat -b T1.txt\n- cat -n 文本文件名：一次性打印文本文件的内容，并对所有行编行号\n  - 例如：cat -n T1.txt\n\n\n\n## more 命令：\n\n> 选项：\n> -d        显示帮助，而不是响铃\n> -f        统计逻辑行数而不是屏幕行数\n> -l        抑制换页(form feed)后的暂停\n> -p        不滚屏，清屏并显示文本\n> -c        不滚屏，显示文本并清理行尾\n> -u        抑制下划线\n> -s        将多个空行压缩为一行\n> -NUM      指定每屏显示的行数为 NUM\n> +NUM      从文件第 NUM 行开始显示\n> +/STRING  从匹配搜索字符串 STRING 的文件位置开始显示\n> -V        输出版本信息并退出\n\n- more 文本文件名：分页打印文本文件内容\n  - 例如：more T1.txt         (可以按回车打印下一行，按空格切换下一页，按b切换上一页，按q退出)\n\n\n\n## grep 命令：\n\n> 用法: grep [选项]... PATTERN [FILE]...\n> 在每个 FILE 或是标准输入中查找 PATTERN。\n> 默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。\n> 例如: grep -i \'hello world\' menu.h main.c\n>\n> 正则表达式选择与解释:\n> -E, --extended-regexp     PATTERN 是一个可扩展的正则表达式(缩写为 ERE)\n> -F, --fixed-strings       PATTERN 是一组由断行符分隔的定长字符串。\n> -G, --basic-regexp        PATTERN 是一个基本正则表达式(缩写为 BRE)\n> -P, --perl-regexp         PATTERN 是一个 Perl 正则表达式\n> -e, --regexp=PATTERN      用 PATTERN 来进行匹配操作\n> -f, --file=FILE           从 FILE 中取得 PATTERN\n> -i, --ignore-case         忽略大小写\n> -w, --word-regexp         强制 PATTERN 仅完全匹配字词\n> -x, --line-regexp         强制 PATTERN 仅完全匹配一行\n> -z, --null-data           一个 0 字节的数据行，但不是空行\n>\n> Miscellaneous:\n> -s, --no-messages         suppress error messages\n> -v, --invert-match        select non-matching lines\n> -V, --version             display version information and exit\n>    --help                display this help text and exit\n>\n> 输出控制:\n> -m, --max-count=NUM       NUM 次匹配后停止\n> -b, --byte-offset         输出的同时打印字节偏移\n> -n, --line-number         输出的同时打印行号\n>    --line-buffered       每行输出清空\n> -H, --with-filename       为每一匹配项打印文件名\n> -h, --no-filename         输出时不显示文件名前缀\n>    --label=LABEL         将LABEL 作为标准输入文件名前缀\n> -o, --only-matching       show only the part of a line matching PATTERN\n> -q, --quiet, --silent     suppress all normal output\n>    --binary-files=TYPE   assume that binary files are TYPE;\n>                          TYPE is \'binary\', \'text\', or \'without-match\'\n> -a, --text                equivalent to --binary-files=text\n> -I                        equivalent to --binary-files=without-match\n> -d, --directories=ACTION  how to handle directories;\n>                          ACTION is \'read\', \'recurse\', or \'skip\'\n> -D, --devices=ACTION      how to handle devices, FIFOs and sockets;\n>                          ACTION is \'read\' or \'skip\'\n> -r, --recursive           like --directories=recurse\n> -R, --dereference-recursive\n>                          likewise, but follow all symlinks\n>    --include=FILE_PATTERN\n>                          search only files that match FILE_PATTERN\n>    --exclude=FILE_PATTERN\n>                          skip files and directories matching FILE_PATTERN\n>    --exclude-from=FILE   skip files matching any file pattern from FILE\n>    --exclude-dir=PATTERN directories that match PATTERN will be skipped.\n> -L, --files-without-match print only names of FILEs containing no match\n> -l, --files-with-matches  print only names of FILEs containing matches\n> -c, --count               print only a count of matching lines per FILE\n> -T, --initial-tab         make tabs line up (if needed)\n> -Z, --null                print 0 byte after FILE name\n>\n> 文件控制:\n> -B, --before-context=NUM  打印以文本起始的NUM 行\n> -A, --after-context=NUM   打印以文本结尾的NUM 行\n> -C, --context=NUM         打印输出文本NUM 行\n> -NUM                      same as --context=NUM\n>    --group-separator=SEP use SEP as a group separator\n>    --no-group-separator  use empty string as a group separator\n>    --color[=WHEN],\n>    --colour[=WHEN]       use markers to highlight the matching strings;\n>                          WHEN is \'always\', \'never\', or \'auto\'\n> -U, --binary              do not strip CR characters at EOL (MSDOS/Windows)\n> -u, --unix-byte-offsets   report offsets as if CRs were not there\n>                          (MSDOS/Windows)\n>\n> ‘egrep’即‘grep -E’。‘fgrep’即‘grep -F’。\n> 直接使用‘egrep’或是‘fgrep’均已不可行了。\n> 若FILE 为 -，将读取标准输入。不带FILE，读取当前目录，除非命令行中指定了-r 选项。\n> 如果少于两个FILE 参数，就要默认使用-h 参数。\n> 如果有任意行被匹配，那退出状态为 0，否则为 1；\n> 如果有错误产生，且未指定 -q 参数，那退出状态为 2。\n\n\n\n- grep 搜索内容  文件名:  在指定文本搜索指定内容，若找到，则返回内容行\n  - 例如：grep username T1.txt\n- grep -n 搜索内容  文件名:  在指定文本搜索指定内容，若找到，则返回内容行及行号。\n  - 例如：grep -n username T1.txt\n- grep -v 搜索内容  文件名:  在指定文本反向搜索指定内容，打印不包含指定内容的行。\n  - 例如：grep -v username T1.txt\n- grep  ^搜索内容   文件名：在指定文本搜索以指定内容开头的行。\n  - 例如：grep  ^\'#\'  /etc/services\n- grep  搜索内容$   文件名：在指定文本搜索以指定内容结束的行。\n  - 例如：grep  s$  /etc/services\n- grep -i  搜索内容   文件名：在指定文本搜索以指定内容结束的行,指定内容不区分大小写\n  - 例如：grep -i abc T1.txt\n\n\n\n## echo 命令：\n\n- echo 输入内容：回显输入内容，把输入的内容输出到屏幕\n  - 例如 ： echo sdasda\n- echo 输入内容 > 文本文件名：把输入内容，打印到指定文件。若指定文件已经存在则会覆盖重新里面的内容；若指定文件不存在，则会创建新文件。\n  - 例如：echo hello world > t1.txt\n- echo 输入内容 >> 文本文件名：把输入内容，追加到指定文件。若指定文件已经存在则会追加到里面的内容的后面；若指定文件不存在，则会创建新文件。\n  - 例如：echo hello world >> t1.txt\n- 指令获取的内容 > 文本文件名：把使用指令获取的文本覆盖到指定文件。只要前面的指令有返回结果都可以覆盖到指定文件中。\n  - grep -i abc T1.txt > t11.txt\n  - ls > t11.txt\n- 指令获取的内容 >> 文本文件名：把使用指令获取的文本追加到指定文件。只要前面的指令有返回结果都可以追加到指定文件中。\n  - grep -i abc T1.txt >> t11.txt\n  - ls >> t11.txt\n\n## 管道：（|）\n\n- 指令1获取内容 | 指令2没有输入：把指令1获取的输出内容作为指令2的输入。\n  - 例如：ls -lh | grep t11\n    - 把ls -lh获取到的输出内容作为grep t11 的输入内容，\n      - 比如ls -lh获取到存放到临时文件ttt.txt ,   ls -lh > ttt.txt\n        - -rw-rw-r--. 1 86god 86god  617 5月  22 11:04 t11.txt\n          -rw-rw-r--. 1 86god 86god   12 5月  22 10:55 t1.txt\n          -rw-rw-r--. 1 86god 86god 1.2K 5月  22 10:46 T1.txt\n      - 则会作为 grep t11 的输入：grep t11 ttt.txt\n        - grep t11 ttt.txt\n  - 例如：grep -v ^\'#\' /etc/services | more\n    - 把获取的内容以分页的形式呈现\n  - 例如：grep -v ^\'#\' /etc/services | grep update\n    - 把获取的内容进行筛选\n\n\n\n## ln 命令：（软链接）\n\n- ln 文件路经文件名称1 文件路经文件名称2：把文件1在文件2的位置创建软链接，类似于快捷方式。两个文件的内容是互通的。\n  - 例如：ln  bb/test.txt  test_softLink\n    - 在当前目录创建bb/test.txt的软链接\n\n## vim命令：\n\n- vim 文件：用编辑器打开文本文档\n  - 例如：vim /etc/passwd 		\n    - 查看密码文档\n\n\n\n## su 命令：\n\n- su 用户名：切换到指定用户，当前用户会挂起\n  - 例如：su user1 \n    - 切换到用户 user1\n- su - 用户名：切换到指定用户，并切换到home/用户 目录，相当于登录，会有上次登录时间的提醒，当前用户会挂起\n  - 例如：su - user1 \n    - 切换到用户 user1，并将当前路径切换至/home/user1\n\n\n\n## exit 命令：\n\n- exit：退出切换的用户，唤醒当前用户\n  - 按 `ctrl` + `D` 可以达到相同的效果\n\n\n\n## sudo 命令：\n\n- sudo 指令命令：利用超管身份运行命令\n  - 例如：sudo useradd user1	\n    - 利用超管身份添加用户\n  - 例如：sudo passwd user1	\n    - 利用超管身份修改用户user1 密码\n\n使用sudo命令，若是出现“不在sudoers文件中，此事将被报告”的问题，\n\n参考这篇文章解决：https://zhuanlan.zhihu.com/p/143388819\n\n\n\n## useradd 命令：\n\n- useradd 用户名:添加用户\n  - 例如：useradd  user1	\n    - 添加用户user1（一般超管才有这权限）\n- useradd -m 用户名：添加用户并在home文件夹创建\n  - 例如：useradd -m user1（一般超管才有这权限）\n    - 添加用户user1并在home文件夹创建\n- useradd -g 组名 用户名：添加用户并且添加到指定分组\n  - 例如：sudo useradd -g3 user4\n    - 添加用户user4到g3分组下，g3是组名\n\n\n\n## usermod 命令：\n\n- usermod -l 新用户名 原用户名：修改用户名\n  - 例如：usermod -l 88god user2\n    - 将user2用户名改为88god\n- usermod -g  组名 用户名：把用户移动到另一个分组\n  - 例如：usermod -g user2 user3\n    - 将user3的移动到user2分组\n- usermod -G 组1，组2……   用户名：给用户修改附加组\n  - 例如：usermod -G user2,86god user3\n    - 把user3的附加组修改为user2和86god\n- usermod -s shell路径   用户名：给用户修改shell\n  - 例如：usermod -s /bin/sh user3\n    - 把user3的shell改为/bin/sh\n\n\n\n## userdel 命令：\n\n- userdel 用户名：删除用户\n  - 例如：userdel user3\n    - 删除用户user3\n- userdel -r 用户名：删除用户并删除该home目录\n  - 例如：userdel -r user3\n    - 删除用户user3并删除home目录	\n- userdel -f 用户名：强制删除用户\n  - 例如：userdel -f user3\n    - 强制删除用户user3\n\n\n\n## passwd 命令：\n\n- passwd 用户名:修改用户密码\n\n  - 例如：passwd user1	修改用户user1 密码（一般超管才有这权限）\n\n- passwd :设置当前用户密码\n\n  \n\n\n\n## id 命令：\n\n- id 用户名：查看用户信息，包括分组编号、id编号和环境\n  - 例如：id user1\n    - 查看user1的信息，包括分组编号(gid)、id编号(uid)和环境\n\n\n\n## groupadd 命令：\n\n- groupadd 组名：添加创建分组\n  - 例如： groupadd g1\n    - 创建分组g1，通过cat /etc/group 可查看所有分组\n\n\n\n## groupmod 命令：\n\n- groupmod -n 新组名 原组名：修改组名\n  - 例如：groupmod -n gnewName g1\n    - 将 g1分组的名字改为 gnewName\n\n\n\n## groupdel 命令：\n\n- groupdel 组名：删除分组\n  - 例如：groupdel  gnewName \n    - 删除gnewName 分组\n\n## chsh 命令：\n\n- chsh -l :查看所有的shell\n  - 相当于：cat /etc/shells\n- chsh 用户名：修改用户的shell\n  - 例如：chsh user3\n    - 会让输入修改后的shell路径	\n\n\n\n## /etc/group 文件：\n\n- 配置当前系统的用户组\n  - 组名\n  - 组密码标志\n  - GID\n  - 组中的附加用户\n\n\n\n## /etc/passwd 文件：\n\n- 配置当前用户的，以及用户的密码，密码在影子文件里\n  - 用户名\n  - 密码标志\n  - UID\n  - GID\n  - 用户全名\n  - 家目录\n  - 使用的shell\n\n\n\n## /etc/shadow 文件：\n\n- 用户密码的影子文件，里面存放加密后的密码\n\n\n\n## /etc/gshadow 文件：\n\n- 用户分组密码的影子文件，里面存放加密后的用户分组密码\n\n\n\n## whoami 命令：\n\n- 查询目前终端登录的用户\n\n\n\n## who 命令：\n\n- 查询目前计算机登录的用户\n\n\n\n## ll 命令：\n\n- 查看当前目录文件以及权限\n  - 权限：一共10位\n    - 第一位：d或者-，d代表文件夹，-代表二进制文件\n    - 后9位分为三组：rwx，r——可读，w——可写，x——可执行\n      - 2-4位：文件所属用户的权限\n      - 5-7位：用户组的权限\n      - 8-10位：其他用户的权限\n\n\n\n## 查看CPU信息：\n\n- cat /proc/cpuinfo   \n  - 查看CPU静态信息\n- top\n  - 查看CPU动态命令\n- dstat\n  - 查看CPU动态信息\n  - 安装方法：`yum install dstat`\n\n\n\n## 查看内存信息：\n\n- cat /proc/meminfo\n  - 查看内存基本容量信息\n- free\n  - 查看内存运行空间信息\n\n\n\n## 查看Linux系统版本：\n\n- uname -a\n  - 查看Linux系统版本\n- cat /etc/redhat-release\n  - 查看Linux系统版本\n\n', 0, 0, '2020-08-07 00:31:44', 6, 0, 1, 'Linux 命令格式：\n\ncmd -option parameter\ncmd 是命令，option 就是一个操作，parameter 操作的对象\n\ncd命令：\ncd 桌面：进入”桌面”目录cd .. ：返回上级目录cd ~:返回当前用户的 home 目录cd ~用户名：返回之前用户的 home 目录cd -: 和上一次打开的文件夹来回切换cd . : 当前的文件夹\nclear 命令：\nclear: 清空终端界面\npwd命令：\npwd:显示当前的路径\nls命令：\nls:查看文件目录ls -f:查看目录中的文件ls -a:查看隐藏文件ls -l :查看文件和目录的详细资料，可查看文件权限ls -i:查看文件和文件夹idll :查看文件和目录的详细资料，类似与ls -l，多了一个 ./ 当前目录和 ../ 上级了目录过滤搜索：\n[abc] ：文件夹或文件包含abc任意一个            \n例如： ls [abc].txt   —-> a.txt             \n*：文件夹或文件包含一个或多个字符 \n例如： ls  *.txt         —-> a.txt    b.txt  aaa.txt\n?:        文件夹或文件包含某个字符                  \n例如：  ls ????.js     —->alog.js   link.js\n\n\nchmod 命令：\nchmod [ugoa] [+-=] [rwxX] 文件名：\nu 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 例如：chmod u+w /etc/sudoers\n将sudoers文件添加可写的权限\n例如：chmod u-wr,g-rw t1.txt \n将t1.txt 的用户和分组的可读可写权限去掉\n\nchmod [ugoa] [+-=] [数字] 文件名：\nr—4 , w—2 , x—1 用数字的和代表权限\n例如：chmod 777 t1.txt\n将t1.txt 文件的用户权限、分组权限、其他用户权限全部设为可读可写可执行\n例如：chmod 467 t1.txt\n将t1.txt 文件的用户权限设为可读，分组权限设为可读可写，其他用户权限设为可读可写可执行\n\n\n\nchown 命令：\nchown 用户名 文件名：修改文件的所属者\n例如：chown user3 t1.txt\n修改t1.txt 的所有者为user3\n\nchown -R 用户名 文件夹名：递归修改文件夹中所有文件的所属者\n例如：chown -R user3 dd\n递归修改dd文件夹中所有文件的所属者为user3 \n\n\nchgrp 命令：\nchgrp 组名 文件名：修改文件的所属组\n例如：chgrp user2 t1.txt\n修改t1.txt 的所有组为user2\n\nchgrp -R 组名 文件夹名：递归修改文件夹中所有文件的所属组\n例如：chgrp -R user2 dd\n递归修改dd文件夹中所有文件的所属组为user2\n\n\ntouch 命令：\ntouch 文件名.txt :  创建txt 文本文件（有txt后缀名）\n例如：touch hello.txt\ntouch 文件名：     创建txt 文本文件（没有txt后缀名）\n例如：touch hello\n\nmkdir 命令：\nmkdir 文件夹名： 创建文件夹\n例如：mkdir 我的文件夹\n\nrm 命令：\nrm 文件名 :            删除文件\n例如：rm T1.txt\nrm -d 文件夹名：   删除文件夹，删除空文件夹\n例如：rm -d 我的文件夹     其中我的文件夹为空文件夹\nrm -r 文件夹名：   删除文件夹，删除文件夹以及里面的内容\n例如：rm -r aa       其中aa为非空文件夹\n\nmv命令：\nmv 文件 文件夹：       移动文件到文件夹    \n例如：mv test.txt bb    mv test2.txt /home/86god/桌面/bb\nmv 文件夹1 文件夹2：    移动文件夹1到文件夹2，若文件夹2不存在，相当于重命名   \n例如：mv aa cc         mv aa ../\nmv 文件  当前目录/名字： 相当于重命名       \n例如：mv test1.txt  ./test3.txt\nmv 文件  指定目录/名字： 移动并重命名        \n例如：mv test1.txt  ./test3.txt\n\ncp 命令：\ncp 文件 文件夹：       复制文件到文件夹   \n例如：cp test.txt bb    cp test2.txt /home/86god/桌面/bb\ncp -r 文件夹1 文件夹2：    复制文件夹1到文件夹2，若文件夹2不存在相当于复制并重命名   \n例如：cp -r aa cc     将aa复制到cc中\ncp 文件  当前目录/名字： 相当于重命名      \n例如：cp test1.txt  ./test3.txt\ncp  -r 文件  指定目录/名字： 移动并重命名        \n例如：mv test1.txt  ./test3.txt\n\nhelp和man命令：（查看帮助文档）\n命令 —help ：查看帮助文档   \n例如 ：ls —help\nman 命令: 查看帮助文档，分页，比较清晰\n例如： man ls\n\nwhich 命令：\nwhich 命令  : 可以查看命令的文件位置\n例如：which ls\n\nfind命令：\nfind 路径 -name 文件名字  ：可以在指定目录下搜索文件，输出文件路径\n例如：find /home/86god/桌面 -name t1.txt例如：find /home/86god/桌面 -name  ‘t*’         模糊搜索要加单引号。\nfind 路径 -iname 文件名字  ：可以在指定目录下搜索文件，输出文件路径，-i是忽略大小写\n例如：find /home/86god/桌面 -iname t1.txt\nfind 路径 -size +块数 ：在指定目录下，查找大于指定块数的文件，注意：一块是512KB。\n例如：find /home/86god/桌面 -size +1\nfind 路径 -size -块数 ：在指定目录下，查找小于指定块数的文件，注意：一块是512KB。\n例如：find /home/86god/桌面 -size -2\nfind 路径 -size 块数 ：在指定目录下，查找等于指定块数的文件，文件的大小为向上取整，4.5数据块会取5数据块，注意：一块是512KB。\n例如：find /home/86god/桌面 -size 2\nfind 路径 -user 用户名：在指定目录下，查找属于指定用户的文件\n例如：find /home/86god/桌面 -user 86god\nfind 路径 -mmin -分钟数：在指定目录下，查找在几分钟内被修改过的文件\n例如：find /home/86god/桌面 -mmin -5\n后面数字的单位是分钟，在5分钟以内被修改的文件\n\nfind 路径 -mmin +分钟数：在指定目录下，查找在大于几分钟被修改过的文件\n例如：find /home/86god/桌面 -mmin +5\n后面数字的单位是分钟，在5分钟以外被修改的文件\n类似的还有：\namin:上次文件被访问的时间cmin:上次文件属性（文件权限）被修改的时间\n\nfind 路径 -type  f  : 在指定目录下，查找所有文件\n例如：find /home/86god/桌面 -type f\nfind 路径 -type  d : 在指定目录下，查找所有文件夹\n例如：find /home/86god/桌面 -type d\nfind 路径 -type  l : 在指定目录下，查找所有链接\n例如：find /home/86god/桌面 -type l\nfind 路径 -inum  id编号 : 在指定目录下，查找指定id的对象\n例如：find /home -inum 34975432\n\nlocate 命令：（搜索速度很快，比find快）\nlocate 文件名：在全局搜索文件\n例如：locate t1.txt\nlocate 文件夹名：打印文件夹中的所有对象\n例如：locate cc\nupdatedb:更新locate的索引库\n例如：updatedb\n\ncat 命令：\n用法：cat [选项]… [文件]…将[文件]或标准输入组合输出到标准输出。\n-A, —show-all           等于-vET-b, —number-nonblank    对非空输出行编号-e                       等于-vE-E, —show-ends          在每行结束处显示”$”-n, —number             对输出的所有行编号-s, —squeeze-blank      不输出多行空行-t                       与-vT 等价-T, —show-tabs          将跳格字符显示为^I-u                       (被忽略)-v, —show-nonprinting   使用^ 和M- 引用，除了LFD和 TAB 之外   —help        显示此帮助信息并退出   —version        显示版本信息并退出\n如果没有指定文件，或者文件为”-“，则从标准输入读取。\n示例：cat f - g  先输出f 的内容，然后输出标准输入的内容，最后输出g 的内容。cat        将标准输入的内容复制到标准输出。\n\n\ncat 文本文件名：一次性打印文本文件的内容\n例如：cat T1.txt\ncat -b 文本文件名：一次性打印文本文件的内容，并对非空行编行号\n例如：cat -b T1.txt\ncat -n 文本文件名：一次性打印文本文件的内容，并对所有行编行号\n例如：cat -n T1.txt\n\nmore 命令：\n选项：-d        显示帮助，而不是响铃-f        统计逻辑行数而不是屏幕行数-l        抑制换页(form feed)后的暂停-p        不滚屏，清屏并显示文本-c        不滚屏，显示文本并清理行尾-u        抑制下划线-s        将多个空行压缩为一行-NUM      指定每屏显示的行数为 NUM+NUM      从文件第 NUM 行开始显示+/STRING  从匹配搜索字符串 STRING 的文件位置开始显示-V        输出版本信息并退出\n\n\nmore 文本文件名：分页打印文本文件内容\n例如：more T1.txt         (可以按回车打印下一行，按空格切换下一页，按b切换上一页，按q退出)\n\ngrep 命令：\n用法: grep [选项]… PATTERN [FILE]…在每个 FILE 或是标准输入中查找 PATTERN。默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。例如: grep -i ‘hello world’ menu.h main.c\n正则表达式选择与解释:-E, —extended-regexp     PATTERN 是一个可扩展的正则表达式(缩写为 ERE)-F, —fixed-strings       PATTERN 是一组由断行符分隔的定长字符串。-G, —basic-regexp        PATTERN 是一个基本正则表达式(缩写为 BRE)-P, —perl-regexp         PATTERN 是一个 Perl 正则表达式-e, —regexp=PATTERN      用 PATTERN 来进行匹配操作-f, —file=FILE           从 FILE 中取得 PATTERN-i, —ignore-case         忽略大小写-w, —word-regexp         强制 PATTERN 仅完全匹配字词-x, —line-regexp         强制 PATTERN 仅完全匹配一行-z, —null-data           一个 0 字节的数据行，但不是空行\nMiscellaneous:-s, —no-messages         suppress error messages-v, —invert-match        select non-matching lines-V, —version             display version information and exit   —help                display this help text and exit\n输出控制:-m, —max-count=NUM       NUM 次匹配后停止-b, —byte-offset         输出的同时打印字节偏移-n, —line-number         输出的同时打印行号   —line-buffered       每行输出清空-H, —with-filename       为每一匹配项打印文件名-h, —no-filename         输出时不显示文件名前缀   —label=LABEL         将LABEL 作为标准输入文件名前缀-o, —only-matching       show only the part of a line matching PATTERN-q, —quiet, —silent     suppress all normal output   —binary-files=TYPE   assume that binary files are TYPE;                         TYPE is ‘binary’, ‘text’, or ‘without-match’-a, —text                equivalent to —binary-files=text-I                        equivalent to —binary-files=without-match-d, —directories=ACTION  how to handle directories;                         ACTION is ‘read’, ‘recurse’, or ‘skip’-D, —devices=ACTION      how to handle devices, FIFOs and sockets;                         ACTION is ‘read’ or ‘skip’-r, —recursive           like —directories=recurse-R, —dereference-recursive                         likewise, but follow all symlinks   —include=FILE_PATTERN                         search only files that match FILE_PATTERN   —exclude=FILE_PATTERN                         skip files and directories matching FILE_PATTERN   —exclude-from=FILE   skip files matching any file pattern from FILE   —exclude-dir=PATTERN directories that match PATTERN will be skipped.-L, —files-without-match print only names of FILEs containing no match-l, —files-with-matches  print only names of FILEs containing matches-c, —count               print only a count of matching lines per FILE-T, —initial-tab         make tabs line up (if needed)-Z, —null                print 0 byte after FILE name\n文件控制:-B, —before-context=NUM  打印以文本起始的NUM 行-A, —after-context=NUM   打印以文本结尾的NUM 行-C, —context=NUM         打印输出文本NUM 行-NUM                      same as —context=NUM   —group-separator=SEP use SEP as a group separator   —no-group-separator  use empty string as a group separator   —color[=WHEN],   —colour[=WHEN]       use markers to highlight the matching strings;                         WHEN is ‘always’, ‘never’, or ‘auto’-U, —binary              do not strip CR characters at EOL (MSDOS/Windows)-u, —unix-byte-offsets   report offsets as if CRs were not there                         (MSDOS/Windows)\n‘egrep’即‘grep -E’。‘fgrep’即‘grep -F’。直接使用‘egrep’或是‘fgrep’均已不可行了。若FILE 为 -，将读取标准输入。不带FILE，读取当前目录，除非命令行中指定了-r 选项。如果少于两个FILE 参数，就要默认使用-h 参数。如果有任意行被匹配，那退出状态为 0，否则为 1；如果有错误产生，且未指定 -q 参数，那退出状态为 2。\n\n\ngrep 搜索内容  文件名:  在指定文本搜索指定内容，若找到，则返回内容行\n例如：grep username T1.txt\ngrep -n 搜索内容  文件名:  在指定文本搜索指定内容，若找到，则返回内容行及行号。\n例如：grep -n username T1.txt\ngrep -v 搜索内容  文件名:  在指定文本反向搜索指定内容，打印不包含指定内容的行。\n例如：grep -v username T1.txt\ngrep  ^搜索内容   文件名：在指定文本搜索以指定内容开头的行。\n例如：grep  ^’#’  /etc/services\ngrep  搜索内容$   文件名：在指定文本搜索以指定内容结束的行。\n例如：grep  s$  /etc/services\ngrep -i  搜索内容   文件名：在指定文本搜索以指定内容结束的行,指定内容不区分大小写\n例如：grep -i abc T1.txt\n\necho 命令：\necho 输入内容：回显输入内容，把输入的内容输出到屏幕\n例如 ： echo sdasda\necho 输入内容 > 文本文件名：把输入内容，打印到指定文件。若指定文件已经存在则会覆盖重新里面的内容；若指定文件不存在，则会创建新文件。\n例如：echo hello world > t1.txt\necho 输入内容 >> 文本文件名：把输入内容，追加到指定文件。若指定文件已经存在则会追加到里面的内容的后面；若指定文件不存在，则会创建新文件。\n例如：echo hello world >> t1.txt\n指令获取的内容 > 文本文件名：把使用指令获取的文本覆盖到指定文件。只要前面的指令有返回结果都可以覆盖到指定文件中。\ngrep -i abc T1.txt > t11.txtls > t11.txt\n指令获取的内容 >> 文本文件名：把使用指令获取的文本追加到指定文件。只要前面的指令有返回结果都可以追加到指定文件中。\ngrep -i abc T1.txt >> t11.txtls >> t11.txt\n\n管道：（|）\n指令1获取内容 | 指令2没有输入：把指令1获取的输出内容作为指令2的输入。\n例如：ls -lh | grep t11\n把ls -lh获取到的输出内容作为grep t11 的输入内容，\n比如ls -lh获取到存放到临时文件ttt.txt ,   ls -lh > ttt.txt\n-rw-rw-r—. 1 86god 86god  617 5月  22 11:04 t11.txt-rw-rw-r—. 1 86god 86god   12 5月  22 10:55 t1.txt-rw-rw-r—. 1 86god 86god 1.2K 5月  22 10:46 T1.txt\n则会作为 grep t11 的输入：grep t11 ttt.txt\ngrep t11 ttt.txt\n\n\n例如：grep -v ^’#’ /etc/services | more\n把获取的内容以分页的形式呈现\n例如：grep -v ^’#’ /etc/services | grep update\n把获取的内容进行筛选\n\n\nln 命令：（软链接）\nln 文件路经文件名称1 文件路经文件名称2：把文件1在文件2的位置创建软链接，类似于快捷方式。两个文件的内容是互通的。\n例如：ln  bb/test.txt  test_softLink\n在当前目录创建bb/test.txt的软链接\n\n\nvim命令：\nvim 文件：用编辑器打开文本文档\n例如：vim /etc/passwd         \n查看密码文档\n\n\nsu 命令：\nsu 用户名：切换到指定用户，当前用户会挂起\n例如：su user1 \n切换到用户 user1\n\nsu - 用户名：切换到指定用户，并切换到home/用户 目录，相当于登录，会有上次登录时间的提醒，当前用户会挂起\n例如：su - user1 \n切换到用户 user1，并将当前路径切换至/home/user1\n\n\nexit 命令：\nexit：退出切换的用户，唤醒当前用户\n按 ctrl + D 可以达到相同的效果\n\nsudo 命令：\nsudo 指令命令：利用超管身份运行命令\n例如：sudo useradd user1    \n利用超管身份添加用户\n例如：sudo passwd user1    \n利用超管身份修改用户user1 密码\n\n\n使用sudo命令，若是出现“不在sudoers文件中，此事将被报告”的问题，\n参考这篇文章解决：https://zhuanlan.zhihu.com/p/143388819\nuseradd 命令：\nuseradd 用户名:添加用户\n例如：useradd  user1    \n添加用户user1（一般超管才有这权限）\n\nuseradd -m 用户名：添加用户并在home文件夹创建\n例如：useradd -m user1（一般超管才有这权限）\n添加用户user1并在home文件夹创建\n\nuseradd -g 组名 用户名：添加用户并且添加到指定分组\n例如：sudo useradd -g3 user4\n添加用户user4到g3分组下，g3是组名\n\n\nusermod 命令：\nusermod -l 新用户名 原用户名：修改用户名\n例如：usermod -l 88god user2\n将user2用户名改为88god\n\nusermod -g  组名 用户名：把用户移动到另一个分组\n例如：usermod -g user2 user3\n将user3的移动到user2分组\n\nusermod -G 组1，组2……   用户名：给用户修改附加组\n例如：usermod -G user2,86god user3\n把user3的附加组修改为user2和86god\n\nusermod -s shell路径   用户名：给用户修改shell\n例如：usermod -s /bin/sh user3\n把user3的shell改为/bin/sh\n\n\nuserdel 命令：\nuserdel 用户名：删除用户\n例如：userdel user3\n删除用户user3\n\nuserdel -r 用户名：删除用户并删除该home目录\n例如：userdel -r user3\n删除用户user3并删除home目录    \n\nuserdel -f 用户名：强制删除用户\n例如：userdel -f user3\n强制删除用户user3\n\n\npasswd 命令：\npasswd 用户名:修改用户密码\n\n例如：passwd user1    修改用户user1 密码（一般超管才有这权限）\npasswd :设置当前用户密码\n\nid 命令：\nid 用户名：查看用户信息，包括分组编号、id编号和环境\n例如：id user1\n查看user1的信息，包括分组编号(gid)、id编号(uid)和环境\n\n\ngroupadd 命令：\ngroupadd 组名：添加创建分组\n例如： groupadd g1\n创建分组g1，通过cat /etc/group 可查看所有分组\n\n\ngroupmod 命令：\ngroupmod -n 新组名 原组名：修改组名\n例如：groupmod -n gnewName g1\n将 g1分组的名字改为 gnewName\n\n\ngroupdel 命令：\ngroupdel 组名：删除分组\n例如：groupdel  gnewName \n删除gnewName 分组\n\n\nchsh 命令：\nchsh -l :查看所有的shell\n相当于：cat /etc/shells\nchsh 用户名：修改用户的shell\n例如：chsh user3\n会让输入修改后的shell路径    \n\n\n/etc/group 文件：\n配置当前系统的用户组\n组名组密码标志GID组中的附加用户\n\n/etc/passwd 文件：\n配置当前用户的，以及用户的密码，密码在影子文件里\n用户名密码标志UIDGID用户全名家目录使用的shell\n\n/etc/shadow 文件：\n用户密码的影子文件，里面存放加密后的密码\n/etc/gshadow 文件：\n用户分组密码的影子文件，里面存放加密后的用户分组密码\nwhoami 命令：\n查询目前终端登录的用户\nwho 命令：\n查询目前计算机登录的用户\nll 命令：\n查看当前目录文件以及权限\n权限：一共10位\n第一位：d或者-，d代表文件夹，-代表二进制文件后9位分为三组：rwx，r——可读，w——可写，x——可执行\n2-4位：文件所属用户的权限5-7位：用户组的权限8-10位：其他用户的权限\n\n\n\n查看CPU信息：\ncat /proc/cpuinfo   \n查看CPU静态信息\ntop\n查看CPU动态命令\ndstat\n查看CPU动态信息安装方法：yum install dstat\n\n查看内存信息：\ncat /proc/meminfo\n查看内存基本容量信息\nfree\n查看内存运行空间信息\n\n查看Linux系统版本：\nuname -a\n查看Linux系统版本\ncat /etc/redhat-release\n查看Linux系统版本\n\n', 0, 1);
INSERT INTO `t_article` VALUES (103, '01. Maven 工具的安装以及项目的创建', 8, '\n## 1、Maven简介\n\n- Maven是 Apache软件基金会的一个开源项目\n- 它用来帮助开发者管理项目中的jar,以及jar之间的依赖关系\n- 完成项目的编译、测试、打包和发布等工作\n\n**Pom(Project Object Model 项目对象模型)**\n\n- Maven 管理的项目的根目录下都有一个 pom.xml 文件\n- pom.xml 文件指示 Maven 如何工作\n- pom.xml 文件中配置项目基本信息以及项目构建信息等。比如：项目坐标、项目依赖的 jar、插件、编译选项等。 \n- 一旦在 pom.xml 文件中配置了所依赖的 jar，Maven 会自动从构件仓库中下载相应的构件。\n\n\n\n## 2、项目坐标\n\n在 Maven 中，将每个项目最终生成的文件称为 artifact(构件)，它可以是 jar 文件，也可以是 war 文件。 \n\ngroupId、artifactId、packaging、version 的组合被称为项目的坐标，它们形成了项目的唯一标识，Maven\n\n通过坐标来精确定位构件。其中 groupId、artifactId、version 是必须的，且这三项的值必须唯一，packaging是可选的(默认为 jar)。\n\n组成元素：\n\n- groupId			组Id\n\n- artifactId      	组件Id\n\n- packaging		包类型\n\n- version			 版本\n\n在项目中使用jar，需要在pom.xml 文件配置jar的坐标，maven 首先去本地仓库找，如果找不到就会去中央仓库找。\n\n\n\n## 3、仓库\n\n中央仓库全球共享,先将jar从中央仓库下载到本地仓库,然后在项目中引用本地仓库的jar.\n\n本地仓库就是本地的仓库，里面存放着jar包。\n\n\n\n## 4、Maven 开发环境搭建\n\n### 4.1 下载maven服务器\n\nmaven官网:\n\nhttp:// maven.apache. org\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps2.jpg)\n\n点击download进行下载如下图\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps3.jpg)\n\n### 4.2  配置maven\n\n（1）将下载二进制的apache-maven-3.5.2-bin.zip进行解压，然后在系统环境中配置环境变量，在path中配置到bin目录，配置成功后输入命令mvn -version\n\n![image-20200617112338342](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617112338342.png)\n\n![image-20200617105540562](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617105540562.png)\n\n（2）配置settings.xml文件\n\n在maven的服务器解压的文件中找到conf文件夹下的settings.xml文件进行修改：\n\n1）修改本地仓库位置\n\n现在自己磁盘中创建一个文件夹mavenRepository，我是在D:\\mavenRepository\n\n然后在settings.xml文件中找到setting标签，把里面的localRepository中的路径改为D:\\mavenRepository，并取消注释。\n\n```xml\n<!--配置本地仓库位置，从中央仓库下载的jar包都 会存储到这个目录-->\n  <localRepository>D:\\mavenRepository</localRepository>\n```\n\n![image-20200617110308845](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617110308845.png)\n\n2）修改为阿里云的maven镜像仓库\n\n找到mirror标签，进行修改\n\n```xml\n  <!--配置中央镜像仓库  阿里云服务器地址  下载速度快 -->\n  <mirror>\n	<id>alimaven</id>\n	<name>aliyun maven</name>\n	<url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n	<mirrorOf>central</mirrorOf>\n   </mirror>\n```\n\n3）修改jdk版本信息\n\n找到profiles标签，添加下面代码，如下图：\n\n```xml\n	<!--配置jdk版本 -->\n		<profile>    \n			<id>jdk-1.8</id>    \n			 <activation>    \n				<activeByDefault>true</activeByDefault>    \n				<jdk>1.8</jdk>    \n			  </activation>    \n			<properties>    \n				<maven.compiler.source>1.8</maven.compiler.source>    \n				<maven.compiler.target>1.8</maven.compiler.target>\n				<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion> \n			</properties>    \n		</profile>\n```\n\n![image-20200617110719995](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617110719995.png)\n\n\n\n到此为止，settings.xml文件就配置完成了！！！\n\n\n\n（3）在eclipse中配置maven插件\n\n- 在eclipse中打开Window-> Preferences->Maven\n- 在Installations 中添加apache-maven-3.5.4安装根目录\n\n![image-20200617111037373](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617111037373.png)\n\n- 在User Settings中，配置settings.xml文件路径\n\n  ![image-20200617111251025](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617111251025.png)\n\n\n\n到此为止，Maven就配置完成了！！！\n\n\n\n## 5、创建Maven工程\n\n（1）\n\n![image-20200617113607181](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617113607181.png)\n\n（2）\n\n![image-20200617113627570](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617113627570.png)\n\n（3）\n\n![image-20200617114121898](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617114121898.png)\n\n（4）第一次创建项目，需要从maven仓库下载jar包\n\n![image-20200617114329977](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617114329977.png)\n\n（5）进来之后如果会报错，需要点击这个\n\n![image-20200617122515408](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617122515408.png)\n\n\n\n## 6、如何在Maven中导入jar包\n\n### 6.1 导入中央仓库包\n\n（1）在Maven仓库官网上，找到使用的jar的仓库文件路径\n\nMaven仓库地址：https://mvnrepository.com/\n\n（2）直接搜索 需要的jar包名，比如：jstl\n\n![image-20200617122850475](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617122850475.png)\n\n（3）找到想要的版本\n\n![image-20200617122951602](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617122951602.png)\n\n（4）复制仓库地址\n\n![image-20200617123048240](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617123048240.png)\n\n（5）粘贴到项目中pom.xml文件的dependencies标签中，如果没有创建dependencies标签。粘贴后保存，eclipse会自动从仓库中下载jar包到本地仓库。\n\n```xml\n<dependencies>\n  	<!-- https://mvnrepository.com/artifact/javax.servlet/jstl -->\n	<dependency>\n	    <groupId>javax.servlet</groupId>\n	    <artifactId>jstl</artifactId>\n	    <version>1.2</version>\n	</dependency>\n </dependencies>\n```\n\n（6）导入servlet-api包\n\n```xml\n<!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->\n	<dependency>\n	    <groupId>javax.servlet</groupId>\n	    <artifactId>javax.servlet-api</artifactId>\n	    <version>4.0.1</version>\n	    <!-- scope:	默认值是compile ，当项目最终打包时，会将jar包拷贝到项目的lib目录中;\n	    				  provided，服务器中或者JDK中已经包含了这些jar包，只在本地编译时需要，所以打包的时候不会被拷贝	\n	     -->\n	    <scope>provided</scope>\n	</dependency>\n```\n\n各个子元素功能解释：\n\n\\<groupId>,\\<artifactId>和\\<version>：依赖项的基本坐标\n\n\\<type>：依赖项的 packaging 类型，默认是 jar; \n\n\\<scope>：依赖项的作用范围，默认是 compile。各个取值及含义如下：\n\ncompile：编译时和运行时依赖。如果你的项目最终打包为 war 包，则该依赖包会被拷贝到 war 包中的 lib 目录中。\n\nprovided：编译项目主代码和测试代码时使用此依赖项，运行时由 jre 或 web 容器提供。如果你的项目最终打包为 war 包，则该 jar 包不会被打包。\n\n\n\n### 6.2 导入本地包\n\n我们除了可以导入人家的中央仓库包，也可以把我们自己写的java程序打包进行导入，作为这个项目的一个工具包。\n\n导入方式和上述方式一致：\n\n```xml\n	<dependency>\n		<groupId>com.company</groupId>\n		<artifactId>MyUtil-0.0.1-SNAPSHOT</artifactId>\n		<version>1.0.0</version>\n	</dependency>\n```\n\n\n\n## 7、使用maven打包\n\n（1）右击 pom.xml文件或者 右击项目，选择 Run as \n\n（2）先选择Maven clear清除上次打包的版本\n\n（3）再选择Maven install进行打包，打包好的jar文件会存放到本地仓库中。\n\n（4）更新仓库：项目右键->Maven->Update Project…\n\n![image-20200617145152856](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200617145152856.png)\n\n\n\n## 8、使用log4j\n\nlog4j是 apche 提供的一款日志组件\n\n### 8.1 如何使用\n\n（1）导入jar包\n\n```xml\n	<!-- log4j -->\n      <dependency>\n         <groupId>log4j</groupId>\n         <artifactId>log4j</artifactId>\n         <version>1.2.17</version>\n      </dependency>\n```\n\n（2）导入 log4j 的配置文件 log4j.properties，源码如下，没有的可以手动创建\n\n```properties\nlog4j.rootLogger = debug,stdout,D\n#System out Console\nlog4j.appender.stdout = org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target = System.out\nlog4j.appender.stdout.layout = org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern = [%p] %d{yyyy-MM-dd HH:mm:ss,SSS} %m%n\n\n#System out File\nlog4j.appender.D = org.apache.log4j.FileAppender\nlog4j.appender.D = org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.D.File = E://logs/log.log\nlog4j.appender.D.Append = true\nlog4j.appender.D.layout = org.apache.log4j.PatternLayout\nlog4j.appender.D.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ] -[%l] %m%n\n```\n\n\n\n（3）在之前任意使用System.out.println();的地方现在都可以使用 log4j 代替。\n\n```java\nimport org.apache.log4j.Logger;\npublic class Demo {\n	public static void main(String[] args) {\n		Logger logger = Logger.getLogger(Demo.class);  \n		logger.debug(\"日志已经调试好\");\n	}\n}\n```\n\n\n\n### 8.2  日志级别\n\n每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：\n A：off 最高等级，用于关闭所有日志记录。\n B：fatal 指出每个严重的错误事件将会导致应用程序的退出。\n C：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。\n D：warm 表明会出现潜在的错误情形。\n E：info 一般和在粗粒度级别上，强调应用程序的运行全程。\n F：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。\n G：all 最低等级，用于打开所有日志记录。\n\n上面这些级别是定义在org.apache.log4j.Level类中。Log4j只建议使用4个级别，优先级从高到低分别是error,warn,info和debug。通过使用日志级别，可以控制应用程序中相应级别日志信息的输出。例如，如果使用b了info级别，则应用程序中所有低于info级别的日志信息(如debug)将不会被打印出来。\n\n\n\nLog4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下：\n\n```\n%m 输出代码中指定的消息\n%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL  \n%r 输出自应用启动到输出该log信息耗费的毫秒数  \n%c 输出所属的类目，通常就是所在类的全名  \n%t 输出产生该日志事件的线程名  \n%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”  \n%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921  \n%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)\n```\n\n', 0, 0, '2020-08-07 00:35:20', 2, 0, 1, '1、Maven简介\nMaven是 Apache软件基金会的一个开源项目它用来帮助开发者管理项目中的jar,以及jar之间的依赖关系完成项目的编译、测试、打包和发布等工作\nPom(Project Object Model 项目对象模型)\n\nMaven 管理的项目的根目录下都有一个 pom.xml 文件pom.xml 文件指示 Maven 如何工作pom.xml 文件中配置项目基本信息以及项目构建信息等。比如：项目坐标、项目依赖的 jar、插件、编译选项等。 一旦在 pom.xml 文件中配置了所依赖的 jar，Maven 会自动从构件仓库中下载相应的构件。\n2、项目坐标在 Maven 中，将每个项目最终生成的文件称为 artifact(构件)，它可以是 jar 文件，也可以是 war 文件。 \ngroupId、artifactId、packaging、version 的组合被称为项目的坐标，它们形成了项目的唯一标识，Maven\n通过坐标来精确定位构件。其中 groupId、artifactId、version 是必须的，且这三项的值必须唯一，packaging是可选的(默认为 jar)。\n组成元素：\n\ngroupId            组Id\nartifactId          组件Id\npackaging        包类型\nversion             版本\n\n在项目中使用jar，需要在pom.xml 文件配置jar的坐标，maven 首先去本地仓库找，如果找不到就会去中央仓库找。\n3、仓库中央仓库全球共享,先将jar从中央仓库下载到本地仓库,然后在项目中引用本地仓库的jar.\n本地仓库就是本地的仓库，里面存放着jar包。\n4、Maven 开发环境搭建4.1 下载maven服务器maven官网:\nhttp:// maven.apache. org\n\n点击download进行下载如下图\n\n4.2  配置maven（1）将下载二进制的apache-maven-3.5.2-bin.zip进行解压，然后在系统环境中配置环境变量，在path中配置到bin目录，配置成功后输入命令mvn -version\n\n\n（2）配置settings.xml文件\n在maven的服务器解压的文件中找到conf文件夹下的settings.xml文件进行修改：\n1）修改本地仓库位置\n现在自己磁盘中创建一个文件夹mavenRepository，我是在D:\\mavenRepository\n然后在settings.xml文件中找到setting标签，把里面的localRepository中的路径改为D:\\mavenRepository，并取消注释。\n<!--配置本地仓库位置，从中央仓库下载的jar包都 会存储到这个目录-->  <localRepository>D:\\mavenRepository</localRepository>\n\n2）修改为阿里云的maven镜像仓库\n找到mirror标签，进行修改\n  <!--配置中央镜像仓库  阿里云服务器地址  下载速度快 -->  <mirror>    <id>alimaven</id>    <name>aliyun maven</name>    <url>http://maven.aliyun.com/nexus/content/groups/public/</url>    <mirrorOf>central</mirrorOf>   </mirror>\n3）修改jdk版本信息\n找到profiles标签，添加下面代码，如下图：\n    <!--配置jdk版本 -->        <profile>                <id>jdk-1.8</id>                 <activation>                    <activeByDefault>true</activeByDefault>                    <jdk>1.8</jdk>                  </activation>                <properties>                    <maven.compiler.source>1.8</maven.compiler.source>                    <maven.compiler.target>1.8</maven.compiler.target>                <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>             </properties>            </profile>\n\n到此为止，settings.xml文件就配置完成了！！！\n（3）在eclipse中配置maven插件\n\n在eclipse中打开Window-> Preferences->Maven在Installations 中添加apache-maven-3.5.4安装根目录\n\n\n在User Settings中，配置settings.xml文件路径\n\n\n到此为止，Maven就配置完成了！！！\n5、创建Maven工程（1）\n\n（2）\n\n（3）\n\n（4）第一次创建项目，需要从maven仓库下载jar包\n\n（5）进来之后如果会报错，需要点击这个\n\n6、如何在Maven中导入jar包6.1 导入中央仓库包（1）在Maven仓库官网上，找到使用的jar的仓库文件路径\nMaven仓库地址：https://mvnrepository.com/\n（2）直接搜索 需要的jar包名，比如：jstl\n\n（3）找到想要的版本\n\n（4）复制仓库地址\n\n（5）粘贴到项目中pom.xml文件的dependencies标签中，如果没有创建dependencies标签。粘贴后保存，eclipse会自动从仓库中下载jar包到本地仓库。\n<dependencies>      <!-- https://mvnrepository.com/artifact/javax.servlet/jstl -->    <dependency>        <groupId>javax.servlet</groupId>        <artifactId>jstl</artifactId>        <version>1.2</version>    </dependency> </dependencies>\n（6）导入servlet-api包\n<!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->    <dependency>        <groupId>javax.servlet</groupId>        <artifactId>javax.servlet-api</artifactId>        <version>4.0.1</version>        <!-- scope:    默认值是compile ，当项目最终打包时，会将jar包拷贝到项目的lib目录中;                          provided，服务器中或者JDK中已经包含了这些jar包，只在本地编译时需要，所以打包的时候不会被拷贝             -->        <scope>provided</scope>    </dependency>\n各个子元素功能解释：\n\\<groupId>,\\<artifactId>和\\<version>：依赖项的基本坐标\n\\<type>：依赖项的 packaging 类型，默认是 jar; \n\\<scope>：依赖项的作用范围，默认是 compile。各个取值及含义如下：\ncompile：编译时和运行时依赖。如果你的项目最终打包为 war 包，则该依赖包会被拷贝到 war 包中的 lib 目录中。\nprovided：编译项目主代码和测试代码时使用此依赖项，运行时由 jre 或 web 容器提供。如果你的项目最终打包为 war 包，则该 jar 包不会被打包。\n6.2 导入本地包我们除了可以导入人家的中央仓库包，也可以把我们自己写的java程序打包进行导入，作为这个项目的一个工具包。\n导入方式和上述方式一致：\n    <dependency>        <groupId>com.company</groupId>        <artifactId>MyUtil-0.0.1-SNAPSHOT</artifactId>        <version>1.0.0</version>    </dependency>\n7、使用maven打包（1）右击 pom.xml文件或者 右击项目，选择 Run as \n（2）先选择Maven clear清除上次打包的版本\n（3）再选择Maven install进行打包，打包好的jar文件会存放到本地仓库中。\n（4）更新仓库：项目右键->Maven->Update Project…\n\n8、使用log4jlog4j是 apche 提供的一款日志组件\n8.1 如何使用（1）导入jar包\n    <!-- log4j -->      <dependency>         <groupId>log4j</groupId>         <artifactId>log4j</artifactId>         <version>1.2.17</version>      </dependency>\n（2）导入 log4j 的配置文件 log4j.properties，源码如下，没有的可以手动创建\nlog4j.rootLogger = debug,stdout,D#System out Consolelog4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%p] %d{yyyy-MM-dd HH:mm:ss,SSS} %m%n#System out Filelog4j.appender.D = org.apache.log4j.FileAppenderlog4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ] -[%l] %m%n\n（3）在之前任意使用System.out.println();的地方现在都可以使用 log4j 代替。\nimport org.apache.log4j.Logger;public class Demo {    public static void main(String[] args) {        Logger logger = Logger.getLogger(Demo.class);          logger.debug(\"日志已经调试好\");    }}\n8.2  日志级别每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为： A：off 最高等级，用于关闭所有日志记录。 B：fatal 指出每个严重的错误事件将会导致应用程序的退出。 C：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。 D：warm 表明会出现潜在的错误情形。 E：info 一般和在粗粒度级别上，强调应用程序的运行全程。 F：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。 G：all 最低等级，用于打开所有日志记录。\n上面这些级别是定义在org.apache.log4j.Level类中。Log4j只建议使用4个级别，优先级从高到低分别是error,warn,info和debug。通过使用日志级别，可以控制应用程序中相应级别日志信息的输出。例如，如果使用b了info级别，则应用程序中所有低于info级别的日志信息(如debug)将不会被打印出来。\nLog4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下：\n%m 输出代码中指定的消息%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL  %r 输出自应用启动到输出该log信息耗费的毫秒数  %c 输出所属的类目，通常就是所在类的全名  %t 输出产生该日志事件的线程名  %n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”  %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921  %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)', 0, 1);
INSERT INTO `t_article` VALUES (104, '02. Mybatis 框架简介和安装配置', 8, '\n## 1、什么是框架？\n\n它是我们软件开发的一套解决方案，不同的框架解决不同的问题。\n\n使用框架的好处：\n\n​	框架封装了很多细节，使开发者可以使用几件极简的方式实现功能，大大提高了开发效率。\n\n框架阶段：\n\nssm框架：\n\n- mybatis 对jdbc进行封装（DAO 输出访问层 数据持久层）\n- spring 全局项目管理\n- springMVC 对servlet进行封装（业务层）\n\n前端框架：\n\n-  layUI\n-  Bootstrap\n\n快速搭建项目\n\n- springBoot \n- 前后端分离开发模式\n\n相关工具\n\n- maven项目管理工具\n- svn/git 项目版本控制器  团队开发项目使用\n\n## 2、三层架构\n\n- 表现层：是用来展示数据的\n- 业务层：是用来处理业务需求\n- 持久层：是和数据库交互的\n\n\n\n## 3、持久层技术解决方案\n\n- JDBC技术：\n  - Connection\n  - PreparedStatement\n  - ResultSet\n- Spring的JdbcTemplate:\n  - Spring中对jdbc的简单封装\n- Apache的DBUtils:\n  - 它和Spring 的JdbcTemplate很像，也是对Jdbc的简单封装\n\n以上都不是框架，\n\n- JDBC是规范\n- Spring的JdbcTemplate和Apache的DBUtils都只是工具类\n\n\n\n## 4、MyBatis 框架概述\n\nMyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。\n\n- MyBatis 是一个持久性框架，用java编写的\n- 它封装了jdbc的细节，是开发者只用关注sql语句本身，而无需关注驱动，创建链接等繁杂的过程\n- 它使用了ORM思想实现了结果集的封装\n\n**ORM思想：**\n\n- Object Relational Mapping 对象关系映射\n\n- 就是把数据库和实体类及实体类的属性对应起来\n\n- 让我们可以操作实体类就实现操作数据库表\n\n  user       ----->		User\n\n  id			----->		userId\n\n  name	 ----->		userName\n\n\n\n## 5、Mybatis 下载和安装\n\n下载地址：https://github.com/mybatis/mybatis-3/releases\n\n中文官方网址：https://mybatis.org/mybatis-3/zh/index.html\n\n![1](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/1-1591846901722.jpg)\n\n\n\n将下载的mybatis-3.5.5.zip进行解压，\n\n其中里面的\n\n- mybatis-3.5.5.jar就是mybatis的核心包，\n- mybatis-3.5.5.pdf 是官方文档\n- LICENSE是执照\n- NOTICE是注意事项，公告\n- lib文件夹里面是一些附加包，用来附加一些功能\n\n将mybatis-3.5.5.jar，lib 路径下的所有jar包，还有jdbc所需要的 导入项目，其中 log4j-1.2.17.jar 是用来输出日志的包，并且需要把数据库对应jdbc驱动包导入到项目。\n\n![4](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/4.jpg)\n\n导入包完成后，我们需要对项目进行一定的配置：\n\n我们在java源码文件夹下创建文件夹conf，用来存放我们的配置文件。\n\n（1）配置log4j，创建log4j.properties\n\n代码：\n\n```properties\n# Rules reminder:\n# DEBUG < INFO < WARN < ERROR < FATAL\n\n# Global logging configuration\nlog4j.rootLogger=DEBUG, stdout\n\n# My logging configuration...\nlog4j.logger.org.mybatis.jpetstore=DEBUG\n\n## Console output...\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%5p %d %C: %m%n\n```\n\n（2）配置数据库链接，可以把数据链接用到的驱动、url、用户名、密码写到一个配置文件中，以后要改直接在配置文件中修改。\n\n在conf文件下创建jdbc.properties 文件\n\n```properties\nurl=jdbc:oracle:thin:@localhost:1521:XE\ndriver=oracle.jdbc.driver.OracleDriver\nusername=mybatis\npassword=123456\n```\n\n\n\n\n\n（3）配置mybatis，创建mybatis-config.xml文件\n\n代码：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n	<!-- 导入数据库配置文件 -->\n	<properties resource=\"jdbc.properties\"></properties>\n	\n	<!-- 配置数据库信息 -->\n	<environments default=\"development\">\n		<environment id=\"development\">\n			<transactionManager type=\"JDBC\" />\n			<dataSource type=\"POOLED\">\n				<property name=\"driver\" value= \"${driver}\" />\n				<property name=\"url\" value= \"${url}\"/>\n				<property name=\"username\" value=\"${username}\" />\n				<property name=\"password\" value=\"${password}\" />\n			</dataSource>\n		</environment>\n	</environments>\n	\n\n	<!-- 将我们写好的sql映射文件一定要注册到全局配置文件中 -->\n	\n</configuration>\n```\n\n其中：\n\n- < property name=\"driver\" value=\"oracle.jdbc.driver.OracleDriver\" /> 中value配置的是数据库驱动，根据自己的数据库配置\n- < property name=\"url\" value=\"jdbc:oracle:thin:@localhost:1521:XE\" />中 value配置的是数据库链接的url\n- < property name=\"username\" value=\"mybatis\" />中value配置的是需要链接的数据库用户名\n- < property name=\"password\" value=\"123456\" />中value配置连接数据库的密码\n- < mappers>< /mappers>中配置的是我们后面写好的sql映射文件\n\n\n\n## 6、连接数据库\n\n创建mybatis连接的工具类\n\nMyBatisUtil.java\n\n```java\npackage com.company.project.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\n\npublic class MyBatisUtil {\n	\n	//主配文件路径\n	private static String resource = \"mybatis-config.xml\";\n	//会话工厂\n	private static SqlSessionFactory sqlSessionFactory;\n	//会话\n	private static SqlSession session;\n	\n	/**\n	 * 创建会话工厂\n	 * @return SqlSessionFactory 会话工厂\n	 */\n	public static SqlSessionFactory createFactory(){\n		if(sqlSessionFactory == null) {\n			InputStream inputStream;\n			try {\n				inputStream = Resources.getResourceAsStream(resource);\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n			} catch (IOException e) {\n				// TODO Auto-generated catch block\n				e.printStackTrace();\n			}\n		}\n		\n		if(sqlSessionFactory != null) {\n			System.out.println(\"工厂创建成功\");\n		}else {\n			System.out.println(\"工厂创建失败\");\n		}\n		return sqlSessionFactory;\n	}\n	\n	/**\n	 * 利用会话工厂创建会话对象\n	 * @return SqlSession 会话对象\n	 */\n	public static SqlSession getSession() {\n		//获取SqlSession实例，能直接执行已经映射的sql语句\n		SqlSession session = createFactory().openSession();\n		\n		if(session!=null) {\n			System.out.println(\"会话创建成功\");\n			\n		}else {\n			System.out.println(\"会话创建失败\");\n		}\n		return session;\n		\n	}\n}\n```\n\n## 7、测试数据库的连接\n\n```java\npackage com.company.project.utiltest;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.log4j.Logger;\nimport org.junit.platform.commons.logging.LoggerFactory;\nimport com.company.project.util.MyBatisUtil;\nimport junit.framework.TestCase;\n\npublic class MyBatisUtilTest extends TestCase {\n	public void testGetSqlSessionFactory() {\n		SqlSessionFactory sessionFactory = MyBatisUtil.createFactory();\n		if (sessionFactory != null) {			\n			System.out.println(\"sessionFactory:\" + sessionFactory);\n			System.out.println(\"会话工厂创建成功！！！\");\n		} else {\n			System.out.println(\"操作提示：sessionFactory创建失败！\");\n		}\n	}\n	\n	public void testGetSqlSession() {\n		SqlSession session = MyBatisUtil.getSession();\n		if (session != null) {			\n			System.out.println(\"session:\" + session);\n			System.out.println(\"会话创建成功！！！\");\n		} else {\n			System.out.println(\"操作提示：SqlSession创建失败！\");\n		}\n	}\n}\n```\n\n', 0, 0, '2020-08-07 00:36:03', 2, 0, 1, '1、什么是框架？它是我们软件开发的一套解决方案，不同的框架解决不同的问题。\n使用框架的好处：\n​    框架封装了很多细节，使开发者可以使用几件极简的方式实现功能，大大提高了开发效率。\n框架阶段：\nssm框架：\n\nmybatis 对jdbc进行封装（DAO 输出访问层 数据持久层）spring 全局项目管理springMVC 对servlet进行封装（业务层）\n前端框架：\n\nlayUIBootstrap\n快速搭建项目\n\nspringBoot 前后端分离开发模式\n相关工具\n\nmaven项目管理工具svn/git 项目版本控制器  团队开发项目使用\n2、三层架构\n表现层：是用来展示数据的业务层：是用来处理业务需求持久层：是和数据库交互的\n3、持久层技术解决方案\nJDBC技术：\nConnectionPreparedStatementResultSet\nSpring的JdbcTemplate:\nSpring中对jdbc的简单封装\nApache的DBUtils:\n它和Spring 的JdbcTemplate很像，也是对Jdbc的简单封装\n\n以上都不是框架，\n\nJDBC是规范Spring的JdbcTemplate和Apache的DBUtils都只是工具类\n4、MyBatis 框架概述MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。\n\nMyBatis 是一个持久性框架，用java编写的它封装了jdbc的细节，是开发者只用关注sql语句本身，而无需关注驱动，创建链接等繁杂的过程它使用了ORM思想实现了结果集的封装\nORM思想：\n\nObject Relational Mapping 对象关系映射\n就是把数据库和实体类及实体类的属性对应起来\n让我们可以操作实体类就实现操作数据库表\nuser       ——->        User\nid            ——->        userId\nname     ——->        userName\n\n5、Mybatis 下载和安装下载地址：https://github.com/mybatis/mybatis-3/releases\n中文官方网址：https://mybatis.org/mybatis-3/zh/index.html\n\n将下载的mybatis-3.5.5.zip进行解压，\n其中里面的\n\nmybatis-3.5.5.jar就是mybatis的核心包，mybatis-3.5.5.pdf 是官方文档LICENSE是执照NOTICE是注意事项，公告lib文件夹里面是一些附加包，用来附加一些功能\n将mybatis-3.5.5.jar，lib 路径下的所有jar包，还有jdbc所需要的 导入项目，其中 log4j-1.2.17.jar 是用来输出日志的包，并且需要把数据库对应jdbc驱动包导入到项目。\n\n导入包完成后，我们需要对项目进行一定的配置：\n我们在java源码文件夹下创建文件夹conf，用来存放我们的配置文件。\n（1）配置log4j，创建log4j.properties\n代码：\n# Rules reminder:# DEBUG < INFO < WARN < ERROR < FATAL# Global logging configurationlog4j.rootLogger=DEBUG, stdout# My logging configuration...log4j.logger.org.mybatis.jpetstore=DEBUG## Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p %d %C: %m%n\n（2）配置数据库链接，可以把数据链接用到的驱动、url、用户名、密码写到一个配置文件中，以后要改直接在配置文件中修改。\n在conf文件下创建jdbc.properties 文件\nurl=jdbc:oracle:thin:@localhost:1521:XEdriver=oracle.jdbc.driver.OracleDriverusername=mybatispassword=123456\n（3）配置mybatis，创建mybatis-config.xml文件\n代码：\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?><!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"><configuration>    <!-- 导入数据库配置文件 -->    <properties resource=\"jdbc.properties\"></properties>    <!-- 配置数据库信息 -->    <environments default=\"development\">        <environment id=\"development\">            <transactionManager type=\"JDBC\" />            <dataSource type=\"POOLED\">                <property name=\"driver\" value= \"${driver}\" />                <property name=\"url\" value= \"${url}\"/>                <property name=\"username\" value=\"${username}\" />                <property name=\"password\" value=\"${password}\" />            </dataSource>        </environment>    </environments>    <!-- 将我们写好的sql映射文件一定要注册到全局配置文件中 --></configuration>\n其中：\n\n< property name=”driver” value=”oracle.jdbc.driver.OracleDriver” /> 中value配置的是数据库驱动，根据自己的数据库配置< property name=”url” value=”jdbc:oracle:thin:@localhost:1521:XE” />中 value配置的是数据库链接的url< property name=”username” value=”mybatis” />中value配置的是需要链接的数据库用户名< property name=”password” value=”123456” />中value配置连接数据库的密码< mappers>< /mappers>中配置的是我们后面写好的sql映射文件\n6、连接数据库创建mybatis连接的工具类\nMyBatisUtil.java\npackage com.company.project.util;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;public class MyBatisUtil {    //主配文件路径    private static String resource = \"mybatis-config.xml\";    //会话工厂    private static SqlSessionFactory sqlSessionFactory;    //会话    private static SqlSession session;    /**     * 创建会话工厂     * @return SqlSessionFactory 会话工厂     */    public static SqlSessionFactory createFactory(){        if(sqlSessionFactory == null) {            InputStream inputStream;            try {                inputStream = Resources.getResourceAsStream(resource);                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);            } catch (IOException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }        }        if(sqlSessionFactory != null) {            System.out.println(\"工厂创建成功\");        }else {            System.out.println(\"工厂创建失败\");        }        return sqlSessionFactory;    }    /**     * 利用会话工厂创建会话对象     * @return SqlSession 会话对象     */    public static SqlSession getSession() {        //获取SqlSession实例，能直接执行已经映射的sql语句        SqlSession session = createFactory().openSession();        if(session!=null) {            System.out.println(\"会话创建成功\");        }else {            System.out.println(\"会话创建失败\");        }        return session;    }}\n7、测试数据库的连接package com.company.project.utiltest;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.log4j.Logger;import org.junit.platform.commons.logging.LoggerFactory;import com.company.project.util.MyBatisUtil;import junit.framework.TestCase;public class MyBatisUtilTest extends TestCase {    public void testGetSqlSessionFactory() {        SqlSessionFactory sessionFactory = MyBatisUtil.createFactory();        if (sessionFactory != null) {                        System.out.println(\"sessionFactory:\" + sessionFactory);            System.out.println(\"会话工厂创建成功！！！\");        } else {            System.out.println(\"操作提示：sessionFactory创建失败！\");        }    }    public void testGetSqlSession() {        SqlSession session = MyBatisUtil.getSession();        if (session != null) {                        System.out.println(\"session:\" + session);            System.out.println(\"会话创建成功！！！\");        } else {            System.out.println(\"操作提示：SqlSession创建失败！\");        }    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (105, '03.Mybatis框架的第一次使用', 8, '\n\n## 1、Po类（数据库表对应的java模型）\n\nUserPo.java\n\n```java\npackage com.company.project.model;\n\n/**\n * @author God_86\n *\n */\npublic class UserPo {\n	private long userId;\n	private String userName;\n	private long phoneNum;\n	private String password;\n	private String name;\n	private String sex;\n	private String shippingAddress;\n	\n	public UserPo() {\n		super();\n		this.userId = 0;\n		this.userName = \"\";\n		this.phoneNum = 0;\n		this.password = \"\";\n		this.name = \"\";\n		this.sex = \"\";\n		this.shippingAddress = \"\";\n	}\n\n\n\n	public String getUserName() {\n		return userName;\n	}\n\n	public long getPhoneNum() {\n		return phoneNum;\n	}\n\n	public String getPassword() {\n		return password;\n	}\n\n	public String getName() {\n		return name;\n	}\n\n	public String getSex() {\n		return sex;\n	}\n\n	public String getShippingAddress() {\n		return shippingAddress;\n	}\n\n	public long getUserId() {\n		return userId;\n	}\n\n	public void setUserId(long userId) {\n		this.userId = userId;\n	}\n\n	public void setUserName(String userName) {\n		this.userName = userName;\n	}\n\n	public void setPhoneNum(long phoneNum) {\n		this.phoneNum = phoneNum;\n	}\n\n	public void setPassword(String password) {\n		this.password = password;\n	}\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public void setSex(String sex) {\n		this.sex = sex;\n	}\n\n	public void setShippingAddress(String shippingAddress) {\n		this.shippingAddress = shippingAddress;\n	}\n\n	@Override\n	public String toString() {\n		return \"UserPo [userId=\" + userId + \", userName=\" + userName + \", phoneNum=\" + phoneNum + \", password=\"\n				+ password + \", name=\" + name + \", sex=\" + sex + \", shippingAddress=\" + shippingAddress + \"]\";\n	}\n\n\n\n	@Override\n	public int hashCode() {\n		final int prime = 31;\n		int result = 1;\n		result = prime * result + ((name == null) ? 0 : name.hashCode());\n		result = prime * result + ((password == null) ? 0 : password.hashCode());\n		result = prime * result + (int) (phoneNum ^ (phoneNum >>> 32));\n		result = prime * result + ((sex == null) ? 0 : sex.hashCode());\n		result = prime * result + ((shippingAddress == null) ? 0 : shippingAddress.hashCode());\n		result = prime * result + (int) (userId ^ (userId >>> 32));\n		result = prime * result + ((userName == null) ? 0 : userName.hashCode());\n		return result;\n	}\n\n\n	@Override\n	public boolean equals(Object obj) {\n		if (this == obj)\n			return true;\n		if (obj == null)\n			return false;\n		if (getClass() != obj.getClass())\n			return false;\n		UserPo other = (UserPo) obj;\n		if (name == null) {\n			if (other.name != null)\n				return false;\n		} else if (!name.equals(other.name))\n			return false;\n		if (password == null) {\n			if (other.password != null)\n				return false;\n		} else if (!password.equals(other.password))\n			return false;\n		if (phoneNum != other.phoneNum)\n			return false;\n		if (sex == null) {\n			if (other.sex != null)\n				return false;\n		} else if (!sex.equals(other.sex))\n			return false;\n		if (shippingAddress == null) {\n			if (other.shippingAddress != null)\n				return false;\n		} else if (!shippingAddress.equals(other.shippingAddress))\n			return false;\n		if (userId != other.userId)\n			return false;\n		if (userName == null) {\n			if (other.userName != null)\n				return false;\n		} else if (!userName.equals(other.userName))\n			return false;\n		return true;\n	}	\n}\n```\n\n## 2、mapper接口类（数据库表操作的方法接口）\n\nUserMapper.java\n\n```java\npackage com.company.project.mapper;\n\nimport java.util.List;\n\nimport org.apache.ibatis.annotations.Select;\n\nimport com.company.project.model.UserPo;\n\npublic interface UserMapper {\n	//插入方法\n	boolean insert(UserPo userPo);\n	\n	//更新方法\n	boolean update(UserPo userPo);\n	\n	//删除方法\n	boolean delete(long id);\n	\n	//查询主键\n	UserPo findById(long id);\n	\n	//查询所有\n	List<UserPo> findAll();\n\n```\n\n## 3、配置文件的编写（java Po 类与数据库表操作的对应关系）\n\nUserMapper.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.company.project.mapper.UserMapper\">\n<!-- \nnamespace：名称空间,指定为接口的全类名\nid：唯一标识\nresultType：返回值类型\n#{id}：从传递过来的参数中取出id值\n\npublic UserPo findById(long id);\n -->\n\n	<!-- 配置结果视图 -->\n	<resultMap type=\"userpo\" id=\"baseResultSet\">\n	\n		<id  column=\"id\" property=\"userId\"/>\n		<result column=\"user_name\" property=\"userName\" />\n		<result column=\"phone_num\" property=\"phoneNum\" />\n		<result column=\"password\" property=\"password\"  />\n		<result column=\"name\" property=\"name\"  />\n		<result column=\"sex\" property=\"sex\"  />\n		<result column=\"shipping_address\" property=\"shippingAddress\"  />	\n	</resultMap>\n	\n	\n	<!-- 通过主键查询 -->\n	<select id=\"findById\"  resultMap=\"baseResultSet\">\n		select id , user_name , phone_num , password , name ,sex,shipping_address from  \"USER\"\n		where id=#{id}\n		<!-- \n		<where>\n			<if test=\"id != null\">id=#{id}</if>\n			<if test=\"user_name != null\">user_name=#{user_name}</if>\n		</where>\n		 -->\n		 \n	</select>\n	\n	<!-- 查询所有 -->\n	<select id=\"findAll\"  resultMap=\"baseResultSet\">\n		select id , user_name , phone_num , password , name ,sex,shipping_address from  \"USER\"\n	</select>\n	\n	<!-- 插入 -->\n	<insert id=\"insert\" parameterType=\"UserPo\" >\n		insert into \"USER\" values(\n			#{userId},\n			#{userName},\n			#{phoneNum},\n			#{password},\n			#{name},\n			#{sex},\n			#{shippingAddress}\n		)\n	</insert>\n	\n	<!-- 更新 -->\n	<update id=\"update\" parameterType=\"UserPo\">\n		update \"USER\"  set  \n			user_name=#{userName},\n			phone_num=#{phoneNum},\n			password=#{password},\n			name=#{name},\n			sex=#{sex},\n			shipping_address=#{shippingAddress}	\n		Where  id = #{userId}\n	</update>\n	\n		<!-- 删除 -->\n	<delete id=\"delete\" parameterType=\"java.lang.Long\">\n		delete \"USER\" \n		Where  id = #{userId}\n	</delete>\n</mapper>\n```\n\n\n\n## 4、更新主配文件\n\nmybatis-config.xml 文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n	<!-- 导入数据库配置文件 -->\n	<properties resource=\"jdbc.properties\"></properties>\n	<typeAliases>\n	<!-- 利用package标签可以直接把整个包的 Po类都导入，这块是导入与数据库表对应的java类-->\n	<package name=\"com.company.project.model\"/>\n	</typeAliases>\n	\n	<!-- 配置数据库信息 -->\n	<environments default=\"development\">\n		<environment id=\"development\">\n			<transactionManager type=\"JDBC\" />\n			<dataSource type=\"POOLED\">\n				<property name=\"driver\" value= \"${driver}\" />\n				<property name=\"url\" value= \"${url}\"/>\n				<property name=\"username\" value=\"${username}\" />\n				<property name=\"password\" value=\"${password}\" />\n			</dataSource>\n		</environment>\n	</environments>\n	\n\n	<!-- 将我们写好的sql映射文件一定要注册到全局配置文件中 -->\n	<mappers>\n		<!-- 利用package标签可以直接把整个包的 xml配置文件都导入，这块是导入数据库表与java Po类对应的配置文件 -->\n		<package name=\"com.company.project.mapper\" />\n	</mappers>\n</configuration>\n```\n\n（1）在 < typeAliases >标签中，利用< package > 导入所有的model Po类\n\n（2）在 < mappers >标签中，利用< package > 导入所有的 XXXMapper.xml配置文件。\n\n**注意：**\n\n- 接口类应该和对应的配置类同名，这样才可以自动配置，可以省去很多步骤\n- 接口类XXXMapper.java应该和对应的配置类XXXMapper.xml应该写在同一个包下，这样可以自动配置。\n- 但是为了防止臃肿，我们可以把配置类XXXMapper.xml文件写在conf下，创建一个与接口类XXXMapper.java同名的包，把XXXMapper.xml文件写在包下，这样看起来，他们两个文件就没有在同一目录下，但是编译以后，在build路径下，接口类XXXMapper.java编译生成的XXXMapper.class会和XXXMapper.xml编译生成的XXXMapper.xml在同一目录文件下，所以间接性的把两个文件放在了同一包下，实现了上述的要求。\n\n\n\n## 5、测试\n\nUserMapperTest.java\n\n```java\npackage com.company.project.daotest;\n\nimport java.util.List;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.company.project.mapper.UserMapper;\nimport com.company.project.model.UserPo;\nimport com.company.project.util.MyBatisUtil;\n\n\nimport junit.framework.TestCase;\n\npublic class UserMapperTest extends TestCase{\n	\n	public void testFindById() {\n		Logger logger = LoggerFactory.getLogger(\"hello\");\n		//获取会话\n		SqlSession session = MyBatisUtil.getSession();\n		try {\n			//获取接口的实现类对象\n			//会自动为接口创建一个代理对象，代理对象去执行增删改查\n			UserMapper mapper = session.getMapper(UserMapper.class);\n			UserPo userPo = mapper.findById(1000001l);\n			System.out.println(userPo);\n			logger.info(userPo.toString());\n		} catch (Exception e) {\n			e.printStackTrace();\n		} finally {\n			session.close();\n		}\n	}\n	\n	public void testFindAll() {\n		\n		//获取会话\n		SqlSession session = MyBatisUtil.getSession();\n		try {\n			//获取接口的实现类对象\n			//会自动为接口创建一个代理对象，代理对象去执行增删改查\n			UserMapper mapper = session.getMapper(UserMapper.class);\n			List<UserPo> userPoList = mapper.findAll();\n			for(UserPo userPo : userPoList) {\n				System.out.println(userPo.toString());\n			}\n		} catch (Exception e) {\n			e.printStackTrace();\n		} finally {\n			session.close();\n		}\n	}\n	\n	public void testInsert() {\n		//获取会话\n		SqlSession session = MyBatisUtil.getSession();\n		try {\n			//获取接口的实现类对象\n			//会自动为接口创建一个代理对象，代理对象去执行增删改查\n			UserMapper mapper = session.getMapper(UserMapper.class);\n			UserPo userPo = new UserPo();\n			userPo.setUserId(1000003l);\n			userPo.setName(\"王五\");\n			userPo.setPassword(\"123456\");\n			userPo.setPhoneNum(15555555555l);\n			userPo.setSex(\"女\");\n			userPo.setShippingAddress(\"陕西省\");\n			userPo.setUserName(\"小仙女\");\n			System.out.println(userPo.toString());\n			boolean flag = mapper.insert(userPo);\n			if(flag) {\n				session.commit();\n				System.out.println(\"插入成功\");\n			}\n		} catch (Exception e) {\n			e.printStackTrace();\n		} finally {\n			session.close();\n		}\n	}\n	\n	public void testUpdate() {\n		//获取会话\n		SqlSession session = MyBatisUtil.getSession();\n		try {\n			//获取接口的实现类对象\n			//会自动为接口创建一个代理对象，代理对象去执行增删改查\n			UserMapper mapper = session.getMapper(UserMapper.class);\n			UserPo userPo = new UserPo();\n			userPo.setUserId(1000003l);\n			userPo.setName(\"王五\");\n			userPo.setPassword(\"123456\");\n			userPo.setPhoneNum(15555555555l);\n			userPo.setSex(\"女\");\n			userPo.setShippingAddress(\"重庆市\");\n			userPo.setUserName(\"小美女\");\n			System.out.println(userPo.toString());\n			boolean flag = mapper.update(userPo);\n			if(flag) {\n				session.commit();\n				System.out.println(\"更新成功\");\n			}\n		} catch (Exception e) {\n			e.printStackTrace();\n		} finally {\n			session.close();\n		}\n	}\n	\n	public void testDelete() {\n		\n		//获取会话\n		SqlSession session = MyBatisUtil.getSession();\n		try {\n			//获取接口的实现类对象\n			//会自动为接口创建一个代理对象，代理对象去执行增删改查\n			UserMapper mapper = session.getMapper(UserMapper.class);\n			boolean flag = mapper.delete(1000003l);\n			if(flag) {\n				session.commit();\n				System.out.println(\"删除成功\");\n				\n			}\n		} catch (Exception e) {\n			e.printStackTrace();\n		} finally {\n			session.close();\n		}\n	}\n}\n```\n\n注意：\n\n在mybatis中，对数据库操作，除了查询以外，其他的操作都需要进行提交 `session.commit();`，否则不会对数据库生效。', 0, 0, '2020-08-07 00:37:25', 2, 0, 1, '1、Po类（数据库表对应的java模型）UserPo.java\npackage com.company.project.model;/** * @author God_86 * */public class UserPo {    private long userId;    private String userName;    private long phoneNum;    private String password;    private String name;    private String sex;    private String shippingAddress;    public UserPo() {        super();        this.userId = 0;        this.userName = \"\";        this.phoneNum = 0;        this.password = \"\";        this.name = \"\";        this.sex = \"\";        this.shippingAddress = \"\";    }    public String getUserName() {        return userName;    }    public long getPhoneNum() {        return phoneNum;    }    public String getPassword() {        return password;    }    public String getName() {        return name;    }    public String getSex() {        return sex;    }    public String getShippingAddress() {        return shippingAddress;    }    public long getUserId() {        return userId;    }    public void setUserId(long userId) {        this.userId = userId;    }    public void setUserName(String userName) {        this.userName = userName;    }    public void setPhoneNum(long phoneNum) {        this.phoneNum = phoneNum;    }    public void setPassword(String password) {        this.password = password;    }    public void setName(String name) {        this.name = name;    }    public void setSex(String sex) {        this.sex = sex;    }    public void setShippingAddress(String shippingAddress) {        this.shippingAddress = shippingAddress;    }    @Override    public String toString() {        return \"UserPo [userId=\" + userId + \", userName=\" + userName + \", phoneNum=\" + phoneNum + \", password=\"                + password + \", name=\" + name + \", sex=\" + sex + \", shippingAddress=\" + shippingAddress + \"]\";    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + ((name == null) ? 0 : name.hashCode());        result = prime * result + ((password == null) ? 0 : password.hashCode());        result = prime * result + (int) (phoneNum ^ (phoneNum >>> 32));        result = prime * result + ((sex == null) ? 0 : sex.hashCode());        result = prime * result + ((shippingAddress == null) ? 0 : shippingAddress.hashCode());        result = prime * result + (int) (userId ^ (userId >>> 32));        result = prime * result + ((userName == null) ? 0 : userName.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        UserPo other = (UserPo) obj;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        if (password == null) {            if (other.password != null)                return false;        } else if (!password.equals(other.password))            return false;        if (phoneNum != other.phoneNum)            return false;        if (sex == null) {            if (other.sex != null)                return false;        } else if (!sex.equals(other.sex))            return false;        if (shippingAddress == null) {            if (other.shippingAddress != null)                return false;        } else if (!shippingAddress.equals(other.shippingAddress))            return false;        if (userId != other.userId)            return false;        if (userName == null) {            if (other.userName != null)                return false;        } else if (!userName.equals(other.userName))            return false;        return true;    }    }\n2、mapper接口类（数据库表操作的方法接口）UserMapper.java\npackage com.company.project.mapper;import java.util.List;import org.apache.ibatis.annotations.Select;import com.company.project.model.UserPo;public interface UserMapper {    //插入方法    boolean insert(UserPo userPo);    //更新方法    boolean update(UserPo userPo);    //删除方法    boolean delete(long id);    //查询主键    UserPo findById(long id);    //查询所有    List<UserPo> findAll();\n3、配置文件的编写（java Po 类与数据库表操作的对应关系）UserMapper.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?><!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"><mapper namespace=\"com.company.project.mapper.UserMapper\"><!-- namespace：名称空间,指定为接口的全类名id：唯一标识resultType：返回值类型#{id}：从传递过来的参数中取出id值public UserPo findById(long id); -->    <!-- 配置结果视图 -->    <resultMap type=\"userpo\" id=\"baseResultSet\">        <id  column=\"id\" property=\"userId\"/>        <result column=\"user_name\" property=\"userName\" />        <result column=\"phone_num\" property=\"phoneNum\" />        <result column=\"password\" property=\"password\"  />        <result column=\"name\" property=\"name\"  />        <result column=\"sex\" property=\"sex\"  />        <result column=\"shipping_address\" property=\"shippingAddress\"  />        </resultMap>    <!-- 通过主键查询 -->    <select id=\"findById\"  resultMap=\"baseResultSet\">        select id , user_name , phone_num , password , name ,sex,shipping_address from  \"USER\"        where id=#{id}        <!--         <where>            <if test=\"id != null\">id=#{id}</if>            <if test=\"user_name != null\">user_name=#{user_name}</if>        </where>         -->    </select>    <!-- 查询所有 -->    <select id=\"findAll\"  resultMap=\"baseResultSet\">        select id , user_name , phone_num , password , name ,sex,shipping_address from  \"USER\"    </select>    <!-- 插入 -->    <insert id=\"insert\" parameterType=\"UserPo\" >        insert into \"USER\" values(            #{userId},            #{userName},            #{phoneNum},            #{password},            #{name},            #{sex},            #{shippingAddress}        )    </insert>    <!-- 更新 -->    <update id=\"update\" parameterType=\"UserPo\">        update \"USER\"  set              user_name=#{userName},            phone_num=#{phoneNum},            password=#{password},            name=#{name},            sex=#{sex},            shipping_address=#{shippingAddress}            Where  id = #{userId}    </update>        <!-- 删除 -->    <delete id=\"delete\" parameterType=\"java.lang.Long\">        delete \"USER\"         Where  id = #{userId}    </delete></mapper>\n4、更新主配文件mybatis-config.xml 文件\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?><!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"><configuration>    <!-- 导入数据库配置文件 -->    <properties resource=\"jdbc.properties\"></properties>    <typeAliases>    <!-- 利用package标签可以直接把整个包的 Po类都导入，这块是导入与数据库表对应的java类-->    <package name=\"com.company.project.model\"/>    </typeAliases>    <!-- 配置数据库信息 -->    <environments default=\"development\">        <environment id=\"development\">            <transactionManager type=\"JDBC\" />            <dataSource type=\"POOLED\">                <property name=\"driver\" value= \"${driver}\" />                <property name=\"url\" value= \"${url}\"/>                <property name=\"username\" value=\"${username}\" />                <property name=\"password\" value=\"${password}\" />            </dataSource>        </environment>    </environments>    <!-- 将我们写好的sql映射文件一定要注册到全局配置文件中 -->    <mappers>        <!-- 利用package标签可以直接把整个包的 xml配置文件都导入，这块是导入数据库表与java Po类对应的配置文件 -->        <package name=\"com.company.project.mapper\" />    </mappers></configuration>\n（1）在 < typeAliases >标签中，利用< package > 导入所有的model Po类\n（2）在 < mappers >标签中，利用< package > 导入所有的 XXXMapper.xml配置文件。\n注意：\n\n接口类应该和对应的配置类同名，这样才可以自动配置，可以省去很多步骤接口类XXXMapper.java应该和对应的配置类XXXMapper.xml应该写在同一个包下，这样可以自动配置。但是为了防止臃肿，我们可以把配置类XXXMapper.xml文件写在conf下，创建一个与接口类XXXMapper.java同名的包，把XXXMapper.xml文件写在包下，这样看起来，他们两个文件就没有在同一目录下，但是编译以后，在build路径下，接口类XXXMapper.java编译生成的XXXMapper.class会和XXXMapper.xml编译生成的XXXMapper.xml在同一目录文件下，所以间接性的把两个文件放在了同一包下，实现了上述的要求。\n5、测试UserMapperTest.java\npackage com.company.project.daotest;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.company.project.mapper.UserMapper;import com.company.project.model.UserPo;import com.company.project.util.MyBatisUtil;import junit.framework.TestCase;public class UserMapperTest extends TestCase{    public void testFindById() {        Logger logger = LoggerFactory.getLogger(\"hello\");        //获取会话        SqlSession session = MyBatisUtil.getSession();        try {            //获取接口的实现类对象            //会自动为接口创建一个代理对象，代理对象去执行增删改查            UserMapper mapper = session.getMapper(UserMapper.class);            UserPo userPo = mapper.findById(1000001l);            System.out.println(userPo);            logger.info(userPo.toString());        } catch (Exception e) {            e.printStackTrace();        } finally {            session.close();        }    }    public void testFindAll() {        //获取会话        SqlSession session = MyBatisUtil.getSession();        try {            //获取接口的实现类对象            //会自动为接口创建一个代理对象，代理对象去执行增删改查            UserMapper mapper = session.getMapper(UserMapper.class);            List<UserPo> userPoList = mapper.findAll();            for(UserPo userPo : userPoList) {                System.out.println(userPo.toString());            }        } catch (Exception e) {            e.printStackTrace();        } finally {            session.close();        }    }    public void testInsert() {        //获取会话        SqlSession session = MyBatisUtil.getSession();        try {            //获取接口的实现类对象            //会自动为接口创建一个代理对象，代理对象去执行增删改查            UserMapper mapper = session.getMapper(UserMapper.class);            UserPo userPo = new UserPo();            userPo.setUserId(1000003l);            userPo.setName(\"王五\");            userPo.setPassword(\"123456\");            userPo.setPhoneNum(15555555555l);            userPo.setSex(\"女\");            userPo.setShippingAddress(\"陕西省\");            userPo.setUserName(\"小仙女\");            System.out.println(userPo.toString());            boolean flag = mapper.insert(userPo);            if(flag) {                session.commit();                System.out.println(\"插入成功\");            }        } catch (Exception e) {            e.printStackTrace();        } finally {            session.close();        }    }    public void testUpdate() {        //获取会话        SqlSession session = MyBatisUtil.getSession();        try {            //获取接口的实现类对象            //会自动为接口创建一个代理对象，代理对象去执行增删改查            UserMapper mapper = session.getMapper(UserMapper.class);            UserPo userPo = new UserPo();            userPo.setUserId(1000003l);            userPo.setName(\"王五\");            userPo.setPassword(\"123456\");            userPo.setPhoneNum(15555555555l);            userPo.setSex(\"女\");            userPo.setShippingAddress(\"重庆市\");            userPo.setUserName(\"小美女\");            System.out.println(userPo.toString());            boolean flag = mapper.update(userPo);            if(flag) {                session.commit();                System.out.println(\"更新成功\");            }        } catch (Exception e) {            e.printStackTrace();        } finally {            session.close();        }    }    public void testDelete() {        //获取会话        SqlSession session = MyBatisUtil.getSession();        try {            //获取接口的实现类对象            //会自动为接口创建一个代理对象，代理对象去执行增删改查            UserMapper mapper = session.getMapper(UserMapper.class);            boolean flag = mapper.delete(1000003l);            if(flag) {                session.commit();                System.out.println(\"删除成功\");            }        } catch (Exception e) {            e.printStackTrace();        } finally {            session.close();        }    }}\n注意：\n在mybatis中，对数据库操作，除了查询以外，其他的操作都需要进行提交 session.commit();，否则不会对数据库生效。\n', 0, 1);
INSERT INTO `t_article` VALUES (106, '04. 解决数据库列名与java属性对应关系', 8, '\n我们在使用mybatis框架的时候，在查询语句中，如果数据库列名与最后接收结构的java对象的属性名不同，就不会把结果值传输进去。\n\n比如：\n\n| 数据库列名 | java属性名 |\n| ---------- | ---------- |\n| id         | id         |\n| user_name  | userName   |\n| password   | password   |\n| reg_time   | regTime    |\n\n下面解决方式都是利用这张表。\n\n\n\n解决这种名称不匹配一共有3种方式：\n\n## 1、方法一：利用列别名\n\n我们在sql的映射文件中，使用select的时候，可以给名称不同的列起一个列别名。\n\n```xml\n	<select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">\n		select \n			id,\n			user_name userName,\n			password,\n			reg_time regTime\n        from t_user \n        where id = #{id}\n	</select>\n```\n\n当然，如果每个select都使用这样写法，这样可能会出现很多重复的sql代码。\n\n我们也可以利用sql标签将重复代码提取出来，然后使用include在需要的地方使用，相当于把代码粘贴过去的。\n\n```xml\n	<!-- 把重复的sql代码可以提炼出来，通过定义别名把sql列名和java属性对应 -->\n	<sql id=\"selectResult\">\n		id,user_name userName,password,reg_time regTime\n	</sql>\n	\n	<select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">\n		select <include refid=\"selectResult\"></include> from t_user where id = #{id}\n	</select>\n```\n\n\n\n## 2、方法二：属性匹配映射\n\n我们在sql映射文件中，利用resultMap标签将数据库列名和java中的属性名进行映射绑定。\n\n```xml\n	 <resultMap type=\"UserPo\" id=\"userResult\">\n	 	<id property=\"id\" column=\"id\"/>\n	 	<result property=\"userName\"  column=\"user_name\"/>\n	 	<result property=\"password\"  column=\"password\"/>\n	 	<result property=\"regTime\"  column=\"reg_time\"/>\n	 </resultMap>\n```\n\n然后需要在查询语句中，将结果的接收方式改为resultMap=\"userResult\"，其中值为上述定义resultMap标签的id。\n\n```xml\n	<select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">\n		select id,user_name,password,reg_time from t_user where id = #{id}\n	</select>\n```\n\n\n\n## 3、方法三：开启类型自动匹配\n\n这种方式需要严格按照命名规范，数据库中的列，应该是单词和单词之间利用下划线连接，java中的属性应该是小驼峰的命名规范。\n\n比如：user_name       ---->        userName\n\n开启类型自动匹配后，会自动进行转换。\n\n如何开启？\n\n在全局配置文件mybatis-config.xml中，添加\n\n```xml\n	<!-- 设置类型自动转换 -->\n	<settings>\n		<setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n	</settings>\n```\n\n**注意：**\n\n在xml文件中，需要注意标签的位置，因为xml文件中有严格的规范。\n\nsettings标签在properties标签的下面，如果没有properties标签，就在configuration标签里面的第一条。', 0, 0, '2020-08-07 00:38:04', 2, 0, 1, '我们在使用mybatis框架的时候，在查询语句中，如果数据库列名与最后接收结构的java对象的属性名不同，就不会把结果值传输进去。\n比如：\n\n\n\n数据库列名\njava属性名\n\n\n\n\nid\nid\n\n\nuser_name\nuserName\n\n\npassword\npassword\n\n\nreg_time\nregTime\n\n\n\n下面解决方式都是利用这张表。\n解决这种名称不匹配一共有3种方式：\n1、方法一：利用列别名我们在sql的映射文件中，使用select的时候，可以给名称不同的列起一个列别名。\n    <select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">        select             id,            user_name userName,            password,            reg_time regTime        from t_user         where id = #{id}    </select>\n当然，如果每个select都使用这样写法，这样可能会出现很多重复的sql代码。\n我们也可以利用sql标签将重复代码提取出来，然后使用include在需要的地方使用，相当于把代码粘贴过去的。\n    <!-- 把重复的sql代码可以提炼出来，通过定义别名把sql列名和java属性对应 -->    <sql id=\"selectResult\">        id,user_name userName,password,reg_time regTime    </sql>    <select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">        select <include refid=\"selectResult\"></include> from t_user where id = #{id}    </select>\n2、方法二：属性匹配映射我们在sql映射文件中，利用resultMap标签将数据库列名和java中的属性名进行映射绑定。\n     <resultMap type=\"UserPo\" id=\"userResult\">         <id property=\"id\" column=\"id\"/>         <result property=\"userName\"  column=\"user_name\"/>         <result property=\"password\"  column=\"password\"/>         <result property=\"regTime\"  column=\"reg_time\"/>     </resultMap>\n然后需要在查询语句中，将结果的接收方式改为resultMap=”userResult”，其中值为上述定义resultMap标签的id。\n    <select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">        select id,user_name,password,reg_time from t_user where id = #{id}    </select>\n3、方法三：开启类型自动匹配这种方式需要严格按照命名规范，数据库中的列，应该是单词和单词之间利用下划线连接，java中的属性应该是小驼峰的命名规范。\n比如：user_name       ——>        userName\n开启类型自动匹配后，会自动进行转换。\n如何开启？\n在全局配置文件mybatis-config.xml中，添加\n    <!-- 设置类型自动转换 -->    <settings>        <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>    </settings>\n注意：\n在xml文件中，需要注意标签的位置，因为xml文件中有严格的规范。\nsettings标签在properties标签的下面，如果没有properties标签，就在configuration标签里面的第一条。\n', 0, 1);
INSERT INTO `t_article` VALUES (107, '05. mybatis多表关联结果处理', 8, '\n## 1、准备数据\n\n创建表：\n\n**dept表：**\n\n```sql\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for dept\n-- ----------------------------\nDROP TABLE IF EXISTS `dept`;\nCREATE TABLE `dept`  (\n  `DEPTNO` int(2) NOT NULL,\n  `DNAME` varchar(14) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,\n  `LOC` varchar(13) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`DEPTNO`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of dept\n-- ----------------------------\nINSERT INTO `dept` VALUES (10, \'ACCOUNTING\', \'NEW YORK\');\nINSERT INTO `dept` VALUES (20, \'RESEARCH\', \'DALLAS\');\nINSERT INTO `dept` VALUES (30, \'SALES\', \'CHICAGO\');\nINSERT INTO `dept` VALUES (40, \'OPERATIONS\', \'BOSTON\');\n\nSET FOREIGN_KEY_CHECKS = 1;\n\n```\n\n**emp表：**\n\n```sql\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for emp\n-- ----------------------------\nDROP TABLE IF EXISTS `emp`;\nCREATE TABLE `emp`  (\n  `EMPNO` int(4) NOT NULL,\n  `ENAME` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,\n  `JOB` varchar(9) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,\n  `MGR` int(4) NULL DEFAULT NULL,\n  `HIREDATE` date NULL DEFAULT NULL,\n  `SAL` double(7, 2) NULL DEFAULT NULL,\n  `COMM` double(7, 2) NULL DEFAULT NULL,\n  `DEPTNO` int(2) NOT NULL,\n  PRIMARY KEY (`EMPNO`) USING BTREE,\n  INDEX `emp`(`DEPTNO`) USING BTREE,\n  CONSTRAINT `emp` FOREIGN KEY (`DEPTNO`) REFERENCES `dept` (`DEPTNO`) ON DELETE CASCADE ON UPDATE CASCADE\n) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of emp\n-- ----------------------------\nINSERT INTO `emp` VALUES (7369, \'SMITH\', \'CLERK\', 7902, \'1980-12-17\', 800.00, NULL, 20);\nINSERT INTO `emp` VALUES (7499, \'ALLEN\', \'SALESMAN\', 7698, \'1981-02-20\', 1600.00, 300.00, 30);\nINSERT INTO `emp` VALUES (7521, \'WARD\', \'SALESMAN\', 7698, \'1981-02-22\', 1250.00, 500.00, 30);\nINSERT INTO `emp` VALUES (7566, \'JONES\', \'MANAGER\', 7839, \'1981-04-02\', 2975.00, NULL, 20);\nINSERT INTO `emp` VALUES (7654, \'MARTIN\', \'SALESMAN\', 7698, \'1981-09-28\', 1250.00, 1400.00, 30);\nINSERT INTO `emp` VALUES (7698, \'BLAKE\', \'MANAGER\', 7839, \'1981-05-01\', 2850.00, NULL, 30);\nINSERT INTO `emp` VALUES (7782, \'CLARK\', \'MANAGER\', 7839, \'1981-06-09\', 2450.00, NULL, 10);\nINSERT INTO `emp` VALUES (7788, \'SCOTT\', \'ANALYST\', 7566, \'1987-04-19\', 3000.00, NULL, 20);\nINSERT INTO `emp` VALUES (7839, \'KING\', \'PRESIDENT\', NULL, \'1981-11-17\', 5000.00, NULL, 10);\nINSERT INTO `emp` VALUES (7844, \'TURNER\', \'SALESMAN\', 7698, \'1981-09-08\', 1500.00, 0.00, 30);\nINSERT INTO `emp` VALUES (7876, \'ADAMS\', \'CLERK\', 7788, \'1987-05-23\', 1100.00, NULL, 20);\nINSERT INTO `emp` VALUES (7900, \'JAMES\', \'CLERK\', 7698, \'1981-12-03\', 950.00, NULL, 30);\nINSERT INTO `emp` VALUES (7902, \'FORD\', \'ANALYST\', 7566, \'1981-12-03\', 3000.00, NULL, 20);\nINSERT INTO `emp` VALUES (7934, \'MILLER\', \'CLERK\', 7782, \'1982-01-23\', 1300.00, NULL, 10);\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n\n\n如上述两张表，互相有着关联关系：一个部门会有多名员工，一名员工附属于一个部门，因此建立了外键关系。\n\n\n\n## 2、建立Po模型类\n\n**DeptPo.java**\n\n```java\npackage com.company.project.Po;\n\nimport java.util.List;\n\npublic class DeptPo {\n	private int deptno;\n	private String dname;\n	private String loc;\n	\n	private List<EmpPo> empPos;\n\n	public int getDeptno() {\n		return deptno;\n	}\n\n	public String getDname() {\n		return dname;\n	}\n\n	public String getLoc() {\n		return loc;\n	}\n\n	public List<EmpPo> getEmpPos() {\n		return empPos;\n	}\n\n	public void setDeptno(int deptno) {\n		this.deptno = deptno;\n	}\n\n	public void setDname(String dname) {\n		this.dname = dname;\n	}\n\n	public void setLoc(String loc) {\n		this.loc = loc;\n	}\n\n	public void setEmpPos(List<EmpPo> empPos) {\n		this.empPos = empPos;\n	}\n\n	@Override\n	public String toString() {\n		return \"DeptPo [deptno=\" + deptno + \", dname=\" + dname + \", loc=\" + loc + \", empPos=\" + empPos + \"]\";\n	}\n}\n```\n\n\n\n**EmpPo.java**\n\n```java\npackage com.company.project.Po;\n\nimport java.sql.Date;\n\npublic class EmpPo {\n	private int empno;\n	private String ename;\n	private String job;\n	private int mgr;\n	private Date hiredate;\n	private double sal;\n	private double comm;\n	private DeptPo deptPo;\n	public int getEmpno() {\n		return empno;\n	}\n	public String getEname() {\n		return ename;\n	}\n	public String getJob() {\n		return job;\n	}\n	public int getMgr() {\n		return mgr;\n	}\n	public Date getHiredate() {\n		return hiredate;\n	}\n	public double getSal() {\n		return sal;\n	}\n	public double getComm() {\n		return comm;\n	}\n\n	public DeptPo getDeptPo() {\n		return deptPo;\n	}\n	public void setEmpno(int empno) {\n		this.empno = empno;\n	}\n	public void setEname(String ename) {\n		this.ename = ename;\n	}\n	public void setJob(String job) {\n		this.job = job;\n	}\n	public void setMgr(int mgr) {\n		this.mgr = mgr;\n	}\n	public void setHiredate(Date hiredate) {\n		this.hiredate = hiredate;\n	}\n	public void setSal(double sal) {\n		this.sal = sal;\n	}\n	public void setComm(double comm) {\n		this.comm = comm;\n	}\n\n	public void setDeptPo(DeptPo deptPo) {\n		this.deptPo = deptPo;\n	}\n	@Override\n	public String toString() {\n		return \"EmpPo [empno=\" + empno + \", ename=\" + ename + \", job=\" + job + \", mgr=\" + mgr + \", hiredate=\" + hiredate\n				+ \", sal=\" + sal + \", comm=\" + comm + \", deptPo=\" + deptPo + \"]\";\n	}\n}\n```\n\n\n\n## 3、建立Dao接口\n\n**EmpDao.java**\n\n```java\npackage com.company.project.dao;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport com.company.project.Po.DeptPo;\nimport com.company.project.Po.EmpPo;\n\npublic interface EmpDao {\n	EmpPo findById(int empno);\n	Map<String, Object> findById2(int empno);\n}\n```\n\n**DeptDao.java**\n\n```java\npackage com.company.project.dao;\n\nimport java.util.List;\n\nimport com.company.project.Po.DeptPo;\nimport com.company.project.Po.EmpPo;\n\npublic interface DeptDao {\n	DeptPo findById(int deptno);\n\n}\n```\n\n\n\n## 4、建立xml映射文件\n\n利用 resultMap 来组合封装查询结果，利用association标签来组装属性对象的结果集。\n\n**EmpMapper.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"com.company.project.dao.EmpDao\">\n	<!-- 把重复的sql代码可以提炼出来，通过定义别名把sql列名和java属性对应 -->\n	<sql id=\"selectResult\">\n		e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno,d.DNAME,d.LOC \n	</sql>\n	\n	\n	<!-- sql查询结果与javaPo类的对应关系 -->\n	 <resultMap type=\"EmpPo\" id=\"EmpResult\">\n	 	<id property=\"empno\" column=\"empno\"/>\n	 	<result property=\"ename\"  column=\"ename\"/>\n	 	<result property=\"job\"  column=\"job\"/>\n	 	<result property=\"mgr\"  column=\"mgr\"/>\n	 	<result property=\"hiredate\"  column=\"hiredate\"/>\n	 	<result property=\"sal\"  column=\"sal\"/>\n	 	<result property=\"comm\"  column=\"comm\"/>\n         <!--利用association标签，建立属性对象的映射 -->\n	 	<association property=\"deptPo\" javaType=\"deptPo\">\n	 		<id property=\"deptno\" column=\"deptno\"/>\n	 		<result property=\"dname\"  column=\"dname\"/>\n	 		<result property=\"loc\"  column=\"loc\"/>\n	 	</association>\n	 </resultMap>\n\n	<!--第一种方式：利用resultMap定义查询结果的映射关系 -->\n	<select id=\"findById\" parameterType=\"int\" resultMap=\"EmpResult\">\n		select\n			<include refid=\"selectResult\"></include>\n		from \n			emp e\n		join\n			dept d\n		on\n			e.DEPTNO = d.DEPTNO\n		where e.empno = #{empno}\n	</select>\n	\n	\n	<!--第一种方式：利用map使用数据库列名接收结果 -->\n	<select id=\"findById2\" parameterType=\"int\" resultType=\"map\">\n		select\n			<include refid=\"selectResult\"></include>\n		from \n			emp e\n		join\n			dept d\n		on\n			e.DEPTNO = d.DEPTNO\n		where e.empno = #{empno}\n	</select>\n\n</mapper>\n```\n\n\n\n**DeptMapper.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n    \n   <mapper namespace=\"com.company.project.dao.DeptDao\">\n       \n   <!-- sql查询结果与javaPo类的对应关系 -->\n   <resultMap type=\"DeptPo\" id=\"deptMap\">\n   		<id column=\"deptno\" property=\"deptno\"/>\n   		<result column=\"dname\" property=\"dname\"/>\n   		<result column=\"loc\" property=\"loc\"/>\n   		<!-- 将一个部门中 的多个员工封装到集合中 -->\n   		<collection property=\"empPos\" javaType=\"list\" ofType=\"EmpPo\">\n   			<id property=\"empno\" column=\"empno\"/>\n		 	<result property=\"ename\"  column=\"ename\"/>\n		 	<result property=\"job\"  column=\"job\"/>\n		 	<result property=\"mgr\"  column=\"mgr\"/>\n		 	<result property=\"hiredate\"  column=\"hiredate\"/>\n		 	<result property=\"sal\"  column=\"sal\"/>\n		 	<result property=\"comm\"  column=\"comm\"/>\n   		</collection>\n   </resultMap>\n   \n   <select id=\"findById\" parameterType=\"int\" resultMap=\"deptMap\">\n   		SELECT\n			e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno,d.DNAME,d.LOC \n		FROM\n			dept d\n			JOIN emp e ON d.deptno = e.deptno \n		WHERE\n			d.deptno = #{deptno}\n   </select>\n   \n\n   </mapper> \n```\n\n\n\n在写完xml映射文件之后，需要在全局配置文件mybatis-config.xml文件中添加映射文件信息\n\n```xml\n	<!-- 将我们写好的sql映射文件一定要注册到全局配置文件中 -->\n	<mappers>\n		<!-- 利用package标签可以直接把整个包的 xml配置文件都导入，这块是导入数据库表与java Po类对应的配置文件 -->\n		<mapper resource=\"com/company/project/mapper/EmpMapper.xml\"/>\n		<mapper resource=\"com/company/project/mapper/DeptMapper.xml\"/>\n	</mappers>\n```\n\n\n\n\n\n## 5、测试类\n\n**EmpTest.java**\n\n```java\npackage com.company.project.test;\n\nimport java.util.List;\n\nimport org.apache.ibatis.session.SqlSession;\n\nimport com.company.project.Po.EmpPo;\nimport com.company.project.dao.EmpDao;\nimport com.company.project.util.MyBatisUtil;\n\nimport junit.framework.TestCase;\n\npublic class EmpTest extends TestCase {\n	public void testFindById() {\n		SqlSession sqlSession = MyBatisUtil.getSqlSession();\n		EmpDao empDao = sqlSession.getMapper(EmpDao.class);\n		EmpPo empPo = empDao.findById(7369);\n		System.out.println(empPo);\n	}\n	\n}\n```\n\n\n\n**DeptTest.java**\n\n```java\npackage com.company.project.test;\n\nimport java.util.List;\n\nimport org.apache.ibatis.session.SqlSession;\n\nimport com.company.project.Po.DeptPo;\nimport com.company.project.Po.EmpPo;\nimport com.company.project.dao.DeptDao;\nimport com.company.project.dao.EmpDao;\nimport com.company.project.util.MyBatisUtil;\n\nimport junit.framework.TestCase;\n\npublic class DeptTest extends TestCase {\n	public void testFindById() {\n		try {\n			SqlSession sqlSession = MyBatisUtil.getSqlSession();\n			DeptDao deptDao = sqlSession.getMapper(DeptDao.class);\n			DeptPo deptPo = deptDao.findById(20);\n			System.out.println(deptPo);\n		}catch (Exception e) {\n			e.printStackTrace();\n		}finally {\n			MyBatisUtil.closeSession();\n		}\n	}\n\n}\n```\n\n', 0, 0, '2020-08-07 00:38:41', 2, 0, 1, '1、准备数据创建表：\ndept表：\nSET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for dept-- ----------------------------DROP TABLE IF EXISTS `dept`;CREATE TABLE `dept`  (  `DEPTNO` int(2) NOT NULL,  `DNAME` varchar(14) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,  `LOC` varchar(13) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,  PRIMARY KEY (`DEPTNO`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of dept-- ----------------------------INSERT INTO `dept` VALUES (10, \'ACCOUNTING\', \'NEW YORK\');INSERT INTO `dept` VALUES (20, \'RESEARCH\', \'DALLAS\');INSERT INTO `dept` VALUES (30, \'SALES\', \'CHICAGO\');INSERT INTO `dept` VALUES (40, \'OPERATIONS\', \'BOSTON\');SET FOREIGN_KEY_CHECKS = 1;\nemp表：\nSET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for emp-- ----------------------------DROP TABLE IF EXISTS `emp`;CREATE TABLE `emp`  (  `EMPNO` int(4) NOT NULL,  `ENAME` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,  `JOB` varchar(9) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,  `MGR` int(4) NULL DEFAULT NULL,  `HIREDATE` date NULL DEFAULT NULL,  `SAL` double(7, 2) NULL DEFAULT NULL,  `COMM` double(7, 2) NULL DEFAULT NULL,  `DEPTNO` int(2) NOT NULL,  PRIMARY KEY (`EMPNO`) USING BTREE,  INDEX `emp`(`DEPTNO`) USING BTREE,  CONSTRAINT `emp` FOREIGN KEY (`DEPTNO`) REFERENCES `dept` (`DEPTNO`) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of emp-- ----------------------------INSERT INTO `emp` VALUES (7369, \'SMITH\', \'CLERK\', 7902, \'1980-12-17\', 800.00, NULL, 20);INSERT INTO `emp` VALUES (7499, \'ALLEN\', \'SALESMAN\', 7698, \'1981-02-20\', 1600.00, 300.00, 30);INSERT INTO `emp` VALUES (7521, \'WARD\', \'SALESMAN\', 7698, \'1981-02-22\', 1250.00, 500.00, 30);INSERT INTO `emp` VALUES (7566, \'JONES\', \'MANAGER\', 7839, \'1981-04-02\', 2975.00, NULL, 20);INSERT INTO `emp` VALUES (7654, \'MARTIN\', \'SALESMAN\', 7698, \'1981-09-28\', 1250.00, 1400.00, 30);INSERT INTO `emp` VALUES (7698, \'BLAKE\', \'MANAGER\', 7839, \'1981-05-01\', 2850.00, NULL, 30);INSERT INTO `emp` VALUES (7782, \'CLARK\', \'MANAGER\', 7839, \'1981-06-09\', 2450.00, NULL, 10);INSERT INTO `emp` VALUES (7788, \'SCOTT\', \'ANALYST\', 7566, \'1987-04-19\', 3000.00, NULL, 20);INSERT INTO `emp` VALUES (7839, \'KING\', \'PRESIDENT\', NULL, \'1981-11-17\', 5000.00, NULL, 10);INSERT INTO `emp` VALUES (7844, \'TURNER\', \'SALESMAN\', 7698, \'1981-09-08\', 1500.00, 0.00, 30);INSERT INTO `emp` VALUES (7876, \'ADAMS\', \'CLERK\', 7788, \'1987-05-23\', 1100.00, NULL, 20);INSERT INTO `emp` VALUES (7900, \'JAMES\', \'CLERK\', 7698, \'1981-12-03\', 950.00, NULL, 30);INSERT INTO `emp` VALUES (7902, \'FORD\', \'ANALYST\', 7566, \'1981-12-03\', 3000.00, NULL, 20);INSERT INTO `emp` VALUES (7934, \'MILLER\', \'CLERK\', 7782, \'1982-01-23\', 1300.00, NULL, 10);SET FOREIGN_KEY_CHECKS = 1;\n如上述两张表，互相有着关联关系：一个部门会有多名员工，一名员工附属于一个部门，因此建立了外键关系。\n2、建立Po模型类DeptPo.java\npackage com.company.project.Po;import java.util.List;public class DeptPo {    private int deptno;    private String dname;    private String loc;    private List<EmpPo> empPos;    public int getDeptno() {        return deptno;    }    public String getDname() {        return dname;    }    public String getLoc() {        return loc;    }    public List<EmpPo> getEmpPos() {        return empPos;    }    public void setDeptno(int deptno) {        this.deptno = deptno;    }    public void setDname(String dname) {        this.dname = dname;    }    public void setLoc(String loc) {        this.loc = loc;    }    public void setEmpPos(List<EmpPo> empPos) {        this.empPos = empPos;    }    @Override    public String toString() {        return \"DeptPo [deptno=\" + deptno + \", dname=\" + dname + \", loc=\" + loc + \", empPos=\" + empPos + \"]\";    }}\nEmpPo.java\npackage com.company.project.Po;import java.sql.Date;public class EmpPo {    private int empno;    private String ename;    private String job;    private int mgr;    private Date hiredate;    private double sal;    private double comm;    private DeptPo deptPo;    public int getEmpno() {        return empno;    }    public String getEname() {        return ename;    }    public String getJob() {        return job;    }    public int getMgr() {        return mgr;    }    public Date getHiredate() {        return hiredate;    }    public double getSal() {        return sal;    }    public double getComm() {        return comm;    }    public DeptPo getDeptPo() {        return deptPo;    }    public void setEmpno(int empno) {        this.empno = empno;    }    public void setEname(String ename) {        this.ename = ename;    }    public void setJob(String job) {        this.job = job;    }    public void setMgr(int mgr) {        this.mgr = mgr;    }    public void setHiredate(Date hiredate) {        this.hiredate = hiredate;    }    public void setSal(double sal) {        this.sal = sal;    }    public void setComm(double comm) {        this.comm = comm;    }    public void setDeptPo(DeptPo deptPo) {        this.deptPo = deptPo;    }    @Override    public String toString() {        return \"EmpPo [empno=\" + empno + \", ename=\" + ename + \", job=\" + job + \", mgr=\" + mgr + \", hiredate=\" + hiredate                + \", sal=\" + sal + \", comm=\" + comm + \", deptPo=\" + deptPo + \"]\";    }}\n3、建立Dao接口EmpDao.java\npackage com.company.project.dao;import java.util.List;import java.util.Map;import com.company.project.Po.DeptPo;import com.company.project.Po.EmpPo;public interface EmpDao {    EmpPo findById(int empno);    Map<String, Object> findById2(int empno);}\nDeptDao.java\npackage com.company.project.dao;import java.util.List;import com.company.project.Po.DeptPo;import com.company.project.Po.EmpPo;public interface DeptDao {    DeptPo findById(int deptno);}\n4、建立xml映射文件利用 resultMap 来组合封装查询结果，利用association标签来组装属性对象的结果集。\nEmpMapper.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE mapper    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"><mapper namespace=\"com.company.project.dao.EmpDao\">    <!-- 把重复的sql代码可以提炼出来，通过定义别名把sql列名和java属性对应 -->    <sql id=\"selectResult\">        e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno,d.DNAME,d.LOC     </sql>    <!-- sql查询结果与javaPo类的对应关系 -->     <resultMap type=\"EmpPo\" id=\"EmpResult\">         <id property=\"empno\" column=\"empno\"/>         <result property=\"ename\"  column=\"ename\"/>         <result property=\"job\"  column=\"job\"/>         <result property=\"mgr\"  column=\"mgr\"/>         <result property=\"hiredate\"  column=\"hiredate\"/>         <result property=\"sal\"  column=\"sal\"/>         <result property=\"comm\"  column=\"comm\"/>         <!--利用association标签，建立属性对象的映射 -->         <association property=\"deptPo\" javaType=\"deptPo\">             <id property=\"deptno\" column=\"deptno\"/>             <result property=\"dname\"  column=\"dname\"/>             <result property=\"loc\"  column=\"loc\"/>         </association>     </resultMap>    <!--第一种方式：利用resultMap定义查询结果的映射关系 -->    <select id=\"findById\" parameterType=\"int\" resultMap=\"EmpResult\">        select            <include refid=\"selectResult\"></include>        from             emp e        join            dept d        on            e.DEPTNO = d.DEPTNO        where e.empno = #{empno}    </select>    <!--第一种方式：利用map使用数据库列名接收结果 -->    <select id=\"findById2\" parameterType=\"int\" resultType=\"map\">        select            <include refid=\"selectResult\"></include>        from             emp e        join            dept d        on            e.DEPTNO = d.DEPTNO        where e.empno = #{empno}    </select></mapper>\nDeptMapper.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE mapper    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">   <mapper namespace=\"com.company.project.dao.DeptDao\">   <!-- sql查询结果与javaPo类的对应关系 -->   <resultMap type=\"DeptPo\" id=\"deptMap\">           <id column=\"deptno\" property=\"deptno\"/>           <result column=\"dname\" property=\"dname\"/>           <result column=\"loc\" property=\"loc\"/>           <!-- 将一个部门中 的多个员工封装到集合中 -->           <collection property=\"empPos\" javaType=\"list\" ofType=\"EmpPo\">               <id property=\"empno\" column=\"empno\"/>             <result property=\"ename\"  column=\"ename\"/>             <result property=\"job\"  column=\"job\"/>             <result property=\"mgr\"  column=\"mgr\"/>             <result property=\"hiredate\"  column=\"hiredate\"/>             <result property=\"sal\"  column=\"sal\"/>             <result property=\"comm\"  column=\"comm\"/>           </collection>   </resultMap>   <select id=\"findById\" parameterType=\"int\" resultMap=\"deptMap\">           SELECT            e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno,d.DNAME,d.LOC         FROM            dept d            JOIN emp e ON d.deptno = e.deptno         WHERE            d.deptno = #{deptno}   </select>   </mapper>\n在写完xml映射文件之后，需要在全局配置文件mybatis-config.xml文件中添加映射文件信息\n    <!-- 将我们写好的sql映射文件一定要注册到全局配置文件中 -->    <mappers>        <!-- 利用package标签可以直接把整个包的 xml配置文件都导入，这块是导入数据库表与java Po类对应的配置文件 -->        <mapper resource=\"com/company/project/mapper/EmpMapper.xml\"/>        <mapper resource=\"com/company/project/mapper/DeptMapper.xml\"/>    </mappers>\n5、测试类EmpTest.java\npackage com.company.project.test;import java.util.List;import org.apache.ibatis.session.SqlSession;import com.company.project.Po.EmpPo;import com.company.project.dao.EmpDao;import com.company.project.util.MyBatisUtil;import junit.framework.TestCase;public class EmpTest extends TestCase {    public void testFindById() {        SqlSession sqlSession = MyBatisUtil.getSqlSession();        EmpDao empDao = sqlSession.getMapper(EmpDao.class);        EmpPo empPo = empDao.findById(7369);        System.out.println(empPo);    }}\nDeptTest.java\npackage com.company.project.test;import java.util.List;import org.apache.ibatis.session.SqlSession;import com.company.project.Po.DeptPo;import com.company.project.Po.EmpPo;import com.company.project.dao.DeptDao;import com.company.project.dao.EmpDao;import com.company.project.util.MyBatisUtil;import junit.framework.TestCase;public class DeptTest extends TestCase {    public void testFindById() {        try {            SqlSession sqlSession = MyBatisUtil.getSqlSession();            DeptDao deptDao = sqlSession.getMapper(DeptDao.class);            DeptPo deptPo = deptDao.findById(20);            System.out.println(deptPo);        }catch (Exception e) {            e.printStackTrace();        }finally {            MyBatisUtil.closeSession();        }    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (108, '06. mybatis 延迟加载', 8, '\n当使用多表联合查询的时候，mybatis会根据需要查询的信息，判断是否可以开启延迟加载，来提高查询效率。\n\n## 1、什么是延迟加载？\n\n延迟加载其实就是将数据加载时机推迟，比如推迟嵌套查询的执行时机。在Mybatis中经常用到关联查询，但是并不是任何时候都需要立即返回关联查询结果。比如查询订单信息，并不一定需要及时返回订单对应的产品信息，查询商品分类信息并不一定要及时返回该类别下有哪些产品，这种情况一下需要一种机制，当需要查看时，再执行查询，返回需要的结果集，这种需求在Mybatis中可以使用延迟加载机制来实现。延迟加载可以实现先查询主表，按需实时做关联查询，返回关联表结果集，一定程度上提高了效率。\n\n**简而言之：**\n\n多表联合查询，根据你需要的结果信息，如果只是想要表1 的信息，那么表2 的查询sql语句就会先不执行。\n\n## 2、启用延迟加载\n\nMybatis配置文件中通过两个属性lazyLoadingEnabled和aggressiveLazyLoading来控制延迟加载和按需加载。\n\nlazyLoadingEnabled：是否启用延迟加载，mybatis默认为false，不启用延迟加载。lazyLoadingEnabled属性控制全局是否使用延迟加载，特殊关联关系也可以通过嵌套查询中fetchType属性单独配置（fetchType属性值lazy或者eager）。\n\naggressiveLazyLoading：是否按需加载属性，默认值false，lazyLoadingEnabled属性启用时只要加载对象，就会加载该对象的所有属性；关闭该属性则会按需加载，即使用到某关联属性时，实时执行嵌套查询加载该属性。\n\n## 3、xml映射的建立\n\n**EmpMapper.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n    \n<!--	\n	namespace 指向对应接口的类路径	\n -->    \n\n<mapper namespace=\"com.company.project.dao.EmpDao\">\n	<!-- 把重复的sql代码可以提炼出来，通过定义别名把sql列名和java属性对应 -->\n	<sql id=\"selectResult\">\n		e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno,d.DNAME,d.LOC \n	</sql>\n	\n	\n	<!-- 关闭延迟加载 -->\n	<resultMap type=\"EmpPo\" id=\"EmpResult1\">\n		<id property=\"empno\" column=\"empno\"/>\n	 	<result property=\"ename\"  column=\"ename\"/>\n	 	<result property=\"job\"  column=\"job\"/>\n	 	<result property=\"mgr\"  column=\"mgr\"/>\n	 	<result property=\"hiredate\"  column=\"hiredate\"/>\n	 	<result property=\"sal\"  column=\"sal\"/>\n	 	<result property=\"comm\"  column=\"comm\"/>\n	 	<!-- \n	 		fetchType属性：lazy 开启延迟加载；eager 关闭延迟加载      \n	 		-->\n	 	<association property=\"deptPo\" javaType=\"DeptPo\" fetchType=\"eager\"\n	 	select=\"com.company.project.dao.EmpDao.findDeptById\" column=\"deptno\">\n	 		\n	 	</association>\n	</resultMap>\n	\n	<!-- 开启延迟加载 -->\n	<resultMap type=\"EmpPo\" id=\"EmpResult2\">\n		<id property=\"empno\" column=\"empno\"/>\n	 	<result property=\"ename\"  column=\"ename\"/>\n	 	<result property=\"job\"  column=\"job\"/>\n	 	<result property=\"mgr\"  column=\"mgr\"/>\n	 	<result property=\"hiredate\"  column=\"hiredate\"/>\n	 	<result property=\"sal\"  column=\"sal\"/>\n	 	<result property=\"comm\"  column=\"comm\"/>\n	 	<!-- \n	 		fetchType属性：lazy 开启延迟加载；eager 关闭延迟加载      \n	 		-->\n	 	<association property=\"deptPo\" javaType=\"DeptPo\" fetchType=\"lazy\"\n	 	select=\"com.company.project.dao.EmpDao.findDeptById\" column=\"deptno\">\n	 		\n	 	</association>\n	</resultMap>\n	\n	<!-- \n	非延迟加载：直接将两个关联表的数据全部查询出来\n	延迟加载（懒加载）：使用某一个数据，才将其查询出来 \n	-->\n	<select id=\"findById1\" parameterType=\"int\" resultMap=\"EmpResult1\">\n		select\n			e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno\n		from \n			emp e\n		where e.empno = #{empno}\n	</select>\n	\n	<select id=\"findById2\" parameterType=\"int\" resultMap=\"EmpResult2\">\n		select\n			e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno\n		from \n			emp e\n		where e.empno = #{empno}\n	</select>\n\n</mapper>\n```\n\n\n\n## 4、测试\n\n**EmpTest.java**\n\n```java\npackage com.company.project.test;\n\nimport java.util.List;\n\nimport org.apache.ibatis.session.SqlSession;\n\nimport com.company.project.Po.EmpPo;\nimport com.company.project.dao.EmpDao;\nimport com.company.project.util.MyBatisUtil;\n\nimport junit.framework.TestCase;\n\npublic class EmpTest extends TestCase {\n\n		//没有开启延迟加载，一次查询会把两个sql语句全部运行\n		public void testFindById1() {\n		try {\n			SqlSession sqlSession = MyBatisUtil.getSqlSession();\n			EmpDao empDao = sqlSession.getMapper(EmpDao.class);\n			\n			EmpPo empPo = empDao.findById3(7369);\n			\n			System.out.println(empPo.getEname());\n			//当用到员工表的部门时，才会执行查询dept的sql语句\n			System.out.println(empPo.getDeptPo().getDname());\n		} catch (Exception e) {\n			e.printStackTrace();\n		} finally {\n			MyBatisUtil.closeSession();\n		}\n	}\n	\n	//开启延迟加载，会根据需要的结果数据来进行sql语句，如下：第一次只查询了emp表\n	public void testFindById2() {\n		try {\n			SqlSession sqlSession = MyBatisUtil.getSqlSession();\n			EmpDao empDao = sqlSession.getMapper(EmpDao.class);\n			\n			EmpPo empPo = empDao.findById3(7369);\n			//只查询emp表\n			System.out.println(empPo.getEname());\n			//当用到员工表的部门时，才会执行查询dept的sql语句\n			System.out.println(empPo.getDeptPo().getDname());\n		} catch (Exception e) {\n			e.printStackTrace();\n		} finally {\n			MyBatisUtil.closeSession();\n		}\n	}\n}\n```\n\n\n\n结果：\n\n```java\n//没有开启延迟加载，testFindById1()的运行结果\n[DEBUG] 2020-06-22 19:58:59,893 ==>  Preparing: select e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno from emp e where e.empno = ? \n[DEBUG] 2020-06-22 19:58:59,930 ==> Parameters: 7369(Integer)\n[DEBUG] 2020-06-22 19:58:59,957 ====>  Preparing: select deptno,dname,loc from dept where deptno = ? \n[DEBUG] 2020-06-22 19:58:59,958 ====> Parameters: 20(Integer)\n[DEBUG] 2020-06-22 19:58:59,960 <====      Total: 1\n[DEBUG] 2020-06-22 19:58:59,962 <==      Total: 1\nSMITH\nRESEARCH\n\n\n//开启延迟加载，testFindById2()的运行结果\n[DEBUG] 2020-06-22 19:57:36,539 ==>  Preparing: select e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno from emp e where e.empno = ? \n[DEBUG] 2020-06-22 19:57:36,570 ==> Parameters: 7369(Integer)\n[DEBUG] 2020-06-22 19:57:36,627 <==      Total: 1\nSMITH\n[DEBUG] 2020-06-22 19:57:36,631 ==>  Preparing: select deptno,dname,loc from dept where deptno = ? \n[DEBUG] 2020-06-22 19:57:36,632 ==> Parameters: 20(Integer)\n[DEBUG] 2020-06-22 19:57:36,634 <==      Total: 1\nRESEARCH\n```\n\n根据结果就可以开出开启延迟加载的作用，若开启，会根据需求来判断执行的sql语句，若不开启，则执行所有的sql语句。', 0, 0, '2020-08-07 00:39:36', 2, 0, 1, '当使用多表联合查询的时候，mybatis会根据需要查询的信息，判断是否可以开启延迟加载，来提高查询效率。\n1、什么是延迟加载？延迟加载其实就是将数据加载时机推迟，比如推迟嵌套查询的执行时机。在Mybatis中经常用到关联查询，但是并不是任何时候都需要立即返回关联查询结果。比如查询订单信息，并不一定需要及时返回订单对应的产品信息，查询商品分类信息并不一定要及时返回该类别下有哪些产品，这种情况一下需要一种机制，当需要查看时，再执行查询，返回需要的结果集，这种需求在Mybatis中可以使用延迟加载机制来实现。延迟加载可以实现先查询主表，按需实时做关联查询，返回关联表结果集，一定程度上提高了效率。\n简而言之：\n多表联合查询，根据你需要的结果信息，如果只是想要表1 的信息，那么表2 的查询sql语句就会先不执行。\n2、启用延迟加载Mybatis配置文件中通过两个属性lazyLoadingEnabled和aggressiveLazyLoading来控制延迟加载和按需加载。\nlazyLoadingEnabled：是否启用延迟加载，mybatis默认为false，不启用延迟加载。lazyLoadingEnabled属性控制全局是否使用延迟加载，特殊关联关系也可以通过嵌套查询中fetchType属性单独配置（fetchType属性值lazy或者eager）。\naggressiveLazyLoading：是否按需加载属性，默认值false，lazyLoadingEnabled属性启用时只要加载对象，就会加载该对象的所有属性；关闭该属性则会按需加载，即使用到某关联属性时，实时执行嵌套查询加载该属性。\n3、xml映射的建立EmpMapper.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE mapper    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"><!--        namespace 指向对应接口的类路径     -->    <mapper namespace=\"com.company.project.dao.EmpDao\">    <!-- 把重复的sql代码可以提炼出来，通过定义别名把sql列名和java属性对应 -->    <sql id=\"selectResult\">        e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno,d.DNAME,d.LOC     </sql>    <!-- 关闭延迟加载 -->    <resultMap type=\"EmpPo\" id=\"EmpResult1\">        <id property=\"empno\" column=\"empno\"/>         <result property=\"ename\"  column=\"ename\"/>         <result property=\"job\"  column=\"job\"/>         <result property=\"mgr\"  column=\"mgr\"/>         <result property=\"hiredate\"  column=\"hiredate\"/>         <result property=\"sal\"  column=\"sal\"/>         <result property=\"comm\"  column=\"comm\"/>         <!--              fetchType属性：lazy 开启延迟加载；eager 关闭延迟加载                   -->         <association property=\"deptPo\" javaType=\"DeptPo\" fetchType=\"eager\"         select=\"com.company.project.dao.EmpDao.findDeptById\" column=\"deptno\">         </association>    </resultMap>    <!-- 开启延迟加载 -->    <resultMap type=\"EmpPo\" id=\"EmpResult2\">        <id property=\"empno\" column=\"empno\"/>         <result property=\"ename\"  column=\"ename\"/>         <result property=\"job\"  column=\"job\"/>         <result property=\"mgr\"  column=\"mgr\"/>         <result property=\"hiredate\"  column=\"hiredate\"/>         <result property=\"sal\"  column=\"sal\"/>         <result property=\"comm\"  column=\"comm\"/>         <!--              fetchType属性：lazy 开启延迟加载；eager 关闭延迟加载                   -->         <association property=\"deptPo\" javaType=\"DeptPo\" fetchType=\"lazy\"         select=\"com.company.project.dao.EmpDao.findDeptById\" column=\"deptno\">         </association>    </resultMap>    <!--     非延迟加载：直接将两个关联表的数据全部查询出来    延迟加载（懒加载）：使用某一个数据，才将其查询出来     -->    <select id=\"findById1\" parameterType=\"int\" resultMap=\"EmpResult1\">        select            e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno        from             emp e        where e.empno = #{empno}    </select>    <select id=\"findById2\" parameterType=\"int\" resultMap=\"EmpResult2\">        select            e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno        from             emp e        where e.empno = #{empno}    </select></mapper>\n4、测试EmpTest.java\npackage com.company.project.test;import java.util.List;import org.apache.ibatis.session.SqlSession;import com.company.project.Po.EmpPo;import com.company.project.dao.EmpDao;import com.company.project.util.MyBatisUtil;import junit.framework.TestCase;public class EmpTest extends TestCase {        //没有开启延迟加载，一次查询会把两个sql语句全部运行        public void testFindById1() {        try {            SqlSession sqlSession = MyBatisUtil.getSqlSession();            EmpDao empDao = sqlSession.getMapper(EmpDao.class);            EmpPo empPo = empDao.findById3(7369);            System.out.println(empPo.getEname());            //当用到员工表的部门时，才会执行查询dept的sql语句            System.out.println(empPo.getDeptPo().getDname());        } catch (Exception e) {            e.printStackTrace();        } finally {            MyBatisUtil.closeSession();        }    }    //开启延迟加载，会根据需要的结果数据来进行sql语句，如下：第一次只查询了emp表    public void testFindById2() {        try {            SqlSession sqlSession = MyBatisUtil.getSqlSession();            EmpDao empDao = sqlSession.getMapper(EmpDao.class);            EmpPo empPo = empDao.findById3(7369);            //只查询emp表            System.out.println(empPo.getEname());            //当用到员工表的部门时，才会执行查询dept的sql语句            System.out.println(empPo.getDeptPo().getDname());        } catch (Exception e) {            e.printStackTrace();        } finally {            MyBatisUtil.closeSession();        }    }}\n结果：\n//没有开启延迟加载，testFindById1()的运行结果[DEBUG] 2020-06-22 19:58:59,893 ==>  Preparing: select e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno from emp e where e.empno = ? [DEBUG] 2020-06-22 19:58:59,930 ==> Parameters: 7369(Integer)[DEBUG] 2020-06-22 19:58:59,957 ====>  Preparing: select deptno,dname,loc from dept where deptno = ? [DEBUG] 2020-06-22 19:58:59,958 ====> Parameters: 20(Integer)[DEBUG] 2020-06-22 19:58:59,960 <====      Total: 1[DEBUG] 2020-06-22 19:58:59,962 <==      Total: 1SMITHRESEARCH//开启延迟加载，testFindById2()的运行结果[DEBUG] 2020-06-22 19:57:36,539 ==>  Preparing: select e.empno,e.ename,e.job,e.mgr,e.hiredate,e.sal,e.comm,e.deptno from emp e where e.empno = ? [DEBUG] 2020-06-22 19:57:36,570 ==> Parameters: 7369(Integer)[DEBUG] 2020-06-22 19:57:36,627 <==      Total: 1SMITH[DEBUG] 2020-06-22 19:57:36,631 ==>  Preparing: select deptno,dname,loc from dept where deptno = ? [DEBUG] 2020-06-22 19:57:36,632 ==> Parameters: 20(Integer)[DEBUG] 2020-06-22 19:57:36,634 <==      Total: 1RESEARCH\n根据结果就可以开出开启延迟加载的作用，若开启，会根据需求来判断执行的sql语句，若不开启，则执行所有的sql语句。\n', 0, 1);
INSERT INTO `t_article` VALUES (109, '07. mybatis 动态 sql', 8, '\nMyBatis 的一个强大的特性之一通常是它的动态 SQL 能力。 如果你有使用JDBC 或其他 相似框架的经验,你就明白条件地串联 SQL 字符串在一起是多么的痛苦,确保不能忘了空 格或在列表的最后省略逗号。动态 SQL 可以彻底处理这种痛苦。\n\n\n\n常用的动态sql标签\n\n- if\n- where\n- trim\n- set\n- choose（when，otherwise）\n- foreach\n\n\n\n## 1、if元素\n\nif标签可以对传入的条件进行判断\n\n如下案例：判断是否传入id，若传入则id查询，若不传入则全部查询。\n\n```xml\n	<select id=\"findByTerm\" parameterType=\"map\" resultMap=\"userResult\">\n		select \n			id,user_name,password,reg_time \n		from \n			t_user \n        <if test=\"id!=null &amp;&amp; id!=\'\' &amp;&amp; id !=0\">\n            where id=#{id}\n        </if>\n\n	</select>\n```\n\n测试：\n\n```java\n	public void testFindByTerm() {\n		SqlSession sqlSession = MyBatisUtil.getSqlSession();\n		UserDao userDao = sqlSession.getMapper(UserDao.class);\n		Map<String, Object> map = new HashMap<String, Object>();\n		map.put(\"id\", \"4\");\n		List<UserPo> userPos = userDao.findByTerm(map);\n		logger.debug(userPos.toString());\n	}\n```\n\n\n\n## 2、where元素\n\n对于查询条件个数不确定的情况，可使用\\<where>元素。\n\n```xml\n	<select id=\"findByTerm\" parameterType=\"map\" resultMap=\"userResult\">\n		select \n			id,user_name,password,reg_time \n		from \n			t_user \n		<where >\n			<if test=\"id!=null &amp;&amp; id!=\'\' &amp;&amp; id !=0\">\n				id=#{id}\n			</if>\n			<if test=\"userName!=null &amp;&amp; userName!=\'\' \">\n				and user_name=#{userName}\n			</if>\n		</where>\n	</select>\n```\n\n\\<where>元素会进行判断，如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头，它会剔除掉AND或OR。\n\n测试：\n\n```java\n	public void testFindByTerm() {\n		SqlSession sqlSession = MyBatisUtil.getSqlSession();\n		UserDao userDao = sqlSession.getMapper(UserDao.class);\n		Map<String, Object> map = new HashMap<String, Object>();\n		map.put(\"id\", \"4\");\n		map.put(\"userName\", \"张三\");\n		List<UserPo> userPos = userDao.findByTerm(map);\n		logger.debug(userPos.toString());\n	}\n```\n\n\n\n## 3、trim元素\n\nwhere标签，其实用trim 也可以表示,当WHERE后紧随AND或则OR的时候，就去除AND或者OR。prefix前缀，prefixOverrides覆盖首部指定内容\n\n```xml\n	<select id=\"findByTerm\" parameterType=\"map\" resultMap=\"userResult\">\n		select \n			id,user_name,password,reg_time \n		from \n			t_user \n		<trim prefix=\"where\" prefixOverrides=\"and|or\" >\n			<if test=\"id!=null &amp;&amp; id!=\'\' &amp;&amp; id !=0\">\n				id=#{id}\n			</if>\n			<if test=\"userName!=null &amp;&amp; userName!=\'\' \">\n				and user_name=#{userName}\n			</if>\n		</trim>\n	</select>\n```\n\n测试：\n\n```java\n	public void testFindByTerm() {\n		SqlSession sqlSession = MyBatisUtil.getSqlSession();\n		UserDao userDao = sqlSession.getMapper(UserDao.class);\n		Map<String, Object> map = new HashMap<String, Object>();\n		map.put(\"id\", \"4\");\n		map.put(\"userName\", \"张三\");\n		List<UserPo> userPos = userDao.findByTerm(map);\n		logger.debug(userPos.toString());\n	}\n```\n\n\n\n## 4、set元素\n\nset标签，可以在需要更新的语句中，通过添加判断条件更新需要的指定列。\n\n同时也可以把最后的一个逗号去掉。\n\n```xml\n	<update id=\"updatePortion\" parameterType=\"UserPo\" >\n		update t_user \n			<set>\n				<if test=\"userName != null &amp;&amp; userName != \'\'\">user_name = #{userName},</if>\n				<if test=\"password != null &amp;&amp; password != \'\'\">password = #{password},</if>\n				<if test=\"regTime != null &amp;&amp; regTime != \'\'\">reg_time = #{regTime}</if>\n			</set>\n			where id = #{id}\n	</update>\n```\n\n\n\n## 5、foreach元素\n\nforeach标签，可以循环遍历指定的数组或者集合。\n\n如下案例：批量删除\n\n```xml\n	<delete id=\"batchDelete\">\n		delete from t_user\n			where id in\n			<foreach collection=\"array\" item=\"id\" open=\"(\" separator=\",\" close=\")\">\n				#{id}\n			</foreach>\n	</delete>\n```\n\n测试：\n\n```java\n	public void testBatchDelete() {\n		SqlSession sqlSession = null;\n		try {\n			sqlSession = MyBatisUtil.getSqlSession();\n			UserDao userDao = sqlSession.getMapper(UserDao.class);\n			String id=\"4,6,\";\n			String[] idList = id.split(\",\"); \n			\n			userDao.batchDelete(idList);\n			sqlSession.close();\n		} catch (Exception e) {\n			// TODO: handle exception\n		} finally {\n			sqlSession.close();\n		}\n	}\n```\n\n\n\n\n\n## 6、XML中的特殊字符\n\n如果 mybatis 使用 XML 配置，不可避免会遇到对一些XML来说的特殊字符。\n\n| 字符 | 对应的XML | 含义   |\n| ---- | --------- | ------ |\n| <    | \\&lt;     | 小于   |\n| >    | \\&rt;     | 大于   |\n| &    | \\&amp;    | 和     |\n| \'    | \\&apos;   | 单引号 |\n| \"    | \\&quot;   | 双引号 |\n\n', 0, 0, '2020-08-07 00:40:19', 2, 0, 1, 'MyBatis 的一个强大的特性之一通常是它的动态 SQL 能力。 如果你有使用JDBC 或其他 相似框架的经验,你就明白条件地串联 SQL 字符串在一起是多么的痛苦,确保不能忘了空 格或在列表的最后省略逗号。动态 SQL 可以彻底处理这种痛苦。\n常用的动态sql标签\n\nifwheretrimsetchoose（when，otherwise）foreach\n1、if元素if标签可以对传入的条件进行判断\n如下案例：判断是否传入id，若传入则id查询，若不传入则全部查询。\n    <select id=\"findByTerm\" parameterType=\"map\" resultMap=\"userResult\">        select             id,user_name,password,reg_time         from             t_user         <if test=\"id!=null &amp;&amp; id!=\'\' &amp;&amp; id !=0\">            where id=#{id}        </if>    </select>\n测试：\n    public void testFindByTerm() {        SqlSession sqlSession = MyBatisUtil.getSqlSession();        UserDao userDao = sqlSession.getMapper(UserDao.class);        Map<String, Object> map = new HashMap<String, Object>();        map.put(\"id\", \"4\");        List<UserPo> userPos = userDao.findByTerm(map);        logger.debug(userPos.toString());    }\n2、where元素对于查询条件个数不确定的情况，可使用\\<where>元素。\n    <select id=\"findByTerm\" parameterType=\"map\" resultMap=\"userResult\">        select             id,user_name,password,reg_time         from             t_user         <where >            <if test=\"id!=null &amp;&amp; id!=\'\' &amp;&amp; id !=0\">                id=#{id}            </if>            <if test=\"userName!=null &amp;&amp; userName!=\'\' \">                and user_name=#{userName}            </if>        </where>    </select>\n\\<where>元素会进行判断，如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头，它会剔除掉AND或OR。\n测试：\n    public void testFindByTerm() {        SqlSession sqlSession = MyBatisUtil.getSqlSession();        UserDao userDao = sqlSession.getMapper(UserDao.class);        Map<String, Object> map = new HashMap<String, Object>();        map.put(\"id\", \"4\");        map.put(\"userName\", \"张三\");        List<UserPo> userPos = userDao.findByTerm(map);        logger.debug(userPos.toString());    }\n3、trim元素where标签，其实用trim 也可以表示,当WHERE后紧随AND或则OR的时候，就去除AND或者OR。prefix前缀，prefixOverrides覆盖首部指定内容\n    <select id=\"findByTerm\" parameterType=\"map\" resultMap=\"userResult\">        select             id,user_name,password,reg_time         from             t_user         <trim prefix=\"where\" prefixOverrides=\"and|or\" >            <if test=\"id!=null &amp;&amp; id!=\'\' &amp;&amp; id !=0\">                id=#{id}            </if>            <if test=\"userName!=null &amp;&amp; userName!=\'\' \">                and user_name=#{userName}            </if>        </trim>    </select>\n测试：\n    public void testFindByTerm() {        SqlSession sqlSession = MyBatisUtil.getSqlSession();        UserDao userDao = sqlSession.getMapper(UserDao.class);        Map<String, Object> map = new HashMap<String, Object>();        map.put(\"id\", \"4\");        map.put(\"userName\", \"张三\");        List<UserPo> userPos = userDao.findByTerm(map);        logger.debug(userPos.toString());    }\n4、set元素set标签，可以在需要更新的语句中，通过添加判断条件更新需要的指定列。\n同时也可以把最后的一个逗号去掉。\n    <update id=\"updatePortion\" parameterType=\"UserPo\" >        update t_user             <set>                <if test=\"userName != null &amp;&amp; userName != \'\'\">user_name = #{userName},</if>                <if test=\"password != null &amp;&amp; password != \'\'\">password = #{password},</if>                <if test=\"regTime != null &amp;&amp; regTime != \'\'\">reg_time = #{regTime}</if>            </set>            where id = #{id}    </update>\n5、foreach元素foreach标签，可以循环遍历指定的数组或者集合。\n如下案例：批量删除\n    <delete id=\"batchDelete\">        delete from t_user            where id in            <foreach collection=\"array\" item=\"id\" open=\"(\" separator=\",\" close=\")\">                #{id}            </foreach>    </delete>\n测试：\n    public void testBatchDelete() {        SqlSession sqlSession = null;        try {            sqlSession = MyBatisUtil.getSqlSession();            UserDao userDao = sqlSession.getMapper(UserDao.class);            String id=\"4,6,\";            String[] idList = id.split(\",\");             userDao.batchDelete(idList);            sqlSession.close();        } catch (Exception e) {            // TODO: handle exception        } finally {            sqlSession.close();        }    }\n6、XML中的特殊字符如果 mybatis 使用 XML 配置，不可避免会遇到对一些XML来说的特殊字符。\n\n\n\n字符\n对应的XML\n含义\n\n\n\n\n<\n\\<\n小于\n\n\n>\n\\&rt;\n大于\n\n\n&\n\\&\n和\n\n\n‘\n\\\'\n单引号\n\n\n“\n\\\"\n双引号\n\n\n\n', 0, 1);
INSERT INTO `t_article` VALUES (110, '08. 一级缓存和二级缓存', 8, '\n## 1、一级缓存\n\nMybatis的一级缓存是指Session缓存。一级缓存的作用域默认是一个SqlSession。Mybatis默认开启一级缓存。\n也就是在同一个SqlSession中，执行相同的查询SQL，第一次会去数据库进行查询，并写到缓存中；\n第二次以后是直接去缓存中取。\n当执行SQL查询中间发生了增删改的操作，MyBatis会把SqlSession的缓存清空。\n\n一级缓存的范围有SESSION和STATEMENT两种，默认是SESSION，如果不想使用一级缓存，可以把一级缓存的范围指定为STATEMENT，这样每次执行完一个Mapper中的语句后都会将一级缓存清除。\n如果需要更改一级缓存的范围，可以在Mybatis的配置文件中，在下通过localCacheScope指定。\n\n```xml\n<setting name=\"localCacheScope\" value=\"STATEMENT\"/>\n```\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps1.jpg)\n\n### 一级缓存的生命周期\n\n　　a、MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。\n\n　　b、如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。\n\n　　c、如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。\n\n　　d、SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用\n\n\n\n### 示例：\n\nUserMapper.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n    \n<mapper namespace=\"com.company.project.dao.UserDao\">\n    \n	<sql id=\"selectResult\">\n		id,user_name,password,reg_time\n	</sql>	\n\n	 <resultMap type=\"UserPo\" id=\"userResult\">\n	 	<id property=\"id\" column=\"id\"/>\n	 	<result property=\"userName\"  column=\"user_name\"/>\n	 	<result property=\"password\"  column=\"password\"/>\n	 	<result property=\"regTime\"  column=\"reg_time\"/>\n	 </resultMap>\n	\n	<select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">\n		select \n			<include refid=\"selectResult\"></include>\n		from\n			t_user \n		where id = #{id}\n	</select>\n	\n</mapper>\n```\n\n测试类：\n\n\n\n```java\npackage com.company.project.test;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.log4j.Logger;\n\nimport com.company.project.Po.UserPo;\nimport com.company.project.dao.UserDao;\nimport com.company.project.util.MyBatisUtil;\nimport junit.framework.TestCase;\n\npublic class UserTest1 extends TestCase{\n	Logger logger = Logger.getLogger(UserTest1.class);\n	\n	public void testFindById() {\n		SqlSession sqlSession = null;\n		try {\n			sqlSession = MyBatisUtil.getSqlSession();\n			UserDao userDao = sqlSession.getMapper(UserDao.class);\n			UserPo userPo1 = userDao.findById(1);\n			logger.debug(userPo1);\n			//一级缓存，遇到相同的sql语句会把结果缓存在sqlSession中，\n			//除非数据库遇到了delete,update,insert，数据库数据发生了改变，一级缓存就会清除\n			//或者sqlSession调用了close()或者clearCache()方法，一级缓存也会清除\n			//sqlSession.clearCache();\n			UserPo userPo2 = userDao.findById(1);\n			logger.debug(userPo2);\n		}catch (Exception e) {\n			e.printStackTrace();\n		}finally {\n			sqlSession.close();\n		}	\n	}\n}\n```\n\n结果：\n\n```java\n[DEBUG] 2020-06-22 20:28:25,419 ==>  Preparing: select id,user_name,password,reg_time from t_user where id = ? \n[DEBUG] 2020-06-22 20:28:25,449 ==> Parameters: 1(Integer)\n[DEBUG] 2020-06-22 20:28:25,472 <==      Total: 1\n[DEBUG] 2020-06-22 20:28:25,475 UserPo [id=1, userName=张三, password=123, regTime=2020-06-18]\n[DEBUG] 2020-06-22 20:28:25,475 UserPo [id=1, userName=张三, password=123, regTime=2020-06-18]\n```\n\n根据结果：会发现开启一级缓存时，在一个sqlSession对象中，相同的sql语句，只会执行一次，然后还缓存下来，后面直接调用结果。\n\n但是，如果数据库遇到了delete,update,insert，数据库数据发生了改变，一级缓存就会清除，或者sqlSession调用了close()或者clearCache()方法，一级缓存也会清除。\n\n\n\n## 2、二级缓存\n\nMybatis的二级缓存是指mapper映射文件。二级缓存的作用域是同一个namespace下的mapper映射文件内容，多个SqlSession共享。Mybatis需要手动设置启动二级缓存。\n\n二级缓存是默认启用的(要生效需要对每个Mapper进行配置)，如想取消，则可以通过Mybatis配置文件中的元素下的子元素来指定cacheEnabled为false。\n\n```xml\n<settings>\n  <setting name=\"cacheEnabled\" value=\"false\" />\n</settings>\n```\n\n要使用二级缓存除了上面一个配置外，我们还需要在我们每个DAO对应的Mapper.xml文件中定义需要使用的cache。\n\n```xml\n<mapper namespace=\"com.company.project.dao.UserDao\">\n	...\n	<cache />\n	...\n</mapper>\n```\n\n### 二级缓存的原理：\n\n\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps2.jpg)\n\n示例：\n\nUserMapper.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n    \n<mapper namespace=\"com.company.project.dao.UserDao\">\n	<cache />\n\n	<sql id=\"selectResult\">\n		id,user_name,password,reg_time\n	</sql>	\n\n	 <resultMap type=\"UserPo\" id=\"userResult\">\n	 	<id property=\"id\" column=\"id\"/>\n	 	<result property=\"userName\"  column=\"user_name\"/>\n	 	<result property=\"password\"  column=\"password\"/>\n	 	<result property=\"regTime\"  column=\"reg_time\"/>\n	 </resultMap>\n	\n	<select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">\n		select \n			<include refid=\"selectResult\"></include>\n		from\n			t_user \n		where id = #{id}\n	</select>\n	\n</mapper>\n```\n\n\n\n测试：UserTest2.java\n\n```java\npackage com.company.project.test;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.log4j.Logger;\n\nimport com.company.project.Po.UserPo;\nimport com.company.project.dao.UserDao;\nimport com.company.project.util.MyBatisUtil;\n\nimport junit.framework.TestCase;\n\npublic class UserTest2 extends TestCase {\n	Logger logger = Logger.getLogger(UserTest1.class);\n	\n	\n	public void testFindById() {\n		SqlSession sqlSession1 = null;\n		SqlSession sqlSession2 = null;\n		try {\n			sqlSession1 = MyBatisUtil.getSqlSession();\n			UserDao userDao1 = sqlSession1.getMapper(UserDao.class);\n			UserPo userPo1 = userDao1.findById(1);\n			logger.debug(userPo1);\n			\n			sqlSession2 = MyBatisUtil.getSqlSession();\n			UserDao userDao2 = sqlSession2.getMapper(UserDao.class);\n			UserPo userPo2 = userDao2.findById(1);\n			logger.debug(userPo2);\n		}catch (Exception e) {\n			e.printStackTrace();\n		}finally {\n			sqlSession1.close();\n			sqlSession2.close();\n		}\n	}\n}\n```\n\n\n\n结果：\n\n```java\n[DEBUG] 2020-06-22 20:37:50,141 ==>  Preparing: select id,user_name,password,reg_time from t_user where id = ? \n[DEBUG] 2020-06-22 20:37:50,142 ==> Parameters: 1(Integer)\n[DEBUG] 2020-06-22 20:37:50,143 <==      Total: 1\n[DEBUG] 2020-06-22 20:37:50,144 UserPo [id=1, userName=张三, password=123, regTime=2020-06-18]\n```\n\n通过观察，我们发现开启了二级缓存，在整个应用中，两次会话，调用同一句sql，sql只执行了一次。', 0, 0, '2020-08-07 00:40:54', 2, 0, 1, '1、一级缓存Mybatis的一级缓存是指Session缓存。一级缓存的作用域默认是一个SqlSession。Mybatis默认开启一级缓存。也就是在同一个SqlSession中，执行相同的查询SQL，第一次会去数据库进行查询，并写到缓存中；第二次以后是直接去缓存中取。当执行SQL查询中间发生了增删改的操作，MyBatis会把SqlSession的缓存清空。\n一级缓存的范围有SESSION和STATEMENT两种，默认是SESSION，如果不想使用一级缓存，可以把一级缓存的范围指定为STATEMENT，这样每次执行完一个Mapper中的语句后都会将一级缓存清除。如果需要更改一级缓存的范围，可以在Mybatis的配置文件中，在下通过localCacheScope指定。\n<setting name=\"localCacheScope\" value=\"STATEMENT\"/>\n\n一级缓存的生命周期　　a、MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。\n　　b、如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。\n　　c、如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。\n　　d、SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用\n示例：UserMapper.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE mapper    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"><mapper namespace=\"com.company.project.dao.UserDao\">    <sql id=\"selectResult\">        id,user_name,password,reg_time    </sql>         <resultMap type=\"UserPo\" id=\"userResult\">         <id property=\"id\" column=\"id\"/>         <result property=\"userName\"  column=\"user_name\"/>         <result property=\"password\"  column=\"password\"/>         <result property=\"regTime\"  column=\"reg_time\"/>     </resultMap>    <select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">        select             <include refid=\"selectResult\"></include>        from            t_user         where id = #{id}    </select></mapper>\n测试类：\npackage com.company.project.test;import org.apache.ibatis.session.SqlSession;import org.apache.log4j.Logger;import com.company.project.Po.UserPo;import com.company.project.dao.UserDao;import com.company.project.util.MyBatisUtil;import junit.framework.TestCase;public class UserTest1 extends TestCase{    Logger logger = Logger.getLogger(UserTest1.class);    public void testFindById() {        SqlSession sqlSession = null;        try {            sqlSession = MyBatisUtil.getSqlSession();            UserDao userDao = sqlSession.getMapper(UserDao.class);            UserPo userPo1 = userDao.findById(1);            logger.debug(userPo1);            //一级缓存，遇到相同的sql语句会把结果缓存在sqlSession中，            //除非数据库遇到了delete,update,insert，数据库数据发生了改变，一级缓存就会清除            //或者sqlSession调用了close()或者clearCache()方法，一级缓存也会清除            //sqlSession.clearCache();            UserPo userPo2 = userDao.findById(1);            logger.debug(userPo2);        }catch (Exception e) {            e.printStackTrace();        }finally {            sqlSession.close();        }        }}\n结果：\n[DEBUG] 2020-06-22 20:28:25,419 ==>  Preparing: select id,user_name,password,reg_time from t_user where id = ? [DEBUG] 2020-06-22 20:28:25,449 ==> Parameters: 1(Integer)[DEBUG] 2020-06-22 20:28:25,472 <==      Total: 1[DEBUG] 2020-06-22 20:28:25,475 UserPo [id=1, userName=张三, password=123, regTime=2020-06-18][DEBUG] 2020-06-22 20:28:25,475 UserPo [id=1, userName=张三, password=123, regTime=2020-06-18]\n根据结果：会发现开启一级缓存时，在一个sqlSession对象中，相同的sql语句，只会执行一次，然后还缓存下来，后面直接调用结果。\n但是，如果数据库遇到了delete,update,insert，数据库数据发生了改变，一级缓存就会清除，或者sqlSession调用了close()或者clearCache()方法，一级缓存也会清除。\n2、二级缓存Mybatis的二级缓存是指mapper映射文件。二级缓存的作用域是同一个namespace下的mapper映射文件内容，多个SqlSession共享。Mybatis需要手动设置启动二级缓存。\n二级缓存是默认启用的(要生效需要对每个Mapper进行配置)，如想取消，则可以通过Mybatis配置文件中的元素下的子元素来指定cacheEnabled为false。\n<settings>  <setting name=\"cacheEnabled\" value=\"false\" /></settings>\n要使用二级缓存除了上面一个配置外，我们还需要在我们每个DAO对应的Mapper.xml文件中定义需要使用的cache。\n<mapper namespace=\"com.company.project.dao.UserDao\">    ...    <cache />    ...</mapper>\n二级缓存的原理：\n示例：\nUserMapper.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE mapper    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"><mapper namespace=\"com.company.project.dao.UserDao\">    <cache />    <sql id=\"selectResult\">        id,user_name,password,reg_time    </sql>         <resultMap type=\"UserPo\" id=\"userResult\">         <id property=\"id\" column=\"id\"/>         <result property=\"userName\"  column=\"user_name\"/>         <result property=\"password\"  column=\"password\"/>         <result property=\"regTime\"  column=\"reg_time\"/>     </resultMap>    <select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">        select             <include refid=\"selectResult\"></include>        from            t_user         where id = #{id}    </select></mapper>\n测试：UserTest2.java\npackage com.company.project.test;import org.apache.ibatis.session.SqlSession;import org.apache.log4j.Logger;import com.company.project.Po.UserPo;import com.company.project.dao.UserDao;import com.company.project.util.MyBatisUtil;import junit.framework.TestCase;public class UserTest2 extends TestCase {    Logger logger = Logger.getLogger(UserTest1.class);    public void testFindById() {        SqlSession sqlSession1 = null;        SqlSession sqlSession2 = null;        try {            sqlSession1 = MyBatisUtil.getSqlSession();            UserDao userDao1 = sqlSession1.getMapper(UserDao.class);            UserPo userPo1 = userDao1.findById(1);            logger.debug(userPo1);            sqlSession2 = MyBatisUtil.getSqlSession();            UserDao userDao2 = sqlSession2.getMapper(UserDao.class);            UserPo userPo2 = userDao2.findById(1);            logger.debug(userPo2);        }catch (Exception e) {            e.printStackTrace();        }finally {            sqlSession1.close();            sqlSession2.close();        }    }}\n结果：\n[DEBUG] 2020-06-22 20:37:50,141 ==>  Preparing: select id,user_name,password,reg_time from t_user where id = ? [DEBUG] 2020-06-22 20:37:50,142 ==> Parameters: 1(Integer)[DEBUG] 2020-06-22 20:37:50,143 <==      Total: 1[DEBUG] 2020-06-22 20:37:50,144 UserPo [id=1, userName=张三, password=123, regTime=2020-06-18]\n通过观察，我们发现开启了二级缓存，在整个应用中，两次会话，调用同一句sql，sql只执行了一次。\n', 0, 1);
INSERT INTO `t_article` VALUES (111, '01. Spring框架概述', 8, '\n## 1、spring 概述\n\nSpring 是一个2003 年兴起的，开源的、轻量级的，非侵入式的一站式的框架。\n\n**轻量级：**核心包非常小\n\n非侵入式：也不代码不会出现框架代码\n\n一站式：提供控制层 SpringMVC ，提供数据访问层 jdbc，事务管理。\n\nSpring 为简化企业级（JavaEE）应用开发而生。\n\n\n\nSpring 是一个 设计层面的框架，他解决的业务逻辑层和其他各层松耦合问题，因此它将面向接口的\n\n编程思想贯彻在整个系统应用中。\n\n\n\n## 2、spring 的核心\n\n控制反转（IOC）和面向切面（AOP）\n\n它是一个**容器框架**，用来装javabean（java对象），中间层框架（万能胶）可以起一个连接作用，比如可以管理其他框架。\n\n将程序中用到的对象同意交给spring框架管理\n\n把控制生成对象的权利,反转给spring框架,\n\n依赖注入\n\n\n\n## 3、Spring 体系结构\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps2.jpg)\n\n\n\n## 4、Spring 项目的搭建\n\n（1）创建Maven 项目\n\n![image-20200623145840843](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200623145840843.png)\n\n![image-20200623145854727](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200623145854727.png)\n\n![image-20200623150005996](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200623150005996.png)\n\n![image-20200623150147767](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200623150147767.png)\n\n\n\n（2）Maven导入spring核心基础jar，在pom.xml文件中添加\n\n```xml\n  <dependencies>\n	  	<!-- spring-context -->\n	<dependency>\n	    <groupId>org.springframework</groupId>\n	    <artifactId>spring-context</artifactId>\n	    <version>5.2.2.RELEASE</version>\n	</dependency>\n  </dependencies>\n```\n\n（3）编写spring配置文件application.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<beans xmlns=\"http://www.springframework.org/schema/beans\" \n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n 	\n 	<!-- \n 		控制反转：IOC  将创建对象的权力，反转给spring框架\n 		id:生成对象的名称\n 		class:需要spring管理的类的地址（全类名）\n 	 -->\n 	<bean  id=\"user\" name=\"user1,user2\" class=\"com.company.springPro.bean.UserPo\"> </bean>\n	\n</beans>\n```\n\n（4）编写 UserPo 实体类\n\n```java\npackage com.company.springPro.bean;\n\npublic class UserPo {\n	private String name;\n	private int age;\n	\n	public UserPo() {\n		// TODO Auto-generated constructor stub\n	}\n\n	public String getName() {\n		return name;\n	}\n\n	public int getAge() {\n		return age;\n	}\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public void setAge(int age) {\n		this.age = age;\n	}\n\n	@Override\n	public String toString() {\n		return \"UserPo [name=\" + name + \", age=\" + age + \"]\";\n	}	\n}\n```\n\n（5）测试 Test.java\n\n```java\npackage com.company.springPro.test;\n\nimport org.springframework.context.ApplicationContext;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport com.company.springPro.bean.UserPo;\n\nimport junit.framework.TestCase;\n\npublic class Test extends TestCase{\n	public void testStart() {\n		\n		//启动spring 		加载spring的配置文件，创建一个ApplicationContext\n		ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"application.xml\");\n		\n		//参数user是在application.xml配置文件中bean对应的id\n		UserPo user = (UserPo)applicationContext.getBean(\"user\");\n		System.out.println(user);\n		UserPo user1 = (UserPo)applicationContext.getBean(\"user1\");\n		System.out.println(user1);\n		UserPo user2 = (UserPo)applicationContext.getBean(\"user2\");\n		System.out.println(user2);\n	}\n}\n```\n\n结果：\n\n```java\ncom.company.springPro.bean.UserPo@4e91d63f\ncom.company.springPro.bean.UserPo@4e91d63f\ncom.company.springPro.bean.UserPo@4e91d63f\n```\n\n根据结果，发现只创建了一次对象。原因是Bean配置中scope默认为singleton:单例的。\n\n\n\n## 5、IOC本质\n\n​		读作 “**反转控制**” (**Inverse of Control**)，更好理解，不是什么技术，而是一种**设计思想**，就是**将原本在程序中手动创建对象的控制权，交由Spring框架来管理。**\n\n正控：若要使用某个对象，需要自己去负责对象的创建\n\n反控：若要使用某个对象，**只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架。**\n\n\n\n简单一句话：**就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。**\n\n\n\n***原理：***\n\n​		Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。\n\n这个过程就叫控制反转 :\n\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 .\n\n反转 : 程序本身不创建对象 , 而变成被动的接收对象 .\n\n\n\n## 6、Spring配置\n\n### 6.1 Bean 配置\n\n（1）id：生成对象的名称\n\n（2）class：需要spring管理的类的地址（全类名）\n\n（3）name：相当于别名，可以为多个，中间逗号隔开\n\n（4）scope：控制生成对象的方式\n\n​		prototype: 原型的. 每次调用 getBean 方法都会返回一个新的 bean. 且在第一次调用 getBean 方法时才创建实例。\n\n​		singleton: 单例的. 每次调用 getBean 方法都会返回同一个 bean. 且在 IOC 容器初始化时即创建 bean 的实例. 默认值 singleton\n\n示例：\n\n```xml\n<bean  id=\"user\" name=\"user1,user2\" class=\"com.company.springPro.bean.UserPo\" scope=\"prototype\"> </bean>\n```\n\n\n\n## 6.2 import 导入其它配置文件\n\n```xml\n<!-- 导入其他spring配置文件 -->\n<import resource=\"bean.xml\"/>\n```\n\n\n\n## 7、依赖注入\n\n### 7.1 属性注入\n\nBean类：UserPo.java\n\n```java\npackage com.company.springPro.bean;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\npublic class UserPo {\n	private String name;\n	private int age;\n	private DeptPo dept;\n	private List list;\n	private Set set;\n	private Map map;\n	private Properties properties;\n	\n	public UserPo() {\n		// TODO Auto-generated constructor stub\n	}	\n\n	public UserPo(String name, int age, DeptPo dept) {\n		super();\n		this.name = name;\n		this.age = age;\n		this.dept = dept;\n	}\n\n	public String getName() {\n		return name;\n	}\n\n	public int getAge() {\n		return age;\n	}\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public void setAge(int age) {\n		this.age = age;\n	}\n\n	public DeptPo getDept() {\n		return dept;\n	}\n\n	public void setDept(DeptPo dept) {\n		this.dept = dept;\n	}	\n\n	public List getList() {\n		return list;\n	}\n\n	public Set getSet() {\n		return set;\n	}\n\n	public Properties getProperties() {\n		return properties;\n	}\n\n	public void setList(List list) {\n		this.list = list;\n	}\n\n	public void setSet(Set set) {\n		this.set = set;\n	}\n\n	public void setProperties(Properties properties) {\n		this.properties = properties;\n	}\n\n	public Map getMap() {\n		return map;\n	}\n\n	public void setMap(Map map) {\n		this.map = map;\n	}\n\n	@Override\n	public String toString() {\n		return \"UserPo [name=\" + name + \", age=\" + age + \", dept=\" + dept + \", list=\" + list + \", set=\" + set + \", map=\"\n				+ map + \", properties=\" + properties + \"]\";\n	}\n}\n```\n\n\n\napplication.xml\n\n```xml\n 	  <!-- 属性注入 -->\n 	  <bean id=\"user\" class=\"com.company.springPro.bean.UserPo\">\n 	  	<property name=\"age\" value=\"100\"/>\n 	  	<property name=\"name\" value=\"张三\" />\n 	  	<property name=\"properties\">\n 	  		<props>\n 	  			<prop key=\"p1\">dept</prop>\n 	  		</props>\n 	  	</property>\n 	  	<property name=\"list\">\n 	  		<list>\n 	  			<value>1</value>\n 	  			<value>2</value>\n 	  			<value>3</value>\n 	  		</list>\n 	  	</property>\n 	  	<property name=\"set\">\n 	  		<set>\n 	  			<value>4</value>\n 	  			<value>5</value>\n 	  			<value>6</value>\n 	  		</set>\n 	  	</property>\n 	  	<property name=\"map\">\n 	  		<map>\n 	  			<entry key=\"key1\" value=\"7\"></entry>\n 	  			<entry key=\"key2\" value=\"8\"></entry>\n 	  			<entry key=\"key3\" value-ref=\"dept\"></entry>\n 	  		</map>\n 	  	</property>\n 	  	\n 	  <bean id=\"dept\" class=\"com.company.springPro.bean.DeptPo\">\n 	  	<property name=\"num\" value=\"10\"></property>\n 	  </bean>\n```\n\n\n\n### 7.2 构造方法注入\n\n```xml\n 	  <!-- 构造方法注入 -->\n 	  <bean id=\"user2\" class=\"com.company.springPro.bean.UserPo\">\n 	  	<constructor-arg type=\"java.lang.String\" value=\"李四\" />\n 	  	<constructor-arg type=\"int\" value=\"18\" />\n 	  	<constructor-arg type=\"DeptPo\" ref=\"dept\" />\n 	  </bean>\n```\n\n', 0, 0, '2020-08-07 00:42:05', 2, 0, 1, '1、spring 概述Spring 是一个2003 年兴起的，开源的、轻量级的，非侵入式的一站式的框架。\n轻量级：核心包非常小\n非侵入式：也不代码不会出现框架代码\n一站式：提供控制层 SpringMVC ，提供数据访问层 jdbc，事务管理。\nSpring 为简化企业级（JavaEE）应用开发而生。\nSpring 是一个 设计层面的框架，他解决的业务逻辑层和其他各层松耦合问题，因此它将面向接口的\n编程思想贯彻在整个系统应用中。\n2、spring 的核心控制反转（IOC）和面向切面（AOP）\n它是一个容器框架，用来装javabean（java对象），中间层框架（万能胶）可以起一个连接作用，比如可以管理其他框架。\n将程序中用到的对象同意交给spring框架管理\n把控制生成对象的权利,反转给spring框架,\n依赖注入\n3、Spring 体系结构\n4、Spring 项目的搭建（1）创建Maven 项目\n\n\n\n\n（2）Maven导入spring核心基础jar，在pom.xml文件中添加\n  <dependencies>          <!-- spring-context -->    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-context</artifactId>        <version>5.2.2.RELEASE</version>    </dependency>  </dependencies>\n（3）编写spring配置文件application.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">     <!--          控制反转：IOC  将创建对象的权力，反转给spring框架         id:生成对象的名称         class:需要spring管理的类的地址（全类名）      -->     <bean  id=\"user\" name=\"user1,user2\" class=\"com.company.springPro.bean.UserPo\"> </bean></beans>\n（4）编写 UserPo 实体类\npackage com.company.springPro.bean;public class UserPo {    private String name;    private int age;    public UserPo() {        // TODO Auto-generated constructor stub    }    public String getName() {        return name;    }    public int getAge() {        return age;    }    public void setName(String name) {        this.name = name;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return \"UserPo [name=\" + name + \", age=\" + age + \"]\";    }    }\n（5）测试 Test.java\npackage com.company.springPro.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.company.springPro.bean.UserPo;import junit.framework.TestCase;public class Test extends TestCase{    public void testStart() {        //启动spring         加载spring的配置文件，创建一个ApplicationContext        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"application.xml\");        //参数user是在application.xml配置文件中bean对应的id        UserPo user = (UserPo)applicationContext.getBean(\"user\");        System.out.println(user);        UserPo user1 = (UserPo)applicationContext.getBean(\"user1\");        System.out.println(user1);        UserPo user2 = (UserPo)applicationContext.getBean(\"user2\");        System.out.println(user2);    }}\n结果：\ncom.company.springPro.bean.UserPo@4e91d63fcom.company.springPro.bean.UserPo@4e91d63fcom.company.springPro.bean.UserPo@4e91d63f\n根据结果，发现只创建了一次对象。原因是Bean配置中scope默认为singleton:单例的。\n5、IOC本质​        读作 “反转控制” (Inverse of Control)，更好理解，不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。\n正控：若要使用某个对象，需要自己去负责对象的创建\n反控：若要使用某个对象，只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架。\n简单一句话：就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。\n原理：\n​        Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。\n这个过程就叫控制反转 :\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 .\n反转 : 程序本身不创建对象 , 而变成被动的接收对象 .\n6、Spring配置6.1 Bean 配置（1）id：生成对象的名称\n（2）class：需要spring管理的类的地址（全类名）\n（3）name：相当于别名，可以为多个，中间逗号隔开\n（4）scope：控制生成对象的方式\n​        prototype: 原型的. 每次调用 getBean 方法都会返回一个新的 bean. 且在第一次调用 getBean 方法时才创建实例。\n​        singleton: 单例的. 每次调用 getBean 方法都会返回同一个 bean. 且在 IOC 容器初始化时即创建 bean 的实例. 默认值 singleton\n示例：\n<bean  id=\"user\" name=\"user1,user2\" class=\"com.company.springPro.bean.UserPo\" scope=\"prototype\"> </bean>\n6.2 import 导入其它配置文件<!-- 导入其他spring配置文件 --><import resource=\"bean.xml\"/>\n7、依赖注入7.1 属性注入Bean类：UserPo.java\npackage com.company.springPro.bean;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class UserPo {    private String name;    private int age;    private DeptPo dept;    private List list;    private Set set;    private Map map;    private Properties properties;    public UserPo() {        // TODO Auto-generated constructor stub    }        public UserPo(String name, int age, DeptPo dept) {        super();        this.name = name;        this.age = age;        this.dept = dept;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }    public void setName(String name) {        this.name = name;    }    public void setAge(int age) {        this.age = age;    }    public DeptPo getDept() {        return dept;    }    public void setDept(DeptPo dept) {        this.dept = dept;    }        public List getList() {        return list;    }    public Set getSet() {        return set;    }    public Properties getProperties() {        return properties;    }    public void setList(List list) {        this.list = list;    }    public void setSet(Set set) {        this.set = set;    }    public void setProperties(Properties properties) {        this.properties = properties;    }    public Map getMap() {        return map;    }    public void setMap(Map map) {        this.map = map;    }    @Override    public String toString() {        return \"UserPo [name=\" + name + \", age=\" + age + \", dept=\" + dept + \", list=\" + list + \", set=\" + set + \", map=\"                + map + \", properties=\" + properties + \"]\";    }}\napplication.xml\n       <!-- 属性注入 -->       <bean id=\"user\" class=\"com.company.springPro.bean.UserPo\">           <property name=\"age\" value=\"100\"/>           <property name=\"name\" value=\"张三\" />           <property name=\"properties\">               <props>                   <prop key=\"p1\">dept</prop>               </props>           </property>           <property name=\"list\">               <list>                   <value>1</value>                   <value>2</value>                   <value>3</value>               </list>           </property>           <property name=\"set\">               <set>                   <value>4</value>                   <value>5</value>                   <value>6</value>               </set>           </property>           <property name=\"map\">               <map>                   <entry key=\"key1\" value=\"7\"></entry>                   <entry key=\"key2\" value=\"8\"></entry>                   <entry key=\"key3\" value-ref=\"dept\"></entry>               </map>           </property>       <bean id=\"dept\" class=\"com.company.springPro.bean.DeptPo\">           <property name=\"num\" value=\"10\"></property>       </bean>\n7.2 构造方法注入       <!-- 构造方法注入 -->       <bean id=\"user2\" class=\"com.company.springPro.bean.UserPo\">           <constructor-arg type=\"java.lang.String\" value=\"李四\" />           <constructor-arg type=\"int\" value=\"18\" />           <constructor-arg type=\"DeptPo\" ref=\"dept\" />       </bean>\n', 0, 1);
INSERT INTO `t_article` VALUES (112, '02. 注解', 8, '\n\n## 1、注解方式的实现：\n\nJava注解：使用事先定义好的注解标签，对类、方法、属性的特征进行标记，在编译、运行时会找到对应的类、方法、属性，进行标签的执行功能。\n\n注解功能封装在jar包中，导入Spring aop jar包即可\n\n```xml\n    <!-- spring-context -->\n	<dependency>\n	    <groupId>org.springframework</groupId>\n	    <artifactId>spring-context</artifactId>\n	    <version>5.2.2.RELEASE</version>\n	</dependency>\n```\n\n添加xml文件约束,源码包中找到对应的 xsd文件。\n\n![image-20200624132628077](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200624132628077.png)\n\n修改配置文件，application.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<beans xmlns=\"http://www.springframework.org/schema/beans\" \nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \nxmlns:context=\"http://www.springframework.org/schema/context\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans \n                    http://www.springframework.org/schema/beans/spring-beans.xsd\n                    http://www.springframework.org/schema/context\n                    http://www.springframework.org/schema/context/spring-context.xsd\">	\n                    \n 	  <!-- 开启自动扫描注解，base-package是需要扫描的包名 -->\n 	  <context:component-scan base-package=\"com.company.springPro\"></context:component-scan>              \n```\n\n## 2、标签的使用\n\n### 2.1  注解创建对象\n\n（1）@Component\n\n对bean层对象的创建\n\n例如：等于 	  \\<bean id=\"user\" class=\"com.company.springPro.bean.UserPo\">\\</bean>\n\n```java\n@Component(value=\"user\")   \npublic class UserPo {}\n```\n\n（2）@Repository\n\n对数据库操作层对象的创建\n\n例如：等于        \\<bean id=\"userDao\" class=\"com.company.springPro.dao.UserDao\">\\</bean>\n\n```java\n@Repository(value = \"userDao\")\npublic class UserDao {}\n```\n\n（3）@Service\n\n对业务处理层对象的创建\n\n例如：等于      \\<bean id=\"userService\" class=\"com.company.springPro.service.UserService\">\\</bean>\n\n```java\n@Service(value=\"userService\") \npublic class UserService {}\n```\n\n### 2.2 对象创建的功能的扩展\n\n（1）@Scope(value=“prototype”)  多例\n\n\n\n（2）@Scope(value=“ singleton ”)  单例\n\n```java\n@Component(value=\"user\") 	\n@Scope(value=\"prototype\") \npublic class UserPo {}\n```\n\n\n\n### 2.3  注解注入属性\n\n@Autowired \n\n自动注入（根据类名去查找，与value值无关），使用注解方式可以不添加get和set方法，在需要引入别的类的对象上方使用。\n\n```java\npublic class UserService {\n	@Autowired\n	private UserDao userDao;\n}\n```\n\n', 0, 0, '2020-08-07 00:42:36', 2, 0, 1, '1、注解方式的实现：Java注解：使用事先定义好的注解标签，对类、方法、属性的特征进行标记，在编译、运行时会找到对应的类、方法、属性，进行标签的执行功能。\n注解功能封装在jar包中，导入Spring aop jar包即可\n    <!-- spring-context -->    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-context</artifactId>        <version>5.2.2.RELEASE</version>    </dependency>\n添加xml文件约束,源码包中找到对应的 xsd文件。\n\n修改配置文件，application.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans                     http://www.springframework.org/schema/beans/spring-beans.xsd                    http://www.springframework.org/schema/context                    http://www.springframework.org/schema/context/spring-context.xsd\">           <!-- 开启自动扫描注解，base-package是需要扫描的包名 -->       <context:component-scan base-package=\"com.company.springPro\"></context:component-scan>\n2、标签的使用2.1  注解创建对象（1）@Component\n对bean层对象的创建\n例如：等于       \\<bean id=\"user\" class=\"com.company.springPro.bean.UserPo\">\\</bean>\n@Component(value=\"user\")   public class UserPo {}\n（2）@Repository\n对数据库操作层对象的创建\n例如：等于        \\<bean id=\"userDao\" class=\"com.company.springPro.dao.UserDao\">\\</bean>\n@Repository(value = \"userDao\")public class UserDao {}\n（3）@Service\n对业务处理层对象的创建\n例如：等于      \\<bean id=\"userService\" class=\"com.company.springPro.service.UserService\">\\</bean>\n@Service(value=\"userService\") public class UserService {}\n2.2 对象创建的功能的扩展（1）@Scope(value=“prototype”)  多例\n（2）@Scope(value=“ singleton ”)  单例\n@Component(value=\"user\")     @Scope(value=\"prototype\") public class UserPo {}\n2.3  注解注入属性@Autowired \n自动注入（根据类名去查找，与value值无关），使用注解方式可以不添加get和set方法，在需要引入别的类的对象上方使用。\npublic class UserService {    @Autowired    private UserDao userDao;}\n', 0, 1);
INSERT INTO `t_article` VALUES (113, '03. Spring  JDBC', 8, '\n\n## 1、简介\n\nSpring是个一站式框架：Spring 自身也提供了控制层的 SpringMVC 和 持久层的 Spring JdbcTemplate。\n\n## 2、开发步骤\n\n### 2.1 在pom.xml文件中添加Maven包\n\n（1）下载Spring JdbcTemplate的jar包\n\n```xml\n	<!-- spring-jdbc -->\n	<dependency>\n		<groupId>org.springframework</groupId>\n		<artifactId>spring-jdbc</artifactId>\n		<version>5.2.2.RELEASE</version>\n	</dependency>\n```\n\n（2）导入阿里数据源\n\n```xml\n	<!-- 阿里数据源 -->\n	<dependency>\n		<groupId>com.alibaba</groupId>\n		<artifactId>druid</artifactId>\n		<version>1.1.10</version>\n	</dependency>\n```\n\n（3）导入mysql驱动包\n\n```xml\n   <!-- mysql-connector-java -->\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.20</version>\n    </dependency>\n  </dependencies>\n```\n\n### 2.2 在application.xml配置文件中\n\n（1）导入事先写好的jdbc配置文件jdbc.properties。\n\n```xml\n 	  <!-- 导入jdbc配置文件 -->\n 	  <context:property-placeholder location=\"jdbc.properties\"/>\n```\n\njdbc.properties文件内容格式如下\n\n```properties\nurl=jdbc:mysql://127.0.0.1:3306/shop?characterEncoding=utf-8&serverTimezone=GMT\ndriver=com.mysql.cj.jdbc.Driver\njdbc_username=root\njdbc_password=123456\ninitialSize=10\nminIdle=5\nmaxActive=20\n```\n\n（2）创建JdbcTemplate\n\n```xml\n 	  <!-- spring管理阿里数据源对象的创建 ,由此数据源管理数据库管理对象-->\n 	  <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n 	  	   <property name=\"driverClassName\" value=\"${driver}\"></property>\n		   <property name=\"url\" value=\"${url}\"></property>\n		   <property name=\"username\" value=\"${jdbc_username}\"></property>\n		   <property name=\"password\" value=\"${jdbc_password}\"></property>\n		   <property name=\"initialSize\" value=\"${initialSize}\"></property>\n		   <property name=\"minIdle\" value=\"${minIdle}\"></property>\n		   <property name=\"maxActive\" value=\"${maxActive}\"></property>\n 	  </bean>\n```\n\n（3）配置jdbc模板\n\n```xml\n 	  <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n	    <property name=\"dataSource\" ref=\"dataSource\"></property>\n	  </bean>\n```\n\n\n\n### 2.3 如何使用 JdbcTemplate 对象\n\n在类中获得 JdbcTemplate 对象，就可以直接使用。JdbcTemplate 可以直接当作已有的类来创建对象。\n\n```java\n@Autowired\nprivate JdbcTemplate jdbcTemplate;\n```\n\n\n\n# 3、JdbcTemplate中常用的方法\n\n### 3.1 execute()\n\nexecute()：无返回值，可执行ddl，增删改语句\n\n```java\n	public void createTable() {\n		// 利用execute执行sql语句\n		jdbcTemplate.execute(\"create table t_test(id int(2) PRIMARY KEY AUTO_INCREMENT, name varchar(255),age int(2))\");\n	}\n```\n\n\n\n### 3.2 update()\n\nupdate()：执行新增、修改、删除语句；\n\n```java\n	public void insert() {\n		jdbcTemplate.update(\"insert into t_test(name,age) values(?,?)\", \"张三\", 18);\n	}\n\n	public void update() {\n		jdbcTemplate.update(\"update t_test set name = ? ,age = ? where id = ?\", \"李四\", 20, 2);\n	}\n\n	public void delete() {\n		jdbcTemplate.update(\"delete from t_test where id = ?\", 3);\n	}\n```\n\n\n\n### 3.3 queryForXXX()\n\nqueryForXXX()：执行查询相关语句；\n\n\n\n**方法一：通过RowMapper将结果集封装成UserPo对象**\n\npublic \\<T> List\\<T> query(String sql, RowMapper\\<T> rowMapper, @Nullable Object... args) throws DataAccessException {}\n\n```java\npublic void findById() {\n			List<UserPo> userList = jdbcTemplate.query(\"select * from t_test where id = ?\", new RowMapper() {\n			@Override		//将查询结果封装到UserPo对象中\n			public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n				UserPo userPo = new UserPo();\n				userPo.setId(rs.getInt(\"id\"));\n				userPo.setName(rs.getString(\"name\"));\n				userPo.setAge(rs.getInt(\"age\"));\n				return userPo;\n			}\n		}, 1);\n		\n		for (UserPo userPo : userList) {\n			System.out.println(userPo);\n		}\n}\n```\n\n\n\n**方法二：直接获取封装成列名映射map对象**\n\npublic List<Map<String, Object>> queryForList(String sql, @Nullable Object... args) throws DataAccessException{}\n\n```java\npublic void findById() {\n		List<Map<String, Object>> list = jdbcTemplate.queryForList(\"select * from t_test where id = ?\", 1);\n		for (Map<String, Object> map : list) {\n			System.out.println(map);\n		}\n}\n```\n\n\n\n**方法三：获取单个对象**\n\npublic Map<String, Object> queryForMap(String sql, @Nullable Object... args) throws DataAccessException {}\n\n```java\npublic void findById() {\n		List<Map<String, Object>> list = jdbcTemplate.queryForList(\"select * from t_test where id = ?\", 1);\n		for (Map<String, Object> map : list) {\n			System.out.println(map);\n		}\n}\n```\n\n\n\n**方法四：直接返回UserPo对象**\n\npublic \\<T> T queryForObject(String sql, RowMapper\\<T> rowMapper, @Nullable Object... args) throws DataAccessException {}\n\n```java\npublic void findById() {\n		UserPo userPo = jdbcTemplate.queryForObject(\"select * from t_test where id = ?\", new RowMapper<UserPo>() {\n			@Override		//将查询结果封装到UserPo对象中\n			public UserPo mapRow(ResultSet rs, int rowNum) throws SQLException {\n				UserPo userPo = new UserPo();\n				userPo.setId(rs.getInt(\"id\"));\n				userPo.setName(rs.getString(\"name\"));\n				userPo.setAge(rs.getInt(\"age\"));\n				return userPo;\n			}\n		}, 1);\n		System.out.println(userPo);\n}\n```\n\n', 0, 0, '2020-08-07 00:43:07', 2, 0, 1, '1、简介Spring是个一站式框架：Spring 自身也提供了控制层的 SpringMVC 和 持久层的 Spring JdbcTemplate。\n2、开发步骤2.1 在pom.xml文件中添加Maven包（1）下载Spring JdbcTemplate的jar包\n    <!-- spring-jdbc -->    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-jdbc</artifactId>        <version>5.2.2.RELEASE</version>    </dependency>\n（2）导入阿里数据源\n    <!-- 阿里数据源 -->    <dependency>        <groupId>com.alibaba</groupId>        <artifactId>druid</artifactId>        <version>1.1.10</version>    </dependency>\n（3）导入mysql驱动包\n   <!-- mysql-connector-java -->    <dependency>        <groupId>mysql</groupId>        <artifactId>mysql-connector-java</artifactId>        <version>8.0.20</version>    </dependency>  </dependencies>\n2.2 在application.xml配置文件中（1）导入事先写好的jdbc配置文件jdbc.properties。\n       <!-- 导入jdbc配置文件 -->       <context:property-placeholder location=\"jdbc.properties\"/>\njdbc.properties文件内容格式如下\nurl=jdbc:mysql://127.0.0.1:3306/shop?characterEncoding=utf-8&serverTimezone=GMTdriver=com.mysql.cj.jdbc.Driverjdbc_username=rootjdbc_password=123456initialSize=10minIdle=5maxActive=20\n（2）创建JdbcTemplate\n       <!-- spring管理阿里数据源对象的创建 ,由此数据源管理数据库管理对象-->       <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">              <property name=\"driverClassName\" value=\"${driver}\"></property>           <property name=\"url\" value=\"${url}\"></property>           <property name=\"username\" value=\"${jdbc_username}\"></property>           <property name=\"password\" value=\"${jdbc_password}\"></property>           <property name=\"initialSize\" value=\"${initialSize}\"></property>           <property name=\"minIdle\" value=\"${minIdle}\"></property>           <property name=\"maxActive\" value=\"${maxActive}\"></property>       </bean>\n（3）配置jdbc模板\n       <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">        <property name=\"dataSource\" ref=\"dataSource\"></property>      </bean>\n2.3 如何使用 JdbcTemplate 对象在类中获得 JdbcTemplate 对象，就可以直接使用。JdbcTemplate 可以直接当作已有的类来创建对象。\n@Autowiredprivate JdbcTemplate jdbcTemplate;\n3、JdbcTemplate中常用的方法3.1 execute()execute()：无返回值，可执行ddl，增删改语句\n    public void createTable() {        // 利用execute执行sql语句        jdbcTemplate.execute(\"create table t_test(id int(2) PRIMARY KEY AUTO_INCREMENT, name varchar(255),age int(2))\");    }\n3.2 update()update()：执行新增、修改、删除语句；\n    public void insert() {        jdbcTemplate.update(\"insert into t_test(name,age) values(?,?)\", \"张三\", 18);    }    public void update() {        jdbcTemplate.update(\"update t_test set name = ? ,age = ? where id = ?\", \"李四\", 20, 2);    }    public void delete() {        jdbcTemplate.update(\"delete from t_test where id = ?\", 3);    }\n3.3 queryForXXX()queryForXXX()：执行查询相关语句；\n方法一：通过RowMapper将结果集封装成UserPo对象\npublic \\<T> List\\<T> query(String sql, RowMapper\\<T> rowMapper, @Nullable Object… args) throws DataAccessException {}\npublic void findById() {            List<UserPo> userList = jdbcTemplate.query(\"select * from t_test where id = ?\", new RowMapper() {            @Override        //将查询结果封装到UserPo对象中            public Object mapRow(ResultSet rs, int rowNum) throws SQLException {                UserPo userPo = new UserPo();                userPo.setId(rs.getInt(\"id\"));                userPo.setName(rs.getString(\"name\"));                userPo.setAge(rs.getInt(\"age\"));                return userPo;            }        }, 1);        for (UserPo userPo : userList) {            System.out.println(userPo);        }}\n方法二：直接获取封装成列名映射map对象\npublic List<Map<String, Object>> queryForList(String sql, @Nullable Object… args) throws DataAccessException{}\npublic void findById() {        List<Map<String, Object>> list = jdbcTemplate.queryForList(\"select * from t_test where id = ?\", 1);        for (Map<String, Object> map : list) {            System.out.println(map);        }}\n方法三：获取单个对象\npublic Map<String, Object> queryForMap(String sql, @Nullable Object… args) throws DataAccessException {}\npublic void findById() {        List<Map<String, Object>> list = jdbcTemplate.queryForList(\"select * from t_test where id = ?\", 1);        for (Map<String, Object> map : list) {            System.out.println(map);        }}\n方法四：直接返回UserPo对象\npublic \\<T> T queryForObject(String sql, RowMapper\\<T> rowMapper, @Nullable Object… args) throws DataAccessException {}\npublic void findById() {        UserPo userPo = jdbcTemplate.queryForObject(\"select * from t_test where id = ?\", new RowMapper<UserPo>() {            @Override        //将查询结果封装到UserPo对象中            public UserPo mapRow(ResultSet rs, int rowNum) throws SQLException {                UserPo userPo = new UserPo();                userPo.setId(rs.getInt(\"id\"));                userPo.setName(rs.getString(\"name\"));                userPo.setAge(rs.getInt(\"age\"));                return userPo;            }        }, 1);        System.out.println(userPo);}\n', 0, 1);
INSERT INTO `t_article` VALUES (114, '04. Spring AOP', 8, '\n\n## 1、什么是AOP\n\n AOP（Aspect-OrientedProgramming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。\n\n 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。\n\n**简而言之：**\n\nAOP：面向切面编程，是对面向对象的补充。将与业务无关的，重复使用的功能提前到一个横切面中（类），通过配置，让业务代码与横切面中的功能产生关联关系，在运行时，通过代理对象去调用绑定的行切面中的功能。\n\n\n\n## 2、Spring 中的AOP的基本概念\n\n**（1）连接点（Joinpoint）：**类中可以被增强的方法，这个方法就被称为连接点**（可以被增强的方法）**\n\n**（2）切入点（pointcut）：**类中有很多方法可以被增强，但实际中只有add和update被增了，那么add和update方法就被称为切入点**（实际实现的连接点）**\n\n**（3）通知(Advice):**  切面**要完成的工作**\n\n- 前置通知，方法之前执行\n- 后置通知，方法执行完之后执行\n- 返回通知,当方法执行返回结果后执行\n- 环绕通知，在方法执行之前，在方法执行之后执行\n- 异常通知，出现异常情况执行\n\n**（4）切面(Aspect)：** **把通知添加到切入点的过程**叫切面\n\n**（5）目标(Target)：**代理的目标对象**(要增强的类)**\n\n**（6）织入(Weaving)：**   将**通知应用到目标的过程**\n\n**（7）代理(Proxy)：** **向目标对象应用通知之后创建的代理对象**\n\n\n\n## 3、AOP 的使用\n\n### 3.1 下载AOP相关jar\n\npom.xml 中添加\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-aspects</artifactId>\n    <version>5.2.2.RELEASE</version>\n</dependency>\n```\n\n\n\n### 3.2 配置AOP\n\napplication.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<beans xmlns=\"http://www.springframework.org/schema/beans\" \nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \nxmlns:context=\"http://www.springframework.org/schema/context\"\nxmlns:aop=\"http://www.springframework.org/schema/aop\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans \n                    http://www.springframework.org/schema/beans/spring-beans.xsd\n                    http://www.springframework.org/schema/context\n                    http://www.springframework.org/schema/context/spring-context.xsd\n                    http://www.springframework.org/schema/aop\n                    http://www.springframework.org/schema/aop/spring-aop.xsd\">	\n 	 \n 	  \n 	  <!-- 开启自动扫描注解 -->\n 	  <context:component-scan base-package=\"com.company.springPro\"></context:component-scan>\n 	  \n 	  <!-- 导入数据库连接配置 -->\n	  <import resource=\"db.xml\"/>\n	  \n	  <!-- 配置装有公共功能的切面 -->\n	  <bean id=\"aopDemo\" class=\"com.company.springPro.util.AOPDemo\"></bean>\n 	  \n 	  <!-- 织入  -->\n 	  <aop:config>\n 	  	<!-- 配置切入点 -->\n		<aop:pointcut expression=\"execution(* com.company.springPro.dao.UserDao.insert(..))\" id=\"insert\"/>\n 	  	<aop:pointcut expression=\"execution(* com.company.springPro.dao.UserDao.update(..))\" id=\"update\"/>\n 	  	<aop:pointcut expression=\"execution(* com.company.springPro.dao.UserDao.find(..))\" id=\"find\"/>\n 	  	<!-- 将切面中的方法与切入点关联 -->\n 	  	<aop:aspect ref=\"aopDemo\">\n 	  		<!-- 前置通知 -->\n 	  		<aop:after method=\"before\" pointcut-ref=\"insert\"/>\n 	  		\n 	  		<!-- 后置通知 -->\n 	  		<aop:before method=\"after\" pointcut-ref=\"insert\"/>\n 	  		\n 	  		<!-- 环绕通知 -->\n 	  		<aop:around method=\"aroundAdvice\" pointcut-ref=\"update\"/>\n 	  		\n 	  		<!-- 异常通知 -->\n 	  		<aop:after-throwing method=\"exceptionAdvice\" pointcut-ref=\"find\" throwing=\"e\"/>\n 	  	</aop:aspect>\n 	  </aop:config> 	  \n</beans>\n```\n\n\n\n###    3.3 切面功能类\n\nAOPDemo.java\n\n```java\npackage com.company.springPro.util;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\n\npublic class AOPDemo {\n	/*\n	 * 定义一个需要添加的新功能\n	 * 通知:实际完成的功能\n	 */\n	\n	public void before() {\n		System.out.println(\"前置通知\");\n	}\n	\n	public void after() {\n		System.out.println(\"后置通知\");\n	}\n	\n	public void aroundAdvice(ProceedingJoinPoint joinPoint) {\n		System.out.println(\"开启事务\");\n		try {\n			//代理对象去代理调用update方法\n			joinPoint.proceed();\n		} catch (Throwable e) {\n			// TODO Auto-generated catch block\n			e.printStackTrace();\n		}\n		System.out.println(\"提交事务\");\n	}\n	\n	public void exceptionAdvice(Throwable e) {\n		System.out.println(\"异常通知\" + e.getMessage());\n	}\n}\n```\n\n', 0, 0, '2020-08-07 00:43:57', 2, 0, 1, '1、什么是AOP AOP（Aspect-OrientedProgramming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。\n 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。\n简而言之：\nAOP：面向切面编程，是对面向对象的补充。将与业务无关的，重复使用的功能提前到一个横切面中（类），通过配置，让业务代码与横切面中的功能产生关联关系，在运行时，通过代理对象去调用绑定的行切面中的功能。\n2、Spring 中的AOP的基本概念（1）连接点（Joinpoint）：类中可以被增强的方法，这个方法就被称为连接点（可以被增强的方法）\n（2）切入点（pointcut）：类中有很多方法可以被增强，但实际中只有add和update被增了，那么add和update方法就被称为切入点（实际实现的连接点）\n（3）通知(Advice):  切面要完成的工作\n\n前置通知，方法之前执行后置通知，方法执行完之后执行返回通知,当方法执行返回结果后执行环绕通知，在方法执行之前，在方法执行之后执行异常通知，出现异常情况执行\n（4）切面(Aspect)： 把通知添加到切入点的过程叫切面\n（5）目标(Target)：代理的目标对象(要增强的类)\n（6）织入(Weaving)：   将通知应用到目标的过程\n（7）代理(Proxy)： 向目标对象应用通知之后创建的代理对象\n3、AOP 的使用3.1 下载AOP相关jarpom.xml 中添加\n<dependency>    <groupId>org.springframework</groupId>    <artifactId>spring-aspects</artifactId>    <version>5.2.2.RELEASE</version></dependency>\n3.2 配置AOPapplication.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"xmlns:aop=\"http://www.springframework.org/schema/aop\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans                     http://www.springframework.org/schema/beans/spring-beans.xsd                    http://www.springframework.org/schema/context                    http://www.springframework.org/schema/context/spring-context.xsd                    http://www.springframework.org/schema/aop                    http://www.springframework.org/schema/aop/spring-aop.xsd\">           <!-- 开启自动扫描注解 -->       <context:component-scan base-package=\"com.company.springPro\"></context:component-scan>       <!-- 导入数据库连接配置 -->      <import resource=\"db.xml\"/>      <!-- 配置装有公共功能的切面 -->      <bean id=\"aopDemo\" class=\"com.company.springPro.util.AOPDemo\"></bean>       <!-- 织入  -->       <aop:config>           <!-- 配置切入点 -->        <aop:pointcut expression=\"execution(* com.company.springPro.dao.UserDao.insert(..))\" id=\"insert\"/>           <aop:pointcut expression=\"execution(* com.company.springPro.dao.UserDao.update(..))\" id=\"update\"/>           <aop:pointcut expression=\"execution(* com.company.springPro.dao.UserDao.find(..))\" id=\"find\"/>           <!-- 将切面中的方法与切入点关联 -->           <aop:aspect ref=\"aopDemo\">               <!-- 前置通知 -->               <aop:after method=\"before\" pointcut-ref=\"insert\"/>               <!-- 后置通知 -->               <aop:before method=\"after\" pointcut-ref=\"insert\"/>               <!-- 环绕通知 -->               <aop:around method=\"aroundAdvice\" pointcut-ref=\"update\"/>               <!-- 异常通知 -->               <aop:after-throwing method=\"exceptionAdvice\" pointcut-ref=\"find\" throwing=\"e\"/>           </aop:aspect>       </aop:config>       </beans>\n3.3 切面功能类AOPDemo.java\npackage com.company.springPro.util;import org.aspectj.lang.ProceedingJoinPoint;public class AOPDemo {    /*     * 定义一个需要添加的新功能     * 通知:实际完成的功能     */    public void before() {        System.out.println(\"前置通知\");    }    public void after() {        System.out.println(\"后置通知\");    }    public void aroundAdvice(ProceedingJoinPoint joinPoint) {        System.out.println(\"开启事务\");        try {            //代理对象去代理调用update方法            joinPoint.proceed();        } catch (Throwable e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        System.out.println(\"提交事务\");    }    public void exceptionAdvice(Throwable e) {        System.out.println(\"异常通知\" + e.getMessage());    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (115, '05. Spring事务管理', 8, '\n\n## 1、什么是事务？\n\n事物可以看做是由对数据库若干操作组成的一个单元，这些操作要么都完成，要么都取消，从而保证数据满足一致性的要求。\n\n\n\n## 2、事务的特征(ACID)\n\n- 原子性（Atomic）：不可分割\n- 一致性（Consistent）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。\n- 隔离性（Insulation）：一个事务的执行不能其它事务干扰。\n- 持久性（Duration）：最终数据必须持久化到硬盘文件中，事务才算完成。\n\n\n\n## 3、Spring 事务管理API\n\n事务控制应该添加在service层，因为service可以会有多个dao层方法。\n\n###  配置事务管理器类（db.xml）\n\n### 3.1 Xml配置方式\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:aop=\"http://www.springframework.org/schema/aop\"\n	xmlns:tx=\"http://www.springframework.org/schema/tx\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n                    http://www.springframework.org/schema/beans/spring-beans.xsd\n                    http://www.springframework.org/schema/context\n                    http://www.springframework.org/schema/context/spring-context.xsd\n                    http://www.springframework.org/schema/aop\n                    http://www.springframework.org/schema/aop/spring-aop.xsd\n                    http://www.springframework.org/schema/tx\n                    http://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n	<!-- 导入jdbc配置文件 -->\n	<context:property-placeholder\n		location=\"jdbc.properties\" />\n\n\n	<!-- spring管理阿里数据源对象的创建 ,由此数据源管理数据库管理对象 -->\n	<bean id=\"dataSource\"\n		class=\"com.alibaba.druid.pool.DruidDataSource\">\n		<property name=\"driverClassName\" value=\"${driver}\"></property>\n		<property name=\"url\" value=\"${url}\"></property>\n		<property name=\"username\" value=\"${jdbc_username}\"></property>\n		<property name=\"password\" value=\"${jdbc_password}\"></property>\n		<property name=\"initialSize\" value=\"${initialSize}\"></property>\n		<property name=\"minIdle\" value=\"${minIdle}\"></property>\n		<property name=\"maxActive\" value=\"${maxActive}\"></property>\n	</bean>\n\n	<!-- 配置jdbc模板 -->\n	<bean id=\"jdbcTemplate\"\n		class=\"org.springframework.jdbc.core.JdbcTemplate\">\n		<property name=\"dataSource\" ref=\"dataSource\"></property>\n	</bean>\n\n	<!-- 配置事务管理器类 -->\n	<bean id=\"transactionManager\"\n		class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n		<property name=\"dataSource\" ref=\"dataSource\"></property>\n	</bean>\n	\n	<!-- 通知 -->\n	<tx:advice id=\"txadvice\"\n		transaction-manager=\"transactionManager\">\n		<tx:attributes>\n		<!-- 配置spring事务传播行为 -->\n			<tx:method name=\"*\" propagation=\"REQUIRED\" />\n		</tx:attributes>\n	</tx:advice>\n\n	<!-- 基于xml配置文件方式实现事务管理配置 -->\n	<aop:config>\n		<aop:pointcut\n			expression=\"execution(* com.company.springPro.service.UserService.*(..))\"\n			id=\"allmethod\" />\n		<aop:advisor advice-ref=\"txadvice\"\n			pointcut-ref=\"allmethod\" />\n	</aop:config>\n</beans>	  \n```\n\n\n\n### 3.2 注解方式\n\n（1）db.xml   开启事务注解功能\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:aop=\"http://www.springframework.org/schema/aop\"\n	xmlns:tx=\"http://www.springframework.org/schema/tx\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n                    http://www.springframework.org/schema/beans/spring-beans.xsd\n                    http://www.springframework.org/schema/context\n                    http://www.springframework.org/schema/context/spring-context.xsd\n                    http://www.springframework.org/schema/aop\n                    http://www.springframework.org/schema/aop/spring-aop.xsd\n                    http://www.springframework.org/schema/tx\n                    http://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n	<!-- 导入jdbc配置文件 -->\n	<context:property-placeholder\n		location=\"jdbc.properties\" />\n\n\n	<!-- spring管理阿里数据源对象的创建 ,由此数据源管理数据库管理对象 -->\n	<bean id=\"dataSource\"\n		class=\"com.alibaba.druid.pool.DruidDataSource\">\n		<property name=\"driverClassName\" value=\"${driver}\"></property>\n		<property name=\"url\" value=\"${url}\"></property>\n		<property name=\"username\" value=\"${jdbc_username}\"></property>\n		<property name=\"password\" value=\"${jdbc_password}\"></property>\n		<property name=\"initialSize\" value=\"${initialSize}\"></property>\n		<property name=\"minIdle\" value=\"${minIdle}\"></property>\n		<property name=\"maxActive\" value=\"${maxActive}\"></property>\n	</bean>\n\n	<!-- 配置jdbc模板 -->\n	<bean id=\"jdbcTemplate\"\n		class=\"org.springframework.jdbc.core.JdbcTemplate\">\n		<property name=\"dataSource\" ref=\"dataSource\"></property>\n	</bean>\n\n	<!-- 配置事务管理器类 -->\n	<bean id=\"transactionManager\"\n		class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n		<property name=\"dataSource\" ref=\"dataSource\"></property>\n	</bean>\n	\n\n	<!-- 开启事务注解功能 -->\n	<tx:annotation-driven transaction-manager=\"transactionManager\"/> \n</beans>	  \n```\n\n\n\n（2）在对应方法或类的上面加上注解标签\n\n```java\n	//事务控制应该添加在service层，因为service可以会有多个dao层方法。\n	@Transactional(propagation=Propagation.REQUIRED) \n	public void save() {\n		userDao.insert1();\n		int a = 10/0;\n		userDao.insert2();\n	}\n```\n\n', 0, 0, '2020-08-07 00:44:32', 2, 0, 1, '1、什么是事务？事物可以看做是由对数据库若干操作组成的一个单元，这些操作要么都完成，要么都取消，从而保证数据满足一致性的要求。\n2、事务的特征(ACID)\n原子性（Atomic）：不可分割一致性（Consistent）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。隔离性（Insulation）：一个事务的执行不能其它事务干扰。持久性（Duration）：最终数据必须持久化到硬盘文件中，事务才算完成。\n3、Spring 事务管理API事务控制应该添加在service层，因为service可以会有多个dao层方法。\n配置事务管理器类（db.xml）3.1 Xml配置方式<?xml version=\"1.0\" encoding=\"UTF-8\"?><beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xmlns:aop=\"http://www.springframework.org/schema/aop\"    xmlns:tx=\"http://www.springframework.org/schema/tx\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans                     http://www.springframework.org/schema/beans/spring-beans.xsd                    http://www.springframework.org/schema/context                    http://www.springframework.org/schema/context/spring-context.xsd                    http://www.springframework.org/schema/aop                    http://www.springframework.org/schema/aop/spring-aop.xsd                    http://www.springframework.org/schema/tx                    http://www.springframework.org/schema/tx/spring-tx.xsd\">    <!-- 导入jdbc配置文件 -->    <context:property-placeholder        location=\"jdbc.properties\" />    <!-- spring管理阿里数据源对象的创建 ,由此数据源管理数据库管理对象 -->    <bean id=\"dataSource\"        class=\"com.alibaba.druid.pool.DruidDataSource\">        <property name=\"driverClassName\" value=\"${driver}\"></property>        <property name=\"url\" value=\"${url}\"></property>        <property name=\"username\" value=\"${jdbc_username}\"></property>        <property name=\"password\" value=\"${jdbc_password}\"></property>        <property name=\"initialSize\" value=\"${initialSize}\"></property>        <property name=\"minIdle\" value=\"${minIdle}\"></property>        <property name=\"maxActive\" value=\"${maxActive}\"></property>    </bean>    <!-- 配置jdbc模板 -->    <bean id=\"jdbcTemplate\"        class=\"org.springframework.jdbc.core.JdbcTemplate\">        <property name=\"dataSource\" ref=\"dataSource\"></property>    </bean>    <!-- 配置事务管理器类 -->    <bean id=\"transactionManager\"        class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">        <property name=\"dataSource\" ref=\"dataSource\"></property>    </bean>    <!-- 通知 -->    <tx:advice id=\"txadvice\"        transaction-manager=\"transactionManager\">        <tx:attributes>        <!-- 配置spring事务传播行为 -->            <tx:method name=\"*\" propagation=\"REQUIRED\" />        </tx:attributes>    </tx:advice>    <!-- 基于xml配置文件方式实现事务管理配置 -->    <aop:config>        <aop:pointcut            expression=\"execution(* com.company.springPro.service.UserService.*(..))\"            id=\"allmethod\" />        <aop:advisor advice-ref=\"txadvice\"            pointcut-ref=\"allmethod\" />    </aop:config></beans>\n3.2 注解方式（1）db.xml   开启事务注解功能\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xmlns:aop=\"http://www.springframework.org/schema/aop\"    xmlns:tx=\"http://www.springframework.org/schema/tx\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans                     http://www.springframework.org/schema/beans/spring-beans.xsd                    http://www.springframework.org/schema/context                    http://www.springframework.org/schema/context/spring-context.xsd                    http://www.springframework.org/schema/aop                    http://www.springframework.org/schema/aop/spring-aop.xsd                    http://www.springframework.org/schema/tx                    http://www.springframework.org/schema/tx/spring-tx.xsd\">    <!-- 导入jdbc配置文件 -->    <context:property-placeholder        location=\"jdbc.properties\" />    <!-- spring管理阿里数据源对象的创建 ,由此数据源管理数据库管理对象 -->    <bean id=\"dataSource\"        class=\"com.alibaba.druid.pool.DruidDataSource\">        <property name=\"driverClassName\" value=\"${driver}\"></property>        <property name=\"url\" value=\"${url}\"></property>        <property name=\"username\" value=\"${jdbc_username}\"></property>        <property name=\"password\" value=\"${jdbc_password}\"></property>        <property name=\"initialSize\" value=\"${initialSize}\"></property>        <property name=\"minIdle\" value=\"${minIdle}\"></property>        <property name=\"maxActive\" value=\"${maxActive}\"></property>    </bean>    <!-- 配置jdbc模板 -->    <bean id=\"jdbcTemplate\"        class=\"org.springframework.jdbc.core.JdbcTemplate\">        <property name=\"dataSource\" ref=\"dataSource\"></property>    </bean>    <!-- 配置事务管理器类 -->    <bean id=\"transactionManager\"        class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">        <property name=\"dataSource\" ref=\"dataSource\"></property>    </bean>    <!-- 开启事务注解功能 -->    <tx:annotation-driven transaction-manager=\"transactionManager\"/> </beans>\n（2）在对应方法或类的上面加上注解标签\n    //事务控制应该添加在service层，因为service可以会有多个dao层方法。    @Transactional(propagation=Propagation.REQUIRED)     public void save() {        userDao.insert1();        int a = 10/0;        userDao.insert2();    }\n', 0, 1);
INSERT INTO `t_article` VALUES (116, '06. Spring 事务传播行为', 8, '\n\n## 1、什么是事务传播行为？\n\n至少是两个东西，才可以发生传播。\n\n事务传播行为（propagation behavior）指的是当一个事务方法调用到另一个事务方法时，这个事务应该如何运行。事务传播行为是spring框架独有的，不属于数据库。\n\n例如：methodA事务方法调用methodB事务方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。\n\n\n\n## 2、Spring 七种传播行为\n\n注意：为了描述，我们把methodA方法调用methodB方法，把methodA看成methodB的父级方法。\n\n| 事务传播行为类型          | 说明                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| PROPAGATION_REQUIRED      | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 |\n| PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，就以非事务方式执行。如果当前有事务，就以事务的方式运行。完全按照父级方法的事务方式执行 |\n| PROPAGATION_REQUIRES_NEW  | 无论父级方法是否使用事务，子级方法都会自己创建一个事务。如果父级方法使用事务，会先将父级事务挂起，执行完自己事务再去执行父级事务。 |\n| PROPAGATION_MANDATORY     | 使用父级的事务，如果父级没有创建事务，就报异常               |\n| PROPAGATION_NOT_SUPPORTED | 子级方法以非事务的形式运行，如果父级存在事务，就将先将父级事务挂起。 |\n| PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务，则抛出异常。             |\n| PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |\n\n\n\n## 3、事务管理器的使用\n\n（1）配置事务管理器\n\n```xml\n	<!-- 配置事务管理器类 -->\n	<bean id=\"transactionManager\"\n		class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n		<property name=\"dataSource\" ref=\"dataSource\"></property>\n	</bean>\n```\n\n（2）给方法上面添加事务管理，有两种方式\n\n第一种：利用通知给对应的方法添加，但是这种方法不常用\n\n```xml\n	<!-- 通知 -->\n	<tx:advice id=\"txadvice\"\n		transaction-manager=\"transactionManager\">\n		<tx:attributes>\n		<!-- 配置spring事务传播行为 -->\n			<tx:method name=\"*\" propagation=\"REQUIRED\" />\n		</tx:attributes>\n	</tx:advice>\n```\n\n第二种：给对应方法上面直接添加标签，这种方法需要先开启事务注解功能\n\n```xml\n	<!-- 开启事务注解功能 -->\n	<tx:annotation-driven transaction-manager=\"transactionManager\"/> \n```\n\n在方法上面使用标签\n\n```java\n	//事务控制应该添加在service层，因为service可以会有多个dao层方法。\n	@Transactional(propagation=Propagation.REQUIRED) \n	public void save() {\n		userDao.insert1();\n		int a = 10/0;\n		userDao.insert2();\n	}\n```\n\n', 0, 0, '2020-08-07 00:45:08', 2, 0, 1, '1、什么是事务传播行为？至少是两个东西，才可以发生传播。\n事务传播行为（propagation behavior）指的是当一个事务方法调用到另一个事务方法时，这个事务应该如何运行。事务传播行为是spring框架独有的，不属于数据库。\n例如：methodA事务方法调用methodB事务方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。\n2、Spring 七种传播行为注意：为了描述，我们把methodA方法调用methodB方法，把methodA看成methodB的父级方法。\n\n\n\n事务传播行为类型\n说明\n\n\n\n\nPROPAGATION_REQUIRED\n如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。\n\n\nPROPAGATION_SUPPORTS\n支持当前事务，如果当前没有事务，就以非事务方式执行。如果当前有事务，就以事务的方式运行。完全按照父级方法的事务方式执行\n\n\nPROPAGATION_REQUIRES_NEW\n无论父级方法是否使用事务，子级方法都会自己创建一个事务。如果父级方法使用事务，会先将父级事务挂起，执行完自己事务再去执行父级事务。\n\n\nPROPAGATION_MANDATORY\n使用父级的事务，如果父级没有创建事务，就报异常\n\n\nPROPAGATION_NOT_SUPPORTED\n子级方法以非事务的形式运行，如果父级存在事务，就将先将父级事务挂起。\n\n\nPROPAGATION_NEVER\n以非事务方式执行，如果当前存在事务，则抛出异常。\n\n\nPROPAGATION_NESTED\n如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。\n\n\n\n3、事务管理器的使用（1）配置事务管理器\n    <!-- 配置事务管理器类 -->    <bean id=\"transactionManager\"        class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">        <property name=\"dataSource\" ref=\"dataSource\"></property>    </bean>\n（2）给方法上面添加事务管理，有两种方式\n第一种：利用通知给对应的方法添加，但是这种方法不常用\n    <!-- 通知 -->    <tx:advice id=\"txadvice\"        transaction-manager=\"transactionManager\">        <tx:attributes>        <!-- 配置spring事务传播行为 -->            <tx:method name=\"*\" propagation=\"REQUIRED\" />        </tx:attributes>    </tx:advice>\n第二种：给对应方法上面直接添加标签，这种方法需要先开启事务注解功能\n    <!-- 开启事务注解功能 -->    <tx:annotation-driven transaction-manager=\"transactionManager\"/>\n在方法上面使用标签\n    //事务控制应该添加在service层，因为service可以会有多个dao层方法。    @Transactional(propagation=Propagation.REQUIRED)     public void save() {        userDao.insert1();        int a = 10/0;        userDao.insert2();    }\n', 0, 1);
INSERT INTO `t_article` VALUES (117, '07. 统一建模语言——UML', 8, '\n\n## 简介：\n\n  统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准.\n\n  统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。\n\n## 1. 类\n\n是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。\n\n(1) 类名（Name）是一个字符串，例如，Student。\n\n(2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：\n\n[可见性]属性名:类型[=默认值]\n\n例如：-name:String\n\n注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。\n\n(3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：\n\n[可见性]名称(参数列表)[:返回类型]\n\n例如：+display():void。\n\n学生类的 UML 表示。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps1.png) \n\n \n\n## 2. 接口\n\n接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。\n图形类接口的 UML 表示。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps2.png) \n\n \n\n## 3. 类图\n\n类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。\n\n类图中的类可以通过某种编程 语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。下图所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps3.png) \n\n \n\n## 4、类之间的关系\n\n在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。\n\n### 4.1 依赖关系\n\n依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。\n\n在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是人与手机的关系图，人通过手机的语音传送方法打电话。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps4.png) \n\n### 4.2 关联关系\n\n关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。\n\n关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。\n\n在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。下图所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps5.png) \n\n### 4.3 聚合关系\n\n   聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。\n  聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\n  在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps6.png) \n\n### 4.4 组合关系\n\n  组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。\n  在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。\n在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps7.png) \n\n### 4.5 泛化关系\n\n  泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。\n  在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图下图所示。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps9.png) \n\n### 4.6 实现关系\n\n实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\n\n在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下图所示。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps9.png) ', 0, 0, '2020-08-07 00:45:37', 2, 0, 1, '简介：  统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准.\n  统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。\n1. 类是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。\n(1) 类名（Name）是一个字符串，例如，Student。\n(2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：\n[可见性]属性名:类型[=默认值]\n例如：-name:String\n注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。\n(3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：\n[可见性]名称(参数列表)[:返回类型]\n例如：+display():void。\n学生类的 UML 表示。\n \n2. 接口接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。图形类接口的 UML 表示。\n \n3. 类图类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。\n类图中的类可以通过某种编程 语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。下图所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。\n \n4、类之间的关系在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。\n4.1 依赖关系依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。\n在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是人与手机的关系图，人通过手机的语音传送方法打电话。\n \n4.2 关联关系关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。\n关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。\n在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。下图所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。\n \n4.3 聚合关系   聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。  聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。  在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图。\n \n4.4 组合关系  组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。  在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图。\n \n4.5 泛化关系  泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。  在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图下图所示。\n \n4.6 实现关系实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\n在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下图所示。\n \n', 0, 1);
INSERT INTO `t_article` VALUES (118, '08. Java设计模式', 8, '\n\n## 1、什么是设计模式\n\n​      设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。  \n\n\n\n## 2、设计模式的意义\n\n​       设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。\n\n   1.可以提高程序员的思维能力、编程能力和设计能力。\n\n   2.使程序设计更加标准化、代码编制更加工程化，使开发效率大大提高，从而缩短软件的开发周期。\n\n   3.使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。\n\n\n\n## 3、java设计模式类型\n\n 根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。\n\n**创建型模式：**用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。提供了单例、原型、工厂方法、抽象工厂、建造者5种创建型模式。\n\n**结构型模式：**用于描述如何将类或对象按某种布局组成更大的结构，提供了代理、适配器、桥接、装饰、外观、享元、组合7种结构型模式。\n\n**行为型模式：**用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器11种行为型模式。\n\n\n\n## 4、23种设计模式\n\n1. **单例（Singleton）模式：**某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。\n\n2. **原型（Prototype）模式：**将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。\n\n3. **工厂方法（Factory Method）模式：**定义一个用于创建产品的接口，由子类决定生产什么产品。\n\n4. **抽象工厂（AbstractFactory）模式：**提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。\n\n5. **建造者（Builder）模式：**将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。\n\n6. **代理（Proxy）模式：**为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。\n\n7. **适配器（Adapter）模式：**将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n\n8. **桥接（Bridge）模式：**将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n\n9. **装饰（Decorator）模式：**动态的给对象增加一些职责，即增加其额外的功能。\n\n10. **外观（Facade）模式：**为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。\n\n11. **享元（Flyweight）模式：**运用共享技术来有效地支持大量细粒度对象的复用。\n\n12. **组合（Composite）模式：**将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。\n\n13. **模板方法（TemplateMethod）模式：**定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n\n14. **策略（Strategy）模式：**定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。\n\n15. **命令（Command）模式：**将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。\n\n16. **职责链（Chain of Responsibility）模式：**把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。\n\n17. **状态（State）模式：**允许一个对象在其内部状态发生改变时改变其行为能力。\n\n18. **观察者（Observer）模式：**多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。\n\n19. **中介者（Mediator）模式：**定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。\n\n20. **迭代器（Iterator）模式：**提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n\n21. **访问者（Visitor）模式：**在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。\n\n22. **备忘录（Memento）模式：**在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。\n\n23. **解释器（Interpreter）模式：**提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。\n\n\n\n## 5、常用的设计模式\n\n### 5.1 单例模式\n\n   在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式. 例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。\n单例模式有 3 个特点：\n单例类只有一个实例对象；\n该单例对象必须由单例类自行创建；\n单例类对外提供一个访问该单例的全局访问点；\n单例模式的结构\n单例类：包含一个实例且能自行创建这个实例的类。\n访问类：使用单例的类。\n\n其结构如图所示。\n\n![image](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image.gif)\n\nSingleton 模式通常有两种实现形式。\n\n#### **第 1 种：懒汉式单例**\n\n该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例\n\n```java\n/*\n * 懒汉式单例(在第一次访问时,才创建对象)\n */\npublic class Singleton {\n	\n	//定义静态的\n	private static Singleton instance = null;  \n	\n	//让构造函数为 private，这样该类就不会被实例化(在其他类中)\n    private Singleton (){}  \n    \n    //对外提供访问单个对象方法, 懒汉式单例在多线程情况下,存在问题,需要加锁\n    public static synchronized Singleton getInstance() { \n    	    \n	    if (instance == null) {  \n	    	 //A 休眠了  B进来了\n	        instance = new Singleton();  \n	    }  \n      return instance;  \n    }\n}\n```\n\n\n\n#### 第 2 种：饿汉式单例\n\n该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。\n\n```java\n/*\n * 饿汉式单例(急切式)  不存在线程安全问题\n */\npublic class Singleton {\n	\n	   //创建 Singleton 的一个对象\n	   private static Singleton instance = new Singleton();\n	 \n	   //让构造函数为 private\n	   private Singleton(){}\n	 \n	   //获取唯一可用的对象    \n	   public static Singleton getInstance(){\n	      return instance;\n	   }\n}\n```\n\n\n\n\n\nJDK代理：底层使用反射机制实现，目标类必须要有实现接口。\n\nCGLIB：底层是动态创建目标类的子类对象（动态生成子类的字节码），目标类不需要实现任何接口。\n\nSpring 中AOP实现方式使用的就是动态代理来实现\n\n​	Spring 会自动选择实现方式“\n\n​			当目标类有接口，使用jdk实现。\n\n​			当目标类没有接口，使用cglib实现。\n\n\n\n### 5.2 工厂模式（Factory Pattern）\n\n\n\n​      工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。\n我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成.\n\n![image-20200625160207742](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200625160207742.png)\n\n```java\n/*\n * 画图形工厂,负责生产对象\n */\npublic class ShapeFactory {\n	\n	    //使用 getShape 方法获取形状类型的对象\n	   public Shape getShape(String shapeType){\n	      if(shapeType == null){\n	         return null;\n	      }        \n	      if(shapeType.equalsIgnoreCase(\"CIRCLE\")){\n	         return new Circle();\n	      } else if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){\n	         return new Rectangle();\n	      } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){\n	         return new Square();\n	      }\n	      return null;\n	   }\n	   \n	   //反射实现\n	   public Shape getShape1(String className){\n		   if(className == null){\n			   return null;\n		   }else{\n				try {\n					return (Shape) Class.forName(className).newInstance();\n				} catch (InstantiationException e) {\n					e.printStackTrace();\n					return null;\n				} catch (IllegalAccessException e) {\n					e.printStackTrace();\n					return null;\n				} catch (ClassNotFoundException e) {\n					e.printStackTrace();\n					return null;\n				}\n		   }      \n	   }   \n}\n```\n\n\n\n### 5.3 代理模式\n\n​       在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。\n\n**代理模式的主要优点有：**\n\n- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n\n- 代理对象可以扩展目标对象的功能；\n\n- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；\n\n  \n\n**模式的结构：**\n\n- 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n- 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n- 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n\n\n其结构图如图所示。\n\n![image-20200625161049441](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200625161049441.png)\n\n\n\n代理实现可以分为静态代理和动态代理。\n\n#### 静态代理：\n\n​     静态代理模式的特点，代理类接受一个Subject接口的对象，任何实现该接口的对象，都可以通过代理类进行代理，增加了通用性。但是也有缺点，每一个代理类都必须实现一遍委托类（也就是realsubject）的接口，如果接口增加方法，则代理类也必须跟着修改。其次，代理类每一个接口对象对应一个委托对象，如果委托对象非常多，则静态代理类就非常臃肿，难以胜任。\n\n```java\n/*\n * 静态代理类\n */\npublic class StaticProxy implements Subject{\n	\n	// 被代理类的实例\n	private Subject subject;//接收目标对象,\n	\n	// 将被代理者的实例传进动态代理类的构造函数中\n	public StaticProxy(Subject subject) {\n        this.subject = subject;\n    }\n	\n	@Override\n	public void visit() {\n		System.out.println(\"before\");\n		subject.visit();//实际执行的还是目标对象的方法\n		System.out.println(\"after\");\n	}\n\n}\n```\n\n\n\n#### 动态代理：\n\n 动态代理中，代理类并不是在Java代码中实现，而是在运行时期生成，相比静态代理，动态代理可以很方便的对委托类的方法进行统一处理，如添加方法调用次数、添加日志功能等等。\n\n动态代理分为jdk动态代理和cglib动态代理。\n\n\n\n#### （1）jdk代理\n\n 动态代理是实现方式，是通过反射来实现的，借助Java自带的java.lang.reflect.Proxy,通过固定的规则生成。\n其步骤如下：\n\n1. 编写一个委托类的接口，即静态代理的（Subject接口）\n\n2. 实现一个真正的委托类，即静态代理的（RealSubject类）\n\n3. 创建一个动态代理类，实现InvocationHandler接口，并重写该invoke方法\n\n4. 在测试类中，生成动态代理的对象。\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\n\n/*\n * 动态代理类\n */\npublic class DynamicProxy implements InvocationHandler{\n    \n	 // 被代理类的实例\n	 private Object object;\n	 \n	 // 将被代理者的实例传进动态代理类的构造函数中\n	 public DynamicProxy(Object object) {\n	        this.object = object;\n	 }\n	 \n    /*\n     * 覆盖InvocationHandler接口中的invoke()方法\n	 *    Object proxy 表示代理对象\n	 *    Method method 代理对象中的方法\n	 *	  Object[] arg2  表示代理方法中的参数\n     * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构\n     * 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到\n     * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊\n     * 代码切入的扩展点了。\n     */\n	 \n	 //方法的调用时间:当动态代理对象调用实际对象方法时,被invoke方法截获\n	@Override    //最大特点:动态的将目标对象,以及目标对象中的方法出传递到过来,\n	public Object invoke(Object proxy, Method method, Object[] arg2) throws Throwable {\n		\n		System.out.println(\"before\");\n		                //这才是实际调用真实主题(目标对象)方法的地方\n		Object result = method.invoke(object, arg2);\n		\n		System.out.println(\"after\");\n	        return result;\n	}\n}\n```\n\n测试类：\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class Test {\n\n	 public static void main(String[] args) {\n         //我们要代理的真实对象\n		 Subject realSubject = new RealSubject();\n		 \n		 ////我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的\n		 InvocationHandler  dynamicProxy = new DynamicProxy(realSubject);\n		 \n	    /*\n         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数\n         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象\n         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了\n         * 第三个参数dynamicProxy， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上\n         */          \n		                       //在运行时,去真正的创建动态代理对象,那我们就要告诉动态代理对象,实际应该代理的目标对象\n		 Subject subject = (Subject) Proxy.newProxyInstance(dynamicProxy.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), dynamicProxy);\n		 \n		 subject.visit(); \n		 //subject.visit1(); \n	}\n}\n```\n\n\n\n#### （2）cglib代理\n\n```java\nimport java.lang.reflect.Method;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\n/**\n * Cglib子类代理工厂\n * 对RealSubject在内存中动态构建一个子类对象\n */\npublic class CGLibProxy implements MethodInterceptor { \n\n	    //维护目标对象\n	    private Object target;\n\n	    public CGLibProxy(Object target) {\n	        this.target = target;\n	    }\n\n	    //给目标对象创建一个代理对象\n	    public Object getProxyInstance(){\n	        //1.工具类,为非接口类型创建一个JAVA代理，Enhancer动态的创建给定类的子类并且拦截代理类的所有的方法\n	        Enhancer en = new Enhancer();\n	        //2.设置父类\n	        en.setSuperclass(target.getClass());\n	        //3.设置回调函数\n	        en.setCallback(this);\n	        //4.创建子类(代理对象)\n	        return en.create();\n\n	    }\n\n	    @Override\n	    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n	        System.out.println(\"开始事务...\");\n\n	        //执行目标对象的方法\n	        Object returnValue = method.invoke(target, args);\n\n	        System.out.println(\"提交事务...\");\n\n	        return returnValue;\n	    }\n}\n```\n\n测试：\n\n```java\npublic class Test {\n	 public static void main(String[] args) {\n		 //目标对象\n		 RealSubject target = new RealSubject();\n		 //代理对象\n		 RealSubject proxy = (RealSubject)new CGLibProxy(target).getProxyInstance();\n		 //执行代理对象的方法\n	      proxy.visit();\n	}\n}\n```\n\n', 0, 0, '2020-08-07 00:46:05', 2, 0, 1, '1、什么是设计模式​      设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。  \n2、设计模式的意义​       设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。\n   1.可以提高程序员的思维能力、编程能力和设计能力。\n   2.使程序设计更加标准化、代码编制更加工程化，使开发效率大大提高，从而缩短软件的开发周期。\n   3.使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。\n3、java设计模式类型 根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。\n创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。提供了单例、原型、工厂方法、抽象工厂、建造者5种创建型模式。\n结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，提供了代理、适配器、桥接、装饰、外观、享元、组合7种结构型模式。\n行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器11种行为型模式。\n4、23种设计模式\n单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。\n原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。\n工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。\n抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。\n建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。\n代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。\n适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。\n外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。\n享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。\n组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。\n模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。\n命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。\n职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。\n状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。\n观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。\n中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。\n迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。\n备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。\n解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。\n\n5、常用的设计模式5.1 单例模式   在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式. 例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。单例模式有 3 个特点：单例类只有一个实例对象；该单例对象必须由单例类自行创建；单例类对外提供一个访问该单例的全局访问点；单例模式的结构单例类：包含一个实例且能自行创建这个实例的类。访问类：使用单例的类。\n其结构如图所示。\n\nSingleton 模式通常有两种实现形式。\n第 1 种：懒汉式单例该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例\n/* * 懒汉式单例(在第一次访问时,才创建对象) */public class Singleton {    //定义静态的    private static Singleton instance = null;      //让构造函数为 private，这样该类就不会被实例化(在其他类中)    private Singleton (){}      //对外提供访问单个对象方法, 懒汉式单例在多线程情况下,存在问题,需要加锁    public static synchronized Singleton getInstance() {         if (instance == null) {               //A 休眠了  B进来了            instance = new Singleton();          }        return instance;      }}\n第 2 种：饿汉式单例该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。\n/* * 饿汉式单例(急切式)  不存在线程安全问题 */public class Singleton {       //创建 Singleton 的一个对象       private static Singleton instance = new Singleton();       //让构造函数为 private       private Singleton(){}       //获取唯一可用的对象           public static Singleton getInstance(){          return instance;       }}\nJDK代理：底层使用反射机制实现，目标类必须要有实现接口。\nCGLIB：底层是动态创建目标类的子类对象（动态生成子类的字节码），目标类不需要实现任何接口。\nSpring 中AOP实现方式使用的就是动态代理来实现\n​    Spring 会自动选择实现方式“\n​            当目标类有接口，使用jdk实现。\n​            当目标类没有接口，使用cglib实现。\n5.2 工厂模式（Factory Pattern）​      工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成.\n\n/* * 画图形工厂,负责生产对象 */public class ShapeFactory {        //使用 getShape 方法获取形状类型的对象       public Shape getShape(String shapeType){          if(shapeType == null){             return null;          }                  if(shapeType.equalsIgnoreCase(\"CIRCLE\")){             return new Circle();          } else if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){             return new Rectangle();          } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){             return new Square();          }          return null;       }       //反射实现       public Shape getShape1(String className){           if(className == null){               return null;           }else{                try {                    return (Shape) Class.forName(className).newInstance();                } catch (InstantiationException e) {                    e.printStackTrace();                    return null;                } catch (IllegalAccessException e) {                    e.printStackTrace();                    return null;                } catch (ClassNotFoundException e) {                    e.printStackTrace();                    return null;                }           }             }   }\n5.3 代理模式​       在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。\n代理模式的主要优点有：\n\n代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n代理对象可以扩展目标对象的功能；\n代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；\n\n模式的结构：\n\n抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n其结构图如图所示。\n\n代理实现可以分为静态代理和动态代理。\n静态代理：​     静态代理模式的特点，代理类接受一个Subject接口的对象，任何实现该接口的对象，都可以通过代理类进行代理，增加了通用性。但是也有缺点，每一个代理类都必须实现一遍委托类（也就是realsubject）的接口，如果接口增加方法，则代理类也必须跟着修改。其次，代理类每一个接口对象对应一个委托对象，如果委托对象非常多，则静态代理类就非常臃肿，难以胜任。\n/* * 静态代理类 */public class StaticProxy implements Subject{    // 被代理类的实例    private Subject subject;//接收目标对象,    // 将被代理者的实例传进动态代理类的构造函数中    public StaticProxy(Subject subject) {        this.subject = subject;    }    @Override    public void visit() {        System.out.println(\"before\");        subject.visit();//实际执行的还是目标对象的方法        System.out.println(\"after\");    }}\n动态代理： 动态代理中，代理类并不是在Java代码中实现，而是在运行时期生成，相比静态代理，动态代理可以很方便的对委托类的方法进行统一处理，如添加方法调用次数、添加日志功能等等。\n动态代理分为jdk动态代理和cglib动态代理。\n（1）jdk代理 动态代理是实现方式，是通过反射来实现的，借助Java自带的java.lang.reflect.Proxy,通过固定的规则生成。其步骤如下：\n\n编写一个委托类的接口，即静态代理的（Subject接口）\n实现一个真正的委托类，即静态代理的（RealSubject类）\n创建一个动态代理类，实现InvocationHandler接口，并重写该invoke方法\n在测试类中，生成动态代理的对象。\n\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/* * 动态代理类 */public class DynamicProxy implements InvocationHandler{     // 被代理类的实例     private Object object;     // 将被代理者的实例传进动态代理类的构造函数中     public DynamicProxy(Object object) {            this.object = object;     }    /*     * 覆盖InvocationHandler接口中的invoke()方法     *    Object proxy 表示代理对象     *    Method method 代理对象中的方法     *      Object[] arg2  表示代理方法中的参数     * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构     * 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到     * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊     * 代码切入的扩展点了。     */     //方法的调用时间:当动态代理对象调用实际对象方法时,被invoke方法截获    @Override    //最大特点:动态的将目标对象,以及目标对象中的方法出传递到过来,    public Object invoke(Object proxy, Method method, Object[] arg2) throws Throwable {        System.out.println(\"before\");                        //这才是实际调用真实主题(目标对象)方法的地方        Object result = method.invoke(object, arg2);        System.out.println(\"after\");            return result;    }}\n测试类：\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class Test {     public static void main(String[] args) {         //我们要代理的真实对象         Subject realSubject = new RealSubject();         ////我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的         InvocationHandler  dynamicProxy = new DynamicProxy(realSubject);        /*         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了         * 第三个参数dynamicProxy， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上         */                                         //在运行时,去真正的创建动态代理对象,那我们就要告诉动态代理对象,实际应该代理的目标对象         Subject subject = (Subject) Proxy.newProxyInstance(dynamicProxy.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), dynamicProxy);         subject.visit();          //subject.visit1();     }}\n（2）cglib代理import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * Cglib子类代理工厂 * 对RealSubject在内存中动态构建一个子类对象 */public class CGLibProxy implements MethodInterceptor {         //维护目标对象        private Object target;        public CGLibProxy(Object target) {            this.target = target;        }        //给目标对象创建一个代理对象        public Object getProxyInstance(){            //1.工具类,为非接口类型创建一个JAVA代理，Enhancer动态的创建给定类的子类并且拦截代理类的所有的方法            Enhancer en = new Enhancer();            //2.设置父类            en.setSuperclass(target.getClass());            //3.设置回调函数            en.setCallback(this);            //4.创建子类(代理对象)            return en.create();        }        @Override        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {            System.out.println(\"开始事务...\");            //执行目标对象的方法            Object returnValue = method.invoke(target, args);            System.out.println(\"提交事务...\");            return returnValue;        }}\n测试：\npublic class Test {     public static void main(String[] args) {         //目标对象         RealSubject target = new RealSubject();         //代理对象         RealSubject proxy = (RealSubject)new CGLibProxy(target).getProxyInstance();         //执行代理对象的方法          proxy.visit();    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (119, '09. Spring集成Mybatis框架', 8, '\n\n## 1、创建Maven项目\n\n![image-20200625175136577](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200625175136577.png)\n\n![image-20200625175220447](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200625175220447.png)\n\n\n\n## 2、导入一下必要的jar包\n\n在pom.xml文件中\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n   					https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>com.company</groupId>\n  <artifactId>SpringDemo05</artifactId>\n  <version>1.0.0</version>\n  <packaging>war</packaging>\n  \n    <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <scope>test</scope>\n    </dependency>\n     <!-- spring-context -->\n	<dependency>\n	    <groupId>org.springframework</groupId>\n	    <artifactId>spring-context</artifactId>\n	    <version>5.2.2.RELEASE</version>\n	</dependency>\n	<!-- spring-jdbc -->\n	<dependency>\n		<groupId>org.springframework</groupId>\n		<artifactId>spring-jdbc</artifactId>\n		<version>5.2.2.RELEASE</version>\n	</dependency>\n	<!-- 阿里数据源 -->\n	<dependency>\n		<groupId>com.alibaba</groupId>\n		<artifactId>druid</artifactId>\n		<version>1.1.10</version>\n	</dependency>\n	\n   <!-- mysql-connector-java -->\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.20</version>\n    </dependency>\n	\n	<!-- Spring 切面实现AOP -->\n	<dependency>\n	    <groupId>org.springframework</groupId>\n	    <artifactId>spring-aspects</artifactId>\n	    <version>5.2.2.RELEASE</version>\n	</dependency>\n	\n	<!-- spring整合mybatis的插件包 -->\n	 <dependency>\n	    <groupId>org.mybatis</groupId>\n	    <artifactId>mybatis-spring</artifactId>\n	    <version>1.3.1</version>\n	</dependency>\n	\n	   <!-- mybatis -->\n	<dependency>\n	    <groupId>org.mybatis</groupId>\n	    <artifactId>mybatis</artifactId>\n	    <version>3.4.2</version>\n	</dependency>\n      \n     <!-- log4j -->\n      <dependency>\n         <groupId>log4j</groupId>\n         <artifactId>log4j</artifactId>\n         <version>1.2.17</version>\n      </dependency>  \n	\n  </dependencies>\n</project>\n```\n\n\n\n## 3、搭建Spring\n\n### 3.1 数据库连接配置文件\n\n**（1）jdbc.properties**\n\n```java\nurl=jdbc:mysql://127.0.0.1:3306/shop?characterEncoding=utf-8&serverTimezone=GMT\ndriver=com.mysql.cj.jdbc.Driver\njdbc_username=root\njdbc_password=123456\ninitialSize=10\nminIdle=5\nmaxActive=20\n```\n\n\n\n**（2）db.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<beans xmlns=\"http://www.springframework.org/schema/beans\" \nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \nxmlns:context=\"http://www.springframework.org/schema/context\"\nxmlns:aop=\"http://www.springframework.org/schema/aop\"\nxmlns:tx=\"http://www.springframework.org/schema/tx\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans \n                    http://www.springframework.org/schema/beans/spring-beans.xsd\n                    http://www.springframework.org/schema/context\n                    http://www.springframework.org/schema/context/spring-context.xsd\n                    http://www.springframework.org/schema/aop\n                    http://www.springframework.org/schema/aop/spring-aop.xsd\n                    http://www.springframework.org/schema/tx\n                    http://www.springframework.org/schema/tx/spring-tx.xsd\">\n        \n        \n        <!-- 加载属性文件 -->\n        <context:property-placeholder location=\"jdbc.properties\"/>\n        \n        <!-- spring管理阿里数据源对象的创建,由此数据源对象管理创建数据库连接对象(Connection) -->\n        <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n           <property name=\"driverClassName\" value=\"${driver}\"></property>\n           <property name=\"url\" value=\"${url}\"></property>\n           <property name=\"username\" value=\"${jdbc_username}\"></property>\n           <property name=\"password\" value=\"${jdbc_password}\"></property>\n           <property name=\"initialSize\" value=\"${initialSize}\"></property>\n		   <property name=\"minIdle\" value=\"${minIdle}\"></property>\n		   <property name=\"maxActive\" value=\"${maxActive}\"></property>\n        </bean>\n        \n        \n        <!-- 配置事务管理器类 -->\n        <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n              <property name=\"dataSource\" ref=\"dataSource\"></property>\n        </bean>\n        \n         <!-- 开启事务注解功能 -->\n         <tx:annotation-driven transaction-manager=\"transactionManager\" />\n         \n</beans>\n```\n\n\n\n**（3）application.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<beans xmlns=\"http://www.springframework.org/schema/beans\" \nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \nxmlns:context=\"http://www.springframework.org/schema/context\"\nxmlns:aop=\"http://www.springframework.org/schema/aop\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans \n                    http://www.springframework.org/schema/beans/spring-beans.xsd\n                    http://www.springframework.org/schema/context\n                    http://www.springframework.org/schema/context/spring-context.xsd\n                    http://www.springframework.org/schema/aop\n                    http://www.springframework.org/schema/aop/spring-aop.xsd\">	\n 	 	  \n 	  <!-- 导入数据库连接配置 -->\n	  <import resource=\"db.xml\"/>\n	  \n	  <!-- 开启自动扫描注解 -->\n 	  <context:component-scan base-package=\"com.company.springPro\"></context:component-scan>\n 	  \n</beans>\n```\n\n## 4、Dao、Po、mapper以及service类的编写\n\n（1）UserPo.java\n\n```java\npackage com.company.project.Po;\n\nimport java.sql.Date;\n\n@Component\npublic class UserPo {\n	private int id;\n	private String userName;\n	private String password;\n	private Date regTime;\n\n	public UserPo() {\n		// TODO Auto-generated constructor stub\n	}\n\n	public UserPo(String userName, String password, Date regTime) {\n		super();\n\n		this.userName = userName;\n		this.password = password;\n		this.regTime = regTime;\n	}\n\n	public int getId() {\n		return id;\n	}\n\n	public String getUserName() {\n		return userName;\n	}\n\n	public String getPassword() {\n		return password;\n	}\n\n	public void setId(int id) {\n		this.id = id;\n	}\n\n	public void setUserName(String userName) {\n		this.userName = userName;\n	}\n\n	public void setPassword(String password) {\n		this.password = password;\n	}\n\n	public Date getRegTime() {\n		return regTime;\n	}\n\n	public void setRegTime(Date regTime) {\n		this.regTime = regTime;\n	}\n\n	@Override\n	public String toString() {\n		return \"UserPo [id=\" + id + \", userName=\" + userName + \", password=\" + password + \", regTime=\" + regTime + \"]\";\n	}\n}\n```\n\n（2）UserDao.java\n\n```java\npackage com.company.springPro.dao;\n\nimport java.util.List;\n\nimport org.springframework.stereotype.Repository;\n\nimport com.company.springPro.Po.UserPo;\n\n@Repository\npublic interface UserDao {\n	void insert(UserPo userPo);\n	void update(UserPo userPo);\n	void delete(int id);\n	UserPo findById(int id);\n	List<UserPo> findAll();\n}\n```\n\n（3）UserService.java\n\n```java\npackage com.company.springPro.service;\n\nimport java.util.List;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport com.company.springPro.Po.UserPo;\nimport com.company.springPro.dao.UserDao;\n\n@Service\npublic class UserService {\n	@Autowired\n	private UserDao userDao;\n	\n	public UserService() {\n		\n	}\n	\n	public void insert(UserPo userPo) {\n		userDao.insert(userPo);\n	}\n	\n	public void update(UserPo userPo) {\n		userDao.update(userPo);\n	}\n	\n	public void delete(int userId) {\n		userDao.delete(userId);\n	}\n	\n	public UserPo findById(int id) {\n		return userDao.findById(id);\n	}\n	\n	public List<UserPo> findAll(){\n		return userDao.findAll();\n	}	\n}\n```\n\n（4）UserMapper.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n    \n<!--	\n	namespace 指向对应接口的类路径\n		\n -->    \n\n<mapper namespace=\"com.company.springPro.dao.UserDao\">\n	<!-- 把重复的sql代码可以提炼出来，通过定义别名把sql列名和java属性对应 -->\n	<sql id=\"selectResult\">\n		id,user_name userName,password,reg_time regTime\n	</sql>\n	\n	\n	<!-- 高级 -->\n	 <resultMap type=\"UserPo\" id=\"userResult\">\n	 	<id property=\"id\" column=\"id\"/>\n	 	<result property=\"userName\"  column=\"user_name\"/>\n	 	<result property=\"password\"  column=\"password\"/>\n	 	<result property=\"regTime\"  column=\"reg_time\"/>\n	 </resultMap>\n\n	<!-- \n		id=\"saveUser\":唯一标记\n		parameterType=\"UserPo\":参数类型\n		useGeneratedKeys=\"true\"：针对于主键自增\n		 -->\n	<insert id=\"insert\" parameterType=\"UserPo\" useGeneratedKeys=\"true\" keyColumn=\"id\" keyProperty=\"id\">\n		insert into t_user(id,user_name,password,reg_time) \n		values\n		(#{id},#{userName},#{password},#{regTime})\n	</insert>\n	\n	<update id=\"update\" parameterType=\"UserPo\" >\n		update t_user \n			set user_name=#{userName},password=#{password},reg_time=#{regTime}\n			where id = #{id}\n	</update>\n	\n	<delete id=\"delete\" parameterType=\"int\">\n		delete from t_user\n			where id = #{id}\n	</delete>\n	\n	<select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">\n		\n		select id,user_name,password,reg_time from t_user where id = #{id}\n	</select>\n	\n	<!-- mybatis会自动把得到的数据进行封装，把每条数据封装成对象 ，最后封装成集合-->\n	<select id=\"findAll\" resultType=\"UserPo\">\n\n		 select id,user_name,password,reg_time from t_user;\n	</select>\n</mapper>\n```\n\n\n\n## 5、搭建MyBatis\n\n（1）mybatis-config.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n\n	\n	<!-- 设置类型自动转换 -->\n	<settings>\n		<setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n	</settings>\n	  \n	<typeAliases>\n	<!-- 利用package标签可以直接把整个包的 Po类都导入，这块是导入与数据库表对应的java类-->\n	<package name=\"com.company.springPro.Po\"/>\n	</typeAliases>\n\n	<!-- 将我们写好的sql映射文件一定要注册到全局配置文件中 -->\n	<mappers>\n		<!-- 利用package标签可以直接把整个包的 xml配置文件都导入，这块是导入数据库表与java Po类对应的配置文件 -->\n		<package name=\"com.company.springPro.mapper\" />\n	</mappers>\n	\n</configuration>\n```\n\n（2）配置sqlSessionFactory\n\n在db.xml文件中添加\n\n```xml\n         <!-- 配置sqlSessionFactory spring管理生成SqlSessionFactory对象-->\n		 <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n		    <!--注入数据库连接管理对象 -->\n		   <property name=\"dataSource\" ref=\"dataSource\"></property>\n		    <!-- 加载mybatis全局配置文件 -->\n		   <property name=\"configLocation\" value=\"mybatis-config.xml\"></property>\n		    <!-- 加载sql映射文件 -->\n		   <property name=\"mapperLocations\" value=\"com/company/springPro/mapper/*Mapper.xml\"></property>\n		 </bean>\n		 \n		 <!-- 指定生成接口代理 -->\n		 <bean id=\"mapperFactory\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n		   <property name=\"basePackage\" value=\"com.company.springPro.dao\"></property>\n		    <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"></property>\n		 </bean>\n```\n\n\n\n## 6、测试\n\n```java\npackage com.company.springPro.test;\n\nimport java.sql.Date;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport com.company.springPro.Po.UserPo;\nimport com.company.springPro.service.UserService;\n\nimport junit.framework.TestCase;\n\npublic class UserTest extends TestCase{\n	Logger logger = Logger.getLogger(UserTest.class);\n	ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\");\n	UserService userService = (UserService) context.getBean(\"userService\");\n	public void testInsert() {\n		//测试期间启动加载spring的写法                         加载spring配置文件,创建一个ApplicationContext\n		\n		\n		UserPo userPo = new UserPo(\"王五\",\"123456\",new Date(System.currentTimeMillis()));\n		userService.insert(userPo);\n		\n	}\n	\n	public void testUpdate() {\n\n		UserPo userPo = new UserPo(\"张三\",\"123\",new Date(System.currentTimeMillis()));\n		userPo.setId(7);\n		userService.update(userPo);\n\n	}\n	\n	public void testDelete() {\n\n		userService.delete(7);\n	}\n	\n	public void testFindById() {\n		UserPo userPo = userService.findById(1);\n		logger.debug(userPo.toString());\n	}\n	\n\n	public void testFindAll() {\n\n		List<UserPo> userList = userService.findAll();\n		for(int i = 0;i<userList.size();i++) {\n			logger.debug(userList.get(i).toString());\n		}	\n	}\n}\n```\n\n', 0, 0, '2020-08-07 00:46:43', 2, 0, 1, '1、创建Maven项目\n\n2、导入一下必要的jar包在pom.xml文件中\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0                       https://maven.apache.org/xsd/maven-4.0.0.xsd\">  <modelVersion>4.0.0</modelVersion>  <groupId>com.company</groupId>  <artifactId>SpringDemo05</artifactId>  <version>1.0.0</version>  <packaging>war</packaging>    <properties>    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>  </properties>  <dependencies>    <dependency>      <groupId>junit</groupId>      <artifactId>junit</artifactId>      <version>3.8.1</version>      <scope>test</scope>    </dependency>     <!-- spring-context -->    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-context</artifactId>        <version>5.2.2.RELEASE</version>    </dependency>    <!-- spring-jdbc -->    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-jdbc</artifactId>        <version>5.2.2.RELEASE</version>    </dependency>    <!-- 阿里数据源 -->    <dependency>        <groupId>com.alibaba</groupId>        <artifactId>druid</artifactId>        <version>1.1.10</version>    </dependency>   <!-- mysql-connector-java -->    <dependency>        <groupId>mysql</groupId>        <artifactId>mysql-connector-java</artifactId>        <version>8.0.20</version>    </dependency>    <!-- Spring 切面实现AOP -->    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-aspects</artifactId>        <version>5.2.2.RELEASE</version>    </dependency>    <!-- spring整合mybatis的插件包 -->     <dependency>        <groupId>org.mybatis</groupId>        <artifactId>mybatis-spring</artifactId>        <version>1.3.1</version>    </dependency>       <!-- mybatis -->    <dependency>        <groupId>org.mybatis</groupId>        <artifactId>mybatis</artifactId>        <version>3.4.2</version>    </dependency>     <!-- log4j -->      <dependency>         <groupId>log4j</groupId>         <artifactId>log4j</artifactId>         <version>1.2.17</version>      </dependency>    </dependencies></project>\n3、搭建Spring3.1 数据库连接配置文件（1）jdbc.properties\nurl=jdbc:mysql://127.0.0.1:3306/shop?characterEncoding=utf-8&serverTimezone=GMTdriver=com.mysql.cj.jdbc.Driverjdbc_username=rootjdbc_password=123456initialSize=10minIdle=5maxActive=20\n（2）db.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"xmlns:aop=\"http://www.springframework.org/schema/aop\"xmlns:tx=\"http://www.springframework.org/schema/tx\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans                     http://www.springframework.org/schema/beans/spring-beans.xsd                    http://www.springframework.org/schema/context                    http://www.springframework.org/schema/context/spring-context.xsd                    http://www.springframework.org/schema/aop                    http://www.springframework.org/schema/aop/spring-aop.xsd                    http://www.springframework.org/schema/tx                    http://www.springframework.org/schema/tx/spring-tx.xsd\">        <!-- 加载属性文件 -->        <context:property-placeholder location=\"jdbc.properties\"/>        <!-- spring管理阿里数据源对象的创建,由此数据源对象管理创建数据库连接对象(Connection) -->        <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">           <property name=\"driverClassName\" value=\"${driver}\"></property>           <property name=\"url\" value=\"${url}\"></property>           <property name=\"username\" value=\"${jdbc_username}\"></property>           <property name=\"password\" value=\"${jdbc_password}\"></property>           <property name=\"initialSize\" value=\"${initialSize}\"></property>           <property name=\"minIdle\" value=\"${minIdle}\"></property>           <property name=\"maxActive\" value=\"${maxActive}\"></property>        </bean>        <!-- 配置事务管理器类 -->        <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">              <property name=\"dataSource\" ref=\"dataSource\"></property>        </bean>         <!-- 开启事务注解功能 -->         <tx:annotation-driven transaction-manager=\"transactionManager\" /></beans>\n（3）application.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"xmlns:aop=\"http://www.springframework.org/schema/aop\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans                     http://www.springframework.org/schema/beans/spring-beans.xsd                    http://www.springframework.org/schema/context                    http://www.springframework.org/schema/context/spring-context.xsd                    http://www.springframework.org/schema/aop                    http://www.springframework.org/schema/aop/spring-aop.xsd\">           <!-- 导入数据库连接配置 -->      <import resource=\"db.xml\"/>      <!-- 开启自动扫描注解 -->       <context:component-scan base-package=\"com.company.springPro\"></context:component-scan></beans>\n4、Dao、Po、mapper以及service类的编写（1）UserPo.java\npackage com.company.project.Po;import java.sql.Date;@Componentpublic class UserPo {    private int id;    private String userName;    private String password;    private Date regTime;    public UserPo() {        // TODO Auto-generated constructor stub    }    public UserPo(String userName, String password, Date regTime) {        super();        this.userName = userName;        this.password = password;        this.regTime = regTime;    }    public int getId() {        return id;    }    public String getUserName() {        return userName;    }    public String getPassword() {        return password;    }    public void setId(int id) {        this.id = id;    }    public void setUserName(String userName) {        this.userName = userName;    }    public void setPassword(String password) {        this.password = password;    }    public Date getRegTime() {        return regTime;    }    public void setRegTime(Date regTime) {        this.regTime = regTime;    }    @Override    public String toString() {        return \"UserPo [id=\" + id + \", userName=\" + userName + \", password=\" + password + \", regTime=\" + regTime + \"]\";    }}\n（2）UserDao.java\npackage com.company.springPro.dao;import java.util.List;import org.springframework.stereotype.Repository;import com.company.springPro.Po.UserPo;@Repositorypublic interface UserDao {    void insert(UserPo userPo);    void update(UserPo userPo);    void delete(int id);    UserPo findById(int id);    List<UserPo> findAll();}\n（3）UserService.java\npackage com.company.springPro.service;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.company.springPro.Po.UserPo;import com.company.springPro.dao.UserDao;@Servicepublic class UserService {    @Autowired    private UserDao userDao;    public UserService() {    }    public void insert(UserPo userPo) {        userDao.insert(userPo);    }    public void update(UserPo userPo) {        userDao.update(userPo);    }    public void delete(int userId) {        userDao.delete(userId);    }    public UserPo findById(int id) {        return userDao.findById(id);    }    public List<UserPo> findAll(){        return userDao.findAll();    }    }\n（4）UserMapper.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE mapper    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"><!--        namespace 指向对应接口的类路径 -->    <mapper namespace=\"com.company.springPro.dao.UserDao\">    <!-- 把重复的sql代码可以提炼出来，通过定义别名把sql列名和java属性对应 -->    <sql id=\"selectResult\">        id,user_name userName,password,reg_time regTime    </sql>    <!-- 高级 -->     <resultMap type=\"UserPo\" id=\"userResult\">         <id property=\"id\" column=\"id\"/>         <result property=\"userName\"  column=\"user_name\"/>         <result property=\"password\"  column=\"password\"/>         <result property=\"regTime\"  column=\"reg_time\"/>     </resultMap>    <!--         id=\"saveUser\":唯一标记        parameterType=\"UserPo\":参数类型        useGeneratedKeys=\"true\"：针对于主键自增         -->    <insert id=\"insert\" parameterType=\"UserPo\" useGeneratedKeys=\"true\" keyColumn=\"id\" keyProperty=\"id\">        insert into t_user(id,user_name,password,reg_time)         values        (#{id},#{userName},#{password},#{regTime})    </insert>    <update id=\"update\" parameterType=\"UserPo\" >        update t_user             set user_name=#{userName},password=#{password},reg_time=#{regTime}            where id = #{id}    </update>    <delete id=\"delete\" parameterType=\"int\">        delete from t_user            where id = #{id}    </delete>    <select id=\"findById\" parameterType=\"int\" resultMap=\"userResult\">        select id,user_name,password,reg_time from t_user where id = #{id}    </select>    <!-- mybatis会自动把得到的数据进行封装，把每条数据封装成对象 ，最后封装成集合-->    <select id=\"findAll\" resultType=\"UserPo\">         select id,user_name,password,reg_time from t_user;    </select></mapper>\n5、搭建MyBatis（1）mybatis-config.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?><!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"><configuration>    <!-- 设置类型自动转换 -->    <settings>        <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>    </settings>    <typeAliases>    <!-- 利用package标签可以直接把整个包的 Po类都导入，这块是导入与数据库表对应的java类-->    <package name=\"com.company.springPro.Po\"/>    </typeAliases>    <!-- 将我们写好的sql映射文件一定要注册到全局配置文件中 -->    <mappers>        <!-- 利用package标签可以直接把整个包的 xml配置文件都导入，这块是导入数据库表与java Po类对应的配置文件 -->        <package name=\"com.company.springPro.mapper\" />    </mappers></configuration>\n（2）配置sqlSessionFactory\n在db.xml文件中添加\n         <!-- 配置sqlSessionFactory spring管理生成SqlSessionFactory对象-->         <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">            <!--注入数据库连接管理对象 -->           <property name=\"dataSource\" ref=\"dataSource\"></property>            <!-- 加载mybatis全局配置文件 -->           <property name=\"configLocation\" value=\"mybatis-config.xml\"></property>            <!-- 加载sql映射文件 -->           <property name=\"mapperLocations\" value=\"com/company/springPro/mapper/*Mapper.xml\"></property>         </bean>         <!-- 指定生成接口代理 -->         <bean id=\"mapperFactory\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">           <property name=\"basePackage\" value=\"com.company.springPro.dao\"></property>            <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"></property>         </bean>\n6、测试package com.company.springPro.test;import java.sql.Date;import java.util.List;import org.apache.log4j.Logger;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.company.springPro.Po.UserPo;import com.company.springPro.service.UserService;import junit.framework.TestCase;public class UserTest extends TestCase{    Logger logger = Logger.getLogger(UserTest.class);    ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\");    UserService userService = (UserService) context.getBean(\"userService\");    public void testInsert() {        //测试期间启动加载spring的写法                         加载spring配置文件,创建一个ApplicationContext        UserPo userPo = new UserPo(\"王五\",\"123456\",new Date(System.currentTimeMillis()));        userService.insert(userPo);    }    public void testUpdate() {        UserPo userPo = new UserPo(\"张三\",\"123\",new Date(System.currentTimeMillis()));        userPo.setId(7);        userService.update(userPo);    }    public void testDelete() {        userService.delete(7);    }    public void testFindById() {        UserPo userPo = userService.findById(1);        logger.debug(userPo.toString());    }    public void testFindAll() {        List<UserPo> userList = userService.findAll();        for(int i = 0;i<userList.size();i++) {            logger.debug(userList.get(i).toString());        }        }}\n', 0, 1);
INSERT INTO `t_article` VALUES (120, '10. SpringMVC框架概述', 8, '\n## 1、SpringMVC 概述\n\nspringmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。\nspringmvc是一个基于mvc的web层框架,方便前后端数据的传输.\nSpring MVC 拥有控制器，接收外部请求，解析参数传给服务层.\n\n\n\n## 2、SpringMVC运行流程\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/wps1.jpg)\n\n**步骤：**\n\n1. 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；\n2. 前端控制器DispatcherServlet接收请求后，调用处理器映射HandlerMapping。\n\n处理器映射器根据请求的url找到处理该请求的处理器Handler（即Controller），将处理器Handler返回给前端控制器DispatcherServlet。\n\n3. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\n\n   HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n\n   数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\n\n   数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n\n   数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\n\n4. Handler(自己的控制器)执行完成后，向DispatcherServlet 返回一个ModelAndView对象；\n\n5. 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；\n\n6. ViewResolver 结合Model和View，来渲染视图\n\n7. 将渲染结果返回给客户端。\n\n\n\n## 3、SpringMVC  组件\n\n- **DispatcherServlet：**Spring中提供了org.springframework.web.servlet.DispatcherServlet类，它从HttpServlet继承而来，它就是Spring MVC中的前端控制器(Front controller)。\n- **HandlerMapping：**DispatcherServlet自己并不处理请求，而是将请求交给页面控制器。那么在DispatcherServlet中如何选择正确的页面控制器呢？这件事情就交给HandlerMapping来做了，经过了HandlerMapping处理之后，DispatcherServlet就知道要将请求交给哪个页面控制器来处理了。\n- **HandlerAdapter：**经过了HandlerMapping处理之后，DispatcherServlet就获取到了处理器，但是处理器有多种，为了方便调用，DispatcherServlet将这些处理器包装成处理器适配器HandlerAdapter，HandlerAdapter调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）。\n- **ModelAndView：**DispatcherServlet取得了ModelAndView之后，需要将把逻辑视图名解析为具体的View，比如jsp视图，pdf视图等，这个解析过程由ViewResolver来完成。\n- **ViewResolver：**ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术。\n- **View：**DispatcherServlet通过ViewResolver取得了具体的view之后，就需要将model中的数据渲染到视图上，最终DispatcherServlet将渲染的结果响应到客户端。', 0, 0, '2020-08-07 00:47:22', 2, 0, 2, '1、SpringMVC 概述springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。springmvc是一个基于mvc的web层框架,方便前后端数据的传输.Spring MVC 拥有控制器，接收外部请求，解析参数传给服务层.\n2、SpringMVC运行流程\n步骤：\n\n用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；前端控制器DispatcherServlet接收请求后，调用处理器映射HandlerMapping。\n处理器映射器根据请求的url找到处理该请求的处理器Handler（即Controller），将处理器Handler返回给前端控制器DispatcherServlet。\n\nDispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\nHttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\n数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\n数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\nHandler(自己的控制器)执行完成后，向DispatcherServlet 返回一个ModelAndView对象；\n根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；\nViewResolver 结合Model和View，来渲染视图\n将渲染结果返回给客户端。\n\n3、SpringMVC  组件\nDispatcherServlet：Spring中提供了org.springframework.web.servlet.DispatcherServlet类，它从HttpServlet继承而来，它就是Spring MVC中的前端控制器(Front controller)。HandlerMapping：DispatcherServlet自己并不处理请求，而是将请求交给页面控制器。那么在DispatcherServlet中如何选择正确的页面控制器呢？这件事情就交给HandlerMapping来做了，经过了HandlerMapping处理之后，DispatcherServlet就知道要将请求交给哪个页面控制器来处理了。HandlerAdapter：经过了HandlerMapping处理之后，DispatcherServlet就获取到了处理器，但是处理器有多种，为了方便调用，DispatcherServlet将这些处理器包装成处理器适配器HandlerAdapter，HandlerAdapter调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）。ModelAndView：DispatcherServlet取得了ModelAndView之后，需要将把逻辑视图名解析为具体的View，比如jsp视图，pdf视图等，这个解析过程由ViewResolver来完成。ViewResolver：ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术。View：DispatcherServlet通过ViewResolver取得了具体的view之后，就需要将model中的数据渲染到视图上，最终DispatcherServlet将渲染的结果响应到客户端。\n', 0, 1);
INSERT INTO `t_article` VALUES (121, '11. 搭建SpringMVC', 8, '\n## 1、pom.xml 导包\n\n```xml\n<!-- spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.2.RELEASE</version>\n</dependency>\n\n<!-- jstl -->\n<dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>jstl</artifactId>\n    <version>1.2</version>\n</dependency>\n```\n\n## 2、web.xml中配置 DispatcherServlet\n\n```xml\n<!--  配置spring 核心请求分发器-->\n  <servlet>\n    <servlet-name>springMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <!-- 配置初始化参数,加载spring配置文件 -->\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <!-- <param-value>/WEB-INF/classes/application.xml</param-value> -->\n      <param-value>classpath:application.xml</param-value>\n    </init-param>\n    <!-- 启动时就创建 DispatcherServlet对象,并加载spring框架-->\n    <load-on-startup>0</load-on-startup>\n  </servlet>\n\n  <!-- 配置请求映射地址 -->\n  <servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n```\n\n## 3、开启SpringMVC注解\n\n```xml\n<!-- 开启springmvc注解 -->\n<mvc:annotation-driven></mvc:annotation-driven>\n```\n\n## 4、配置视图解析器\n\n```xml\n    <!-- 视图解析器 -->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"></property>\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"></property>\n        <property name=\"suffix\" value=\".jsp\"></property>\n    </bean>\n```\n\n## 5、控制器类搭建\n\n@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象\n\n@RequestMapping 注解是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n\n\n```java\npackage com.company.springMVC.service;\n\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.ModelAndView;\n\n/*\n定义控制层类，spring生成控制层类对象\n */\n@Controller\n/*\n@RequestMapping使用前,需要在配置文件中开启springMVC注解功能\n可以作用于类、方法\n作用于类就是为了类提供一个映射地址,在整个项目中必须是唯一的.\n作用于方法是为方法提供映射地址,在同一个类中必须是唯一的.\n */\n@RequestMapping(value = \"/user\")\npublic class UserController {\n\n    /*\n    @RequestMapping\n    value/path 指定请求方法的映射地址  可以为多个\n    method 指定哪些请求方式可以访问此方法 ,如果没有定义 get/post均可访问\n     */\n    @RequestMapping(value = \"/firstUserList\")\n    public ModelAndView findUserList() {\n        System.out.println(\"2sdsd\");\n        //创建ModelAndView对象，设置视图名（jsp的地址，根目录是WEB-INF），数据\n        ModelAndView mv = new ModelAndView(\"user/userList\");\n        mv.addObject(\"userName\", \"jim\");\n        return mv;\n    }\n}\n```\n\n\n\n## 6、jsp显示  \n\n路径：WEB-INF/jsp/user/userList.jps\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n用户列表\n${userName}\n</body>\n</html>\n```\n\n', 0, 0, '2020-08-07 00:48:07', 2, 0, 1, '1、pom.xml 导包<!-- spring-webmvc --><dependency>    <groupId>org.springframework</groupId>    <artifactId>spring-webmvc</artifactId>    <version>5.2.2.RELEASE</version></dependency><!-- jstl --><dependency>    <groupId>javax.servlet</groupId>    <artifactId>jstl</artifactId>    <version>1.2</version></dependency>\n2、web.xml中配置 DispatcherServlet<!--  配置spring 核心请求分发器-->  <servlet>    <servlet-name>springMVC</servlet-name>    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>    <!-- 配置初始化参数,加载spring配置文件 -->    <init-param>      <param-name>contextConfigLocation</param-name>      <!-- <param-value>/WEB-INF/classes/application.xml</param-value> -->      <param-value>classpath:application.xml</param-value>    </init-param>    <!-- 启动时就创建 DispatcherServlet对象,并加载spring框架-->    <load-on-startup>0</load-on-startup>  </servlet>  <!-- 配置请求映射地址 -->  <servlet-mapping>    <servlet-name>springMVC</servlet-name>    <url-pattern>/</url-pattern>  </servlet-mapping>\n3、开启SpringMVC注解<!-- 开启springmvc注解 --><mvc:annotation-driven></mvc:annotation-driven>\n4、配置视图解析器    <!-- 视图解析器 -->    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">        <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"></property>        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"></property>        <property name=\"suffix\" value=\".jsp\"></property>    </bean>\n5、控制器类搭建@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象\n@RequestMapping 注解是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\npackage com.company.springMVC.service;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;/*定义控制层类，spring生成控制层类对象 */@Controller/*@RequestMapping使用前,需要在配置文件中开启springMVC注解功能可以作用于类、方法作用于类就是为了类提供一个映射地址,在整个项目中必须是唯一的.作用于方法是为方法提供映射地址,在同一个类中必须是唯一的. */@RequestMapping(value = \"/user\")public class UserController {    /*    @RequestMapping    value/path 指定请求方法的映射地址  可以为多个    method 指定哪些请求方式可以访问此方法 ,如果没有定义 get/post均可访问     */    @RequestMapping(value = \"/firstUserList\")    public ModelAndView findUserList() {        System.out.println(\"2sdsd\");        //创建ModelAndView对象，设置视图名（jsp的地址，根目录是WEB-INF），数据        ModelAndView mv = new ModelAndView(\"user/userList\");        mv.addObject(\"userName\", \"jim\");        return mv;    }}\n6、jsp显示路径：WEB-INF/jsp/user/userList.jps\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %><html><head>    <title>Title</title></head><body>用户列表${userName}</body></html>\n', 0, 1);
INSERT INTO `t_article` VALUES (122, '12. 解决绝对路径和静态资源访问', 8, '\n## 1、设置绝对路径\n\n路径问题一直在访问过程中一直存在，如果把所有的路径都替换为绝对路径，就可以解决这个问题。\n\n### 1.1 编写过滤器\n\nObjectListener.java\n\n```java\npackage com.company.springMVC.util;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\n\n/**\n * 监听器类\n * 设置全局默认地址\n */\npublic class ObjectListener implements ServletContextListener {\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println(\"ServletContext对象创建\");\n\n        //监听ServletContext 对象的创建\n        ServletContext context = sce.getServletContext();\n        context.setAttribute(\"path\", context.getContextPath());\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n    }\n}\n```\n\n### 1.2 配置监听器\n\nweb.xml\n\n```xml\n  <!-- 配置监听器 -->\n  <listener>\n    <listener-class>com.company.springMVC.util.ObjectListener</listener-class>\n  </listener>\n```\n\n### 1.3 使用绝对路径\n\n使用EL表达式 ${path}\n\n```jsp\n<form id=\"formID\" action=\"${path}/userController/userSave\">\n    用户名：<input type=\"text\" name=\"userName\">\n    <br/>\n    密码：<input type=\"password\" name=\"password\">\n    <input type=\"submit\" value=\"提交\" id=\"submitBtn\">\n</form>\n```\n\n\n\n## 2、设置静态资源访问\n\n由于SpringMVC的特性，静态资源默认是不允许被访问的，需要修改配置。\n\n在SpringMVC的配置文件中springmvc.xml\n\n```xml\n<!-- 过滤静态资源文件  -->\n<mvc:default-servlet-handler/>\n```\n\n', 0, 0, '2020-08-07 00:48:51', 2, 0, 1, '1、设置绝对路径路径问题一直在访问过程中一直存在，如果把所有的路径都替换为绝对路径，就可以解决这个问题。\n1.1 编写过滤器ObjectListener.java\npackage com.company.springMVC.util;import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;/** * 监听器类 * 设置全局默认地址 */public class ObjectListener implements ServletContextListener {    @Override    public void contextInitialized(ServletContextEvent sce) {        System.out.println(\"ServletContext对象创建\");        //监听ServletContext 对象的创建        ServletContext context = sce.getServletContext();        context.setAttribute(\"path\", context.getContextPath());    }    @Override    public void contextDestroyed(ServletContextEvent sce) {    }}\n1.2 配置监听器web.xml\n  <!-- 配置监听器 -->  <listener>    <listener-class>com.company.springMVC.util.ObjectListener</listener-class>  </listener>\n1.3 使用绝对路径使用EL表达式 ${path}\n<form id=\"formID\" action=\"${path}/userController/userSave\">    用户名：<input type=\"text\" name=\"userName\">    <br/>    密码：<input type=\"password\" name=\"password\">    <input type=\"submit\" value=\"提交\" id=\"submitBtn\"></form>\n2、设置静态资源访问由于SpringMVC的特性，静态资源默认是不允许被访问的，需要修改配置。\n在SpringMVC的配置文件中springmvc.xml\n<!-- 过滤静态资源文件  --><mvc:default-servlet-handler/>\n', 0, 1);
INSERT INTO `t_article` VALUES (123, '13. SpringMVC请求转发与重定向', 8, '\n\n## 1、概述 \n\nSpringMVC默认响应时使用请求转发方式,返回值可以是ModelAndView,String\n\n控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息。\n• 添加模型数据: addObject(String attributeName, Object  attributeValue)\n• 设置视图: void setViewName(String viewName)\n\n如果返回String,可以将数据封装到一个Model对象中,直返返回字符串格式的视图名即可.\n\n\n\n## 2、标签解释\n\n#### @Controller\n\nSpring 配置中指定了自动扫描的basepackage后，Spring会扫描这些包以及子包中的使用了@Controller标识的类，然后将类加入到Spring IOC容器中，注入依赖。需要注意的是这个bean在spring IOC容器中是单例的，每次请求到来的时候，使用的是同一个bean对象。\n\n#### @RequestMapping\n\n它的作用就是与请求相匹配，如果匹配上了，所修饰的方法才会被执行。这里我们只需要关注两个属性：\n\nvalue :请求的路径，这个路径相对于应用的上下文，它是path的别名。类型是一个String[] ,也就是说它可以匹配多个请求路径\n\nmethod: 请求的方法。我们知道HTTP协议的请求方式有 GET和POST.\n\n或者使用@GetMapping, @PostMapping\n\n \n\n当前的请求只有与@RequestMapping上指定的属性都匹配的时候，才会执行它标注的方法。下面分析几个例子,假设应用的上下文路径为 \"http://localhost:9090/\"\n\n@RequestMapping(\"/users\")  请求的路径为 \"http://localhost:9090/users\" ,请求方式没有限制，即可以是GET也可以是POST，还能是其它的几个\n\n@RequestMapping(value=\"/users\", method= RequestMethod.GET) 请求路径为\"http://localhost:9090/users\", 请求方式只能是GET。\n\n@RequestMapping(value=\"/users\", method={ RequestMethod.GET , RequestMethod.POST}) 请求路径为“http://localhost:9090/users”, 请求方式只能是GET或者POST。\n\n@RequestMapping({\"/home\",\"/index\",\"/\",\"\"})  可以匹配的路径有4个，\"http://localhost:9090/home\" , \"http://localhost:9090/index\" , \"http://localhost:9090/\" , \"http://localhost:9090\" ,而请求方式没有限制\n\n\n\n## 3、请求转发\n\n@RequestMapping \n\nvalue/path 指定请求方法的映射地址  可以为多个。\nmethod 指定哪些请求方式可以访问此方法 ,如果没有定义，get/post均可访问。\n\n```java\n    @RequestMapping(value = \"/first\", method = RequestMethod.GET)\n    public ModelAndView findUserList() {\n        //创建ModelAndView对象，设置视图名（jsp的地址），数据，视图名就是请求转发的地址\n        ModelAndView mv = new ModelAndView(\"user/userList\");\n        mv.addObject(\"userName\", \"jim\");\n        return mv;\n    }\n```\n\n\n\n## 4、获取请求头部信息\n\n（1）@RequestHeader(\"User-Agent\") String userAgent\n把请求头中参数值 绑定给 指定的变量\n\n（2）@RequestParam(\"account\") String acc\n把请求中(表单)中的参数 绑定给指定的变量\n\n```java\n    @RequestMapping(value = \"/second\")\n    public ModelAndView second(@RequestHeader(\"User-Agent\") String agent){\n        //创建ModelAndView对象，设置视图名（jsp的地址），数据\n        ModelAndView mv = new ModelAndView(\"user/userList\");\n        System.out.println(agent);\n        return mv;\n    }\n```\n\n\n\n## 5、接收请求参数\n\n### 5.1 方法一：请求参数与形参对应\n\n```java\n    @RequestMapping(value = \"/third\")\n    public ModelAndView third(@RequestHeader(\"userName\") String userName,@RequestHeader(\"passWord\") String passWord){\n        //创建ModelAndView对象，设置视图名（jsp的地址），数据\n        ModelAndView mv = new ModelAndView(\"user/userList\");\n        System.out.println(userName);\n        System.out.println(passWord);\n        return mv;\n    }\n```\n\n\n\n### 5.2 方法二：省略请求参数\n\n可以把形参设置和请求参数一致，这样SpringMVC就会自动匹配。\n\n```java\n    /*\n    获取参数方式1：\n    @RequestHeader(\"userName\") String userName\n    请求参数与形参对应\n     */\n    @RequestMapping(value = \"/four\")\n    public ModelAndView four(String userName,String passWord){\n        //创建ModelAndView对象，设置视图名（jsp的地址），数据\n        ModelAndView mv = new ModelAndView(\"user/userList\");\n        System.out.println(userName);\n        System.out.println(passWord);\n        return mv;\n    }\n```\n\n\n\n### 5.3 方法三：利用对象自动封装\n\n可以把形参设置为接收对象，但是对象的属性名应该和请求参数一致，这样SpringMVC就会自动匹配。\n\n```java\n    @RequestMapping(value = \"/four\")\n    public ModelAndView four(User user){\n        //创建ModelAndView对象，设置视图名（jsp的地址），数据\n        ModelAndView mv = new ModelAndView(\"user/userList\");\n        System.out.println(user.getUserName());\n        System.out.println(user.getPassword());\n        return mv;\n    }\n```\n\n## 6、获取servlet 内置对象\n\n可以直接将servlet内置对象作为形参创建，SpringMVC会自动匹配到内置对象进行赋值。\n\n```java\n    @RequestMapping(value = \"/userSave\")\n    public ModelAndView userSave(User user, HttpSession session){\n\n        System.out.println(user.getUserName());\n        System.out.println(user.getPassword());\n        System.out.println(user.getRegTime());\n        session.setAttribute(\"userInfo\", user);\n        ModelAndView mv = new ModelAndView(\"user/save\");\n        return mv;\n    }\n```\n\n\n\n## 7、重定向\n\n控制器方法返回字符串类型的值会被当成逻辑视图名处理,如果返回的字符串中带 redirect: 前缀时，SpringMVC 会对他们进行特殊处理：将 redirect: 当成指示符，其后的字符串作为 URL 来处理\n\nreturn \"redirect:/page/student/update.jsp\"; \n\n```java\n    @RequestMapping(value=\"/save\")\n    public String saveUser(User user, String mark, HttpServletRequest req){\n        //调用数据访问层\n        //userService.saveUser(user);\n        //把数据封装到HttpServletRequest对象中\n        req.setAttribute(\"userName\",\"jim\");\n        req.setAttribute(\"userAge\",23);\n        System.out.println(\"12311\");\n        //return \"redirect:/test.jsp\";\n        //字符串以redirect开头,进行重定向处理,不能访问web-inf下面的jsp\n        return \"redirect:/index.jsp\";\n    }\n```\n\n', 0, 0, '2020-08-07 00:49:38', 6, 0, 1, '1、概述SpringMVC默认响应时使用请求转发方式,返回值可以是ModelAndView,String\n控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息。• 添加模型数据: addObject(String attributeName, Object  attributeValue)• 设置视图: void setViewName(String viewName)\n如果返回String,可以将数据封装到一个Model对象中,直返返回字符串格式的视图名即可.\n2、标签解释@ControllerSpring 配置中指定了自动扫描的basepackage后，Spring会扫描这些包以及子包中的使用了@Controller标识的类，然后将类加入到Spring IOC容器中，注入依赖。需要注意的是这个bean在spring IOC容器中是单例的，每次请求到来的时候，使用的是同一个bean对象。\n@RequestMapping它的作用就是与请求相匹配，如果匹配上了，所修饰的方法才会被执行。这里我们只需要关注两个属性：\nvalue :请求的路径，这个路径相对于应用的上下文，它是path的别名。类型是一个String[] ,也就是说它可以匹配多个请求路径\nmethod: 请求的方法。我们知道HTTP协议的请求方式有 GET和POST.\n或者使用@GetMapping, @PostMapping\n当前的请求只有与@RequestMapping上指定的属性都匹配的时候，才会执行它标注的方法。下面分析几个例子,假设应用的上下文路径为 “http://localhost:9090/“\n@RequestMapping(“/users”)  请求的路径为 “http://localhost:9090/users“ ,请求方式没有限制，即可以是GET也可以是POST，还能是其它的几个\n@RequestMapping(value=”/users”, method= RequestMethod.GET) 请求路径为”http://localhost:9090/users“, 请求方式只能是GET。\n@RequestMapping(value=”/users”, method={ RequestMethod.GET , RequestMethod.POST}) 请求路径为“http://localhost:9090/users”, 请求方式只能是GET或者POST。\n@RequestMapping({“/home”,”/index”,”/“,””})  可以匹配的路径有4个，”http://localhost:9090/home“ , “http://localhost:9090/index“ , “http://localhost:9090/“ , “http://localhost:9090“ ,而请求方式没有限制\n3、请求转发@RequestMapping \nvalue/path 指定请求方法的映射地址  可以为多个。method 指定哪些请求方式可以访问此方法 ,如果没有定义，get/post均可访问。\n    @RequestMapping(value = \"/first\", method = RequestMethod.GET)    public ModelAndView findUserList() {        //创建ModelAndView对象，设置视图名（jsp的地址），数据，视图名就是请求转发的地址        ModelAndView mv = new ModelAndView(\"user/userList\");        mv.addObject(\"userName\", \"jim\");        return mv;    }\n4、获取请求头部信息（1）@RequestHeader(“User-Agent”) String userAgent把请求头中参数值 绑定给 指定的变量\n（2）@RequestParam(“account”) String acc把请求中(表单)中的参数 绑定给指定的变量\n    @RequestMapping(value = \"/second\")    public ModelAndView second(@RequestHeader(\"User-Agent\") String agent){        //创建ModelAndView对象，设置视图名（jsp的地址），数据        ModelAndView mv = new ModelAndView(\"user/userList\");        System.out.println(agent);        return mv;    }\n5、接收请求参数5.1 方法一：请求参数与形参对应    @RequestMapping(value = \"/third\")    public ModelAndView third(@RequestHeader(\"userName\") String userName,@RequestHeader(\"passWord\") String passWord){        //创建ModelAndView对象，设置视图名（jsp的地址），数据        ModelAndView mv = new ModelAndView(\"user/userList\");        System.out.println(userName);        System.out.println(passWord);        return mv;    }\n5.2 方法二：省略请求参数可以把形参设置和请求参数一致，这样SpringMVC就会自动匹配。\n    /*    获取参数方式1：    @RequestHeader(\"userName\") String userName    请求参数与形参对应     */    @RequestMapping(value = \"/four\")    public ModelAndView four(String userName,String passWord){        //创建ModelAndView对象，设置视图名（jsp的地址），数据        ModelAndView mv = new ModelAndView(\"user/userList\");        System.out.println(userName);        System.out.println(passWord);        return mv;    }\n5.3 方法三：利用对象自动封装可以把形参设置为接收对象，但是对象的属性名应该和请求参数一致，这样SpringMVC就会自动匹配。\n    @RequestMapping(value = \"/four\")    public ModelAndView four(User user){        //创建ModelAndView对象，设置视图名（jsp的地址），数据        ModelAndView mv = new ModelAndView(\"user/userList\");        System.out.println(user.getUserName());        System.out.println(user.getPassword());        return mv;    }\n6、获取servlet 内置对象可以直接将servlet内置对象作为形参创建，SpringMVC会自动匹配到内置对象进行赋值。\n    @RequestMapping(value = \"/userSave\")    public ModelAndView userSave(User user, HttpSession session){        System.out.println(user.getUserName());        System.out.println(user.getPassword());        System.out.println(user.getRegTime());        session.setAttribute(\"userInfo\", user);        ModelAndView mv = new ModelAndView(\"user/save\");        return mv;    }\n7、重定向控制器方法返回字符串类型的值会被当成逻辑视图名处理,如果返回的字符串中带 redirect: 前缀时，SpringMVC 会对他们进行特殊处理：将 redirect: 当成指示符，其后的字符串作为 URL 来处理\nreturn “redirect:/page/student/update.jsp”; \n    @RequestMapping(value=\"/save\")    public String saveUser(User user, String mark, HttpServletRequest req){        //调用数据访问层        //userService.saveUser(user);        //把数据封装到HttpServletRequest对象中        req.setAttribute(\"userName\",\"jim\");        req.setAttribute(\"userAge\",23);        System.out.println(\"12311\");        //return \"redirect:/test.jsp\";        //字符串以redirect开头,进行重定向处理,不能访问web-inf下面的jsp        return \"redirect:/index.jsp\";    }\n', 0, 1);
INSERT INTO `t_article` VALUES (124, '14. SpringMVC解决中文乱码问题', 8, '\n\n​	我们发现在提交请求的时候，如果输入的是中文，处理器方法获取到之后是乱码。乱码产生的原因在Java Web课程中已经讲解过了，解决的方法就是添加一个过滤器，为request对象设置编码集。SpringMVC中已经为我们提供了这个过滤器，只需要在web.xml中配置好即可：\n\n```xml\n  <!-- 编写过滤器 解决中文乱码问题-->\n  <filter>\n    <filter-name>characterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n      <param-name>encoding</param-name>\n      <param-value>UTF-8</param-value>\n    </init-param>\n  </filter>\n\n  <!-- 配置过滤器  /*代表项目下所有文件 -->\n  <filter-mapping>\n    <filter-name>characterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n\n```\n\n', 0, 0, '2020-08-07 00:50:10', 2, 0, 1, '​    我们发现在提交请求的时候，如果输入的是中文，处理器方法获取到之后是乱码。乱码产生的原因在Java Web课程中已经讲解过了，解决的方法就是添加一个过滤器，为request对象设置编码集。SpringMVC中已经为我们提供了这个过滤器，只需要在web.xml中配置好即可：\n  <!-- 编写过滤器 解决中文乱码问题-->  <filter>    <filter-name>characterEncodingFilter</filter-name>    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>    <init-param>      <param-name>encoding</param-name>      <param-value>UTF-8</param-value>    </init-param>  </filter>  <!-- 配置过滤器  /*代表项目下所有文件 -->  <filter-mapping>    <filter-name>characterEncodingFilter</filter-name>    <url-pattern>/*</url-pattern>  </filter-mapping>\n', 0, 1);
INSERT INTO `t_article` VALUES (125, '15. SpringMVC的Ajax', 8, '\n\n@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来向异步请求返回JSON数据。\n\n注意：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。\n\n（1）添加jacksonjar包\n\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.9.1</version>\n</dependency>\n```\n\n（2）利用jQuery来实现Ajax异步请求\n\n```jsp\n<%--\n  Created by IntelliJ IDEA.\n  User: God_86\n  Date: 2020/6/29\n  Time: 21:52\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>填写用户信息</title>\n    <script type=\"text/javascript\" src=\"${path}/statics/js/jQuery3.5.1.js\"></script>\n    <script type=\"text/javascript\">\n        $(function () {\n            $(\"#submitBtn\").click(function () {\n                $.post(\"${path}/userController/userSave\",$(\'#formID\').serialize(),function (data) {\n                    alert(data.userName)\n                })\n            })\n        })\n\n    </script>\n</head>\n\n<body>\n<form id=\"formID\">\n    用户名：<input type=\"text\" name=\"userName\">\n    <br/>\n    密码：<input type=\"password\" name=\"password\">\n    <input type=\"button\" value=\"提交\" id=\"submitBtn\">\n</form>\n</body>\n</html>\n```\n\n（3）写处理方法\n\n```java\n    @RequestMapping(value = \"/userSave\")\n    @ResponseBody   //将返回的内容以流的形式响应 == resp.getWriter().print(\"\");\n    //springMVC异步返回结果时,是以json格式返回的\n    public User userSave(User user, HttpSession session){\n        System.out.println(user.getUserName());\n        System.out.println(user.getPassword());\n        System.out.println(user.getRegTime());\n        return user;\n    }\n```\n\n', 0, 0, '2020-08-07 00:50:53', 2, 0, 1, '@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来向异步请求返回JSON数据。\n注意：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。\n（1）添加jacksonjar包\n<dependency>    <groupId>com.fasterxml.jackson.core</groupId>    <artifactId>jackson-databind</artifactId>    <version>2.9.1</version></dependency>\n（2）利用jQuery来实现Ajax异步请求\n<%--  Created by IntelliJ IDEA.  User: God_86  Date: 2020/6/29  Time: 21:52  To change this template use File | Settings | File Templates.--%><%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %><html><head>    <title>填写用户信息</title>    <script type=\"text/javascript\" src=\"${path}/statics/js/jQuery3.5.1.js\"></script>    <script type=\"text/javascript\">        $(function () {            $(\"#submitBtn\").click(function () {                $.post(\"${path}/userController/userSave\",$(\'#formID\').serialize(),function (data) {                    alert(data.userName)                })            })        })    </script></head><body><form id=\"formID\">    用户名：<input type=\"text\" name=\"userName\">    <br/>    密码：<input type=\"password\" name=\"password\">    <input type=\"button\" value=\"提交\" id=\"submitBtn\"></form></body></html>\n（3）写处理方法\n    @RequestMapping(value = \"/userSave\")    @ResponseBody   //将返回的内容以流的形式响应 == resp.getWriter().print(\"\");    //springMVC异步返回结果时,是以json格式返回的    public User userSave(User user, HttpSession session){        System.out.println(user.getUserName());        System.out.println(user.getPassword());        System.out.println(user.getRegTime());        return user;    }\n', 0, 1);
INSERT INTO `t_article` VALUES (126, '16. 文件上传和下载', 8, '\n\n## 1、导入上传下载所需jar文件\n\n```xml\n    <!-- 文件的上传和下载 -->\n    <dependency>\n      <groupId>commons-fileupload</groupId>\n      <artifactId>commons-fileupload</artifactId>\n      <version>1.3.3</version>\n    </dependency>\n```\n\n\n\n## 2、在springmvc.xml中配置文件解析器\n\n```xml\n    <!-- 文件解析器 -->\n    <bean id=\"multipartResolver\"  class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n        <property name=\"defaultEncoding\" value=\"utf-8\"></property>\n        <property name=\"maxUploadSize\" value=\"10485760\"></property>\n    </bean>\n```\n\n\n\n## 3、编写service业务类\n\n**控制器类**\n\n```java\n@RequestParam(“fileName”) CommonsMultipartFile file接收文件\nfile.getOriginalFilename();获得原始文件名\nfile.getContentType();获得文件类型\nfile.getInputStream();获得输入流对象\n```\n\n**文件下载**\n\n```java\n设置响应内容\nresponse.setContentType(\"applicatoin/octet-stream\");代表任意的二进制数据\nresponse.setHeader(“content-disposition\", \"attachment;filename=\"+\nnew String(filename.getBytes(\"utf-8\"),“ISO-8859-1\"));\nContent-disposition,attachment; filename= :告诉浏览器下载文件的名称,弹出文件下载框\nfilename:文件名称，如果为中文，则会出现乱码。\n使用fileName = new String(fileName.getBytes(), \"ISO8859-1\")\n通过response对象获取OutputStream对象\nresponse.getOutputStream();\n```\n\n\n\n**示例：**\n\n```java\npackage com.company.springmvc.service;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.multipart.commons.CommonsMultipartFile;\nimport org.springframework.web.servlet.ModelAndView;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\n\n@Controller\n@RequestMapping(\"/fileManage\")\npublic class FileManage {\n\n    @RequestMapping(\"/toFileUpload\")\n    public ModelAndView toFileUpload(){\n        ModelAndView mv = new ModelAndView(\"file/fileUpload\");\n        return mv;\n    }\n\n    @RequestMapping(\"/fileUpload\")\n    public ModelAndView fileUpload(@RequestParam(\"fileupload\") CommonsMultipartFile file){\n        String path = \"\";\n        String filename = \"\";\n        try {\n            filename = file.getOriginalFilename();\n            path = \"D:\\\\Program Files\\\\apache-tomcat-8.5.53\\\\webapps\\\\userFile\\\\\"+filename;\n            File f = new File(path);\n            file.transferTo(f);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        ModelAndView mv = new ModelAndView(\"file/uploadOver\");\n        mv.addObject(\"imgPath\", filename);\n        return  mv;\n    }\n\n    @RequestMapping(\"/downLoad\")\n    public ModelAndView downLoad(String fileName , HttpServletResponse response){\n        String path = \"D:\\\\Program Files\\\\apache-tomcat-8.5.53\\\\webapps\\\\userFile\\\\\" + fileName;\n\n        try {\n            FileInputStream in = new FileInputStream(path);\n            //下载文件响应设置\n            //以二进制字符流响应\n            response.setContentType(\"application/octet-stream\");\n            //调用浏览器下载器，选择文件存放位置\n            response.setHeader(\"content-disposition\",\"filename=\"+ new String( \"我的图像.jpg\".getBytes(\"utf-8\"),\"ISO-8859-1\"));\n\n            OutputStream out = response.getOutputStream();\n            byte [] b = new byte[1024];\n            int length = 0;\n            while ((length = in.read(b)) != -1){\n                out.write(b, 0, length);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        ModelAndView mv = new ModelAndView(\"file/uploadOver\");\n        mv.addObject(\"imgPath\", fileName);\n        return  mv;\n    }\n}\n```\n\n\n\n## 3、编写jsp\n\n**表单：**\n\n```jsp\nmethod=\"post\" \nenctype=\"multipart/form-data\"\n```\n\nfileUpload.jsp\n\n```jsp\n<%--\n  Created by IntelliJ IDEA.\n  User: God_86\n  Date: 2020/6/30\n  Time: 10:21\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>文件上传</title>\n</head>\n<body>\n    <h1>文件上传</h1>\n    <form action=\"${path}/fileManage/fileUpload\"  method=\"post\" enctype=\"multipart/form-data\">\n        <input type=\"file\" name=\"fileupload\">\n        <input type=\"submit\" value=\"上传\">\n    </form>\n\n</body>\n</html>\n```\n\n\n\nuploadOver.jsp\n\n```java\n<%--\n  Created by IntelliJ IDEA.\n  User: God_86\n  Date: 2020/6/30\n  Time: 10:41\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>文件上传完成</title>\n</head>\n<body>\n<h1>文件上传完成</h1>\n<a href=\"${path}/fileManage/downLoad?fileName=${imgPath}\">\n    <img src=\"http://127.0.0.1:8888/userFile/${imgPath}\">\n</a>\n</body>\n</html>\n```\n\n', 0, 0, '2020-08-07 00:51:50', 2, 0, 1, '1、导入上传下载所需jar文件    <!-- 文件的上传和下载 -->    <dependency>      <groupId>commons-fileupload</groupId>      <artifactId>commons-fileupload</artifactId>      <version>1.3.3</version>    </dependency>\n2、在springmvc.xml中配置文件解析器    <!-- 文件解析器 -->    <bean id=\"multipartResolver\"  class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">        <property name=\"defaultEncoding\" value=\"utf-8\"></property>        <property name=\"maxUploadSize\" value=\"10485760\"></property>    </bean>\n3、编写service业务类控制器类\n@RequestParam(“fileName”) CommonsMultipartFile file接收文件file.getOriginalFilename();获得原始文件名file.getContentType();获得文件类型file.getInputStream();获得输入流对象\n文件下载\n设置响应内容response.setContentType(\"applicatoin/octet-stream\");代表任意的二进制数据response.setHeader(“content-disposition\", \"attachment;filename=\"+new String(filename.getBytes(\"utf-8\"),“ISO-8859-1\"));Content-disposition,attachment; filename= :告诉浏览器下载文件的名称,弹出文件下载框filename:文件名称，如果为中文，则会出现乱码。使用fileName = new String(fileName.getBytes(), \"ISO8859-1\")通过response对象获取OutputStream对象response.getOutputStream();\n示例：\npackage com.company.springmvc.service;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.commons.CommonsMultipartFile;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;@Controller@RequestMapping(\"/fileManage\")public class FileManage {    @RequestMapping(\"/toFileUpload\")    public ModelAndView toFileUpload(){        ModelAndView mv = new ModelAndView(\"file/fileUpload\");        return mv;    }    @RequestMapping(\"/fileUpload\")    public ModelAndView fileUpload(@RequestParam(\"fileupload\") CommonsMultipartFile file){        String path = \"\";        String filename = \"\";        try {            filename = file.getOriginalFilename();            path = \"D:\\\\Program Files\\\\apache-tomcat-8.5.53\\\\webapps\\\\userFile\\\\\"+filename;            File f = new File(path);            file.transferTo(f);        } catch (Exception e) {            e.printStackTrace();        }        ModelAndView mv = new ModelAndView(\"file/uploadOver\");        mv.addObject(\"imgPath\", filename);        return  mv;    }    @RequestMapping(\"/downLoad\")    public ModelAndView downLoad(String fileName , HttpServletResponse response){        String path = \"D:\\\\Program Files\\\\apache-tomcat-8.5.53\\\\webapps\\\\userFile\\\\\" + fileName;        try {            FileInputStream in = new FileInputStream(path);            //下载文件响应设置            //以二进制字符流响应            response.setContentType(\"application/octet-stream\");            //调用浏览器下载器，选择文件存放位置            response.setHeader(\"content-disposition\",\"filename=\"+ new String( \"我的图像.jpg\".getBytes(\"utf-8\"),\"ISO-8859-1\"));            OutputStream out = response.getOutputStream();            byte [] b = new byte[1024];            int length = 0;            while ((length = in.read(b)) != -1){                out.write(b, 0, length);            }            out.close();            in.close();        } catch (Exception e) {            e.printStackTrace();        }        ModelAndView mv = new ModelAndView(\"file/uploadOver\");        mv.addObject(\"imgPath\", fileName);        return  mv;    }}\n3、编写jsp表单：\nmethod=\"post\" enctype=\"multipart/form-data\"\nfileUpload.jsp\n<%--  Created by IntelliJ IDEA.  User: God_86  Date: 2020/6/30  Time: 10:21  To change this template use File | Settings | File Templates.--%><%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %><html><head>    <title>文件上传</title></head><body>    <h1>文件上传</h1>    <form action=\"${path}/fileManage/fileUpload\"  method=\"post\" enctype=\"multipart/form-data\">        <input type=\"file\" name=\"fileupload\">        <input type=\"submit\" value=\"上传\">    </form></body></html>\nuploadOver.jsp\n<%--  Created by IntelliJ IDEA.  User: God_86  Date: 2020/6/30  Time: 10:41  To change this template use File | Settings | File Templates.--%><%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %><html><head>    <title>文件上传完成</title></head><body><h1>文件上传完成</h1><a href=\"${path}/fileManage/downLoad?fileName=${imgPath}\">    <img src=\"http://127.0.0.1:8888/userFile/${imgPath}\"></a></body></html>\n', 0, 1);
INSERT INTO `t_article` VALUES (127, '17. 拦截器', 8, '\n\n## 1、拦截器接口：HandlerInterceptor \n\nSpringMVC定义了拦截器接口HandlerInterceptor \n\n该接口中定义了三个方法,这三个方法的调用时在SpringMVC框架内部完成的，调用这个三个方法的时候，其参数的值也是从框架内部传递进来的。\n\n## 2、三个方法\n\n**boolean preHandle**\n\n预处理方法，实现处理器方法的预处理，就是在处理器方法执行之前这个方法会被执行，相当于拦截了处理器方法，框架会传递请求和响应对象给该方法，第三个参数为被拦截的处理器方法。如果preHandle方法返回true表示继续流程（如调用下一个拦截器或处理器方法），返回false表示流程中断，不会继续调用其他的拦截器或处理器方法，此时我们需要通过response来产生响应；\n\n**void postHandle**\n\n后处理方法，实现处理器方法的后处理，就是在处理器方法调用完成，但在渲染视图之前，该方法被调用，此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理。\n\n**afterCompletion**\n\n整个请求处理完毕，即在视图渲染完毕时该方法被执行。\n\n\n\n## 3、拦截器的实现\n\n案例：检测是否登录，若没有登录或登录过期则跳转到登录页面。\n\n### 3.1 编写拦截器类\n\n```java\npackage com.company.ssm.interceptor;\n\nimport com.company.ssm.bean.User;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    /*\n        方法：检测用户是否登录，若没有登录则跳转登录页\n        当请求到达控制器之前被执行\n	   true--继续向下执行,到达下一个拦截器,或控制器\n	   false--不会继续向下执行\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        HttpSession session = request.getSession();\n        User user = (User) session.getAttribute(\"user\");\n        if(user != null){\n            response.sendRedirect(request.getContextPath()+\"/loginCtl/toLogin\");\n            return false;\n        }else{\n            return true;\n        }\n    }\n\n    /*\n    控制器方法执行之后执行\n     */\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n\n    }\n\n    /*\n    整个请求结束后执行\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n\n    }\n}\n```\n\n\n\n### 3.2 注册拦截器\n\n在springmvc.xml中添加\n\n```java\n    <!-- 拦截器 -->\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/**\"/><!-- 配置哪些请求被拦截  拦截器不会拦截jsp页面请求-->\n            <mvc:exclude-mapping path=\"/statics/**\"/><!-- 哪些请求不被拦截 -->\n            <mvc:exclude-mapping path=\"/loginCtl/toLogin\"/><!-- 哪些请求不被拦截 -->\n            <bean id=\"demo\" class=\"com.company.ssm.interceptor.LoginInterceptor\"></bean>\n        </mvc:interceptor>\n    </mvc:interceptors>\n```\n\n', 0, 0, '2020-08-07 00:52:27', 2, 0, 1, '1、拦截器接口：HandlerInterceptorSpringMVC定义了拦截器接口HandlerInterceptor \n该接口中定义了三个方法,这三个方法的调用时在SpringMVC框架内部完成的，调用这个三个方法的时候，其参数的值也是从框架内部传递进来的。\n2、三个方法boolean preHandle\n预处理方法，实现处理器方法的预处理，就是在处理器方法执行之前这个方法会被执行，相当于拦截了处理器方法，框架会传递请求和响应对象给该方法，第三个参数为被拦截的处理器方法。如果preHandle方法返回true表示继续流程（如调用下一个拦截器或处理器方法），返回false表示流程中断，不会继续调用其他的拦截器或处理器方法，此时我们需要通过response来产生响应；\nvoid postHandle\n后处理方法，实现处理器方法的后处理，就是在处理器方法调用完成，但在渲染视图之前，该方法被调用，此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理。\nafterCompletion\n整个请求处理完毕，即在视图渲染完毕时该方法被执行。\n3、拦截器的实现案例：检测是否登录，若没有登录或登录过期则跳转到登录页面。\n3.1 编写拦截器类package com.company.ssm.interceptor;import com.company.ssm.bean.User;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginInterceptor implements HandlerInterceptor {    /*        方法：检测用户是否登录，若没有登录则跳转登录页        当请求到达控制器之前被执行       true--继续向下执行,到达下一个拦截器,或控制器       false--不会继续向下执行     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        HttpSession session = request.getSession();        User user = (User) session.getAttribute(\"user\");        if(user != null){            response.sendRedirect(request.getContextPath()+\"/loginCtl/toLogin\");            return false;        }else{            return true;        }    }    /*    控制器方法执行之后执行     */    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    /*    整个请求结束后执行     */    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}\n3.2 注册拦截器在springmvc.xml中添加\n    <!-- 拦截器 -->    <mvc:interceptors>        <mvc:interceptor>            <mvc:mapping path=\"/**\"/><!-- 配置哪些请求被拦截  拦截器不会拦截jsp页面请求-->            <mvc:exclude-mapping path=\"/statics/**\"/><!-- 哪些请求不被拦截 -->            <mvc:exclude-mapping path=\"/loginCtl/toLogin\"/><!-- 哪些请求不被拦截 -->            <bean id=\"demo\" class=\"com.company.ssm.interceptor.LoginInterceptor\"></bean>        </mvc:interceptor>    </mvc:interceptors>\n', 0, 1);
INSERT INTO `t_article` VALUES (128, '16. SSM 搭建', 8, '\n\nSSM：Spring、SpringMVC、Mybatis\n\n### 项目完成图：\n\n![image-20200630221018122](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200630221018122.png)\n\n\n\n## 1、搭建 SpringMVC\n\n### 1.1 导入spring和springMVC包\n\n- spring-webmvc\n- servlet-api\n- 异步请求jacksonjar\n- jstl\n- 文件上传下载commons-fileupload\n- spring-context\n- 阿里数据源\n\n```xml\n  <dependencies>\n    <!-- spring-webmvc -->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-webmvc</artifactId>\n      <version>5.2.2.RELEASE</version>\n    </dependency>\n\n    <!-- servlet-api -->\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>4.0.1</version>\n      <scope>provided</scope>\n    </dependency>\n\n    <!--添加jacksonjar包,spring异步请求时转换json对象需要的包-->\n    <dependency>\n      <groupId>com.fasterxml.jackson.core</groupId>\n      <artifactId>jackson-databind</artifactId>\n      <version>2.9.1</version>\n    </dependency>\n\n    <!-- jstl -->\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>jstl</artifactId>\n      <version>1.2</version>\n    </dependency>\n\n    <!-- 文件上传下载 -->\n    <dependency>\n      <groupId>commons-fileupload</groupId>\n      <artifactId>commons-fileupload</artifactId>\n      <version>1.3.3</version>\n    </dependency>\n\n    <!-- spring-context -->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>5.2.2.RELEASE</version>\n    </dependency>\n      \n    <!-- 阿里数据源 -->\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>druid</artifactId>\n      <version>1.1.10</version>\n    </dependency>\n\n  </dependencies>\n```\n\n### 1.2 创建spring配置文件\n\n创建application.xml 和 springmvc.xml文件\n\n#### application.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context\n                           https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!-- 开启spring的注解扫描功能 -->\n    <context:component-scan base-package=\"com.company.ssm\"></context:component-scan>\n\n    <!--导入springMVC配置 -->\n    <import resource=\"springmvc.xml\"/>\n\n    <!-- 导入数据库连接配置 -->\n    <import resource=\"db.xml\"/>\n</beans>\n```\n\n#### springmvc.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/mvc\n                           http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!-- 开启springmvc注解 -->\n    <mvc:annotation-driven></mvc:annotation-driven>\n\n    <!-- 视图解析器 -->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"></property>\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"></property>\n        <property name=\"suffix\" value=\".jsp\"></property>\n    </bean>\n\n    <!-- 过滤静态资源文件  -->\n    <mvc:default-servlet-handler/>\n\n    <!-- 文件解析器 -->\n    <bean id=\"multipartResolver\"  class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n        <property name=\"defaultEncoding\" value=\"utf-8\"></property>\n        <property name=\"maxUploadSize\" value=\"10485760\"></property>\n    </bean>\n\n    <!-- 拦截器 -->\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/**\"/><!-- 配置哪些请求被拦截  拦截器不会拦截jsp页面请求-->\n            <mvc:exclude-mapping path=\"/statics/**\"/><!-- 哪些请求不被拦截 -->\n            <mvc:exclude-mapping path=\"/loginCtl/toLogin\"/><!-- 哪些请求不被拦截 -->\n            <bean id=\"demo\" class=\"com.company.ssm.interceptor.LoginInterceptor\"></bean>\n        </mvc:interceptor>\n    </mvc:interceptors>\n\n</beans>\n```\n\n\n\n### 1.3 在web.xml中配置 spring 请求分发 servlet\n\n#### web.xml\n\n```xml\n<!DOCTYPE web-app PUBLIC\n        \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n        \"http://java.sun.com/dtd/web-app_2_3.dtd\" >\n\n<web-app  version=\"2.5\"\n          xmlns=\"http://java.sun.com/xml/ns/javaee\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n  <display-name>Archetype Created Web Application</display-name>\n\n  <!--  配置spring 核心请求分发器-->\n  <servlet>\n    <servlet-name>springMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <!-- 配置初始化参数,加载spring配置文件 -->\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <!-- <param-value>/WEB-INF/classes/application.xml</param-value> -->\n      <param-value>classpath:application.xml</param-value>\n    </init-param>\n    <!-- 启动时就创建 DispatcherServlet对象,并加载spring框架-->\n    <load-on-startup>0</load-on-startup>\n  </servlet>\n\n  <!-- 配置请求映射地址 -->\n  <servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n\n</web-app>\n```\n\n\n\n### 1.4 创建jsp页面\n\n#### login.jsp\n\n```jsp\n<%--\n  Created by IntelliJ IDEA.\n  User: God_86\n  Date: 2020/6/30\n  Time: 14:45\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>登录</title>\n</head>\n<body>\n<h1>登录页面</h1>\n<form action=\"${path}/loginCtl/login\" method=\"post\">\n    用户名：<input type=\"text\" name=\"userName\"> <br>\n    密码：<input type=\"password\" name=\"password\"> <br>\n    <input type=\"submit\" value=\"登录\">\n</form>\n</body>\n</html>\n\n```\n\n\n\n#### loginSuccess.jsp\n\n```jsp\n<%--\n  Created by IntelliJ IDEA.\n  User: God_86\n  Date: 2020/6/30\n  Time: 16:06\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>登录成功</title>\n</head>\n<body>\n登录成功\n</body>\n</html>\n```\n\n\n\n### 1.5 创建控制器类\n\n![image-20200630145949431](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200630145949431.png)\n\nSpringMVC搭建成功！！！\n\n\n\n## 2、集成MyBatis \n\n### 2.1 导包\n\n- Springjdbc 模块\n- Mybatis\n- Mysql驱动\n- Log4j\n- Spring 整合 mybatis 的插件包\n- Spring 切面实现AOP\n\n```xml\n  <!-- spring-context -->\n	<!-- spring-jdbc -->\n	<dependency>\n		<groupId>org.springframework</groupId>\n		<artifactId>spring-jdbc</artifactId>\n		<version>5.2.2.RELEASE</version>\n	</dependency>\n	\n   <!-- mysql -->\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.20</version>\n    </dependency>\n	\n	<!-- Spring 切面实现AOP -->\n	<dependency>\n	    <groupId>org.springframework</groupId>\n	    <artifactId>spring-aspects</artifactId>\n	    <version>5.2.2.RELEASE</version>\n	</dependency>\n	\n	<!-- spring整合mybatis的插件包 -->\n	 <dependency>\n	    <groupId>org.mybatis</groupId>\n	    <artifactId>mybatis-spring</artifactId>\n	    <version>1.3.1</version>\n	</dependency>\n	\n	   <!-- mybatis -->\n	<dependency>\n	    <groupId>org.mybatis</groupId>\n	    <artifactId>mybatis</artifactId>\n	    <version>3.4.2</version>\n	</dependency>\n      \n     <!-- log4j -->\n      <dependency>\n         <groupId>log4j</groupId>\n         <artifactId>log4j</artifactId>\n         <version>1.2.17</version>\n      </dependency>  \n```\n\n### 2.2 创建包结构\n\n![image-20200630221205957](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/img/image-20200630221205957.png)\n\n\n\n\n\n### 2.3 创建Spring,mybatis 配置文件\n\n#### jdbc.properties\n\n```properties\nurl=jdbc:mysql://127.0.0.1:3306/shop?characterEncoding=utf-8&serverTimezone=GMT\ndriver=com.mysql.cj.jdbc.Driver\njdbc_username=root\njdbc_password=123456\ninitialSize=10\nminIdle=5\nmaxActive=20\n```\n\n\n\n#### log4j.properties\n\n```properties\nlog4j.rootLogger = debug,stdout,D\n#System out Console\nlog4j.appender.stdout = org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target = System.out\nlog4j.appender.stdout.layout = org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern = [%p] %d{yyyy-MM-dd HH:mm:ss,SSS} %m%n\n\n#System out File\nlog4j.appender.D = org.apache.log4j.FileAppender\nlog4j.appender.D = org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.D.File = F://eclipse-workspace/log.log\nlog4j.appender.D.Append = true\nlog4j.appender.D.layout = org.apache.log4j.PatternLayout\nlog4j.appender.D.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ] -[%l] %m%n\n```\n\n\n\n#### db.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<beans xmlns=\"http://www.springframework.org/schema/beans\" \nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \nxmlns:context=\"http://www.springframework.org/schema/context\"\nxmlns:aop=\"http://www.springframework.org/schema/aop\"\nxmlns:tx=\"http://www.springframework.org/schema/tx\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans \n                    http://www.springframework.org/schema/beans/spring-beans.xsd\n                    http://www.springframework.org/schema/context\n                    http://www.springframework.org/schema/context/spring-context.xsd\n                    http://www.springframework.org/schema/aop\n                    http://www.springframework.org/schema/aop/spring-aop.xsd\n                    http://www.springframework.org/schema/tx\n                    http://www.springframework.org/schema/tx/spring-tx.xsd\">\n        \n        \n        <!-- 加载属性文件 -->\n        <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n        \n        <!-- spring管理阿里数据源对象的创建,由此数据源对象管理创建数据库连接对象(Connection) -->\n        <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n           <property name=\"driverClassName\" value=\"${driver}\"></property>\n           <property name=\"url\" value=\"${url}\"></property>\n           <property name=\"username\" value=\"${jdbc_username}\"></property>\n           <property name=\"password\" value=\"${jdbc_password}\"></property>\n           <property name=\"initialSize\" value=\"${initialSize}\"></property>\n		   <property name=\"minIdle\" value=\"${minIdle}\"></property>\n		   <property name=\"maxActive\" value=\"${maxActive}\"></property>\n        </bean>\n        \n        \n        <!-- 配置事务管理器类 -->\n        <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n              <property name=\"dataSource\" ref=\"dataSource\"></property>\n        </bean>\n        \n         <!-- 开启事务注解功能 -->\n         <tx:annotation-driven transaction-manager=\"transactionManager\" />\n         \n         \n         <!-- 配置sqlSessionFactory spring管理生成SqlSessionFactory对象-->\n		 <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n		    <!--注入数据库连接管理对象 -->\n		   <property name=\"dataSource\" ref=\"dataSource\"></property>\n		    <!-- 加载mybatis全局配置文件 -->\n		   <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"></property>\n		    <!-- 加载sql映射文件 -->\n<!--             <property name=\"mapperLocations\" value=\"classpath:com/company/ssm/mapper/*Mapper.xml\"></property>-->\n		   <property name=\"mapperLocations\" value=\"classpath:mybatis/mapper/*Mapper.xml\"></property>\n             <!-- java bean注册别名 -->\n<!--           <property name=\"typeAliasesPackage\" value=\"com.company.ssm.bean\"></property>-->\n		 </bean>\n		 \n		 <!-- 指定生成接口代理 -->\n		 <bean id=\"mapperFactory\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n		   <property name=\"basePackage\" value=\"com.company.ssm.dao\"></property>\n		    <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"></property>\n		 </bean>\n</beans>\n```\n\n\n\n#### mybatis-config.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n	<typeAliases>\n        <package name=\"com.company.ssm.bean\"/>\n    </typeAliases>\n</configuration>\n```\n\n\n\n## 3、监听器\n\n设置全局默认地址的监听器类 \n\n#### ObjectListener.java\n\n```java\npackage com.company.ssm.util;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\n\n\n/**\n * 监听器类\n * 设置全局默认地址\n */\npublic class ObjectListener implements ServletContextListener {\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println(\"ServletContext对象创建\");\n\n        //监听ServletContext 对象的创建\n        ServletContext context = sce.getServletContext();\n        context.setAttribute(\"path\", context.getContextPath());\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n\n    }\n}\n```\n\n配置监听器：\n\n#### web.xml\n\n```xml\n  <!-- 配置监听器,设置上下文路径 -->\n  <listener>\n    <listener-class>com.company.ssm.util.ObjectListener</listener-class>\n  </listener>\n```\n\n\n\n## 4、拦截器\n\n登录拦截器\n\n#### LoginInterceptor.java\n\n```java\npackage com.company.ssm.interceptor;\n\nimport com.company.ssm.bean.User;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    /*\n        方法：检测用户是否登录，若没有登录则跳转登录页\n        当请求到达控制器之前被执行\n	   true--继续向下执行,到达下一个拦截器,或控制器\n	   false--不会继续向下执行\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        HttpSession session = request.getSession();\n        User user = (User) session.getAttribute(\"user\");\n        if(user != null){\n            response.sendRedirect(request.getContextPath()+\"/loginCtl/toLogin\");\n            return false;\n        }else{\n            return true;\n        }\n    }\n\n    /*\n    控制器方法执行之后执行\n     */\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n\n    }\n\n    /*\n    整个请求结束后执行\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n\n    }\n}\n```\n\n配置拦截器：\n\n#### springmvc.xml\n\n```xml\n    <!-- 拦截器 -->\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <mvc:mapping path=\"/**\"/><!-- 配置哪些请求被拦截  拦截器不会拦截jsp页面请求-->\n            <mvc:exclude-mapping path=\"/statics/**\"/><!-- 哪些请求不被拦截 -->\n            <mvc:exclude-mapping path=\"/loginCtl/toLogin\"/><!-- 哪些请求不被拦截 -->\n            <bean id=\"demo\" class=\"com.company.ssm.interceptor.LoginInterceptor\"></bean>\n        </mvc:interceptor>\n    </mvc:interceptors>\n```\n\n', 0, 0, '2020-08-07 00:53:44', 3, 0, 1, 'SSM：Spring、SpringMVC、Mybatis\n项目完成图：\n1、搭建 SpringMVC1.1 导入spring和springMVC包\nspring-webmvcservlet-api异步请求jacksonjarjstl文件上传下载commons-fileuploadspring-context阿里数据源\n  <dependencies>    <!-- spring-webmvc -->    <dependency>      <groupId>org.springframework</groupId>      <artifactId>spring-webmvc</artifactId>      <version>5.2.2.RELEASE</version>    </dependency>    <!-- servlet-api -->    <dependency>      <groupId>javax.servlet</groupId>      <artifactId>javax.servlet-api</artifactId>      <version>4.0.1</version>      <scope>provided</scope>    </dependency>    <!--添加jacksonjar包,spring异步请求时转换json对象需要的包-->    <dependency>      <groupId>com.fasterxml.jackson.core</groupId>      <artifactId>jackson-databind</artifactId>      <version>2.9.1</version>    </dependency>    <!-- jstl -->    <dependency>      <groupId>javax.servlet</groupId>      <artifactId>jstl</artifactId>      <version>1.2</version>    </dependency>    <!-- 文件上传下载 -->    <dependency>      <groupId>commons-fileupload</groupId>      <artifactId>commons-fileupload</artifactId>      <version>1.3.3</version>    </dependency>    <!-- spring-context -->    <dependency>      <groupId>org.springframework</groupId>      <artifactId>spring-context</artifactId>      <version>5.2.2.RELEASE</version>    </dependency>    <!-- 阿里数据源 -->    <dependency>      <groupId>com.alibaba</groupId>      <artifactId>druid</artifactId>      <version>1.1.10</version>    </dependency>  </dependencies>\n1.2 创建spring配置文件创建application.xml 和 springmvc.xml文件\napplication.xml<?xml version=\"1.0\" encoding=\"UTF-8\"?><beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/context                           https://www.springframework.org/schema/context/spring-context.xsd\">    <!-- 开启spring的注解扫描功能 -->    <context:component-scan base-package=\"com.company.ssm\"></context:component-scan>    <!--导入springMVC配置 -->    <import resource=\"springmvc.xml\"/>    <!-- 导入数据库连接配置 -->    <import resource=\"db.xml\"/></beans>\nspringmvc.xml<?xml version=\"1.0\" encoding=\"UTF-8\"?><beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd\">    <!-- 开启springmvc注解 -->    <mvc:annotation-driven></mvc:annotation-driven>    <!-- 视图解析器 -->    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">        <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"></property>        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"></property>        <property name=\"suffix\" value=\".jsp\"></property>    </bean>    <!-- 过滤静态资源文件  -->    <mvc:default-servlet-handler/>    <!-- 文件解析器 -->    <bean id=\"multipartResolver\"  class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">        <property name=\"defaultEncoding\" value=\"utf-8\"></property>        <property name=\"maxUploadSize\" value=\"10485760\"></property>    </bean>    <!-- 拦截器 -->    <mvc:interceptors>        <mvc:interceptor>            <mvc:mapping path=\"/**\"/><!-- 配置哪些请求被拦截  拦截器不会拦截jsp页面请求-->            <mvc:exclude-mapping path=\"/statics/**\"/><!-- 哪些请求不被拦截 -->            <mvc:exclude-mapping path=\"/loginCtl/toLogin\"/><!-- 哪些请求不被拦截 -->            <bean id=\"demo\" class=\"com.company.ssm.interceptor.LoginInterceptor\"></bean>        </mvc:interceptor>    </mvc:interceptors></beans>\n1.3 在web.xml中配置 spring 请求分发 servletweb.xml<!DOCTYPE web-app PUBLIC        \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"        \"http://java.sun.com/dtd/web-app_2_3.dtd\" ><web-app  version=\"2.5\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">  <display-name>Archetype Created Web Application</display-name>  <!--  配置spring 核心请求分发器-->  <servlet>    <servlet-name>springMVC</servlet-name>    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>    <!-- 配置初始化参数,加载spring配置文件 -->    <init-param>      <param-name>contextConfigLocation</param-name>      <!-- <param-value>/WEB-INF/classes/application.xml</param-value> -->      <param-value>classpath:application.xml</param-value>    </init-param>    <!-- 启动时就创建 DispatcherServlet对象,并加载spring框架-->    <load-on-startup>0</load-on-startup>  </servlet>  <!-- 配置请求映射地址 -->  <servlet-mapping>    <servlet-name>springMVC</servlet-name>    <url-pattern>/</url-pattern>  </servlet-mapping></web-app>\n1.4 创建jsp页面login.jsp<%--  Created by IntelliJ IDEA.  User: God_86  Date: 2020/6/30  Time: 14:45  To change this template use File | Settings | File Templates.--%><%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %><html><head>    <title>登录</title></head><body><h1>登录页面</h1><form action=\"${path}/loginCtl/login\" method=\"post\">    用户名：<input type=\"text\" name=\"userName\"> <br>    密码：<input type=\"password\" name=\"password\"> <br>    <input type=\"submit\" value=\"登录\"></form></body></html>\nloginSuccess.jsp<%--  Created by IntelliJ IDEA.  User: God_86  Date: 2020/6/30  Time: 16:06  To change this template use File | Settings | File Templates.--%><%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %><html><head>    <title>登录成功</title></head><body>登录成功</body></html>\n1.5 创建控制器类\nSpringMVC搭建成功！！！\n2、集成MyBatis2.1 导包\nSpringjdbc 模块MybatisMysql驱动Log4jSpring 整合 mybatis 的插件包Spring 切面实现AOP\n  <!-- spring-context -->    <!-- spring-jdbc -->    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-jdbc</artifactId>        <version>5.2.2.RELEASE</version>    </dependency>   <!-- mysql -->    <dependency>        <groupId>mysql</groupId>        <artifactId>mysql-connector-java</artifactId>        <version>8.0.20</version>    </dependency>    <!-- Spring 切面实现AOP -->    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-aspects</artifactId>        <version>5.2.2.RELEASE</version>    </dependency>    <!-- spring整合mybatis的插件包 -->     <dependency>        <groupId>org.mybatis</groupId>        <artifactId>mybatis-spring</artifactId>        <version>1.3.1</version>    </dependency>       <!-- mybatis -->    <dependency>        <groupId>org.mybatis</groupId>        <artifactId>mybatis</artifactId>        <version>3.4.2</version>    </dependency>     <!-- log4j -->      <dependency>         <groupId>log4j</groupId>         <artifactId>log4j</artifactId>         <version>1.2.17</version>      </dependency>\n2.2 创建包结构\n2.3 创建Spring,mybatis 配置文件jdbc.propertiesurl=jdbc:mysql://127.0.0.1:3306/shop?characterEncoding=utf-8&serverTimezone=GMTdriver=com.mysql.cj.jdbc.Driverjdbc_username=rootjdbc_password=123456initialSize=10minIdle=5maxActive=20\nlog4j.propertieslog4j.rootLogger = debug,stdout,D#System out Consolelog4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%p] %d{yyyy-MM-dd HH:mm:ss,SSS} %m%n#System out Filelog4j.appender.D = org.apache.log4j.FileAppenderlog4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = F://eclipse-workspace/log.loglog4j.appender.D.Append = truelog4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ] -[%l] %m%n\ndb.xml<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"xmlns:aop=\"http://www.springframework.org/schema/aop\"xmlns:tx=\"http://www.springframework.org/schema/tx\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans                     http://www.springframework.org/schema/beans/spring-beans.xsd                    http://www.springframework.org/schema/context                    http://www.springframework.org/schema/context/spring-context.xsd                    http://www.springframework.org/schema/aop                    http://www.springframework.org/schema/aop/spring-aop.xsd                    http://www.springframework.org/schema/tx                    http://www.springframework.org/schema/tx/spring-tx.xsd\">        <!-- 加载属性文件 -->        <context:property-placeholder location=\"classpath:jdbc.properties\"/>        <!-- spring管理阿里数据源对象的创建,由此数据源对象管理创建数据库连接对象(Connection) -->        <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">           <property name=\"driverClassName\" value=\"${driver}\"></property>           <property name=\"url\" value=\"${url}\"></property>           <property name=\"username\" value=\"${jdbc_username}\"></property>           <property name=\"password\" value=\"${jdbc_password}\"></property>           <property name=\"initialSize\" value=\"${initialSize}\"></property>           <property name=\"minIdle\" value=\"${minIdle}\"></property>           <property name=\"maxActive\" value=\"${maxActive}\"></property>        </bean>        <!-- 配置事务管理器类 -->        <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">              <property name=\"dataSource\" ref=\"dataSource\"></property>        </bean>         <!-- 开启事务注解功能 -->         <tx:annotation-driven transaction-manager=\"transactionManager\" />         <!-- 配置sqlSessionFactory spring管理生成SqlSessionFactory对象-->         <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">            <!--注入数据库连接管理对象 -->           <property name=\"dataSource\" ref=\"dataSource\"></property>            <!-- 加载mybatis全局配置文件 -->           <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"></property>            <!-- 加载sql映射文件 --><!--             <property name=\"mapperLocations\" value=\"classpath:com/company/ssm/mapper/*Mapper.xml\"></property>-->           <property name=\"mapperLocations\" value=\"classpath:mybatis/mapper/*Mapper.xml\"></property>             <!-- java bean注册别名 --><!--           <property name=\"typeAliasesPackage\" value=\"com.company.ssm.bean\"></property>-->         </bean>         <!-- 指定生成接口代理 -->         <bean id=\"mapperFactory\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">           <property name=\"basePackage\" value=\"com.company.ssm.dao\"></property>            <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"></property>         </bean></beans>\nmybatis-config.xml<?xml version=\"1.0\" encoding=\"UTF-8\" ?><!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"><configuration>    <typeAliases>        <package name=\"com.company.ssm.bean\"/>    </typeAliases></configuration>\n3、监听器设置全局默认地址的监听器类 \nObjectListener.javapackage com.company.ssm.util;import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;/** * 监听器类 * 设置全局默认地址 */public class ObjectListener implements ServletContextListener {    @Override    public void contextInitialized(ServletContextEvent sce) {        System.out.println(\"ServletContext对象创建\");        //监听ServletContext 对象的创建        ServletContext context = sce.getServletContext();        context.setAttribute(\"path\", context.getContextPath());    }    @Override    public void contextDestroyed(ServletContextEvent sce) {    }}\n配置监听器：\nweb.xml  <!-- 配置监听器,设置上下文路径 -->  <listener>    <listener-class>com.company.ssm.util.ObjectListener</listener-class>  </listener>\n4、拦截器登录拦截器\nLoginInterceptor.javapackage com.company.ssm.interceptor;import com.company.ssm.bean.User;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginInterceptor implements HandlerInterceptor {    /*        方法：检测用户是否登录，若没有登录则跳转登录页        当请求到达控制器之前被执行       true--继续向下执行,到达下一个拦截器,或控制器       false--不会继续向下执行     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        HttpSession session = request.getSession();        User user = (User) session.getAttribute(\"user\");        if(user != null){            response.sendRedirect(request.getContextPath()+\"/loginCtl/toLogin\");            return false;        }else{            return true;        }    }    /*    控制器方法执行之后执行     */    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    /*    整个请求结束后执行     */    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}\n配置拦截器：\nspringmvc.xml    <!-- 拦截器 -->    <mvc:interceptors>        <mvc:interceptor>            <mvc:mapping path=\"/**\"/><!-- 配置哪些请求被拦截  拦截器不会拦截jsp页面请求-->            <mvc:exclude-mapping path=\"/statics/**\"/><!-- 哪些请求不被拦截 -->            <mvc:exclude-mapping path=\"/loginCtl/toLogin\"/><!-- 哪些请求不被拦截 -->            <bean id=\"demo\" class=\"com.company.ssm.interceptor.LoginInterceptor\"></bean>        </mvc:interceptor>    </mvc:interceptors>\n', 0, 1);
INSERT INTO `t_article` VALUES (129, '19. SpringBoot的搭建', 8, '\n\n## 1、Spring的优缺点\n\n### 1.1 优点\n\n（1）开源,轻量级,非侵入式的一站式框架,简化企业级应用开发。\n\n（2）控制反转(IOC),依赖注入(DI)降低了组件之间的耦合性，实现了软件各层之间的解耦。\n\n（3）面向切面(AOP)，利用它可以很容易实现一些拦截，如事务控制等。\n\n（4）spring对于主流的应用框架提供了很好的支持，例如mybatis。\n\n（5）spring提供有自己的mvc实现。\n\n### 1.2 缺点\n\n虽然Spring的组件代码是轻量级的,但它的配置却是重量级的。虽然spring引入了注解功能,但是仍然需要编写大量的模板化配置文件.\n\n项目的jar依赖管理也是一件耗时耗力的事情,在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。\n\n\n\n###  1.3 SpringBoot解决问题\n\nSpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想.可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。\n\n\n\n## 2、SpringBoot的概述\n\n### 2.1 概述\n\nSpring Boot是由Pivotal团队提供的在spring框架基础之上二次开发的框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。\n\n该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域成为领导者。\n\nSpring Boot就是对各种框架的整合，让他们集成在一起更加简单，它做了那些没有它你自己也会去做的Spring Bean配置。你不用再写这些样板配置了，可以专注于应用程序的逻辑.\n\nSpring Boot你只需要“run”就可以非常轻易的构建独立的、生产级别的spring应用。\n\n我们为spring平台和第三方依赖库提供了一种固定化的使用方式，使你能非常轻松的开始开发你的应用程序。大部分Spring Boot应用只需要很少的配置。\n\n\n\n### 2.2 SpringBoot的特点\n\n（1）创建独立的spring应用程序\n\n（2）直接内嵌tomcat、jetty和undertow（不需要打包成war包部署）\n\n（3）提供了固定化的“starter”配置，以简化构建配置\n\n（4）尽可能的自动配置spring和第三方库\n\n（5）提供产品级的功能，如：安全指标、运行状况监测和外部化配置等\n\n（6）绝对不会生成代码，并且不需要XML配置\n\n\n\n### 2.3 SpringBoot的核心功能\n\n**起步依赖**\n\n 起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。\n\n**自动配置**\n\n Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。\n\n\n\n## 3、搭建SpringBoot环境\n\n### （1）Maven 下载 SpringBoot 依赖的jar包\n\n```xml\n<!-- spring-boot web启动器 -->\n	<dependency>\n		<groupId>org.springframework.boot</groupId>\n		<artifactId>spring-boot-starter-web</artifactId>\n		<version>2.2.2.RELEASE</version>\n	</dependency>\n	\n<!-- 配置springboot内置tomcat环境 -->\n	<dependency>\n		<groupId>org.springframework.boot</groupId>\n		<artifactId>spring-boot-starter-tomcat</artifactId>\n		<version>2.2.2.RELEASE</version>\n	</dependency>	\n```\n\n### （2）编写入口程序main函数\n\nSpringBoot 通过java的注解的形式启动，就像javaSE程序一样，通过main函数入口。\n\n```java\npackage com.company.springboot03;\n\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Springboot03Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot03Application.class, args);\n    }\n}\n```\n\n### （3）编写配置文件 application.yml\n\n```yml\n#内置服务器的配置\nserver:\n  port: 9999\n\n#spring的配置（配置spring视图解析器和数据源配置）\nspring:\n  mvc:\n    view:\n      prefix: /WEB-INF/jsp/\n      suffix: .jsp\n  datasource:\n    url: jdbc:mysql://127.0.0.1:3306/shop?characterEncoding=utf-8&serverTimezone=GMT\n    username: root\n    password: 123456\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    platform: mysql\n    type: com.alibaba.druid.pool.DruidDataSource\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n```\n\n### （4）配置springboot热部署\n\n```xml\n<dependency>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-devtools</artifactId>\n	<version>2.2.2.RELEASE</version>\n</dependency>\n```\n\n以后修改代码之后就不用每次执行main函数启动工程.\n\n### （5）配置SpringBoot支持jsp\n\n```xml\n<dependency>\n	<groupId>org.apache.tomcat.embed</groupId>\n	<artifactId>tomcat-embed-jasper</artifactId>\n	<version>9.0.22</version>\n</dependency>\n```\n\n配置视图解析器\n\n```yml\nspring:\n  mvc:\n    view:\n      prefix: /WEB-INF/jsp/\n      suffix: .jsp\n```\n\n### （6）SpringBoot集成JDBC\n\n导入jdbc包\n\n```xml\n    <!-- jdbc -->\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-jdbc</artifactId>\n      <version>2.2.2.RELEASE</version>\n    </dependency>\n```\n\n导入mysql驱动包\n\n```xml\n    <!-- mysql-connector-java -->\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>8.0.20</version>\n    </dependency>\n```\n\n\n\n### （7）配置数据源信息\n\n导入阿里数据源\n\n```xml\n<!-- 阿里数据源 -->\n	<dependency>\n	  <groupId>com.alibaba</groupId>\n	  <artifactId>druid</artifactId>\n	  <version>1.1.10</version>\n	</dependency>\n```\n\n在yml文件注册阿里数据库连接池\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://127.0.0.1:3306/shop?characterEncoding=utf-8&serverTimezone=GMT\n    username: root\n    password: 123456\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    platform: mysql\n    type: com.alibaba.druid.pool.DruidDataSource\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n```\n\n\n\n### （8）编写配置Druid的监控\n\nDruidDataSourceConfig.java\n\n```java\npackage com.company.springBootPro.util;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.sql.DataSource;\n\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.support.http.StatViewServlet;\nimport com.alibaba.druid.support.http.WebStatFilter;\n//spring自动扫描加载此类\n@Configuration\npublic class DruidDataSourceConfig {\n\n	    @Bean\n		@ConfigurationProperties(prefix = \"spring.datasource\")\n	    public DataSource druid() {\n	        return new DruidDataSource();\n	    }\n	 \n	    // 配置Druid的监控\n	    // 1、配置一个管理后台的Servlet\n	    @Bean\n	    public ServletRegistrationBean statViewServlet() {\n	        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\");\n	 \n	        Map<String, String> initParams = new HashMap<String, String>();\n	        // 监控页面登录用户名	 \n	        initParams.put(\"loginUsername\", \"admin\");\n	 \n	        // 监控页面登录用户密码\n	        initParams.put(\"loginPassword\", \"123456\");\n	 \n	        // ip白名单（没有配置或者为空，则允许所有访问）\n	        initParams.put(\"allow\", \"\");\n	 \n	        // ip黑名单（如果某个ip同时存在，deny优先于allow）\n	        initParams.put(\"deny\", \"\");\n	        bean.setInitParameters(initParams);\n	        return bean;\n	    }\n	 \n	    // 2、配置一个web监控的filter\n	    @Bean\n	    public FilterRegistrationBean webStatFilter() {\n	        FilterRegistrationBean bean = new FilterRegistrationBean();\n	        bean.setFilter(new WebStatFilter());\n	 \n	        Map<String, String> initParams = new HashMap<String, String>();\n	 \n	        // 不拦截的静态资源\n	        initParams.put(\"exclusions\", \"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\");\n	        bean.setInitParameters(initParams);\n	 \n	        // 拦截所有的请求\n	        bean.setUrlPatterns(Arrays.asList(\"/*\"));\n	        return bean;\n	    }\n}\n```\n\n### （9）集成Mybatis\n\n导入springboot集成mybatis环境的jar包\n\n```xml\n <dependency>\n		<groupId>org.mybatis.spring.boot</groupId>\n		<artifactId>mybatis-spring-boot-starter</artifactId>\n	    <version>2.1.1</version>\n</dependency>\n```\n\n\n\n在application.yml中配置mybatis信息\n\n```yml\nmybatis:\n  mapper-locations: classpath:mapper/*Mapper.xml             #映射文件\n  type-aliases-package: com.company.springBootPro.bean       #别名\n  configuration:\n    cache-enabled: true                                        #二级缓存\n    map-underscore-to-camel-case: true                         #java驼峰与数据库下划线对应转换\n```\n\napplication.yml中配置控制台输出sql脚本\n\n```yml\n# 配置控制台输出sql脚本\nlogging:\n  level:\n    com:\n      company:\n        springBootPro:\n          dao: TRACE\n```\n\n在Springboot03Application.java主函数类的上面添加扫描mapper文件注解\n\n```java\npackage com.company.springboot03;\n\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@MapperScan(\"com.company.springboot03.mapper\")\npublic class Springboot03Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot03Application.class, args);\n    }\n}\n```\n\n\n\n### （10）配置文件上传\n\n导入配置文件上传jar包\n\n```xml\n        <!-- 文件上传下载 -->\n        <dependency>\n            <groupId>commons-fileupload</groupId>\n            <artifactId>commons-fileupload</artifactId>\n            <version>1.3.3</version>\n        </dependency>\n```\n\n\n\n编写文件上传配置类\n\n```java\npackage com.company.springboot03.util;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\n\n@Configuration\npublic class MultipartConfig {\n\n	/**\n     * 文件上传配置\n     * @return\n     */\n    @Bean\n    public CommonsMultipartResolver multipartConfigElement() {\n    	CommonsMultipartResolver multipartresolver = new CommonsMultipartResolver();\n    	multipartresolver.setMaxUploadSize(1024*1024*5);\n    	multipartresolver.setDefaultEncoding(\"utf-8\");\n        return multipartresolver;\n    }\n}\n```\n\n\n\n### （11）配置自定义拦截器\n\n编写拦截器类\n\n```java\npackage com.company.springboot03.util;\n\nimport com.company.springboot03.bean.User;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    /*\n        方法：检测用户是否登录，若没有登录则跳转登录页\n        当请求到达控制器之前被执行\n	   true--继续向下执行,到达下一个拦截器,或控制器\n	   false--不会继续向下执行\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        HttpSession session = request.getSession();\n        User user = (User) session.getAttribute(\"user\");\n        if(user == null){\n            response.sendRedirect(request.getContextPath()+\"/demoCtl/toLogin\");\n            return false;\n        }else{\n            return true;\n        }\n    }\n\n    /*\n    控制器方法执行之后执行\n     */\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n\n    }\n\n    /*\n    整个请求结束后执行\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n\n    }\n}\n```\n\n\n\n配置自定义拦截器\n\n```java\npackage com.company.springboot03.util;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n/**\n * 注册自定义拦截器\n */\n@Configuration\npublic class InterceptorConfig implements WebMvcConfigurer{\n\n	public void addInterceptors(InterceptorRegistry registry) {\n		InterceptorRegistration inter =  registry.addInterceptor(new LoginInterceptor());\n				inter.addPathPatterns(\"/**\"); 					//拦截的路径\n				inter.excludePathPatterns(\"/demoCtl/toLogin\");	//放行的路径\n	}\n}\n```\n\n', 0, 0, '2020-08-07 00:55:18', 2, 0, 1, '1、Spring的优缺点1.1 优点（1）开源,轻量级,非侵入式的一站式框架,简化企业级应用开发。\n（2）控制反转(IOC),依赖注入(DI)降低了组件之间的耦合性，实现了软件各层之间的解耦。\n（3）面向切面(AOP)，利用它可以很容易实现一些拦截，如事务控制等。\n（4）spring对于主流的应用框架提供了很好的支持，例如mybatis。\n（5）spring提供有自己的mvc实现。\n1.2 缺点虽然Spring的组件代码是轻量级的,但它的配置却是重量级的。虽然spring引入了注解功能,但是仍然需要编写大量的模板化配置文件.\n项目的jar依赖管理也是一件耗时耗力的事情,在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。\n1.3 SpringBoot解决问题SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想.可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。\n2、SpringBoot的概述2.1 概述Spring Boot是由Pivotal团队提供的在spring框架基础之上二次开发的框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。\n该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域成为领导者。\nSpring Boot就是对各种框架的整合，让他们集成在一起更加简单，它做了那些没有它你自己也会去做的Spring Bean配置。你不用再写这些样板配置了，可以专注于应用程序的逻辑.\nSpring Boot你只需要“run”就可以非常轻易的构建独立的、生产级别的spring应用。\n我们为spring平台和第三方依赖库提供了一种固定化的使用方式，使你能非常轻松的开始开发你的应用程序。大部分Spring Boot应用只需要很少的配置。\n2.2 SpringBoot的特点（1）创建独立的spring应用程序\n（2）直接内嵌tomcat、jetty和undertow（不需要打包成war包部署）\n（3）提供了固定化的“starter”配置，以简化构建配置\n（4）尽可能的自动配置spring和第三方库\n（5）提供产品级的功能，如：安全指标、运行状况监测和外部化配置等\n（6）绝对不会生成代码，并且不需要XML配置\n2.3 SpringBoot的核心功能起步依赖\n 起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。\n自动配置\n Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。\n3、搭建SpringBoot环境（1）Maven 下载 SpringBoot 依赖的jar包<!-- spring-boot web启动器 -->    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-web</artifactId>        <version>2.2.2.RELEASE</version>    </dependency><!-- 配置springboot内置tomcat环境 -->    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-tomcat</artifactId>        <version>2.2.2.RELEASE</version>    </dependency>\n（2）编写入口程序main函数SpringBoot 通过java的注解的形式启动，就像javaSE程序一样，通过main函数入口。\npackage com.company.springboot03;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Springboot03Application {    public static void main(String[] args) {        SpringApplication.run(Springboot03Application.class, args);    }}\n（3）编写配置文件 application.yml#内置服务器的配置server:  port: 9999#spring的配置（配置spring视图解析器和数据源配置）spring:  mvc:    view:      prefix: /WEB-INF/jsp/      suffix: .jsp  datasource:    url: jdbc:mysql://127.0.0.1:3306/shop?characterEncoding=utf-8&serverTimezone=GMT    username: root    password: 123456    driver-class-name: com.mysql.cj.jdbc.Driver    platform: mysql    type: com.alibaba.druid.pool.DruidDataSource    initialSize: 5    minIdle: 5    maxActive: 20\n（4）配置springboot热部署<dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-devtools</artifactId>    <version>2.2.2.RELEASE</version></dependency>\n以后修改代码之后就不用每次执行main函数启动工程.\n（5）配置SpringBoot支持jsp<dependency>    <groupId>org.apache.tomcat.embed</groupId>    <artifactId>tomcat-embed-jasper</artifactId>    <version>9.0.22</version></dependency>\n配置视图解析器\nspring:  mvc:    view:      prefix: /WEB-INF/jsp/      suffix: .jsp\n（6）SpringBoot集成JDBC导入jdbc包\n    <!-- jdbc -->    <dependency>      <groupId>org.springframework.boot</groupId>      <artifactId>spring-boot-starter-jdbc</artifactId>      <version>2.2.2.RELEASE</version>    </dependency>\n导入mysql驱动包\n    <!-- mysql-connector-java -->    <dependency>      <groupId>mysql</groupId>      <artifactId>mysql-connector-java</artifactId>      <version>8.0.20</version>    </dependency>\n（7）配置数据源信息导入阿里数据源\n<!-- 阿里数据源 -->    <dependency>      <groupId>com.alibaba</groupId>      <artifactId>druid</artifactId>      <version>1.1.10</version>    </dependency>\n在yml文件注册阿里数据库连接池\nspring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/shop?characterEncoding=utf-8&serverTimezone=GMT    username: root    password: 123456    driver-class-name: com.mysql.cj.jdbc.Driver    platform: mysql    type: com.alibaba.druid.pool.DruidDataSource    initialSize: 5    minIdle: 5    maxActive: 20\n（8）编写配置Druid的监控DruidDataSourceConfig.java\npackage com.company.springBootPro.util;import java.util.Arrays;import java.util.HashMap;import java.util.Map;import javax.sql.DataSource;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;//spring自动扫描加载此类@Configurationpublic class DruidDataSourceConfig {        @Bean        @ConfigurationProperties(prefix = \"spring.datasource\")        public DataSource druid() {            return new DruidDataSource();        }        // 配置Druid的监控        // 1、配置一个管理后台的Servlet        @Bean        public ServletRegistrationBean statViewServlet() {            ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\");            Map<String, String> initParams = new HashMap<String, String>();            // 监控页面登录用户名                 initParams.put(\"loginUsername\", \"admin\");            // 监控页面登录用户密码            initParams.put(\"loginPassword\", \"123456\");            // ip白名单（没有配置或者为空，则允许所有访问）            initParams.put(\"allow\", \"\");            // ip黑名单（如果某个ip同时存在，deny优先于allow）            initParams.put(\"deny\", \"\");            bean.setInitParameters(initParams);            return bean;        }        // 2、配置一个web监控的filter        @Bean        public FilterRegistrationBean webStatFilter() {            FilterRegistrationBean bean = new FilterRegistrationBean();            bean.setFilter(new WebStatFilter());            Map<String, String> initParams = new HashMap<String, String>();            // 不拦截的静态资源            initParams.put(\"exclusions\", \"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\");            bean.setInitParameters(initParams);            // 拦截所有的请求            bean.setUrlPatterns(Arrays.asList(\"/*\"));            return bean;        }}\n（9）集成Mybatis导入springboot集成mybatis环境的jar包\n <dependency>        <groupId>org.mybatis.spring.boot</groupId>        <artifactId>mybatis-spring-boot-starter</artifactId>        <version>2.1.1</version></dependency>\n在application.yml中配置mybatis信息\nmybatis:  mapper-locations: classpath:mapper/*Mapper.xml             #映射文件  type-aliases-package: com.company.springBootPro.bean       #别名  configuration:    cache-enabled: true                                        #二级缓存    map-underscore-to-camel-case: true                         #java驼峰与数据库下划线对应转换\napplication.yml中配置控制台输出sql脚本\n# 配置控制台输出sql脚本logging:  level:    com:      company:        springBootPro:          dao: TRACE\n在Springboot03Application.java主函数类的上面添加扫描mapper文件注解\npackage com.company.springboot03;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(\"com.company.springboot03.mapper\")public class Springboot03Application {    public static void main(String[] args) {        SpringApplication.run(Springboot03Application.class, args);    }}\n（10）配置文件上传导入配置文件上传jar包\n        <!-- 文件上传下载 -->        <dependency>            <groupId>commons-fileupload</groupId>            <artifactId>commons-fileupload</artifactId>            <version>1.3.3</version>        </dependency>\n编写文件上传配置类\npackage com.company.springboot03.util;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.multipart.commons.CommonsMultipartResolver;@Configurationpublic class MultipartConfig {    /**     * 文件上传配置     * @return     */    @Bean    public CommonsMultipartResolver multipartConfigElement() {        CommonsMultipartResolver multipartresolver = new CommonsMultipartResolver();        multipartresolver.setMaxUploadSize(1024*1024*5);        multipartresolver.setDefaultEncoding(\"utf-8\");        return multipartresolver;    }}\n（11）配置自定义拦截器编写拦截器类\npackage com.company.springboot03.util;import com.company.springboot03.bean.User;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginInterceptor implements HandlerInterceptor {    /*        方法：检测用户是否登录，若没有登录则跳转登录页        当请求到达控制器之前被执行       true--继续向下执行,到达下一个拦截器,或控制器       false--不会继续向下执行     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        HttpSession session = request.getSession();        User user = (User) session.getAttribute(\"user\");        if(user == null){            response.sendRedirect(request.getContextPath()+\"/demoCtl/toLogin\");            return false;        }else{            return true;        }    }    /*    控制器方法执行之后执行     */    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    /*    整个请求结束后执行     */    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}\n配置自定义拦截器\npackage com.company.springboot03.util;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 注册自定义拦截器 */@Configurationpublic class InterceptorConfig implements WebMvcConfigurer{    public void addInterceptors(InterceptorRegistry registry) {        InterceptorRegistration inter =  registry.addInterceptor(new LoginInterceptor());                inter.addPathPatterns(\"/**\");                     //拦截的路径                inter.excludePathPatterns(\"/demoCtl/toLogin\");    //放行的路径    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (130, '01. 链表', 8, '\n\n## 1、链表的概述\n\n### 1.1 链式存储：\n\n用一组任意类型的存储单元存储线性表，在逻辑上面相邻的结点在物理位置上面不一定相邻。\n\n### 1.2 链表：\n\n采用链式存储方法的线性表叫做链表\n\n### 1.3  链表的特点：\n\n其结点的存储单元可以不连续，每个结点中除存储原表结点中的数据外，还须存储指示其直接后继或前趋结点的地址，以反映结点之间的逻辑关系。因此，链表中每个结点由两部分构成：**数据域和链域**。\n\n链表**没有固定的长度**，可以在后面一直加\n\n### 1.4  链表的分类\n\n从实现角度可分为：动态链表和静态链表\n\n从链接方式可分为：单链表、双链表和循环链表\n\n## 2、单链表\n\n指的是单向链表，每个节点的结构如下：\n\n![img](https://pic4.zhimg.com/v2-803ef9fc1306e345b495a62c087c8c77_b.png)\n\n把结点的实现，用面向对象的方法分析，把结点归为一个Structural类。\n\nStructural类中把数据域和后继节点都转为类的属性。\n\n![img](https://pic4.zhimg.com/v2-f41015fcf4b471c53f2e7ba3dd08facb_b.png)\n\n通常，我们定义一个链表，在他的第一个元素都不存储东西，让他只作为一个head标记，具体原因为什么？\n\n因为链表有删除操作，如果要删除的是第一个结点，我们没有最前面head结点的话，就没有办法进行。\n\n比如，数据域我们就存储一个name。\n\n那么Node类的结构如下：\n\n```java\npublic class Structural {\n	public String name;\n	public Structural next;\n}\n```\n\n我们可以把创建节点，分配空间的过程，在构造方法中完成\n\n```java\n// 创建节点，分配空间\n	public Structural(String name, Structural next) {\n		// TODO Auto-generated constructor stub\n		this.name = name;\n		this.next = next;\n	}\n```\n\n这样我们利用类的构造方法就可以完成，结点的创建过程。\n\n因为链表最小单元，就是一个结点，我们就把链表的操作归给，这个结点的方法，写出静态方法，调用的时候，只需要直接用类名调用就行。\n\n一个结点就是一个链表，如需加入更多结点只需要在后面接着加就好了！！！\n\n下来开始写链表的操作：\n\n（1）插入操作\n\n![img](https://pic3.zhimg.com/v2-1a22c90e46ba8df3aee23b6dde2c804a_b.png)\n\n![img](https://pic1.zhimg.com/v2-6f65f6803b634e7b7492fece88c09cd0_b.png)\n\n```java\n// 插入操作(链表头节点，一个指定节点，要插入的节点) 插到指定节点之后\n	public static void insert(Structural head, Structural index, Structural data) {\n		boolean flag = false;\n		// 如果头指针不存在，链表不存在\n		if (head == null) {\n			return;\n		}\n		// 如果插入到头节点之后,也就是要成为第一个元素\n		if (head.next == index) {\n			data.next = head.next;\n			head.next = data;\n			flag = true;\n		}\n\n		while (head.next != null) {\n			head = head.next;\n			if (head == index) {\n				data.next = head.next;\n				head.next = data;\n				flag = true;\n\n				break;\n			}\n\n		}\n		if (flag == true) {\n			System.out.println(\"插入成功\");\n		} else {\n			System.out.println(\"插入失败\");\n		}\n\n	}\n```\n\n（2）删除操作\n\n![img](https://pic4.zhimg.com/v2-8920e66d267f640bc80d8e53bdddeedb_b.png)\n\n代码实现：\n\n```java\n	// 删除操作(头节点，要删除节点)\n	public static void dir(Structural head, Structural data) {\n		boolean flag = false;\n		// 如果头指针不存在，链表不存在\n		if (head == null) {\n			System.out.println(\"删除失败\");\n			return;\n		}\n		// 如果删除头节点\n		if (head == data) {\n			head = head.next;\n			flag = true;\n		}\n		while (head.next != null) {\n			if (head.next == data) {\n				head.next = head.next.next;\n				flag = true;\n				break;\n			}\n			head = head.next;\n		}\n		if (flag) {\n			System.out.println(\"删除成功\");\n		} else {\n			System.out.println(\"删除失败\");\n		}\n	}\n```\n\n(3)  修改操作\n\n![img](https://pic2.zhimg.com/v2-279cd9587580affcc5aaee10d4d07d65_b.png)\n\n代码实现：\n\n```java\npublic static void revise(Structural head, Structural str1, Structural str2) {\n		boolean flag = false;\n		if (head == null) {\n			System.out.println(\"修改失败\");\n		}\n\n		while (head.next != null) {\n\n			if (head.next == str1) {\n				str2.next = head.next.next;\n				head.next = str2;\n				flag = true;\n				break;\n			}\n			head = head.next;\n		}\n		if (flag) {\n			System.out.println(\"修改成功\");\n		} else {\n			System.out.println(\"修改失败\");\n		}\n\n	}\n```\n\n测试：\n\n```java\npublic class LinkedList {\n	public static void main(String[] args) {\n		Structural head = new Structural(null, null);\n		Structural structural1 = new Structural(\"a\",null);\n		Structural structural2 = new Structural(\"b\",null);\n		Structural structural3 = new Structural(\"c\",null);\n		Structural structural4 = new Structural(\"d\",null);\n		Structural structural5 = new Structural(\"e\",null);\n		\n		//单向链表\n		head.next = structural1;\n		structural1.next = structural2;\n		structural2.next = structural3;\n		structural3.next = structural4;\n		structural4.next = structural5;		\n		\n		\n		for(Structural structural = head ; structural != null ;structural = structural.next) {\n			System.out.println(structural);\n		}\n		\n		\n		\n		System.out.println(\"---------------------\");\n		//插入(把f插到d后面)\n		Structural structural6 = new Structural(\"f\", null);\n		Structural.insert(head, structural4, structural6);\n		for(Structural structural = head ; structural != null ;structural = structural.next) {\n			System.out.println(structural);\n		}\n		System.out.println(\"---------------------\");\n		//删除(把f删除)中间元素删除\n		Structural.dir(head, structural6);\n		for(Structural structural = head ; structural != null ;structural = structural.next) {\n			System.out.println(structural);\n		}\n		System.out.println(\"---------------------\");\n		//删除(把a删除)头节点删除\n		Structural.dir(head, structural1);\n		for(Structural structural = head ; structural != null ;structural = structural.next) {\n			System.out.println(structural);\n		}\n		System.out.println(\"---------------------\");\n		//删除(把e删除)末尾节点删除\n		Structural.dir(head, structural5);\n		for(Structural structural = head ; structural != null ;structural = structural.next) {\n			System.out.println(structural);\n		}\n		System.out.println(\"---------------------\");\n		\n		//修改(把c改为g)\n		Structural structural7 = new Structural(\"g\", null);\n		Structural.revise(head,structural3, structural7);\n		for(Structural structural = head ; structural != null ;structural = structural.next) {\n			System.out.println(structural);\n		}\n		System.out.println(\"---------------------\");\n		\n			\n	}\n	\n}\n```\n\n结果：+\n\n```java\nStructural [name=null]\nStructural [name=a]\nStructural [name=b]\nStructural [name=c]\nStructural [name=d]\nStructural [name=e]\n---------------------\n插入成功\nStructural [name=null]\nStructural [name=a]\nStructural [name=b]\nStructural [name=c]\nStructural [name=d]\nStructural [name=f]\nStructural [name=e]\n---------------------\n删除成功\nStructural [name=null]\nStructural [name=a]\nStructural [name=b]\nStructural [name=c]\nStructural [name=d]\nStructural [name=e]\n---------------------\n删除成功\nStructural [name=null]\nStructural [name=b]\nStructural [name=c]\nStructural [name=d]\nStructural [name=e]\n---------------------\n删除成功\nStructural [name=null]\nStructural [name=b]\nStructural [name=c]\nStructural [name=d]\n---------------------\n修改成功\nStructural [name=null]\nStructural [name=b]\nStructural [name=g]\nStructural [name=d]\n---------------------\n```\n\n终于无聊的把自己的思路说完了。\n\n## 3、一道经典的算法题——判断单链表是否有环\n\n先看看链表可能出现的情况，所有单链表无非三种情况\n\n​	 * 第一种：从头节点指向下个，一直指下去，最后一个结点的next指向null\n\n​	 * 第二种：从头节点指向下个，一直指下去，最后一个结点的next指向头节点，形成一个首尾相连的环链表\n\n​	 * 第三种：从头节点指向下个，一直指下去，最后一个结点的next指向局部节点，形成一个局部尾部有环的链表。\n\n关于如何判断单链表是否有环，有三种解法：\n\n（1）先定义1个结点，先让他等于头节点，然后向后遍历，遍历一次，和头节点对比一次，如果出现相同，说明链表有环，如果没有出现相等情况，则说明没有环。\n\n但是这种算法只能处理，前两种情况，因此缺乏普遍性，不适用。\n\n（2）遍历链表，每遍历一个，把他们的hashcode值，先和数组里面的比较，如果没有再存储到一个数组里，如果找到有重复的，就说明有环。\n\n（3）算法效率最高的,定义两个指针，一个跑得快，一个跑得慢，有一天他两相遇了，说明有环\n\n例子：两个人都沿着跑步，都向前跑，一个跑的快，一个跑得慢，有一天他两相遇了，说明跑道中有环。\n\n代码实现：\n\n```java\npublic static boolean hasLoop(Structural head) {\n		\n		if(head == null) {\n			return false;\n		}\n		//定义一个跑的快的，每次遍历两个节点\n		Structural stru1 = head;\n		\n		//定义一个跑的慢的，每次遍历一个节点\n		Structural stru2 = head;\n		while(true) {\n			//避免一开始就相遇，让跑的快的，先跑两步。\n			stru1 = stru1.next.next;\n			stru2 =stru2.next;\n			if(stru1 == null) {\n				System.out.println(\"链表没有环\");\n				return false;\n			}\n			if(stru2 == stru1) {\n					System.out.println(\"链表有环\");\n					return true;\n				}		\n			}\n		}\n```\n\n', 0, 0, '2020-08-07 00:56:54', 2, 0, 1, '1、链表的概述1.1 链式存储：用一组任意类型的存储单元存储线性表，在逻辑上面相邻的结点在物理位置上面不一定相邻。\n1.2 链表：采用链式存储方法的线性表叫做链表\n1.3  链表的特点：其结点的存储单元可以不连续，每个结点中除存储原表结点中的数据外，还须存储指示其直接后继或前趋结点的地址，以反映结点之间的逻辑关系。因此，链表中每个结点由两部分构成：数据域和链域。\n链表没有固定的长度，可以在后面一直加\n1.4  链表的分类从实现角度可分为：动态链表和静态链表\n从链接方式可分为：单链表、双链表和循环链表\n2、单链表指的是单向链表，每个节点的结构如下：\n\n把结点的实现，用面向对象的方法分析，把结点归为一个Structural类。\nStructural类中把数据域和后继节点都转为类的属性。\n\n通常，我们定义一个链表，在他的第一个元素都不存储东西，让他只作为一个head标记，具体原因为什么？\n因为链表有删除操作，如果要删除的是第一个结点，我们没有最前面head结点的话，就没有办法进行。\n比如，数据域我们就存储一个name。\n那么Node类的结构如下：\npublic class Structural {    public String name;    public Structural next;}\n我们可以把创建节点，分配空间的过程，在构造方法中完成\n// 创建节点，分配空间    public Structural(String name, Structural next) {        // TODO Auto-generated constructor stub        this.name = name;        this.next = next;    }\n这样我们利用类的构造方法就可以完成，结点的创建过程。\n因为链表最小单元，就是一个结点，我们就把链表的操作归给，这个结点的方法，写出静态方法，调用的时候，只需要直接用类名调用就行。\n一个结点就是一个链表，如需加入更多结点只需要在后面接着加就好了！！！\n下来开始写链表的操作：\n（1）插入操作\n\n\n// 插入操作(链表头节点，一个指定节点，要插入的节点) 插到指定节点之后    public static void insert(Structural head, Structural index, Structural data) {        boolean flag = false;        // 如果头指针不存在，链表不存在        if (head == null) {            return;        }        // 如果插入到头节点之后,也就是要成为第一个元素        if (head.next == index) {            data.next = head.next;            head.next = data;            flag = true;        }        while (head.next != null) {            head = head.next;            if (head == index) {                data.next = head.next;                head.next = data;                flag = true;                break;            }        }        if (flag == true) {            System.out.println(\"插入成功\");        } else {            System.out.println(\"插入失败\");        }    }\n（2）删除操作\n\n代码实现：\n    // 删除操作(头节点，要删除节点)    public static void dir(Structural head, Structural data) {        boolean flag = false;        // 如果头指针不存在，链表不存在        if (head == null) {            System.out.println(\"删除失败\");            return;        }        // 如果删除头节点        if (head == data) {            head = head.next;            flag = true;        }        while (head.next != null) {            if (head.next == data) {                head.next = head.next.next;                flag = true;                break;            }            head = head.next;        }        if (flag) {            System.out.println(\"删除成功\");        } else {            System.out.println(\"删除失败\");        }    }\n(3)  修改操作\n\n代码实现：\npublic static void revise(Structural head, Structural str1, Structural str2) {        boolean flag = false;        if (head == null) {            System.out.println(\"修改失败\");        }        while (head.next != null) {            if (head.next == str1) {                str2.next = head.next.next;                head.next = str2;                flag = true;                break;            }            head = head.next;        }        if (flag) {            System.out.println(\"修改成功\");        } else {            System.out.println(\"修改失败\");        }    }\n测试：\npublic class LinkedList {    public static void main(String[] args) {        Structural head = new Structural(null, null);        Structural structural1 = new Structural(\"a\",null);        Structural structural2 = new Structural(\"b\",null);        Structural structural3 = new Structural(\"c\",null);        Structural structural4 = new Structural(\"d\",null);        Structural structural5 = new Structural(\"e\",null);        //单向链表        head.next = structural1;        structural1.next = structural2;        structural2.next = structural3;        structural3.next = structural4;        structural4.next = structural5;                for(Structural structural = head ; structural != null ;structural = structural.next) {            System.out.println(structural);        }        System.out.println(\"---------------------\");        //插入(把f插到d后面)        Structural structural6 = new Structural(\"f\", null);        Structural.insert(head, structural4, structural6);        for(Structural structural = head ; structural != null ;structural = structural.next) {            System.out.println(structural);        }        System.out.println(\"---------------------\");        //删除(把f删除)中间元素删除        Structural.dir(head, structural6);        for(Structural structural = head ; structural != null ;structural = structural.next) {            System.out.println(structural);        }        System.out.println(\"---------------------\");        //删除(把a删除)头节点删除        Structural.dir(head, structural1);        for(Structural structural = head ; structural != null ;structural = structural.next) {            System.out.println(structural);        }        System.out.println(\"---------------------\");        //删除(把e删除)末尾节点删除        Structural.dir(head, structural5);        for(Structural structural = head ; structural != null ;structural = structural.next) {            System.out.println(structural);        }        System.out.println(\"---------------------\");        //修改(把c改为g)        Structural structural7 = new Structural(\"g\", null);        Structural.revise(head,structural3, structural7);        for(Structural structural = head ; structural != null ;structural = structural.next) {            System.out.println(structural);        }        System.out.println(\"---------------------\");    }}\n结果：+\nStructural [name=null]Structural [name=a]Structural [name=b]Structural [name=c]Structural [name=d]Structural [name=e]---------------------插入成功Structural [name=null]Structural [name=a]Structural [name=b]Structural [name=c]Structural [name=d]Structural [name=f]Structural [name=e]---------------------删除成功Structural [name=null]Structural [name=a]Structural [name=b]Structural [name=c]Structural [name=d]Structural [name=e]---------------------删除成功Structural [name=null]Structural [name=b]Structural [name=c]Structural [name=d]Structural [name=e]---------------------删除成功Structural [name=null]Structural [name=b]Structural [name=c]Structural [name=d]---------------------修改成功Structural [name=null]Structural [name=b]Structural [name=g]Structural [name=d]---------------------\n终于无聊的把自己的思路说完了。\n3、一道经典的算法题——判断单链表是否有环先看看链表可能出现的情况，所有单链表无非三种情况\n​     * 第一种：从头节点指向下个，一直指下去，最后一个结点的next指向null\n​     * 第二种：从头节点指向下个，一直指下去，最后一个结点的next指向头节点，形成一个首尾相连的环链表\n​     * 第三种：从头节点指向下个，一直指下去，最后一个结点的next指向局部节点，形成一个局部尾部有环的链表。\n关于如何判断单链表是否有环，有三种解法：\n（1）先定义1个结点，先让他等于头节点，然后向后遍历，遍历一次，和头节点对比一次，如果出现相同，说明链表有环，如果没有出现相等情况，则说明没有环。\n但是这种算法只能处理，前两种情况，因此缺乏普遍性，不适用。\n（2）遍历链表，每遍历一个，把他们的hashcode值，先和数组里面的比较，如果没有再存储到一个数组里，如果找到有重复的，就说明有环。\n（3）算法效率最高的,定义两个指针，一个跑得快，一个跑得慢，有一天他两相遇了，说明有环\n例子：两个人都沿着跑步，都向前跑，一个跑的快，一个跑得慢，有一天他两相遇了，说明跑道中有环。\n代码实现：\npublic static boolean hasLoop(Structural head) {        if(head == null) {            return false;        }        //定义一个跑的快的，每次遍历两个节点        Structural stru1 = head;        //定义一个跑的慢的，每次遍历一个节点        Structural stru2 = head;        while(true) {            //避免一开始就相遇，让跑的快的，先跑两步。            stru1 = stru1.next.next;            stru2 =stru2.next;            if(stru1 == null) {                System.out.println(\"链表没有环\");                return false;            }            if(stru2 == stru1) {                    System.out.println(\"链表有环\");                    return true;                }                    }        }\n', 0, 1);
INSERT INTO `t_article` VALUES (131, '02. 树的遍历算法（递归和非递归实现）', 8, '\n##前言\n树从存储方式上可分为顺序树和链式树\n\n这节我们主要说的是链式树。\n\n## 1.  定义结点\n\n```java\npublic class Node {\n	public String name;          //结点的数据域，拿String name代替\n	public Node lchild;          //存放左孩子\n	public Node rchild;          //存放右孩子\n	public boolean status;       //非递归后序遍历会用到\n	public Node() {\n		// TODO Auto-generated constructor stub\n		this.name = \"\";\n		this.lchild = null;\n		this.rchild = null;\n		this.status = false;\n	}\n	\n	public Node(String string) {\n		// TODO Auto-generated constructor stub\n		this.name = string;\n		this.lchild = null;\n		this.rchild = null;\n		this.status = false;\n	}	\n}\n```\n\n## 2.  树的创建\n\n定义一个Tree类，里面主要实现树的创建，和一些遍历操作，先部分展示代码并讲解，在最后会给出全部源码。\n\n我们为了养成良好的习惯，建议把每个东西归结成一个类，比如树，栈，队列，都分开定义，到用的时候，直接new就行了。\n\n### 先定义数据结构\n\n1.树的结构：\n\n```java\npublic class Tree {\n\n	// 声明输入流\n	Scanner scanner;\n\n	// 声明一个队列(层序遍历会用到)\n	Seqqueue queue;\n\n	// 声明一个栈(非递归的先序，中序，后序会用到)\n	Seqstack stack;\n\n	public Tree() {\n		// TODO Auto-generated constructor stub\n		// 初始化输入流\n		this.scanner = new Scanner(System.in);\n\n		// 初始化队列\n		this.queue = new Seqqueue();\n		this.queue.initQueue(10);\n\n		// 初始化栈\n		this.stack = new Seqstack();\n		this.stack.InitStack(20);\n\n	}\n```\n\n2.栈的结构：（树的非递归遍历会用到）\n\n```java\npublic class Seqstack {\n	// 节点数组(模拟顺序栈)\n	public Node[] nodes;\n\n	// 栈顶下标\n	public int top;\n\n	public Seqstack() {\n		// TODO Auto-generated constructor stub\n		this.top = -1;\n\n	}\n\n	// 初始化栈\n	public void InitStack(int size) {\n		this.nodes = new Node[size];\n		this.top = -1;\n\n	}\n\n	// 判断栈空\n	public boolean IsEmpty() {\n		if (this.top == -1) {\n			return true;\n		}\n\n		return false;\n	}\n\n	// 判断栈满\n	public boolean IsFull() {\n		if (this.top == this.nodes.length - 1) {\n			return true;\n		}\n\n		return false;\n	}\n\n	// 入栈\n	public void push(Node node) {\n		if (IsFull()) {\n			System.out.println(\"栈已经满了，入栈失败\");\n			return;\n		}\n		this.top++;\n		this.nodes[this.top] = node;\n	}\n\n	// 出栈\n	public Node pop() {\n		if (IsEmpty()) {\n			System.out.println(\"栈已经空了，出栈失败\");\n			return null;\n		}\n		Node node = this.nodes[this.top];\n		this.top--;\n		return node;\n\n	}\n\n	// 清空栈\n	public void ClearStack() {\n		// 如果不为空，就一直出栈\n		while (!IsEmpty()) {\n			Node node = pop();\n		}\n\n	}\n\n	// 拿到栈顶元素\n	public Node getTop() {\n		if (IsEmpty()) {\n			System.out.println(\"栈中没有元素\");\n			return null;\n		}\n		return this.nodes[this.top];\n	}\n}\n```\n\n3.循环队列的结构：（树的层序遍历会用到）\n\n```java\npublic class Seqqueue {\n	public Node[] queue;\n	public int QUEUE_SIZE;\n	public int front;\n	public int rear;\n	\n	//初始化队列\n		public void initQueue(int size) {\n			this.QUEUE_SIZE = size;\n			this.queue = new Node[size];\n			this.front = 0;\n			this.rear = 0;\n		\n		}\n		\n		//判断队列是否为空\n		public boolean isEmpty() {\n			if(this.front  == this.rear ) {\n				return true;\n			}\n			else {\n				return false;\n			}\n		}\n		\n		//判断队列是否为满\n		public boolean isFull() {\n			if((this.front % this.QUEUE_SIZE) == ((this.rear+1) % this.QUEUE_SIZE)) {\n				return true;\n			}\n			else {\n				return false;\n			}\n		}\n		\n		//入队\n		public void enterQueue(Node node) {\n			if(isFull()) {\n				System.out.println(\"队列已经满了，入队失败\");\n		        return;		\n			}\n			this.queue[this.rear] = node;\n			this.rear ++;\n			this.rear = this.rear % this.QUEUE_SIZE;\n			\n		}\n		//出队\n		public Node deleteQueue() {\n			if(isEmpty()){\n				System.out.println(\"队列为空，出队失败\");\n				return null;\n			}\n			this.front = this.front % this.QUEUE_SIZE;\n			Node node = this.queue[this.front];\n			\n			this.front++;\n			return node;\n		}\n}\n```\n\n4. 树的递归创建方式：（使用先序创建）\n\n```java\n	// 递归创建树（树的头节点）\n	Node createBiTree(Node tree) {\n		String string = scanner.nextLine();\n		if (string.equals(\".\")) {\n			return null;\n		}\n		tree = new Node();\n\n		tree.name = string;\n		tree.lchild = createBiTree(tree.lchild);\n		tree.rchild = createBiTree(tree.rchild);\n		return tree;\n	}\n```\n\n## 3. 树的递归遍历\n\n我们利用三种遍历的特点，根据他们的打印顺序总结出来:\n\n先序：根左右\n\n中序：左跟右\n\n后序：左右跟\n\n### 3.1 树的递归先序遍历\n\n```java\n	// 先序遍历(递归)\n	void PreOrder(Node tree) {\n		if (tree != null) {\n			System.out.println(tree.name);\n			PreOrder(tree.lchild);\n			PreOrder(tree.rchild);\n		}\n\n	}\n```\n\n### 3.2  树的递归中序遍历\n\n```java\n	// 中序遍历(递归)\n	void Inthread(Node tree) {\n		if (tree != null) {\n			Inthread(tree.lchild);\n			System.out.println(tree.name);\n			Inthread(tree.rchild);\n		}\n	}\n```\n\n## 3.3  树的递归后序遍历\n\n```java\n	// 后序遍历(递归)\n	void PostOrder(Node tree) {\n		if (tree != null) {\n			PostOrder(tree.lchild);\n			PostOrder(tree.rchild);\n			System.out.println(tree.name);\n		}\n	}\n```\n\n递归的遍历特别简单，只需要知道递归的原理就OK了，不做详解。\n\n## 4.  树的非递归遍历\n\n树的非递归遍历，还会用到栈，利用栈的先进后出的特点，实现树的遍历。\n\n### 4.1 树的非递归先序遍历\n\n这块我会给出两种方法，原理基本相同。\n\n**（1）根据先序打印特点：根左右。**\n\n我们用到压栈和出栈来模拟这个过程：\n\n1. 由于栈是先进后出的，所以我们先访问根节点，压栈。\n2. 然后判断栈不为空，然后出栈，打印。\n3. 对出栈的结点进行判断，他有没有右孩子，如果有，把右孩子压栈。\n4. 再判断有没有左孩子，如果有，把左孩子压栈。\n5. 完成后，再跳回第2步，一直循环\n\n```java\n	// 先序遍历(非递归)\n	void nonPreOrder(Node tree) {\n		Node temp = null;\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		stack.push(tree);\n		while (!stack.IsEmpty()) {\n			temp = stack.pop();\n			System.out.println(temp.name);\n			if (temp.rchild != null) {\n				stack.push(temp.rchild);\n			}\n			if (temp.lchild != null) {\n				stack.push(temp.lchild);\n			}\n		}\n	}\n```\n\n（2）第二种只是把压栈的顺序，进行了一点修正，其他的都差不多，但是，为了方便记忆非递归的先序，中序，后序，建议学习第二种的算法。\n\n```java\n	// 先序遍历(非递归)\n	void nonPreOrder2(Node tree) {\n\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		Node temp = null;\n		temp = tree;\n		while (!stack.IsEmpty() || temp != null) {\n			while (temp != null) {\n				System.out.println(temp.name);\n				stack.push(temp);\n				temp = temp.lchild;\n			}\n			temp = stack.pop();\n			temp = temp.rchild;\n		}\n	}\n```\n\n### 4.2 树的非递归中序遍历\n\n**根据中序打印特点：左跟右。**\n\n我们用到压栈和出栈来模拟这个过程：\n\n1. 由于栈是先进后出的，所以我们先访问根节点，用temp结点记录。\n2. 然后判断栈不为空或者temp不为空，进入循环。\n3. 先将temp的所有左子树全部压栈。\n4. 然后出栈栈顶结点，打印\n5. 然后再判断出栈的这个结点有没有右孩子，如果有，将右孩子入栈\n6. 再将右孩子结点 的所有左孩子全部入栈，即从第3步开始循环。\n\n```java\n	// 中序遍历(非递归)\n	void nonInthread(Node tree) {\n\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		Node temp = null;\n		temp = tree;\n		while (!stack.IsEmpty() || temp != null) {\n			while (temp != null) {\n				stack.push(temp);\n				temp = temp.lchild;\n			}\n\n			temp = stack.pop();\n			System.out.println(temp.name);\n			temp = temp.rchild;\n\n		}\n	}\n```\n\n中序的非递归遍历，和上述的先序的第二种非递归遍历比较，会发现，只改变了打印的位置，其他的都没有变化，所以建议记住，先序的第二种算法。\n\n### 4.2 树的非递归后序遍历\n\n后序我会给出，自己总结的三种方法，各有特点，其中第一种可以和前两对应起来，改动较小，对应编程能力差的同学，可以着重学习，后两种方法也很nice，想要多学点的同学，也可以学习。\n\n**（1）第一种：根据后序打印特点：左右跟。**\n\n我们根据先序的过程，先访问根节点，再访问左孩子，最后访问右孩子，根据具体的顺序，我们可以发现其实后序只需要，**把先序打印的过程，换成一个如另一个栈的过程，所以我们需要两个栈，再把先将左孩子压栈，后将右孩子压栈，变成先将右孩子压栈，再将左孩子压栈，最后我们的第二个栈中就得到了后序的倒序，我们再将第二个栈出栈，打印就行。**\n\n```java\n	// 后序遍历(非递归3)\n	void nonPostOrder3(Node tree) {\n		Seqstack stack2 = new Seqstack();\n		stack2.InitStack(20);\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		Node temp = null;\n		temp = tree;\n		while (!stack.IsEmpty() || temp != null) {\n			while (temp != null) {\n				stack2.push(temp);       //这行改变\n				stack.push(temp);\n				temp = temp.rchild;      //这行改变\n			}\n			temp = stack.pop();\n			temp = temp.lchild;\n		}\n		while (!stack2.IsEmpty()) {              //把第二个栈全部出栈打印\n			temp = stack2.pop();              \n			System.out.println(temp.name);\n\n		}\n	}\n```\n\n### 后两种方法，都需要明白一个特点：\n\n我们可以观察前序、中序、后序的过程，根据他们是第几次访问根节点然后再打印的特点，我们可以发现：\n\n1. 先序都是先访问根节点，然后打印，然后再访问他的左孩子，把他的左孩子又看出根节点，然后打印，又去访问他的左孩子，如果左孩子不存在，去访问他的右孩子，把他的右孩子又看成根节点，一直重复上面的步骤。（这块的根节点指的是每一个结点都看成根节点，不是特指树的根节点）。\n2. 中序都是先访问根节点，然后访问所有的左孩子，左孩子全部访问结束，再回来访问根节点，打印根节点，再去访问右孩子，又去访问右孩子的所有左孩子，一直重复上面步骤。\n3. 后序都是先访问根节点，再访问他的全部左孩子，左孩子全部访问结束，再回来访问他的根节点，又访问他的全部右孩子，右孩子全部访问结束，再反过来打印根节点。（这块的根节点指的是每一个结点都看成根节点，不是特指树的根节点）。\n\n总结一个特点：\n\n1. **先序**：**第一次**访问一个结点时打印\n2. **中序**：**第二次**访问一个结点时打印\n3. **后序**：**第三次**访问一个结点时打印\n\n**后序什么时候打印，可以根据他是不是访问完右孩子过来的，如果是访问完右孩子过来的，就让他打印，否则去遍历他的右孩子。**\n\n下面的两种方法都是根据，这个特点完成的，这是有点稍微的区别。\n\n**（2）第二种：多创建一个结点，用来记录出栈的元素，进行判断**\n\n```java\n	// 后序遍历(非递归1)\n	void nonPostOrder(Node tree) {\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		Node temp, r = null;   //r用来记录\n		temp = tree;\n		while (temp != null || !stack.IsEmpty()) {\n			if (temp != null) {\n				stack.push(temp);\n				temp = temp.lchild;\n			} else {\n				temp = stack.getTop();\n				if (temp.rchild != null && temp.rchild != r) {\n					temp = temp.rchild;\n				} else {\n					temp = stack.pop();\n					System.out.println(temp.name);\n					r = temp;\n					temp = null;\n				}\n			}\n\n		}\n\n	}\n```\n\n**（3）第三种：利用在结点中，多一个属性，用来记录是第几次访问**\n\n```java\n	// 后序遍历(非递归2)\n	void nonPostOrder2(Node tree) {\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		Node temp;\n		temp = tree;\n		stack.push(temp);\n		temp = temp.lchild;\n		while (!stack.IsEmpty() || temp != null) {\n			while (temp != null) {\n				stack.push(temp);\n				temp = temp.lchild;\n			}\n\n			temp = stack.pop();\n			if (temp.rchild != null && temp.status == false) {\n				stack.push(temp);\n				temp.status = true;\n				temp = temp.rchild;\n			} else {\n				System.out.println(temp.name);\n				temp = null;\n			}\n\n		}\n	}\n```\n\n## 5. 树的层序遍历\n\n用到了队列\n\n```java\n	// 层序遍历\n	void cengxu(Node tree) {\n		Node temp = null;\n		queue.front = queue.rear = 0;\n		if (tree == null) {\n			System.out.println(\"该树为空\");\n			return;\n		}\n		queue.enterQueue(tree);\n		while (queue.front != queue.rear) {\n			temp = queue.deleteQueue();\n			System.out.println(temp.name);\n			if (temp.lchild != null) {\n				queue.enterQueue(temp.lchild);\n			}\n			if (temp.rchild != null) {\n				queue.enterQueue(temp.rchild);\n			}\n\n		}\n	}\n```\n\n## 6.  计算树的深度\n\n```java\n	// 递归计算树的深度\n	int high(Node t) {\n		int h = 0, left = 0, right = 0;\n		if (t == null) {\n			return 0;\n		}\n		left = high(t.lchild);\n		right = high(t.rchild);\n		h = (left > right ? left : right) + 1;\n		return h;\n	}\n```\n\n## 7.  反转二叉树\n\n### 7.1 递归方法\n\n```java\n	// 反转二叉树(递归)\n	void recReversal(Node tree) {\n		if (tree == null) {\n			return;\n		}\n		if (tree.lchild == null && tree.rchild == null) {\n			return;\n		}\n		Node temp = tree.lchild;\n		tree.lchild = tree.rchild;\n		tree.rchild = temp;\n		recReversal(tree.lchild);\n		recReversal(tree.rchild);\n	}\n```\n\n### 7.2 非递归算法\n\n用到栈\n\n```java\n	// 反转二叉树(非递归)\n	void nonRecReversal(Node tree) {\n		Node t = null;\n		if (tree == null) {\n			System.out.println(\"树为空\");\n			return;\n		}\n		stack.push(tree);\n		while (!stack.IsEmpty()) {\n			Node temp = stack.pop();\n			t = temp.lchild;\n			temp.lchild = temp.rchild;\n			temp.rchild = t;\n\n			if (temp.rchild != null) {\n				stack.push(temp.rchild);\n			}\n			if (temp.lchild != null) {\n				stack.push(temp.lchild);\n			}\n		}\n	}\n```\n\n### 8.  统计结点数（递归）\n\n```java\n	// 统计结点数(递归)\n	int getNodeNum(Node tree) {\n		int nodes = 0;\n		if (tree == null) {			\n			return 0;\n		}\n		else {\n			nodes = 1 + getNodeNum(tree.lchild) + getNodeNum(tree.rchild);\n		}\n		\n		return nodes;\n	}\n```\n\n## 9.  统计叶子结点数（递归）\n\n```java\n	//统计叶子结点数（递归）\n	int getLeafNum(Node tree) {\n		if(tree == null) {\n			return 0;\n		}\n		if(tree.lchild == null &&tree.rchild == null) {\n			return 1;\n		}\n		return getLeafNum(tree.lchild) + getLeafNum(tree.rchild);			\n	}\n```\n\n## 10.  判断一个结点是否是一个子树上的结点（递归）\n\n```java\n	//找一个结点是否是一个子树的结点\n	boolean Ishave(Node tree,Node node) {\n		if(node == null || tree == null) {\n			return false;\n		}\n		if(tree.name.equals(node.name)) {\n			return true;\n		}\n		else {\n			return Ishave(tree.lchild, node) | Ishave(tree.rchild, node);\n		}\n		\n	}\n```\n\n## 11. 代码的综合\n\n对上面讲述所有代码算法的综合\n\n树的创建和操作：\n\n//class Tree\n\n```java\nimport java.util.Scanner;\n\npublic class Tree {\n\n	// 声明输入流\n	Scanner scanner;\n\n	// 声明一个队列(层序遍历会用到)\n	Seqqueue queue;\n\n	// 声明一个栈(非递归的先序，中序，后序会用到)\n	Seqstack stack;\n\n	public Tree() {\n		// TODO Auto-generated constructor stub\n		// 初始化输入流\n		this.scanner = new Scanner(System.in);\n\n		// 初始化队列\n		this.queue = new Seqqueue();\n		this.queue.initQueue(10);\n\n		// 初始化栈\n		this.stack = new Seqstack();\n		this.stack.InitStack(20);\n\n	}\n\n	// 递归创建树（树的头节点）\n	Node createBiTree(Node tree) {\n		String string = scanner.nextLine();\n		if (string.equals(\".\")) {\n			return null;\n		}\n		tree = new Node();\n\n		tree.name = string;\n		tree.lchild = createBiTree(tree.lchild);\n		tree.rchild = createBiTree(tree.rchild);\n		return tree;\n	}\n\n	// 先序遍历(递归)\n	void PreOrder(Node tree) {\n		if (tree != null) {\n			System.out.println(tree.name);\n			PreOrder(tree.lchild);\n			PreOrder(tree.rchild);\n		}\n\n	}\n\n	// 先序遍历(非递归)\n	void nonPreOrder(Node tree) {\n		Node temp = null;\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		stack.push(tree);\n		while (!stack.IsEmpty()) {\n			temp = stack.pop();\n			System.out.println(temp.name);\n			if (temp.rchild != null) {\n				stack.push(temp.rchild);\n			}\n			if (temp.lchild != null) {\n				stack.push(temp.lchild);\n			}\n		}\n	}\n\n	// 先序遍历(非递归)\n	void nonPreOrder2(Node tree) {\n\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		Node temp = null;\n		temp = tree;\n		while (!stack.IsEmpty() || temp != null) {\n			while (temp != null) {\n				System.out.println(temp.name);\n				stack.push(temp);\n				temp = temp.lchild;\n			}\n			temp = stack.pop();\n			temp = temp.rchild;\n		}\n	}\n\n	// 中序遍历(递归)\n	void Inthread(Node tree) {\n		if (tree != null) {\n			Inthread(tree.lchild);\n			System.out.println(tree.name);\n			Inthread(tree.rchild);\n		}\n	}\n\n	// 中序遍历(非递归)\n	void nonInthread(Node tree) {\n\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		Node temp = null;\n		temp = tree;\n		while (!stack.IsEmpty() || temp != null) {\n			while (temp != null) {\n				stack.push(temp);\n				temp = temp.lchild;\n			}\n\n			temp = stack.pop();\n			System.out.println(temp.name);\n			temp = temp.rchild;\n\n		}\n	}\n\n	// 后序遍历(递归)\n	void PostOrder(Node tree) {\n		if (tree != null) {\n			PostOrder(tree.lchild);\n			PostOrder(tree.rchild);\n			System.out.println(tree.name);\n		}\n	}\n\n	// 后序遍历(非递归1)\n	void nonPostOrder(Node tree) {\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		Node temp, r = null;\n		temp = tree;\n		while (temp != null || !stack.IsEmpty()) {\n			if (temp != null) {\n				stack.push(temp);\n				temp = temp.lchild;\n			} else {\n				temp = stack.getTop();\n				if (temp.rchild != null && temp.rchild != r) {\n					temp = temp.rchild;\n				} else {\n					temp = stack.pop();\n					System.out.println(temp.name);\n					r = temp;\n					temp = null;\n				}\n			}\n\n		}\n\n	}\n\n	// 后序遍历(非递归2)\n	void nonPostOrder2(Node tree) {\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		Node temp;\n		temp = tree;\n		stack.push(temp);\n		temp = temp.lchild;\n		while (!stack.IsEmpty() || temp != null) {\n			while (temp != null) {\n				stack.push(temp);\n				temp = temp.lchild;\n			}\n\n			temp = stack.pop();\n			if (temp.rchild != null && temp.status == false) {\n				stack.push(temp);\n				temp.status = true;\n				temp = temp.rchild;\n			} else {\n				System.out.println(temp.name);\n				temp = null;\n			}\n\n		}\n	}\n\n	// 后序遍历(非递归3)\n	void nonPostOrder3(Node tree) {\n		Seqstack stack2 = new Seqstack();\n		stack2.InitStack(20);\n		if (tree == null) {\n			System.out.println(\"树不存在\");\n			return;\n		}\n		Node temp = null;\n		temp = tree;\n		while (!stack.IsEmpty() || temp != null) {\n			while (temp != null) {\n				stack2.push(temp);\n				stack.push(temp);\n				temp = temp.rchild;\n			}\n			temp = stack.pop();\n			temp = temp.lchild;\n		}\n		while (!stack2.IsEmpty()) {\n			temp = stack2.pop();\n			System.out.println(temp.name);\n\n		}\n	}\n\n	// 层序遍历\n	void cengxu(Node tree) {\n		Node temp = null;\n		queue.front = queue.rear = 0;\n		if (tree == null) {\n			System.out.println(\"该树为空\");\n			return;\n		}\n		queue.enterQueue(tree);\n		while (queue.front != queue.rear) {\n			temp = queue.deleteQueue();\n			System.out.println(temp.name);\n			if (temp.lchild != null) {\n				queue.enterQueue(temp.lchild);\n			}\n			if (temp.rchild != null) {\n				queue.enterQueue(temp.rchild);\n			}\n\n		}\n	}\n\n	// 递归计算树的深度\n	int high(Node t) {\n		int h = 0, left = 0, right = 0;\n		if (t == null) {\n			return 0;\n		}\n		left = high(t.lchild);\n		right = high(t.rchild);\n		h = (left > right ? left : right) + 1;\n		return h;\n	}\n\n	// 反转二叉树(递归)\n	void recReversal(Node tree) {\n		if (tree == null) {\n			return;\n		}\n		if (tree.lchild == null && tree.rchild == null) {\n			return;\n		}\n		Node temp = tree.lchild;\n		tree.lchild = tree.rchild;\n		tree.rchild = temp;\n		recReversal(tree.lchild);\n		recReversal(tree.rchild);\n	}\n\n	// 反转二叉树(非递归)\n	void nonRecReversal(Node tree) {\n		Node t = null;\n		if (tree == null) {\n			System.out.println(\"树为空\");\n			return;\n		}\n		stack.push(tree);\n		while (!stack.IsEmpty()) {\n			Node temp = stack.pop();\n			t = temp.lchild;\n			temp.lchild = temp.rchild;\n			temp.rchild = t;\n\n			if (temp.rchild != null) {\n				stack.push(temp.rchild);\n			}\n			if (temp.lchild != null) {\n				stack.push(temp.lchild);\n			}\n		}\n	}\n	\n	//统计叶子结点数（递归）\n	int getLeafNum(Node tree) {\n		if(tree == null) {\n			return 0;\n		}\n		if(tree.lchild == null &&tree.rchild == null) {\n			return 1;\n		}\n		return getLeafNum(tree.lchild) + getLeafNum(tree.rchild);			\n	}\n	\n	// 统计结点数(递归)\n	int getNodeNum(Node tree) {\n		int nodes = 0;\n		if (tree == null) {			\n			return 0;\n		}\n		else {\n			nodes = 1 + getNodeNum(tree.lchild) + getNodeNum(tree.rchild);\n		}\n		\n		return nodes;\n	}\n	\n	//判断一个结点是否是一个子树的结点\n	boolean Ishave(Node tree,Node node) {\n		if(node == null || tree == null) {\n			return false;\n		}\n		if(tree.name.equals(node.name)) {\n			return true;\n		}\n		else {\n			return Ishave(tree.lchild, node) | Ishave(tree.rchild, node);\n		}\n		\n	}\n\n}\n```\n\n栈的结构：\n\n//class Seqstack\n\n```java\npublic class Seqstack {\n	// 节点数组(模拟顺序栈)\n	public Node[] nodes;\n\n	// 栈顶下标\n	public int top;\n\n	public Seqstack() {\n		// TODO Auto-generated constructor stub\n		this.top = -1;\n\n	}\n\n	// 初始化栈\n	public void InitStack(int size) {\n		this.nodes = new Node[size];\n		this.top = -1;\n\n	}\n\n	// 判断栈空\n	public boolean IsEmpty() {\n		if (this.top == -1) {\n			return true;\n		}\n\n		return false;\n	}\n\n	// 判断栈满\n	public boolean IsFull() {\n		if (this.top == this.nodes.length - 1) {\n			return true;\n		}\n\n		return false;\n	}\n\n	// 入栈\n	public void push(Node node) {\n		if (IsFull()) {\n			System.out.println(\"栈已经满了，入栈失败\");\n			return;\n		}\n		this.top++;\n		this.nodes[this.top] = node;\n	}\n\n	// 出栈\n	public Node pop() {\n		if (IsEmpty()) {\n			System.out.println(\"栈已经空了，出栈失败\");\n			return null;\n		}\n		Node node = this.nodes[this.top];\n		this.top--;\n		return node;\n\n	}\n\n	// 清空栈\n	public void ClearStack() {\n		// 如果不为空，就一直出栈\n		while (!IsEmpty()) {\n			Node node = pop();\n		}\n\n	}\n\n	// 拿到栈顶元素\n	public Node getTop() {\n		if (IsEmpty()) {\n			System.out.println(\"栈中没有元素\");\n			return null;\n		}\n		return this.nodes[this.top];\n	}\n}\n```\n\n循环队列的结构：\n\n//class Seqqueue\n\n```java\npublic class Seqqueue {\n	public Node[] queue;\n	public int QUEUE_SIZE;\n	public int front;\n	public int rear;\n	\n	//初始化队列\n		public void initQueue(int size) {\n			this.QUEUE_SIZE = size;\n			this.queue = new Node[size];\n			this.front = 0;\n			this.rear = 0;\n		\n		}\n		\n		//判断队列是否为空\n		public boolean isEmpty() {\n			if(this.front  == this.rear ) {\n				return true;\n			}\n			else {\n				return false;\n			}\n		}\n		\n		//判断队列是否为满\n		public boolean isFull() {\n			if((this.front % this.QUEUE_SIZE) == ((this.rear+1) % this.QUEUE_SIZE)) {\n				return true;\n			}\n			else {\n				return false;\n			}\n		}\n		\n		//入队\n		public void enterQueue(Node node) {\n			if(isFull()) {\n				System.out.println(\"队列已经满了，入队失败\");\n		        return;		\n			}\n			this.queue[this.rear] = node;\n			this.rear ++;\n			this.rear = this.rear % this.QUEUE_SIZE;\n			\n		}\n		//出队\n		public Node deleteQueue() {\n			if(isEmpty()){\n				System.out.println(\"队列为空，出队失败\");\n				return null;\n			}\n			this.front = this.front % this.QUEUE_SIZE;\n			Node node = this.queue[this.front];\n			\n			this.front++;\n			return node;\n		}\n}\n```\n\n给个测试用例：\n\n//class Client\n\n```java\npublic class Client {\n	public static void main(String[] args) {\n		Tree tree = new Tree();\n		Node node = null ;\n\n		Node node4 = new Node(\"a\");\n		\n\n		\n		node = tree.createBiTree(node);		\n		System.out.println(\"创建完成\");	\n		\n		\n		\n		System.out.println(\"递归先序遍历\");\n		tree.PreOrder(node);\n		System.out.println(\"---------------------\");\n		System.out.println(\"非递归先序遍历\");\n		tree.nonPreOrder(node);\n		System.out.println(\"---------------------\");\n		System.out.println(\"非递归先序遍历2\");\n		tree.nonPreOrder2(node);\n		System.out.println(\"---------------------\");\n		\n		\n		\n		System.out.println(\"递归中序遍历\");\n		tree.Inthread(node);\n		System.out.println(\"---------------------\");\n		System.out.println(\"非递归中序遍历\");\n		tree.nonInthread(node);\n		System.out.println(\"---------------------\");\n		\n		\n		\n		System.out.println(\"后序遍历(递归)\");\n		tree.PostOrder(node);\n		System.out.println(\"---------------------\");\n		System.out.println(\"后序遍历(非递归)\");\n		tree.nonPostOrder(node);\n		System.out.println(\"---------------------\");\n		System.out.println(\"后序遍历(非递归2)\");\n		tree.nonPostOrder2(node);\n		System.out.println(\"---------------------\");\n		System.out.println(\"后序遍历(非递归3)\");\n		tree.nonPostOrder3(node);\n		System.out.println(\"---------------------\");\n		\n		System.out.println(\"层序遍历\");\n		tree.cengxu(node);\n		System.out.println(\"---------------------\");\n		\n		\n		\n		System.out.println(\"树的深度\"+tree.high(node));\n		System.out.println(\"---------------------\");\n		\n		\n		\n		System.out.println(\"递归反转二叉树\");\n		tree.recReversal(node);\n		tree.cengxu(node);\n		System.out.println(\"-------------------\");\n		\n		\n		System.out.println(\"非递归反转二叉树\");\n		tree.nonRecReversal(node);\n		tree.cengxu(node);\n		System.out.println(\"-------------------\");\n		\n		System.out.println(\"树的叶子数:\" + tree.getLeafNum(node));\n		System.out.println(\"--------------------\");\n		\n		System.out.println(\"树的结点数:\" + tree.getNodeNum(node));\n		System.out.println(\"--------------------\");\n		\n		System.out.println(\"判断一个结点是否是一个子树上面的结点\");\n		System.out.println(tree.Ishave(node.lchild, node4));\n	}\n}\n```\n\n', 0, 0, '2020-08-07 00:57:52', 2, 0, 1, '前言树从存储方式上可分为顺序树和链式树\n这节我们主要说的是链式树。\n1.  定义结点public class Node {    public String name;          //结点的数据域，拿String name代替    public Node lchild;          //存放左孩子    public Node rchild;          //存放右孩子    public boolean status;       //非递归后序遍历会用到    public Node() {        // TODO Auto-generated constructor stub        this.name = \"\";        this.lchild = null;        this.rchild = null;        this.status = false;    }    public Node(String string) {        // TODO Auto-generated constructor stub        this.name = string;        this.lchild = null;        this.rchild = null;        this.status = false;    }    }\n2.  树的创建定义一个Tree类，里面主要实现树的创建，和一些遍历操作，先部分展示代码并讲解，在最后会给出全部源码。\n我们为了养成良好的习惯，建议把每个东西归结成一个类，比如树，栈，队列，都分开定义，到用的时候，直接new就行了。\n先定义数据结构1.树的结构：\npublic class Tree {    // 声明输入流    Scanner scanner;    // 声明一个队列(层序遍历会用到)    Seqqueue queue;    // 声明一个栈(非递归的先序，中序，后序会用到)    Seqstack stack;    public Tree() {        // TODO Auto-generated constructor stub        // 初始化输入流        this.scanner = new Scanner(System.in);        // 初始化队列        this.queue = new Seqqueue();        this.queue.initQueue(10);        // 初始化栈        this.stack = new Seqstack();        this.stack.InitStack(20);    }\n2.栈的结构：（树的非递归遍历会用到）\npublic class Seqstack {    // 节点数组(模拟顺序栈)    public Node[] nodes;    // 栈顶下标    public int top;    public Seqstack() {        // TODO Auto-generated constructor stub        this.top = -1;    }    // 初始化栈    public void InitStack(int size) {        this.nodes = new Node[size];        this.top = -1;    }    // 判断栈空    public boolean IsEmpty() {        if (this.top == -1) {            return true;        }        return false;    }    // 判断栈满    public boolean IsFull() {        if (this.top == this.nodes.length - 1) {            return true;        }        return false;    }    // 入栈    public void push(Node node) {        if (IsFull()) {            System.out.println(\"栈已经满了，入栈失败\");            return;        }        this.top++;        this.nodes[this.top] = node;    }    // 出栈    public Node pop() {        if (IsEmpty()) {            System.out.println(\"栈已经空了，出栈失败\");            return null;        }        Node node = this.nodes[this.top];        this.top--;        return node;    }    // 清空栈    public void ClearStack() {        // 如果不为空，就一直出栈        while (!IsEmpty()) {            Node node = pop();        }    }    // 拿到栈顶元素    public Node getTop() {        if (IsEmpty()) {            System.out.println(\"栈中没有元素\");            return null;        }        return this.nodes[this.top];    }}\n3.循环队列的结构：（树的层序遍历会用到）\npublic class Seqqueue {    public Node[] queue;    public int QUEUE_SIZE;    public int front;    public int rear;    //初始化队列        public void initQueue(int size) {            this.QUEUE_SIZE = size;            this.queue = new Node[size];            this.front = 0;            this.rear = 0;        }        //判断队列是否为空        public boolean isEmpty() {            if(this.front  == this.rear ) {                return true;            }            else {                return false;            }        }        //判断队列是否为满        public boolean isFull() {            if((this.front % this.QUEUE_SIZE) == ((this.rear+1) % this.QUEUE_SIZE)) {                return true;            }            else {                return false;            }        }        //入队        public void enterQueue(Node node) {            if(isFull()) {                System.out.println(\"队列已经满了，入队失败\");                return;                    }            this.queue[this.rear] = node;            this.rear ++;            this.rear = this.rear % this.QUEUE_SIZE;        }        //出队        public Node deleteQueue() {            if(isEmpty()){                System.out.println(\"队列为空，出队失败\");                return null;            }            this.front = this.front % this.QUEUE_SIZE;            Node node = this.queue[this.front];            this.front++;            return node;        }}\n\n树的递归创建方式：（使用先序创建）\n    // 递归创建树（树的头节点）    Node createBiTree(Node tree) {        String string = scanner.nextLine();        if (string.equals(\".\")) {            return null;        }        tree = new Node();        tree.name = string;        tree.lchild = createBiTree(tree.lchild);        tree.rchild = createBiTree(tree.rchild);        return tree;    }\n3. 树的递归遍历我们利用三种遍历的特点，根据他们的打印顺序总结出来:\n先序：根左右\n中序：左跟右\n后序：左右跟\n3.1 树的递归先序遍历    // 先序遍历(递归)    void PreOrder(Node tree) {        if (tree != null) {            System.out.println(tree.name);            PreOrder(tree.lchild);            PreOrder(tree.rchild);        }    }\n3.2  树的递归中序遍历    // 中序遍历(递归)    void Inthread(Node tree) {        if (tree != null) {            Inthread(tree.lchild);            System.out.println(tree.name);            Inthread(tree.rchild);        }    }\n3.3  树的递归后序遍历    // 后序遍历(递归)    void PostOrder(Node tree) {        if (tree != null) {            PostOrder(tree.lchild);            PostOrder(tree.rchild);            System.out.println(tree.name);        }    }\n递归的遍历特别简单，只需要知道递归的原理就OK了，不做详解。\n4.  树的非递归遍历树的非递归遍历，还会用到栈，利用栈的先进后出的特点，实现树的遍历。\n4.1 树的非递归先序遍历这块我会给出两种方法，原理基本相同。\n（1）根据先序打印特点：根左右。\n我们用到压栈和出栈来模拟这个过程：\n\n由于栈是先进后出的，所以我们先访问根节点，压栈。然后判断栈不为空，然后出栈，打印。对出栈的结点进行判断，他有没有右孩子，如果有，把右孩子压栈。再判断有没有左孩子，如果有，把左孩子压栈。完成后，再跳回第2步，一直循环\n    // 先序遍历(非递归)    void nonPreOrder(Node tree) {        Node temp = null;        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        stack.push(tree);        while (!stack.IsEmpty()) {            temp = stack.pop();            System.out.println(temp.name);            if (temp.rchild != null) {                stack.push(temp.rchild);            }            if (temp.lchild != null) {                stack.push(temp.lchild);            }        }    }\n（2）第二种只是把压栈的顺序，进行了一点修正，其他的都差不多，但是，为了方便记忆非递归的先序，中序，后序，建议学习第二种的算法。\n    // 先序遍历(非递归)    void nonPreOrder2(Node tree) {        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        Node temp = null;        temp = tree;        while (!stack.IsEmpty() || temp != null) {            while (temp != null) {                System.out.println(temp.name);                stack.push(temp);                temp = temp.lchild;            }            temp = stack.pop();            temp = temp.rchild;        }    }\n4.2 树的非递归中序遍历根据中序打印特点：左跟右。\n我们用到压栈和出栈来模拟这个过程：\n\n由于栈是先进后出的，所以我们先访问根节点，用temp结点记录。然后判断栈不为空或者temp不为空，进入循环。先将temp的所有左子树全部压栈。然后出栈栈顶结点，打印然后再判断出栈的这个结点有没有右孩子，如果有，将右孩子入栈再将右孩子结点 的所有左孩子全部入栈，即从第3步开始循环。\n    // 中序遍历(非递归)    void nonInthread(Node tree) {        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        Node temp = null;        temp = tree;        while (!stack.IsEmpty() || temp != null) {            while (temp != null) {                stack.push(temp);                temp = temp.lchild;            }            temp = stack.pop();            System.out.println(temp.name);            temp = temp.rchild;        }    }\n中序的非递归遍历，和上述的先序的第二种非递归遍历比较，会发现，只改变了打印的位置，其他的都没有变化，所以建议记住，先序的第二种算法。\n4.2 树的非递归后序遍历后序我会给出，自己总结的三种方法，各有特点，其中第一种可以和前两对应起来，改动较小，对应编程能力差的同学，可以着重学习，后两种方法也很nice，想要多学点的同学，也可以学习。\n（1）第一种：根据后序打印特点：左右跟。\n我们根据先序的过程，先访问根节点，再访问左孩子，最后访问右孩子，根据具体的顺序，我们可以发现其实后序只需要，把先序打印的过程，换成一个如另一个栈的过程，所以我们需要两个栈，再把先将左孩子压栈，后将右孩子压栈，变成先将右孩子压栈，再将左孩子压栈，最后我们的第二个栈中就得到了后序的倒序，我们再将第二个栈出栈，打印就行。\n    // 后序遍历(非递归3)    void nonPostOrder3(Node tree) {        Seqstack stack2 = new Seqstack();        stack2.InitStack(20);        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        Node temp = null;        temp = tree;        while (!stack.IsEmpty() || temp != null) {            while (temp != null) {                stack2.push(temp);       //这行改变                stack.push(temp);                temp = temp.rchild;      //这行改变            }            temp = stack.pop();            temp = temp.lchild;        }        while (!stack2.IsEmpty()) {              //把第二个栈全部出栈打印            temp = stack2.pop();                          System.out.println(temp.name);        }    }\n后两种方法，都需要明白一个特点：我们可以观察前序、中序、后序的过程，根据他们是第几次访问根节点然后再打印的特点，我们可以发现：\n\n先序都是先访问根节点，然后打印，然后再访问他的左孩子，把他的左孩子又看出根节点，然后打印，又去访问他的左孩子，如果左孩子不存在，去访问他的右孩子，把他的右孩子又看成根节点，一直重复上面的步骤。（这块的根节点指的是每一个结点都看成根节点，不是特指树的根节点）。中序都是先访问根节点，然后访问所有的左孩子，左孩子全部访问结束，再回来访问根节点，打印根节点，再去访问右孩子，又去访问右孩子的所有左孩子，一直重复上面步骤。后序都是先访问根节点，再访问他的全部左孩子，左孩子全部访问结束，再回来访问他的根节点，又访问他的全部右孩子，右孩子全部访问结束，再反过来打印根节点。（这块的根节点指的是每一个结点都看成根节点，不是特指树的根节点）。\n总结一个特点：\n\n先序：第一次访问一个结点时打印中序：第二次访问一个结点时打印后序：第三次访问一个结点时打印\n后序什么时候打印，可以根据他是不是访问完右孩子过来的，如果是访问完右孩子过来的，就让他打印，否则去遍历他的右孩子。\n下面的两种方法都是根据，这个特点完成的，这是有点稍微的区别。\n（2）第二种：多创建一个结点，用来记录出栈的元素，进行判断\n    // 后序遍历(非递归1)    void nonPostOrder(Node tree) {        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        Node temp, r = null;   //r用来记录        temp = tree;        while (temp != null || !stack.IsEmpty()) {            if (temp != null) {                stack.push(temp);                temp = temp.lchild;            } else {                temp = stack.getTop();                if (temp.rchild != null && temp.rchild != r) {                    temp = temp.rchild;                } else {                    temp = stack.pop();                    System.out.println(temp.name);                    r = temp;                    temp = null;                }            }        }    }\n（3）第三种：利用在结点中，多一个属性，用来记录是第几次访问\n    // 后序遍历(非递归2)    void nonPostOrder2(Node tree) {        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        Node temp;        temp = tree;        stack.push(temp);        temp = temp.lchild;        while (!stack.IsEmpty() || temp != null) {            while (temp != null) {                stack.push(temp);                temp = temp.lchild;            }            temp = stack.pop();            if (temp.rchild != null && temp.status == false) {                stack.push(temp);                temp.status = true;                temp = temp.rchild;            } else {                System.out.println(temp.name);                temp = null;            }        }    }\n5. 树的层序遍历用到了队列\n    // 层序遍历    void cengxu(Node tree) {        Node temp = null;        queue.front = queue.rear = 0;        if (tree == null) {            System.out.println(\"该树为空\");            return;        }        queue.enterQueue(tree);        while (queue.front != queue.rear) {            temp = queue.deleteQueue();            System.out.println(temp.name);            if (temp.lchild != null) {                queue.enterQueue(temp.lchild);            }            if (temp.rchild != null) {                queue.enterQueue(temp.rchild);            }        }    }\n6.  计算树的深度    // 递归计算树的深度    int high(Node t) {        int h = 0, left = 0, right = 0;        if (t == null) {            return 0;        }        left = high(t.lchild);        right = high(t.rchild);        h = (left > right ? left : right) + 1;        return h;    }\n7.  反转二叉树7.1 递归方法    // 反转二叉树(递归)    void recReversal(Node tree) {        if (tree == null) {            return;        }        if (tree.lchild == null && tree.rchild == null) {            return;        }        Node temp = tree.lchild;        tree.lchild = tree.rchild;        tree.rchild = temp;        recReversal(tree.lchild);        recReversal(tree.rchild);    }\n7.2 非递归算法用到栈\n    // 反转二叉树(非递归)    void nonRecReversal(Node tree) {        Node t = null;        if (tree == null) {            System.out.println(\"树为空\");            return;        }        stack.push(tree);        while (!stack.IsEmpty()) {            Node temp = stack.pop();            t = temp.lchild;            temp.lchild = temp.rchild;            temp.rchild = t;            if (temp.rchild != null) {                stack.push(temp.rchild);            }            if (temp.lchild != null) {                stack.push(temp.lchild);            }        }    }\n8.  统计结点数（递归）    // 统计结点数(递归)    int getNodeNum(Node tree) {        int nodes = 0;        if (tree == null) {                        return 0;        }        else {            nodes = 1 + getNodeNum(tree.lchild) + getNodeNum(tree.rchild);        }        return nodes;    }\n9.  统计叶子结点数（递归）    //统计叶子结点数（递归）    int getLeafNum(Node tree) {        if(tree == null) {            return 0;        }        if(tree.lchild == null &&tree.rchild == null) {            return 1;        }        return getLeafNum(tree.lchild) + getLeafNum(tree.rchild);                }\n10.  判断一个结点是否是一个子树上的结点（递归）    //找一个结点是否是一个子树的结点    boolean Ishave(Node tree,Node node) {        if(node == null || tree == null) {            return false;        }        if(tree.name.equals(node.name)) {            return true;        }        else {            return Ishave(tree.lchild, node) | Ishave(tree.rchild, node);        }    }\n11. 代码的综合对上面讲述所有代码算法的综合\n树的创建和操作：\n//class Tree\nimport java.util.Scanner;public class Tree {    // 声明输入流    Scanner scanner;    // 声明一个队列(层序遍历会用到)    Seqqueue queue;    // 声明一个栈(非递归的先序，中序，后序会用到)    Seqstack stack;    public Tree() {        // TODO Auto-generated constructor stub        // 初始化输入流        this.scanner = new Scanner(System.in);        // 初始化队列        this.queue = new Seqqueue();        this.queue.initQueue(10);        // 初始化栈        this.stack = new Seqstack();        this.stack.InitStack(20);    }    // 递归创建树（树的头节点）    Node createBiTree(Node tree) {        String string = scanner.nextLine();        if (string.equals(\".\")) {            return null;        }        tree = new Node();        tree.name = string;        tree.lchild = createBiTree(tree.lchild);        tree.rchild = createBiTree(tree.rchild);        return tree;    }    // 先序遍历(递归)    void PreOrder(Node tree) {        if (tree != null) {            System.out.println(tree.name);            PreOrder(tree.lchild);            PreOrder(tree.rchild);        }    }    // 先序遍历(非递归)    void nonPreOrder(Node tree) {        Node temp = null;        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        stack.push(tree);        while (!stack.IsEmpty()) {            temp = stack.pop();            System.out.println(temp.name);            if (temp.rchild != null) {                stack.push(temp.rchild);            }            if (temp.lchild != null) {                stack.push(temp.lchild);            }        }    }    // 先序遍历(非递归)    void nonPreOrder2(Node tree) {        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        Node temp = null;        temp = tree;        while (!stack.IsEmpty() || temp != null) {            while (temp != null) {                System.out.println(temp.name);                stack.push(temp);                temp = temp.lchild;            }            temp = stack.pop();            temp = temp.rchild;        }    }    // 中序遍历(递归)    void Inthread(Node tree) {        if (tree != null) {            Inthread(tree.lchild);            System.out.println(tree.name);            Inthread(tree.rchild);        }    }    // 中序遍历(非递归)    void nonInthread(Node tree) {        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        Node temp = null;        temp = tree;        while (!stack.IsEmpty() || temp != null) {            while (temp != null) {                stack.push(temp);                temp = temp.lchild;            }            temp = stack.pop();            System.out.println(temp.name);            temp = temp.rchild;        }    }    // 后序遍历(递归)    void PostOrder(Node tree) {        if (tree != null) {            PostOrder(tree.lchild);            PostOrder(tree.rchild);            System.out.println(tree.name);        }    }    // 后序遍历(非递归1)    void nonPostOrder(Node tree) {        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        Node temp, r = null;        temp = tree;        while (temp != null || !stack.IsEmpty()) {            if (temp != null) {                stack.push(temp);                temp = temp.lchild;            } else {                temp = stack.getTop();                if (temp.rchild != null && temp.rchild != r) {                    temp = temp.rchild;                } else {                    temp = stack.pop();                    System.out.println(temp.name);                    r = temp;                    temp = null;                }            }        }    }    // 后序遍历(非递归2)    void nonPostOrder2(Node tree) {        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        Node temp;        temp = tree;        stack.push(temp);        temp = temp.lchild;        while (!stack.IsEmpty() || temp != null) {            while (temp != null) {                stack.push(temp);                temp = temp.lchild;            }            temp = stack.pop();            if (temp.rchild != null && temp.status == false) {                stack.push(temp);                temp.status = true;                temp = temp.rchild;            } else {                System.out.println(temp.name);                temp = null;            }        }    }    // 后序遍历(非递归3)    void nonPostOrder3(Node tree) {        Seqstack stack2 = new Seqstack();        stack2.InitStack(20);        if (tree == null) {            System.out.println(\"树不存在\");            return;        }        Node temp = null;        temp = tree;        while (!stack.IsEmpty() || temp != null) {            while (temp != null) {                stack2.push(temp);                stack.push(temp);                temp = temp.rchild;            }            temp = stack.pop();            temp = temp.lchild;        }        while (!stack2.IsEmpty()) {            temp = stack2.pop();            System.out.println(temp.name);        }    }    // 层序遍历    void cengxu(Node tree) {        Node temp = null;        queue.front = queue.rear = 0;        if (tree == null) {            System.out.println(\"该树为空\");            return;        }        queue.enterQueue(tree);        while (queue.front != queue.rear) {            temp = queue.deleteQueue();            System.out.println(temp.name);            if (temp.lchild != null) {                queue.enterQueue(temp.lchild);            }            if (temp.rchild != null) {                queue.enterQueue(temp.rchild);            }        }    }    // 递归计算树的深度    int high(Node t) {        int h = 0, left = 0, right = 0;        if (t == null) {            return 0;        }        left = high(t.lchild);        right = high(t.rchild);        h = (left > right ? left : right) + 1;        return h;    }    // 反转二叉树(递归)    void recReversal(Node tree) {        if (tree == null) {            return;        }        if (tree.lchild == null && tree.rchild == null) {            return;        }        Node temp = tree.lchild;        tree.lchild = tree.rchild;        tree.rchild = temp;        recReversal(tree.lchild);        recReversal(tree.rchild);    }    // 反转二叉树(非递归)    void nonRecReversal(Node tree) {        Node t = null;        if (tree == null) {            System.out.println(\"树为空\");            return;        }        stack.push(tree);        while (!stack.IsEmpty()) {            Node temp = stack.pop();            t = temp.lchild;            temp.lchild = temp.rchild;            temp.rchild = t;            if (temp.rchild != null) {                stack.push(temp.rchild);            }            if (temp.lchild != null) {                stack.push(temp.lchild);            }        }    }    //统计叶子结点数（递归）    int getLeafNum(Node tree) {        if(tree == null) {            return 0;        }        if(tree.lchild == null &&tree.rchild == null) {            return 1;        }        return getLeafNum(tree.lchild) + getLeafNum(tree.rchild);                }    // 统计结点数(递归)    int getNodeNum(Node tree) {        int nodes = 0;        if (tree == null) {                        return 0;        }        else {            nodes = 1 + getNodeNum(tree.lchild) + getNodeNum(tree.rchild);        }        return nodes;    }    //判断一个结点是否是一个子树的结点    boolean Ishave(Node tree,Node node) {        if(node == null || tree == null) {            return false;        }        if(tree.name.equals(node.name)) {            return true;        }        else {            return Ishave(tree.lchild, node) | Ishave(tree.rchild, node);        }    }}\n栈的结构：\n//class Seqstack\npublic class Seqstack {    // 节点数组(模拟顺序栈)    public Node[] nodes;    // 栈顶下标    public int top;    public Seqstack() {        // TODO Auto-generated constructor stub        this.top = -1;    }    // 初始化栈    public void InitStack(int size) {        this.nodes = new Node[size];        this.top = -1;    }    // 判断栈空    public boolean IsEmpty() {        if (this.top == -1) {            return true;        }        return false;    }    // 判断栈满    public boolean IsFull() {        if (this.top == this.nodes.length - 1) {            return true;        }        return false;    }    // 入栈    public void push(Node node) {        if (IsFull()) {            System.out.println(\"栈已经满了，入栈失败\");            return;        }        this.top++;        this.nodes[this.top] = node;    }    // 出栈    public Node pop() {        if (IsEmpty()) {            System.out.println(\"栈已经空了，出栈失败\");            return null;        }        Node node = this.nodes[this.top];        this.top--;        return node;    }    // 清空栈    public void ClearStack() {        // 如果不为空，就一直出栈        while (!IsEmpty()) {            Node node = pop();        }    }    // 拿到栈顶元素    public Node getTop() {        if (IsEmpty()) {            System.out.println(\"栈中没有元素\");            return null;        }        return this.nodes[this.top];    }}\n循环队列的结构：\n//class Seqqueue\npublic class Seqqueue {    public Node[] queue;    public int QUEUE_SIZE;    public int front;    public int rear;    //初始化队列        public void initQueue(int size) {            this.QUEUE_SIZE = size;            this.queue = new Node[size];            this.front = 0;            this.rear = 0;        }        //判断队列是否为空        public boolean isEmpty() {            if(this.front  == this.rear ) {                return true;            }            else {                return false;            }        }        //判断队列是否为满        public boolean isFull() {            if((this.front % this.QUEUE_SIZE) == ((this.rear+1) % this.QUEUE_SIZE)) {                return true;            }            else {                return false;            }        }        //入队        public void enterQueue(Node node) {            if(isFull()) {                System.out.println(\"队列已经满了，入队失败\");                return;                    }            this.queue[this.rear] = node;            this.rear ++;            this.rear = this.rear % this.QUEUE_SIZE;        }        //出队        public Node deleteQueue() {            if(isEmpty()){                System.out.println(\"队列为空，出队失败\");                return null;            }            this.front = this.front % this.QUEUE_SIZE;            Node node = this.queue[this.front];            this.front++;            return node;        }}\n给个测试用例：\n//class Client\npublic class Client {    public static void main(String[] args) {        Tree tree = new Tree();        Node node = null ;        Node node4 = new Node(\"a\");        node = tree.createBiTree(node);                System.out.println(\"创建完成\");            System.out.println(\"递归先序遍历\");        tree.PreOrder(node);        System.out.println(\"---------------------\");        System.out.println(\"非递归先序遍历\");        tree.nonPreOrder(node);        System.out.println(\"---------------------\");        System.out.println(\"非递归先序遍历2\");        tree.nonPreOrder2(node);        System.out.println(\"---------------------\");        System.out.println(\"递归中序遍历\");        tree.Inthread(node);        System.out.println(\"---------------------\");        System.out.println(\"非递归中序遍历\");        tree.nonInthread(node);        System.out.println(\"---------------------\");        System.out.println(\"后序遍历(递归)\");        tree.PostOrder(node);        System.out.println(\"---------------------\");        System.out.println(\"后序遍历(非递归)\");        tree.nonPostOrder(node);        System.out.println(\"---------------------\");        System.out.println(\"后序遍历(非递归2)\");        tree.nonPostOrder2(node);        System.out.println(\"---------------------\");        System.out.println(\"后序遍历(非递归3)\");        tree.nonPostOrder3(node);        System.out.println(\"---------------------\");        System.out.println(\"层序遍历\");        tree.cengxu(node);        System.out.println(\"---------------------\");        System.out.println(\"树的深度\"+tree.high(node));        System.out.println(\"---------------------\");        System.out.println(\"递归反转二叉树\");        tree.recReversal(node);        tree.cengxu(node);        System.out.println(\"-------------------\");        System.out.println(\"非递归反转二叉树\");        tree.nonRecReversal(node);        tree.cengxu(node);        System.out.println(\"-------------------\");        System.out.println(\"树的叶子数:\" + tree.getLeafNum(node));        System.out.println(\"--------------------\");        System.out.println(\"树的结点数:\" + tree.getNodeNum(node));        System.out.println(\"--------------------\");        System.out.println(\"判断一个结点是否是一个子树上面的结点\");        System.out.println(tree.Ishave(node.lchild, node4));    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (132, '03.图的深度和广度优先遍历（递归和非递归都有，邻接表和邻接矩阵）', 8, '\n\n> 图论是一个很重要的工具，这节主要是图的创建和遍历的Java代码，不讲理论，只撸代码，理论网上很多，具体一步步该怎么走，其他的贴子也都给全了，但是都是c语言，我们用Java实现和模拟图论。\n\n内容有点多，给个目录：\n\n## 目录：\n\n**1.  图结点的创建**\n\n**2.  图的创建**\n\n​      **2.1 图的结构和初始化**     \n\n​      **2.2 邻接矩阵**   \n\n​      **2.3 邻接表**\n\n**3.  邻接表的两种遍历**\n\n​     **3.1 深度优先遍历（邻接表）**\n\n​           **3.1.1 递归算法（邻接表）**\n\n​           **3.1.2 非递归算法（邻接表）**\n\n​     **3.2 广度优先遍历（邻接表）**\n\n**4.  邻接矩阵的两种遍历**\n\n​      **4.1 深度优先遍历（邻接矩阵）**\n\n​           **4.1.1 递归算法（邻接矩阵）**\n\n​            **4.1.2 非递归算法（邻接矩阵）**\n\n​      **4.2  广度优先搜索（邻接矩阵）**\n\n**5.  项目完整代码**\n\n## 1.  图结点的创建\n\n```\npublic class Node {\n	public int name;\n	public Node next;\n	public Boolean flag;\n	\n	public Node() {\n		// TODO Auto-generated constructor stub\n		this.name = 0;\n		this.next = null;\n		this.flag = false;\n	}\n	public Node(int name) {\n		\n		this.name = name;\n		this.next = null;\n		this.flag = false;\n	}\n	\n}\n```\n\n## 2.  图的创建\n\n### 2.1 图的结构和初始化\n\n```\nimport java.util.Scanner;\n\npublic class Graph {\n	public Node[] nodes;\n	public int[][] A;\n	public int Sidenum;\n	public Seqqueue queue;\n	public Seqstack stack;\n	Scanner scanner;\n\n	public Graph(int Nodenum, int Sidenum) {\n		this.nodes = new Node[Nodenum];\n		for (int i = 0; i < Nodenum; i++) {\n			this.nodes[i] = new Node(i);\n		}\n		this.A = new int[Nodenum][Nodenum];\n		this.Sidenum = Sidenum;\n		for (int i = 0; i < Nodenum; i++) {\n			for (int j = 0; j < Nodenum; j++) {\n				this.A[i][j] = 0;\n			}\n		}\n		scanner = new Scanner(System.in);\n		this.queue = new Seqqueue();\n		this.queue.initQueue(20);\n		this.stack = new Seqstack();\n		this.stack.InitStack(20);\n\n	}\n}\n```\n\n### 2.2 邻接矩阵\n\n```\n	// 邻接矩阵创建(有向图)\n	void creat1() {\n		int a, b;\n		for (int i = 0; i < this.Sidenum; i++) {\n			a = scanner.nextInt();\n			b = scanner.nextInt();\n			this.A[a][b] = 1;\n		}\n		System.out.println(\"图创建成功\");\n	}\n\n	// 邻接矩阵创建(无向图)\n	void creat2() {\n		int a, b;\n		for (int i = 0; i < this.Sidenum; i++) {\n			a = scanner.nextInt();\n			b = scanner.nextInt();\n			this.A[a][b] = 1;\n			this.A[b][a] = 1;\n		}\n		System.out.println(\"图创建成功\");\n	}\n\n	// 遍历输出邻接矩阵\n	void traver1() {\n		for (int i = 0; i < nodes.length; i++) {\n\n			for (int j = 0; j < nodes.length; j++) {\n				System.out.print(this.A[i][j] + \" \");\n			}\n			System.out.println(\"\");\n		}\n	}\n```\n\n### 2.3 邻接表\n\n```\n	// 邻接表创建\n	void creat3() {\n		int a, b;\n		for (int i = 0; i < this.Sidenum; i++) {\n			a = scanner.nextInt();\n			b = scanner.nextInt();\n			Node node = this.nodes[a];\n\n			// 防止把同一条边加入多次\n			while (node.next != null && node.next.name != b) {\n				node = node.next;\n			}\n			if (node.next == null) {\n				Node n = new Node(b);\n				n.next = nodes[a].next;\n				nodes[a].next = n;\n			}\n		}\n		System.out.println(\"图创建成功\");\n	}\n\n	// 遍历输出邻接表\n	void traver2() {\n		Node node;\n		for (int i = 0; i < nodes.length; i++) {\n			node = nodes[i];\n			System.out.print(node.name + \":\");\n			while (node.next != null) {\n				System.out.print(node.next.name + \" \");\n				node = node.next;\n			}\n			System.out.println(\"\");\n		}\n	}\n```\n\n## 3.  邻接表的两种遍历\n\nflag属性用来标记结点有没有被访问过，所以需要初始化。\n\n```\n	// 初始化访问标记\n	void initFlag() {\n		// 初始化\n		for (int i = 0; i < this.nodes.length; i++) {\n			this.nodes[i].flag = false;\n		}\n	}\n```\n\n### 3.1 深度优先遍历（邻接表）\n\n**3.1.1 递归算法**（邻接表）\n\n```\n	// 深度优先遍历(从head结点开始) 递归算法 邻接表\n	void DFS1(Node head) {\n		Node pNode;\n		if (!this.nodes[head.name].flag) {\n			System.out.print(head.name + \" \");\n			this.nodes[head.name].flag = true;\n		}\n\n		pNode = this.nodes[head.name].next;\n		while (pNode != null) {\n			if (!this.nodes[pNode.name].flag) {\n				DFS1(pNode);\n			} else {\n				pNode = pNode.next;\n			}\n\n		}\n	}\n```\n\n**3.1.2 非递归算法**（邻接表）\n\n用到的栈，定义在文章最后完整项目代码中有，这块只是引用。\n\n```\n	// 深度优先遍历(从head结点开始) 非递归算法 邻接表\n	void DFS2(Node head) {\n		// 初始化访问标记\n		initFlag();\n		// 初始化栈\n		this.stack.InitStack(20);\n		Node pNode, wNode;\n		this.stack.push(head);\n		System.out.print(head.name + \" \");\n		this.nodes[head.name].flag = true;\n		while (!this.stack.IsEmpty()) {\n			pNode = this.stack.pop();\n			wNode = pNode.next;\n			while (wNode != null) {\n				if (!this.nodes[wNode.name].flag) {\n					this.stack.push(wNode);\n					this.nodes[wNode.name].flag = true;\n					System.out.print(wNode.name + \" \");\n					wNode = this.nodes[wNode.name].next;\n				} else {\n					wNode = wNode.next;\n				}\n			}\n		}\n	}\n```\n\n### 3.2 广度优先遍历（邻接表）\n\n**因为广度优先遍历需要用到队列，所以不能递归，递归只能是用到栈时才能。**\n\n用到的队列，定义在文章最后完整项目代码中有，这块只是引用。\n\n```\n	void BFS1(Node head) {\n		// 初始化访问标记\n		initFlag();\n		// 初始化队列\n		this.queue.initQueue(20);\n		Node pNode;\n		this.queue.enterQueue(head);\n		this.nodes[head.name].flag = true;\n		while (!this.queue.isEmpty()) {\n			pNode = this.queue.deleteQueue();\n			pNode = this.nodes[pNode.name];\n			System.out.print(pNode.name + \" \");\n			while (pNode != null) {\n				pNode = pNode.next;\n				if (pNode != null && !this.nodes[pNode.name].flag) {\n					this.queue.enterQueue(pNode);\n					this.nodes[pNode.name].flag = true;\n				}\n			}\n		}\n\n	}\n```\n\n## 4.  邻接矩阵的两种遍历\n\n### 4.1 深度优先遍历（邻接矩阵）\n\n**4.1.1 递归算法**（邻接矩阵）\n\n```\n	// 深度优先遍历（从0号结点开始） 递归算法 邻接矩阵\n	void DFSM(int i) {\n		int j = 0;\n		System.out.print(this.nodes[i].name + \" \");\n		this.nodes[i].flag = true;\n		for (j = 0; j < this.Sidenum; j++) {\n			if (this.A[i][j] == 1 && !this.nodes[j].flag) {\n				DFSM(j);\n			}\n		}\n	}\n\n	void DFS3() {\n		for (int i = 0; i < this.Sidenum; i++) {\n			if (!this.nodes[i].flag) {\n				DFSM(i);\n			}\n		}\n	}\n```\n\n**4.1.2 非递归算法**（邻接矩阵）\n\n用到的栈，定义在文章最后完整项目代码中有，这块只是引用。\n\n```\n	// 深度优先遍历（从0号结点开始） 非递归算法 邻接矩阵\n	void DFS4(Node head) {\n		// 初始化访问标记\n		initFlag();\n		int i = 0;\n		// 初始化栈\n		this.stack.InitStack(20);\n		Node pNode, wNode = null;\n		this.stack.push(head);\n		System.out.print(head.name + \" \");\n		this.nodes[head.name].flag = true;\n		while (!this.stack.IsEmpty()) {\n			pNode = this.stack.getTop();\n			for (i = 0; i < this.Sidenum; i++) {\n				if (this.A[pNode.name][i] == 1 && !this.nodes[i].flag) {\n					System.out.print(this.nodes[i].name + \" \");\n					this.nodes[i].flag = true;\n					this.stack.push(this.nodes[i]);\n					break;\n				}\n			}\n			if (i == this.Sidenum) {\n				this.stack.pop();\n			}\n\n		}\n	}\n```\n\n### 4.2  广度优先搜索（邻接矩阵）\n\n**因为广度优先遍历需要用到队列，所以不能递归，递归只能是用到栈时才能。**\n\n用到的队列，定义在文章最后完整项目代码中有，这块只是引用。\n\n```\n	// 广度优先遍历（从0号结点开始） 非递归算法 邻接矩阵\n	void BFS2(int k) {\n		// 初始化被访问标记\n		initFlag();\n		// 初始化队列\n		this.queue.initQueue(20);\n		Node node;\n		System.out.print(this.nodes[k].name + \" \");\n		this.nodes[k].flag = true;\n		this.queue.enterQueue(this.nodes[k]);\n		while (!this.queue.isEmpty()) {\n			node = this.queue.deleteQueue();\n			for (int i = 0; i < this.Sidenum; i++) {\n				if (this.A[node.name][i] == 1 && !this.nodes[i].flag) {\n					System.out.print(this.nodes[i].name + \" \");\n					this.nodes[i].flag = true;\n					this.queue.enterQueue(this.nodes[i]);\n				}\n			}\n		}\n	}\n```\n\n## **5.  项目完整代码**\n\n**项目的代码比较多，主要有下面几个类，防止查找麻烦，目录如下：**\n\n**目录：**\n\n1. class Node 结点定义\n2. class Seqqueue  队列定义\n3. class Seqstack  栈的定义\n4. class Graph  图的定义及操作\n5. class Client   测试类\n\n**内容：**\n\n1. **//class Node 结点定义**\n\n```\npackage com.company.project.graph;\n\npublic class Node {\n	public int name;\n	public Node next;\n	public Boolean flag;\n	\n	public Node() {\n		// TODO Auto-generated constructor stub\n		this.name = 0;\n		this.next = null;\n		this.flag = false;\n	}\n	public Node(int name) {\n		\n		this.name = name;\n		this.next = null;\n		this.flag = false;\n	}	\n}\n```\n\n\\2. //class Seqqueue  队列定义\n\n```\npackage com.company.project.graph;\n\npublic class Seqqueue {\n	public Node[] queue;\n	public int QUEUE_SIZE;\n	public int front;\n	public int rear;\n	\n	//初始化队列\n		public void initQueue(int size) {\n			this.QUEUE_SIZE = size;\n			this.queue = new Node[size];\n			this.front = 0;\n			this.rear = 0;		\n		}\n		\n		//判断队列是否为空\n		public boolean isEmpty() {\n			if(this.front  == this.rear ) {\n				return true;\n			}\n			else {\n				return false;\n			}\n		}\n		\n		//判断队列是否为满\n		public boolean isFull() {\n			if((this.front % this.QUEUE_SIZE) == ((this.rear+1) % this.QUEUE_SIZE)) {\n				return true;\n			}\n			else {\n				return false;\n			}\n		}\n		\n		//入队\n		public void enterQueue(Node node) {\n			if(isFull()) {\n				System.out.println(\"队列已经满了，入队失败\");\n		        return;		\n			}\n			this.queue[this.rear] = node;\n			this.rear ++;\n			this.rear = this.rear % this.QUEUE_SIZE;\n			\n		}\n		//出队\n		public Node deleteQueue() {\n			if(isEmpty()){\n				System.out.println(\"队列为空，出队失败\");\n				return null;\n			}\n			this.front = this.front % this.QUEUE_SIZE;\n			Node node = this.queue[this.front];\n			\n			this.front++;\n			return node;\n		}\n}\n```\n\n\\3. //class Seqstack  栈的定义\n\n```\npackage com.company.project.graph;\n\npublic class Seqstack {\n	// 节点数组(模拟顺序栈)\n	public Node[] nodes;\n\n	// 栈顶下标\n	public int top;\n\n	public Seqstack() {\n		// TODO Auto-generated constructor stub\n		this.top = -1;\n\n	}\n\n	// 初始化栈\n	public void InitStack(int size) {\n		this.nodes = new Node[size];\n		this.top = -1;\n\n	}\n\n	// 判断栈空\n	public boolean IsEmpty() {\n		if (this.top == -1) {\n			return true;\n		}\n\n		return false;\n	}\n\n	// 判断栈满\n	public boolean IsFull() {\n		if (this.top == this.nodes.length - 1) {\n			return true;\n		}\n\n		return false;\n	}\n\n	// 入栈\n	public void push(Node node) {\n		if (IsFull()) {\n			System.out.println(\"栈已经满了，入栈失败\");\n			return;\n		}\n		this.top++;\n		this.nodes[this.top] = node;\n	}\n\n	// 出栈\n	public Node pop() {\n		if (IsEmpty()) {\n			System.out.println(\"栈已经空了，出栈失败\");\n			return null;\n		}\n		Node node = this.nodes[this.top];\n		this.top--;\n		return node;\n\n	}\n\n	// 清空栈\n	public void ClearStack() {\n		// 如果不为空，就一直出栈\n		while (!IsEmpty()) {\n			Node node = pop();\n		}\n\n	}\n\n	// 拿到栈顶元素\n	public Node getTop() {\n		if (IsEmpty()) {\n			System.out.println(\"栈中没有元素\");\n			return null;\n		}\n		return this.nodes[this.top];\n	}\n}\n```\n\n\\4. //class Graph  图的定义及操作\n\n```\npackage com.company.project.graph;\n\nimport java.util.Scanner;\n\npublic class Graph {\n	public Node[] nodes;\n	public int[][] A;\n	public int Sidenum;\n	public Seqqueue queue;\n	public Seqstack stack;\n	Scanner scanner;\n\n	public Graph(int Nodenum, int Sidenum) {\n		this.nodes = new Node[Nodenum];\n		for (int i = 0; i < Nodenum; i++) {\n			this.nodes[i] = new Node(i);\n		}\n		this.A = new int[Nodenum][Nodenum];\n		this.Sidenum = Sidenum;\n		for (int i = 0; i < Nodenum; i++) {\n			for (int j = 0; j < Nodenum; j++) {\n				this.A[i][j] = 0;\n			}\n		}\n		scanner = new Scanner(System.in);\n		this.queue = new Seqqueue();\n		this.queue.initQueue(20);\n		this.stack = new Seqstack();\n		this.stack.InitStack(20);\n\n	}\n\n	// 邻接矩阵创建(有向图)\n	void creat1() {\n		int a, b;\n		for (int i = 0; i < this.Sidenum; i++) {\n			a = scanner.nextInt();\n			b = scanner.nextInt();\n			this.A[a][b] = 1;\n		}\n		System.out.println(\"图创建成功\");\n	}\n\n	// 邻接矩阵创建(无向图)\n	void creat2() {\n		int a, b;\n		for (int i = 0; i < this.Sidenum; i++) {\n			a = scanner.nextInt();\n			b = scanner.nextInt();\n			this.A[a][b] = 1;\n			this.A[b][a] = 1;\n		}\n		System.out.println(\"图创建成功\");\n	}\n\n	// 邻接表创建\n	void creat3() {\n		int a, b;\n		for (int i = 0; i < this.Sidenum; i++) {\n			a = scanner.nextInt();\n			b = scanner.nextInt();\n			Node node = this.nodes[a];\n\n			// 防止把同一条边加入多次\n			while (node.next != null && node.next.name != b) {\n				node = node.next;\n			}\n			if (node.next == null) {\n				Node n = new Node(b);\n				n.next = nodes[a].next;\n				nodes[a].next = n;\n			}\n		}\n		System.out.println(\"图创建成功\");\n	}\n\n	// 遍历输出邻接矩阵\n	void traver1() {\n		for (int i = 0; i < nodes.length; i++) {\n\n			for (int j = 0; j < nodes.length; j++) {\n				System.out.print(this.A[i][j] + \" \");\n			}\n			System.out.println(\"\");\n		}\n	}\n\n	// 遍历输出邻接表\n	void traver2() {\n		Node node;\n		for (int i = 0; i < nodes.length; i++) {\n			node = nodes[i];\n			System.out.print(node.name + \":\");\n			while (node.next != null) {\n				System.out.print(node.next.name + \" \");\n				node = node.next;\n			}\n			System.out.println(\"\");\n		}\n	}\n\n//邻接表的两种遍历（递归和非递归）\n	// 初始化访问标记\n	void initFlag() {\n		// 初始化\n		for (int i = 0; i < this.nodes.length; i++) {\n			this.nodes[i].flag = false;\n		}\n	}\n\n	// 深度优先遍历(从head结点开始) 递归算法 邻接表\n	void DFS1(Node head) {\n		Node pNode;\n		if (!this.nodes[head.name].flag) {\n			System.out.print(head.name + \" \");\n			this.nodes[head.name].flag = true;\n		}\n\n		pNode = this.nodes[head.name].next;\n		while (pNode != null) {\n			if (!this.nodes[pNode.name].flag) {\n				DFS1(pNode);\n			} else {\n				pNode = pNode.next;\n			}\n\n		}\n	}\n\n	// 深度优先遍历(从head结点开始) 非递归算法 邻接表\n	void DFS2(Node head) {\n		// 初始化访问标记\n		initFlag();\n		// 初始化栈\n		this.stack.InitStack(20);\n		Node pNode, wNode;\n		this.stack.push(head);\n		System.out.print(head.name + \" \");\n		this.nodes[head.name].flag = true;\n		while (!this.stack.IsEmpty()) {\n			pNode = this.stack.pop();\n			wNode = pNode.next;\n			while (wNode != null) {\n				if (!this.nodes[wNode.name].flag) {\n					this.stack.push(wNode);\n					this.nodes[wNode.name].flag = true;\n					System.out.print(wNode.name + \" \");\n					wNode = this.nodes[wNode.name].next;\n				} else {\n					wNode = wNode.next;\n				}\n			}\n		}\n	}\n\n	// 广度优先遍历(从head结点开始)（非递归） 邻接表\n	// 因为广度优先遍历需要用到队列，所以不能递归，递归只能是用到栈时才能\n	void BFS1(Node head) {\n		// 初始化访问标记\n		initFlag();\n		// 初始化队列\n		this.queue.initQueue(20);\n		Node pNode;\n		this.queue.enterQueue(head);\n		this.nodes[head.name].flag = true;\n		while (!this.queue.isEmpty()) {\n			pNode = this.queue.deleteQueue();\n			pNode = this.nodes[pNode.name];\n			System.out.print(pNode.name + \" \");\n			while (pNode != null) {\n				pNode = pNode.next;\n				if (pNode != null && !this.nodes[pNode.name].flag) {\n					this.queue.enterQueue(pNode);\n					this.nodes[pNode.name].flag = true;\n				}\n			}\n		}\n\n	}\n\n//邻接矩阵的两种遍历（递归和非递归）邻接矩阵	\n\n	// 深度优先遍历（从0号结点开始） 递归算法 邻接矩阵\n	void DFSM(int i) {\n		int j = 0;\n		System.out.print(this.nodes[i].name + \" \");\n		this.nodes[i].flag = true;\n		for (j = 0; j < this.Sidenum; j++) {\n			if (this.A[i][j] == 1 && !this.nodes[j].flag) {\n				DFSM(j);\n			}\n		}\n	}\n\n	void DFS3() {\n		for (int i = 0; i < this.Sidenum; i++) {\n			if (!this.nodes[i].flag) {\n				DFSM(i);\n			}\n		}\n	}\n\n	// 深度优先遍历（从0号结点开始） 非递归算法 邻接矩阵\n	void DFS4(Node head) {\n		// 初始化访问标记\n		initFlag();\n		int i = 0;\n		// 初始化栈\n		this.stack.InitStack(20);\n		Node pNode, wNode = null;\n		this.stack.push(head);\n		System.out.print(head.name + \" \");\n		this.nodes[head.name].flag = true;\n		while (!this.stack.IsEmpty()) {\n			pNode = this.stack.getTop();\n			for (i = 0; i < this.Sidenum; i++) {\n				if (this.A[pNode.name][i] == 1 && !this.nodes[i].flag) {\n					System.out.print(this.nodes[i].name + \" \");\n					this.nodes[i].flag = true;\n					this.stack.push(this.nodes[i]);\n					break;\n				}\n			}\n			if (i == this.Sidenum) {\n				this.stack.pop();\n			}\n\n		}\n	}\n\n	// 广度优先遍历（从0号结点开始） 非递归算法 邻接矩阵\n	void BFS2(int k) {\n		// 初始化被访问标记\n		initFlag();\n		// 初始化队列\n		this.queue.initQueue(20);\n		Node node;\n		System.out.print(this.nodes[k].name + \" \");\n		this.nodes[k].flag = true;\n		this.queue.enterQueue(this.nodes[k]);\n		while (!this.queue.isEmpty()) {\n			node = this.queue.deleteQueue();\n			for (int i = 0; i < this.Sidenum; i++) {\n				if (this.A[node.name][i] == 1 && !this.nodes[i].flag) {\n					System.out.print(this.nodes[i].name + \" \");\n					this.nodes[i].flag = true;\n					this.queue.enterQueue(this.nodes[i]);\n				}\n			}\n		}\n	}\n}\n```\n\n\\5. //class Client  测试类（里面有邻接表和邻接矩阵 的全部操作测试，需要那个，把剩余的注释就行）\n\n```\npackage com.company.project.graph;\n\nimport java.util.Scanner;\n\npublic class Client {\n	public static void main(String[] args) {\n		Scanner scanner = new Scanner(System.in);\n		System.out.println(\"输入顶点数：\");\n		int Nodenum = scanner.nextInt();\n		System.out.println(\"输入边数：\");\n		int Sidenum = scanner.nextInt();\n		Graph graph = new Graph(Nodenum, Sidenum);\n// 邻接矩阵创建\n		// 邻接矩阵创建\n		System.out.println(\"输入边的两个顶点：\");\n		graph.creat1();\n		graph.traver1();\n// 邻接表创建\n		// 邻接表创建\n		System.out.println(\"输入边的两个顶点：\");\n		graph.creat3();\n		System.out.println(\"邻接表：\");\n		graph.traver2();\n\n//邻接表的搜索\n		// 深度优先搜索\n		System.out.println(\"深度优先搜索（递归）\");\n		graph.initFlag();\n		graph.DFS1(graph.nodes[0]);\n		System.out.println(\"\");\n\n		// 深度优先搜索\n		System.out.println(\"深度优先搜索（非递归）\");\n		graph.DFS2(graph.nodes[0]);\n		System.out.println(\"\");\n\n		// 广度优先遍历\n		System.out.println(\"广度优先搜索（非递归）\");\n		graph.BFS1(graph.nodes[0]);\n\n//邻接矩阵的搜索\n		// 深度优先搜索\n		System.out.println(\"深度优先搜索（递归）\");\n		graph.initFlag();\n		graph.DFS3();\n		System.out.println(\"\");\n		\n		// 深度优先搜索\n		System.out.println(\"深度优先搜索（非递归）\");\n		graph.initFlag();\n		graph.DFS4(graph.nodes[0]);\n		System.out.println(\"\");\n		\n		// 广度优先搜索\n		System.out.println(\"广度优先搜索（非递归）\");\n		graph.initFlag();\n		graph.BFS2(0);\n		System.out.println(\"\");\n\n	}\n}\n```', 0, 0, '2020-08-07 00:58:35', 2, 0, 1, '\n图论是一个很重要的工具，这节主要是图的创建和遍历的Java代码，不讲理论，只撸代码，理论网上很多，具体一步步该怎么走，其他的贴子也都给全了，但是都是c语言，我们用Java实现和模拟图论。\n\n内容有点多，给个目录：\n目录：1.  图结点的创建\n2.  图的创建\n​      2.1 图的结构和初始化     \n​      2.2 邻接矩阵   \n​      2.3 邻接表\n3.  邻接表的两种遍历\n​     3.1 深度优先遍历（邻接表）\n​           3.1.1 递归算法（邻接表）\n​           3.1.2 非递归算法（邻接表）\n​     3.2 广度优先遍历（邻接表）\n4.  邻接矩阵的两种遍历\n​      4.1 深度优先遍历（邻接矩阵）\n​           4.1.1 递归算法（邻接矩阵）\n​            4.1.2 非递归算法（邻接矩阵）\n​      4.2  广度优先搜索（邻接矩阵）\n5.  项目完整代码\n1.  图结点的创建public class Node {    public int name;    public Node next;    public Boolean flag;    public Node() {        // TODO Auto-generated constructor stub        this.name = 0;        this.next = null;        this.flag = false;    }    public Node(int name) {        this.name = name;        this.next = null;        this.flag = false;    }}2.  图的创建2.1 图的结构和初始化import java.util.Scanner;public class Graph {    public Node[] nodes;    public int[][] A;    public int Sidenum;    public Seqqueue queue;    public Seqstack stack;    Scanner scanner;    public Graph(int Nodenum, int Sidenum) {        this.nodes = new Node[Nodenum];        for (int i = 0; i < Nodenum; i++) {            this.nodes[i] = new Node(i);        }        this.A = new int[Nodenum][Nodenum];        this.Sidenum = Sidenum;        for (int i = 0; i < Nodenum; i++) {            for (int j = 0; j < Nodenum; j++) {                this.A[i][j] = 0;            }        }        scanner = new Scanner(System.in);        this.queue = new Seqqueue();        this.queue.initQueue(20);        this.stack = new Seqstack();        this.stack.InitStack(20);    }}2.2 邻接矩阵    // 邻接矩阵创建(有向图)    void creat1() {        int a, b;        for (int i = 0; i < this.Sidenum; i++) {            a = scanner.nextInt();            b = scanner.nextInt();            this.A[a][b] = 1;        }        System.out.println(\"图创建成功\");    }    // 邻接矩阵创建(无向图)    void creat2() {        int a, b;        for (int i = 0; i < this.Sidenum; i++) {            a = scanner.nextInt();            b = scanner.nextInt();            this.A[a][b] = 1;            this.A[b][a] = 1;        }        System.out.println(\"图创建成功\");    }    // 遍历输出邻接矩阵    void traver1() {        for (int i = 0; i < nodes.length; i++) {            for (int j = 0; j < nodes.length; j++) {                System.out.print(this.A[i][j] + \" \");            }            System.out.println(\"\");        }    }2.3 邻接表    // 邻接表创建    void creat3() {        int a, b;        for (int i = 0; i < this.Sidenum; i++) {            a = scanner.nextInt();            b = scanner.nextInt();            Node node = this.nodes[a];            // 防止把同一条边加入多次            while (node.next != null && node.next.name != b) {                node = node.next;            }            if (node.next == null) {                Node n = new Node(b);                n.next = nodes[a].next;                nodes[a].next = n;            }        }        System.out.println(\"图创建成功\");    }    // 遍历输出邻接表    void traver2() {        Node node;        for (int i = 0; i < nodes.length; i++) {            node = nodes[i];            System.out.print(node.name + \":\");            while (node.next != null) {                System.out.print(node.next.name + \" \");                node = node.next;            }            System.out.println(\"\");        }    }3.  邻接表的两种遍历flag属性用来标记结点有没有被访问过，所以需要初始化。\n    // 初始化访问标记    void initFlag() {        // 初始化        for (int i = 0; i < this.nodes.length; i++) {            this.nodes[i].flag = false;        }    }3.1 深度优先遍历（邻接表）3.1.1 递归算法（邻接表）\n    // 深度优先遍历(从head结点开始) 递归算法 邻接表    void DFS1(Node head) {        Node pNode;        if (!this.nodes[head.name].flag) {            System.out.print(head.name + \" \");            this.nodes[head.name].flag = true;        }        pNode = this.nodes[head.name].next;        while (pNode != null) {            if (!this.nodes[pNode.name].flag) {                DFS1(pNode);            } else {                pNode = pNode.next;            }        }    }3.1.2 非递归算法（邻接表）\n用到的栈，定义在文章最后完整项目代码中有，这块只是引用。\n    // 深度优先遍历(从head结点开始) 非递归算法 邻接表    void DFS2(Node head) {        // 初始化访问标记        initFlag();        // 初始化栈        this.stack.InitStack(20);        Node pNode, wNode;        this.stack.push(head);        System.out.print(head.name + \" \");        this.nodes[head.name].flag = true;        while (!this.stack.IsEmpty()) {            pNode = this.stack.pop();            wNode = pNode.next;            while (wNode != null) {                if (!this.nodes[wNode.name].flag) {                    this.stack.push(wNode);                    this.nodes[wNode.name].flag = true;                    System.out.print(wNode.name + \" \");                    wNode = this.nodes[wNode.name].next;                } else {                    wNode = wNode.next;                }            }        }    }3.2 广度优先遍历（邻接表）因为广度优先遍历需要用到队列，所以不能递归，递归只能是用到栈时才能。\n用到的队列，定义在文章最后完整项目代码中有，这块只是引用。\n    void BFS1(Node head) {        // 初始化访问标记        initFlag();        // 初始化队列        this.queue.initQueue(20);        Node pNode;        this.queue.enterQueue(head);        this.nodes[head.name].flag = true;        while (!this.queue.isEmpty()) {            pNode = this.queue.deleteQueue();            pNode = this.nodes[pNode.name];            System.out.print(pNode.name + \" \");            while (pNode != null) {                pNode = pNode.next;                if (pNode != null && !this.nodes[pNode.name].flag) {                    this.queue.enterQueue(pNode);                    this.nodes[pNode.name].flag = true;                }            }        }    }4.  邻接矩阵的两种遍历4.1 深度优先遍历（邻接矩阵）4.1.1 递归算法（邻接矩阵）\n    // 深度优先遍历（从0号结点开始） 递归算法 邻接矩阵    void DFSM(int i) {        int j = 0;        System.out.print(this.nodes[i].name + \" \");        this.nodes[i].flag = true;        for (j = 0; j < this.Sidenum; j++) {            if (this.A[i][j] == 1 && !this.nodes[j].flag) {                DFSM(j);            }        }    }    void DFS3() {        for (int i = 0; i < this.Sidenum; i++) {            if (!this.nodes[i].flag) {                DFSM(i);            }        }    }4.1.2 非递归算法（邻接矩阵）\n用到的栈，定义在文章最后完整项目代码中有，这块只是引用。\n    // 深度优先遍历（从0号结点开始） 非递归算法 邻接矩阵    void DFS4(Node head) {        // 初始化访问标记        initFlag();        int i = 0;        // 初始化栈        this.stack.InitStack(20);        Node pNode, wNode = null;        this.stack.push(head);        System.out.print(head.name + \" \");        this.nodes[head.name].flag = true;        while (!this.stack.IsEmpty()) {            pNode = this.stack.getTop();            for (i = 0; i < this.Sidenum; i++) {                if (this.A[pNode.name][i] == 1 && !this.nodes[i].flag) {                    System.out.print(this.nodes[i].name + \" \");                    this.nodes[i].flag = true;                    this.stack.push(this.nodes[i]);                    break;                }            }            if (i == this.Sidenum) {                this.stack.pop();            }        }    }4.2  广度优先搜索（邻接矩阵）因为广度优先遍历需要用到队列，所以不能递归，递归只能是用到栈时才能。\n用到的队列，定义在文章最后完整项目代码中有，这块只是引用。\n    // 广度优先遍历（从0号结点开始） 非递归算法 邻接矩阵    void BFS2(int k) {        // 初始化被访问标记        initFlag();        // 初始化队列        this.queue.initQueue(20);        Node node;        System.out.print(this.nodes[k].name + \" \");        this.nodes[k].flag = true;        this.queue.enterQueue(this.nodes[k]);        while (!this.queue.isEmpty()) {            node = this.queue.deleteQueue();            for (int i = 0; i < this.Sidenum; i++) {                if (this.A[node.name][i] == 1 && !this.nodes[i].flag) {                    System.out.print(this.nodes[i].name + \" \");                    this.nodes[i].flag = true;                    this.queue.enterQueue(this.nodes[i]);                }            }        }    }5.  项目完整代码项目的代码比较多，主要有下面几个类，防止查找麻烦，目录如下：\n目录：\n\nclass Node 结点定义class Seqqueue  队列定义class Seqstack  栈的定义class Graph  图的定义及操作class Client   测试类\n内容：\n\n//class Node 结点定义\npackage com.company.project.graph;public class Node {    public int name;    public Node next;    public Boolean flag;    public Node() {        // TODO Auto-generated constructor stub        this.name = 0;        this.next = null;        this.flag = false;    }    public Node(int name) {        this.name = name;        this.next = null;        this.flag = false;    }    }\\2. //class Seqqueue  队列定义\npackage com.company.project.graph;public class Seqqueue {    public Node[] queue;    public int QUEUE_SIZE;    public int front;    public int rear;    //初始化队列        public void initQueue(int size) {            this.QUEUE_SIZE = size;            this.queue = new Node[size];            this.front = 0;            this.rear = 0;                }        //判断队列是否为空        public boolean isEmpty() {            if(this.front  == this.rear ) {                return true;            }            else {                return false;            }        }        //判断队列是否为满        public boolean isFull() {            if((this.front % this.QUEUE_SIZE) == ((this.rear+1) % this.QUEUE_SIZE)) {                return true;            }            else {                return false;            }        }        //入队        public void enterQueue(Node node) {            if(isFull()) {                System.out.println(\"队列已经满了，入队失败\");                return;                    }            this.queue[this.rear] = node;            this.rear ++;            this.rear = this.rear % this.QUEUE_SIZE;        }        //出队        public Node deleteQueue() {            if(isEmpty()){                System.out.println(\"队列为空，出队失败\");                return null;            }            this.front = this.front % this.QUEUE_SIZE;            Node node = this.queue[this.front];            this.front++;            return node;        }}\\3. //class Seqstack  栈的定义\npackage com.company.project.graph;public class Seqstack {    // 节点数组(模拟顺序栈)    public Node[] nodes;    // 栈顶下标    public int top;    public Seqstack() {        // TODO Auto-generated constructor stub        this.top = -1;    }    // 初始化栈    public void InitStack(int size) {        this.nodes = new Node[size];        this.top = -1;    }    // 判断栈空    public boolean IsEmpty() {        if (this.top == -1) {            return true;        }        return false;    }    // 判断栈满    public boolean IsFull() {        if (this.top == this.nodes.length - 1) {            return true;        }        return false;    }    // 入栈    public void push(Node node) {        if (IsFull()) {            System.out.println(\"栈已经满了，入栈失败\");            return;        }        this.top++;        this.nodes[this.top] = node;    }    // 出栈    public Node pop() {        if (IsEmpty()) {            System.out.println(\"栈已经空了，出栈失败\");            return null;        }        Node node = this.nodes[this.top];        this.top--;        return node;    }    // 清空栈    public void ClearStack() {        // 如果不为空，就一直出栈        while (!IsEmpty()) {            Node node = pop();        }    }    // 拿到栈顶元素    public Node getTop() {        if (IsEmpty()) {            System.out.println(\"栈中没有元素\");            return null;        }        return this.nodes[this.top];    }}\\4. //class Graph  图的定义及操作\npackage com.company.project.graph;import java.util.Scanner;public class Graph {    public Node[] nodes;    public int[][] A;    public int Sidenum;    public Seqqueue queue;    public Seqstack stack;    Scanner scanner;    public Graph(int Nodenum, int Sidenum) {        this.nodes = new Node[Nodenum];        for (int i = 0; i < Nodenum; i++) {            this.nodes[i] = new Node(i);        }        this.A = new int[Nodenum][Nodenum];        this.Sidenum = Sidenum;        for (int i = 0; i < Nodenum; i++) {            for (int j = 0; j < Nodenum; j++) {                this.A[i][j] = 0;            }        }        scanner = new Scanner(System.in);        this.queue = new Seqqueue();        this.queue.initQueue(20);        this.stack = new Seqstack();        this.stack.InitStack(20);    }    // 邻接矩阵创建(有向图)    void creat1() {        int a, b;        for (int i = 0; i < this.Sidenum; i++) {            a = scanner.nextInt();            b = scanner.nextInt();            this.A[a][b] = 1;        }        System.out.println(\"图创建成功\");    }    // 邻接矩阵创建(无向图)    void creat2() {        int a, b;        for (int i = 0; i < this.Sidenum; i++) {            a = scanner.nextInt();            b = scanner.nextInt();            this.A[a][b] = 1;            this.A[b][a] = 1;        }        System.out.println(\"图创建成功\");    }    // 邻接表创建    void creat3() {        int a, b;        for (int i = 0; i < this.Sidenum; i++) {            a = scanner.nextInt();            b = scanner.nextInt();            Node node = this.nodes[a];            // 防止把同一条边加入多次            while (node.next != null && node.next.name != b) {                node = node.next;            }            if (node.next == null) {                Node n = new Node(b);                n.next = nodes[a].next;                nodes[a].next = n;            }        }        System.out.println(\"图创建成功\");    }    // 遍历输出邻接矩阵    void traver1() {        for (int i = 0; i < nodes.length; i++) {            for (int j = 0; j < nodes.length; j++) {                System.out.print(this.A[i][j] + \" \");            }            System.out.println(\"\");        }    }    // 遍历输出邻接表    void traver2() {        Node node;        for (int i = 0; i < nodes.length; i++) {            node = nodes[i];            System.out.print(node.name + \":\");            while (node.next != null) {                System.out.print(node.next.name + \" \");                node = node.next;            }            System.out.println(\"\");        }    }//邻接表的两种遍历（递归和非递归）    // 初始化访问标记    void initFlag() {        // 初始化        for (int i = 0; i < this.nodes.length; i++) {            this.nodes[i].flag = false;        }    }    // 深度优先遍历(从head结点开始) 递归算法 邻接表    void DFS1(Node head) {        Node pNode;        if (!this.nodes[head.name].flag) {            System.out.print(head.name + \" \");            this.nodes[head.name].flag = true;        }        pNode = this.nodes[head.name].next;        while (pNode != null) {            if (!this.nodes[pNode.name].flag) {                DFS1(pNode);            } else {                pNode = pNode.next;            }        }    }    // 深度优先遍历(从head结点开始) 非递归算法 邻接表    void DFS2(Node head) {        // 初始化访问标记        initFlag();        // 初始化栈        this.stack.InitStack(20);        Node pNode, wNode;        this.stack.push(head);        System.out.print(head.name + \" \");        this.nodes[head.name].flag = true;        while (!this.stack.IsEmpty()) {            pNode = this.stack.pop();            wNode = pNode.next;            while (wNode != null) {                if (!this.nodes[wNode.name].flag) {                    this.stack.push(wNode);                    this.nodes[wNode.name].flag = true;                    System.out.print(wNode.name + \" \");                    wNode = this.nodes[wNode.name].next;                } else {                    wNode = wNode.next;                }            }        }    }    // 广度优先遍历(从head结点开始)（非递归） 邻接表    // 因为广度优先遍历需要用到队列，所以不能递归，递归只能是用到栈时才能    void BFS1(Node head) {        // 初始化访问标记        initFlag();        // 初始化队列        this.queue.initQueue(20);        Node pNode;        this.queue.enterQueue(head);        this.nodes[head.name].flag = true;        while (!this.queue.isEmpty()) {            pNode = this.queue.deleteQueue();            pNode = this.nodes[pNode.name];            System.out.print(pNode.name + \" \");            while (pNode != null) {                pNode = pNode.next;                if (pNode != null && !this.nodes[pNode.name].flag) {                    this.queue.enterQueue(pNode);                    this.nodes[pNode.name].flag = true;                }            }        }    }//邻接矩阵的两种遍历（递归和非递归）邻接矩阵        // 深度优先遍历（从0号结点开始） 递归算法 邻接矩阵    void DFSM(int i) {        int j = 0;        System.out.print(this.nodes[i].name + \" \");        this.nodes[i].flag = true;        for (j = 0; j < this.Sidenum; j++) {            if (this.A[i][j] == 1 && !this.nodes[j].flag) {                DFSM(j);            }        }    }    void DFS3() {        for (int i = 0; i < this.Sidenum; i++) {            if (!this.nodes[i].flag) {                DFSM(i);            }        }    }    // 深度优先遍历（从0号结点开始） 非递归算法 邻接矩阵    void DFS4(Node head) {        // 初始化访问标记        initFlag();        int i = 0;        // 初始化栈        this.stack.InitStack(20);        Node pNode, wNode = null;        this.stack.push(head);        System.out.print(head.name + \" \");        this.nodes[head.name].flag = true;        while (!this.stack.IsEmpty()) {            pNode = this.stack.getTop();            for (i = 0; i < this.Sidenum; i++) {                if (this.A[pNode.name][i] == 1 && !this.nodes[i].flag) {                    System.out.print(this.nodes[i].name + \" \");                    this.nodes[i].flag = true;                    this.stack.push(this.nodes[i]);                    break;                }            }            if (i == this.Sidenum) {                this.stack.pop();            }        }    }    // 广度优先遍历（从0号结点开始） 非递归算法 邻接矩阵    void BFS2(int k) {        // 初始化被访问标记        initFlag();        // 初始化队列        this.queue.initQueue(20);        Node node;        System.out.print(this.nodes[k].name + \" \");        this.nodes[k].flag = true;        this.queue.enterQueue(this.nodes[k]);        while (!this.queue.isEmpty()) {            node = this.queue.deleteQueue();            for (int i = 0; i < this.Sidenum; i++) {                if (this.A[node.name][i] == 1 && !this.nodes[i].flag) {                    System.out.print(this.nodes[i].name + \" \");                    this.nodes[i].flag = true;                    this.queue.enterQueue(this.nodes[i]);                }            }        }    }}\\5. //class Client  测试类（里面有邻接表和邻接矩阵 的全部操作测试，需要那个，把剩余的注释就行）\npackage com.company.project.graph;import java.util.Scanner;public class Client {    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        System.out.println(\"输入顶点数：\");        int Nodenum = scanner.nextInt();        System.out.println(\"输入边数：\");        int Sidenum = scanner.nextInt();        Graph graph = new Graph(Nodenum, Sidenum);// 邻接矩阵创建        // 邻接矩阵创建        System.out.println(\"输入边的两个顶点：\");        graph.creat1();        graph.traver1();// 邻接表创建        // 邻接表创建        System.out.println(\"输入边的两个顶点：\");        graph.creat3();        System.out.println(\"邻接表：\");        graph.traver2();//邻接表的搜索        // 深度优先搜索        System.out.println(\"深度优先搜索（递归）\");        graph.initFlag();        graph.DFS1(graph.nodes[0]);        System.out.println(\"\");        // 深度优先搜索        System.out.println(\"深度优先搜索（非递归）\");        graph.DFS2(graph.nodes[0]);        System.out.println(\"\");        // 广度优先遍历        System.out.println(\"广度优先搜索（非递归）\");        graph.BFS1(graph.nodes[0]);//邻接矩阵的搜索        // 深度优先搜索        System.out.println(\"深度优先搜索（递归）\");        graph.initFlag();        graph.DFS3();        System.out.println(\"\");        // 深度优先搜索        System.out.println(\"深度优先搜索（非递归）\");        graph.initFlag();        graph.DFS4(graph.nodes[0]);        System.out.println(\"\");        // 广度优先搜索        System.out.println(\"广度优先搜索（非递归）\");        graph.initFlag();        graph.BFS2(0);        System.out.println(\"\");    }}', 0, 1);
INSERT INTO `t_article` VALUES (133, '04. 插入类排序（直接插入排序、折半插入排序、希尔排序）', 8, '\n\n## 一 、插入类排序\n\n基本思想：\n\n在一个已排好序的记录子集的基础上，每一步将下一个待排序的记录有序插入到已排好序的记录子集中，直到将所有待排记录全部插入为止。\n\n插入排序有多种具体实现算法：\n\n​       （1）  直接插入排序\n\n​       （2）  折半插入排序\n\n​       （3）  表插入排序\n\n​       （4）  希尔排序\n\n## 二、 直接插入排序\n\n**基本操作：**将第i个记录插入到前面i-1个已排好序的记录中。\n\n**具体过程**：将第i个记录的关键字Ki顺次与其前面记录的关键字Ki-1，Ki-2，…K1进行比较，将所有关键字大于Ki的记录依次向后移动一个位置，直到遇见一个关键字小于或者等于Ki的记录Kj，此时Kj后面必为空位置，将第i个记录插入空位置即可。\n\n关键字序列T=（48,62,35,77,55,14,35,98），\n\n请写出直接插入排序的中间过程序列。\n\n{ 48 }       62         35       77        55      14       35         98 \n\n{ 48         62 }       35       77        55      14       35         98\n\n{ 35        48        62 }       77        55      14       35         98  \n\n{ 35        48        62         77 }      55      14       35         98 \n\n{ 35        48        55        62        77 }      14      35         98 \n\n{ 14        35        48        55        62       77 }     35         98 \n\n{ 14        35        35        48        55        62      77 }       98 \n\n{ 14        35        35        48        55        62      77          98}\n\n平均时间复杂度：T(n)=O(n*n)\n\n空间：只需要一个辅助空间r[0]。\n\n算法的稳定性：稳定 \n\n代码：\n\n```java\n//假设待排序记录存放在r[1..n]之中，\n//附设一个监视哨r[0]，使得r[0]始终存放待插入的记录\npublic void insSort(Node[] r) {\n		int j = 0;\n		for (int i = 2; i < r.length; i++) {\n			r[0] = r[i];\n			j = i - 1;\n			while(r[0].key < r[j].key) {\n				r[j + 1] = r[j];\n				j = j -1;\n			}\n			r[j + 1] = r[0];\n		}\n	}\n```\n\n## 三、 折半插入排序\n\n算法分析：\n\n​     虽然折半插入排序法与直接插入排序法相比较，改善了算法中比较次数的数量级，但其并未改变移动元素的时间耗费，所以折半插入排序的总的时间复杂度仍然是O(n2)。 较，因此插入n-1个元素的平均关键字的比较次数为O(nlog2n)。 \n\n​      虽然折半插入排序法与直接插入排序法相比较，改善了算法中比较次数的数量级，但其并未改变移动元素的时间耗费，所以折半插入排序的总的时间复杂度仍然是O(n2)。 \n\n```java\n	void sort(Node[] nodes) {\n		Node x;\n		int low, mid, high = 0;\n		for (int i = 1; i < nodes.length; i++) {\n			x = nodes[i]; \n			low = 0;\n			high = i - 1;\n			while (low <= high) {\n				mid = (low + high) / 2;\n				if (x.key < nodes[mid].key) {\n					high = mid - 1;\n				} else {\n					low = mid + 1;\n				}\n			}\n			for (int j = i - 1; j >= low; j--) {\n				nodes[j + 1] = nodes[j];\n			}\n			nodes[low] = x;\n		}\n	}\n```\n\n## 四、 希尔插入排序\n\n希尔插入排序 (Shell\'s Sort)\n\n是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。\n\n 具体步骤：\n\n 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序， 随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n\n时间复杂度：O(n^1.3~2)\n\n 空间复杂度：O(1)\n\n 稳定性：不稳定\n\n```java\nvoid hillSort(Node[] nodes) {\n		int len = nodes.length / 2;\n		Node node;\n		while (len != 0) {\n			for (int i = len; i < nodes.length; i++) {			\n				for(int j = len ; j<nodes.length ;j+= len) {\n					if (nodes[j].key < nodes[j - len].key) {\n						node = nodes[j];\n						nodes[j] = nodes[j - len];\n						nodes[j - len] = node;\n					}\n				}\n			}\n			len = len / 2;\n		}\n	}\n```', 0, 0, '2020-08-07 00:59:03', 2, 0, 1, '一 、插入类排序基本思想：\n在一个已排好序的记录子集的基础上，每一步将下一个待排序的记录有序插入到已排好序的记录子集中，直到将所有待排记录全部插入为止。\n插入排序有多种具体实现算法：\n​       （1）  直接插入排序\n​       （2）  折半插入排序\n​       （3）  表插入排序\n​       （4）  希尔排序\n二、 直接插入排序基本操作：将第i个记录插入到前面i-1个已排好序的记录中。\n具体过程：将第i个记录的关键字Ki顺次与其前面记录的关键字Ki-1，Ki-2，…K1进行比较，将所有关键字大于Ki的记录依次向后移动一个位置，直到遇见一个关键字小于或者等于Ki的记录Kj，此时Kj后面必为空位置，将第i个记录插入空位置即可。\n关键字序列T=（48,62,35,77,55,14,35,98），\n请写出直接插入排序的中间过程序列。\n{ 48 }       62         35       77        55      14       35         98 \n{ 48         62 }       35       77        55      14       35         98\n{ 35        48        62 }       77        55      14       35         98  \n{ 35        48        62         77 }      55      14       35         98 \n{ 35        48        55        62        77 }      14      35         98 \n{ 14        35        48        55        62       77 }     35         98 \n{ 14        35        35        48        55        62      77 }       98 \n{ 14        35        35        48        55        62      77          98}\n平均时间复杂度：T(n)=O(n*n)\n空间：只需要一个辅助空间r[0]。\n算法的稳定性：稳定 \n代码：\n//假设待排序记录存放在r[1..n]之中，//附设一个监视哨r[0]，使得r[0]始终存放待插入的记录public void insSort(Node[] r) {        int j = 0;        for (int i = 2; i < r.length; i++) {            r[0] = r[i];            j = i - 1;            while(r[0].key < r[j].key) {                r[j + 1] = r[j];                j = j -1;            }            r[j + 1] = r[0];        }    }\n三、 折半插入排序算法分析：\n​     虽然折半插入排序法与直接插入排序法相比较，改善了算法中比较次数的数量级，但其并未改变移动元素的时间耗费，所以折半插入排序的总的时间复杂度仍然是O(n2)。 较，因此插入n-1个元素的平均关键字的比较次数为O(nlog2n)。 \n​      虽然折半插入排序法与直接插入排序法相比较，改善了算法中比较次数的数量级，但其并未改变移动元素的时间耗费，所以折半插入排序的总的时间复杂度仍然是O(n2)。 \n    void sort(Node[] nodes) {        Node x;        int low, mid, high = 0;        for (int i = 1; i < nodes.length; i++) {            x = nodes[i];             low = 0;            high = i - 1;            while (low <= high) {                mid = (low + high) / 2;                if (x.key < nodes[mid].key) {                    high = mid - 1;                } else {                    low = mid + 1;                }            }            for (int j = i - 1; j >= low; j--) {                nodes[j + 1] = nodes[j];            }            nodes[low] = x;        }    }\n四、 希尔插入排序希尔插入排序 (Shell’s Sort)\n是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。\n 具体步骤：\n 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序， 随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n时间复杂度：O(n^1.3~2)\n 空间复杂度：O(1)\n 稳定性：不稳定\nvoid hillSort(Node[] nodes) {        int len = nodes.length / 2;        Node node;        while (len != 0) {            for (int i = len; i < nodes.length; i++) {                            for(int j = len ; j<nodes.length ;j+= len) {                    if (nodes[j].key < nodes[j - len].key) {                        node = nodes[j];                        nodes[j] = nodes[j - len];                        nodes[j - len] = node;                    }                }            }            len = len / 2;        }    }\n', 0, 1);
INSERT INTO `t_article` VALUES (134, '05.交换类排序（冒泡排序，快速排序）', 8, '\n## 1、  交换类排序\n\n**基本思想：**\n\n**两两比较待排序记录的关键字，如果发生逆序（即排列顺序与排序后的次序正好相反），则交换之，直到所有记录都排好序为止。**\n\n**交换排序的主要算法有：**\n\n   **（1）  冒泡排序**\n\n   **（2）  快速排序**\n\n## **2、 冒泡排序**（Bubble Sort）\n\n**基本思想：**\n\n**每趟不断将相邻记录两两比较，并按“前小后大”（或“前大后小”）规则交换。**\n\n**步骤:**\n\n它重复地走访过要排序的元素列，**依次比较两个相邻的元素**，如果顺序（如从大到小、首字母从从Z到A）错误就把他们**交换**过来。走访元素的工作是重复地进行直到**没有相邻元素需要交换**，也就是说该元素列已经排序完成。\n\n这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。\n\n```\n	void bubbleSort(Node[] nodes) {\n		Node node = null;\n		for (int i = 0; i < nodes.length; i++) {\n			for (int j = 1; j < nodes.length - i; j++) {\n				if (nodes[j - 1].key > nodes[j].key) {\n					node = nodes[j - 1];\n					nodes[j - 1] = nodes[j];\n					nodes[j] = node;\n				}\n			}\n		}\n	}\n```\n\n### 算法分析：\n\n **优点：**每趟结束时，不仅能找出一个最大值到最后面位置，还能同时部分理顺其他元素；一旦下趟没有交换发生，还可以提前结束排序。\n\n**时间复杂度 ：O（n²）**\n\n**空间效率：O（1） —只在交换时用到一个辅助单元**\n\n**算法稳定性：**稳定排序算法\n\n**实    质：**把小（大）的元素往前（后）调\n\n## 3.  快速排序（Quicksort）\n\n**基本思想：**通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以[递归](https://baike.baidu.com/item/递归/1740695)进行，以此达到整个数据变成有序[序列](https://baike.baidu.com/item/序列/1302588)。\n\n**步骤：**\n\n1. 从后向前比，用基准值和最后一个值比较，如果比基准值小，就交换位置，否则就接着往前找，直到找到第一个比基准值小的值。\n2. 在从后往前找到第一个比基准值小的值并交换位置后，又开始从前往后比较。如果有比基准值大的，就交换位置；如果没有，则继续比较下一个，直到找到第一个比基准值大的值才交换位置。\n3. 重复执行以上步骤，直到从前向后比较的索引大于等于从后往前的索引，则结束一次循环。这时，对于基准值来说，左右两边都是有序的数据序列。\n4. 重复循环以上过程，分别比较左右两边的序列，直到整个数据序列有序。\n\n**优点：**通过一次交换消除多个逆序，所以特别快！\n\n![img](https://pic4.zhimg.com/v2-0d6afa605d842263db51d2f6325af833_b.gif)\n\n```\npublic class quickSort {\n\n	public int pos = 0;\n\n	void QKSort(Node r[], int low, int high) {\n		if (low < high) {\n			pos = QKPass(r, low, high);\n			QKSort(r, low, pos - 1);\n			QKSort(r, pos + 1, high);\n		}\n	}\n\n	int QKPass(Node[] r, int left, int right) {\n		Node x = r[left];        //基准值\n		int low = left, high = right;  // low从前往后比较的索引，high从后往前比较的索引\n		while (low < high) {\n\n			while (low < high && r[high].key >= x.key) {\n				//从后往前比较\n				high--;\n			}	\n			//如果没找到比基准值小的就继续往前找，\n			//否则，就交换位置（直接赋值也行，基准值在x里面保存）。然后再从前往后找\n			if (low < high) {\n				r[low] = r[high];\n				low++;\n			}\n			\n			//从前往后比较\n			while (low < high && r[low].key < x.key) {\n				low++;\n			}\n			//如果没找到比基准值大的就继续往后找，\n			//否则，就交换位置（直接赋值也行，基准值在x里面保存）。\n			if (low < high) {\n				r[high] = r[low];\n				high--;\n			}\n		}\n\n		//此时在low的左边都小于基准值，右边都大于基准值\n		r[low] = x;\n		return low;\n	}\n}\n```\n\n**时间效率：**O(nlog2n)（但最坏情况下为：O(n2))\n\n**平均时间复杂度:**  O(nlog2n)。\n\n**稳 定 性：** 不 稳 定\n\n为改善最坏情况下的时间性能，可采用其他方法选取中间数。通常采用“三者值取中”方法，即比较H->r[low].key、H->r[high].key与H->r[(low+high)/2].key，取三者中关键字为中值的元素为中间数。\n\n从空间性能上看，尽管快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归。最好的情况下，即快速排序的每一趟排序都将元素序列均匀地分割成长度相近的两个子表，所需栈的最大深度为log2(n+1)；但最坏的情况下，栈的最大深度为n。这样，快速排序的**空间复杂度为O(log2n))**。', 0, 0, '2020-08-07 00:59:37', 2, 0, 1, '1、  交换类排序基本思想：\n两两比较待排序记录的关键字，如果发生逆序（即排列顺序与排序后的次序正好相反），则交换之，直到所有记录都排好序为止。\n交换排序的主要算法有：\n   （1）  冒泡排序\n   （2）  快速排序\n2、 冒泡排序（Bubble Sort）基本思想：\n每趟不断将相邻记录两两比较，并按“前小后大”（或“前大后小”）规则交换。\n步骤:\n它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。\n这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。\n    void bubbleSort(Node[] nodes) {        Node node = null;        for (int i = 0; i < nodes.length; i++) {            for (int j = 1; j < nodes.length - i; j++) {                if (nodes[j - 1].key > nodes[j].key) {                    node = nodes[j - 1];                    nodes[j - 1] = nodes[j];                    nodes[j] = node;                }            }        }    }算法分析： 优点：每趟结束时，不仅能找出一个最大值到最后面位置，还能同时部分理顺其他元素；一旦下趟没有交换发生，还可以提前结束排序。\n时间复杂度 ：O（n²）\n空间效率：O（1） —只在交换时用到一个辅助单元\n算法稳定性：稳定排序算法\n实    质：把小（大）的元素往前（后）调\n3.  快速排序（Quicksort）基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n步骤：\n\n从后向前比，用基准值和最后一个值比较，如果比基准值小，就交换位置，否则就接着往前找，直到找到第一个比基准值小的值。在从后往前找到第一个比基准值小的值并交换位置后，又开始从前往后比较。如果有比基准值大的，就交换位置；如果没有，则继续比较下一个，直到找到第一个比基准值大的值才交换位置。重复执行以上步骤，直到从前向后比较的索引大于等于从后往前的索引，则结束一次循环。这时，对于基准值来说，左右两边都是有序的数据序列。重复循环以上过程，分别比较左右两边的序列，直到整个数据序列有序。\n优点：通过一次交换消除多个逆序，所以特别快！\n\npublic class quickSort {    public int pos = 0;    void QKSort(Node r[], int low, int high) {        if (low < high) {            pos = QKPass(r, low, high);            QKSort(r, low, pos - 1);            QKSort(r, pos + 1, high);        }    }    int QKPass(Node[] r, int left, int right) {        Node x = r[left];        //基准值        int low = left, high = right;  // low从前往后比较的索引，high从后往前比较的索引        while (low < high) {            while (low < high && r[high].key >= x.key) {                //从后往前比较                high--;            }                //如果没找到比基准值小的就继续往前找，            //否则，就交换位置（直接赋值也行，基准值在x里面保存）。然后再从前往后找            if (low < high) {                r[low] = r[high];                low++;            }            //从前往后比较            while (low < high && r[low].key < x.key) {                low++;            }            //如果没找到比基准值大的就继续往后找，            //否则，就交换位置（直接赋值也行，基准值在x里面保存）。            if (low < high) {                r[high] = r[low];                high--;            }        }        //此时在low的左边都小于基准值，右边都大于基准值        r[low] = x;        return low;    }}时间效率：O(nlog2n)（但最坏情况下为：O(n2))\n平均时间复杂度:  O(nlog2n)。\n稳 定 性： 不 稳 定\n为改善最坏情况下的时间性能，可采用其他方法选取中间数。通常采用“三者值取中”方法，即比较H->r[low].key、H->r[high].key与H->r[(low+high)/2].key，取三者中关键字为中值的元素为中间数。\n从空间性能上看，尽管快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归。最好的情况下，即快速排序的每一趟排序都将元素序列均匀地分割成长度相近的两个子表，所需栈的最大深度为log2(n+1)；但最坏的情况下，栈的最大深度为n。这样，快速排序的空间复杂度为O(log2n))。\n', 0, 1);
INSERT INTO `t_article` VALUES (135, '06.选择类排序法（树形选择排序，堆排序）', 8, '\n\n> 参考网页：\n>\n> https://mparticle.uc.cn/article.html?uc_param_str=frdnsnpfvecpntnwprdssskt&client=ucweb&wm_id=4d05a795442940a38808b3ae2bfad173&title_type=1&pagetype=share&app=smds-iflow&btifl=100&wm_cid=322828638447734784&wm_aid=3946200b31164d938e83aa6a0b9658f1&uc_share_depth=1mparticle.uc.cn\n\n## 选择类排序法\n\n**基本思想：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。**\n\n## **1.  简单选择排序**\n\n**基本思想：**第i趟简单选择排序是指通过n-i次关键字的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录进行交换。共需进行n-1趟比较，直到所有记录排序完成为止。\n\n**时间效率：O(n2)——虽移动次数较少，但比较次数仍多。**\n\n**空间效率：O(1)——1个附加单元。**\n\n**算法的稳定性：不稳定**\n\n```java\n	void selectSort(Node[] nodes) {\n		Node temp;\n		int k = 0,i = 0,j =0;\n		for(i = 0;i<nodes.length;i++) {\n			k = i;\n			for(j = i +1;j<nodes.length;j++) {\n				if(nodes[j].key < nodes[k].key) {\n					k = j;\n				}\n			}\n			if(k != j ) {\n				temp = nodes[i];\n				nodes[i] = nodes[k];\n				nodes[k] = temp;\n			}\n		}\n		\n	}\n```\n\n## 2.  树型选择排序\n\n[树形](https://baike.baidu.com/item/树形)选择排序又称[锦标赛](https://baike.baidu.com/item/锦标赛)排序（Tournament Sort），是一种按照锦标赛的思想进行选择排序的方法。首先对n个记录的关键字进行两两比较，然后在n/2个较小者之间再进行两两比较，如此重复，直至选出最小的记录为止。\n\n **基本思想：**先把待排序的n个记录的关键字两两进行比较，取出较小者。然后再在n/2 个较小者中，采用同样的方法进行比较选出每两个中的较小者，如此反复，直至选出最小关键字记录为止。 \n\n```java\n	void treeSelectSort(Node[] nodes){\n		int i,j,min;\n		Node temp = null;\n		for( i = 0;i<nodes.length;i++) {\n			min = i;\n			for(j = i +1;j<nodes.length;j++) {\n				if(nodes[j].key < nodes[min].key) {\n					min = j;\n				}\n			}\n			if(i != min) {\n				temp = nodes[min];\n				nodes[min] = nodes[i];\n				nodes[i] = temp;\n			}\n		}	\n	}\n```\n\n**算法分析：**\n\n被选中的关键字都是走了一条由叶子结点到根结点的比较的过程,由于含有n个叶子节点的完全二叉数的深度为log2n +1，则在树型选择排序中，每选择一个小关键字需要进行log2n次比较，因此其时间复杂度为O(nlog2n)。移动记录次数不超过比较次数，故总的算法时间复杂度为O(nlog2n)。\n\n## 3.  堆排序\n\n堆排序是对树型选择排序的进一步改进。采用堆排序时，只需要一个记录大小的辅助空间。堆排序是在排序过程中，将向量中存储的数据看成一棵完全二叉树，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择关键字最小的记录，即待排序记录仍采用向量数组方式存储，并非采用树的存储结构，而仅仅是采用完全二叉树的顺序结构的特征进行分析而已。 \n\n堆的含义：完全二叉树的所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。若系列是堆，则堆顶元素必定为序列中n个元素的最小值（或最大值）。\n\n **具体做法**：\n\n 把待排序的记录的关键字存放在数组r[1..n]之中，将r看成是一棵完全二叉树的顺序表示，每个结点表示一个记录，第一个记录r[1]作为二叉树的根，以下各记录r[2...n]依次逐层从左到右顺序排列，任意结点r[i]的左孩子是r[2i],右孩子是r[2i+1],双亲是r[i/2]。对这棵完全二叉树进行调整，使各结点的关键字值满足下列条件：\n\nr[i].key≥r[2i].key并且r[i].key≥r[2i+1].key(i=1,2, ...n/2 )，\n\n 满足这个条件的完全二叉树为堆。 \n\n![img](https://pic3.zhimg.com/v2-658d0f58eed41a5c11cd1d1c039269ba_b.gif)\n\n堆排序二叉树图\n\n![img](https://pic1.zhimg.com/v2-04db8c096f497eae53bf179d0d900fac_b.gif)\n\n堆排序方块图\n\n**堆排序的过程主要需要解决两个问题：**\n\n  **(1) 按堆定义建初堆**\n\n **一个任意序列看成是对应的完全二叉树，由于叶结点可以视为单元素的堆，因而可以反复利用“筛选”法，自底向上逐层把所有子树调整为堆，直到将整个完全二叉树调整为堆。**\n\n**（2）去掉最大元之后重建堆，得到次大元。**\n\n- 将堆顶元素和最后一个元素互换，此时根结点的左右子树均为大顶堆\n- 若根结点存在左右子树，则比较根结点和左右子树根结点的值，否则调整结束，跳到步骤1\n- 若根结点值依旧均大于左右子树的根结点的值，则跳转到第1步执行\n- 否则将根结点和左右子树根结点较大值互换，跳转到第2步，以被交换的子树的根结点作为第2步根结点执行\n\n```java\npublic class HeapSort {\n	// 交换两个位置\n	void swap(Node[] nodes, int n, int m) {\n		Node temp;\n		temp = nodes[n];\n		nodes[n] = nodes[m];\n		nodes[m] = temp;\n		\n	}\n\n	//堆排序的主函数\n	void heapSort(Node arr[], int count) {\n		//从下往上构建初始堆\n		//从根节点的上一层结点开始向上遍历\n		for (int i = count / 2 - 1; i >= 0; i--) {\n			shiftDown(arr, count, i);  \n		}\n		\n		\n		//从上往下调整堆，构建大根堆（循环每进行一次，都会把最大元素交换到堆顶）\n		for (int j = count - 1; j > 0; j--) {\n			swap(arr, 0, j);   //将堆顶元素与待排序的堆末元素交换\n			shiftDown(arr, j, 0);   //抛去大根堆最后一个元素，对前面元素进行建堆\n		}\n	}\n\n	//arr是待排序数组，count是未排序的个数，在count下标往后的已经排好序，\n	//currentRoot当前的种子下标\n	//作用：构建大根堆\n	void shiftDown(Node[] arr, int count, int currentRoot) {\n		int max;\n		while (2 * currentRoot + 1 < count) {   //该种子有左子树\n			max = 2 * currentRoot + 1;       //默认他的左孩子为最大值\n			if (max + 1 < count && arr[max + 1].key > arr[max].key) {\n				//如果他的右孩子也在未排序序列，并且右孩子比左孩子大，让右孩子为最大值\n				max = max + 1;\n			}\n			if (arr[currentRoot].key >= arr[max].key) {\n				//如果种子结点的值大于或等于左右孩子最大值，就退出循环\n				break;\n			}\n			swap(arr, currentRoot, max);   //否则，就让种子结点和他的左右孩子的最大结点交换\n			currentRoot = max;   //并且将种子下标换成最大结点下标，进行下一轮循环\n		}\n	}\n\n}\n```\n\n**堆排序在最坏情况下，其时间复杂度也为O(nlog2n)，这是堆排序的最大优点。**\n\n**堆排序是一种不稳定的排序方法，**\n\n**它不适用于待排序记录个数n较少的情况，但对于n较大的文件还是很有效的。**', 0, 0, '2020-08-07 01:00:18', 2, 0, 1, '\n参考网页：\nhttps://mparticle.uc.cn/article.html?uc_param_str=frdnsnpfvecpntnwprdssskt&client=ucweb&wm_id=4d05a795442940a38808b3ae2bfad173&title_type=1&pagetype=share&app=smds-iflow&btifl=100&wm_cid=322828638447734784&wm_aid=3946200b31164d938e83aa6a0b9658f1&uc_share_depth=1mparticle.uc.cn\n\n选择类排序法基本思想：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。\n1.  简单选择排序基本思想：第i趟简单选择排序是指通过n-i次关键字的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录进行交换。共需进行n-1趟比较，直到所有记录排序完成为止。\n时间效率：O(n2)——虽移动次数较少，但比较次数仍多。\n空间效率：O(1)——1个附加单元。\n算法的稳定性：不稳定\n    void selectSort(Node[] nodes) {        Node temp;        int k = 0,i = 0,j =0;        for(i = 0;i<nodes.length;i++) {            k = i;            for(j = i +1;j<nodes.length;j++) {                if(nodes[j].key < nodes[k].key) {                    k = j;                }            }            if(k != j ) {                temp = nodes[i];                nodes[i] = nodes[k];                nodes[k] = temp;            }        }    }\n2.  树型选择排序树形选择排序又称锦标赛排序（Tournament Sort），是一种按照锦标赛的思想进行选择排序的方法。首先对n个记录的关键字进行两两比较，然后在n/2个较小者之间再进行两两比较，如此重复，直至选出最小的记录为止。\n 基本思想：先把待排序的n个记录的关键字两两进行比较，取出较小者。然后再在n/2 个较小者中，采用同样的方法进行比较选出每两个中的较小者，如此反复，直至选出最小关键字记录为止。 \n    void treeSelectSort(Node[] nodes){        int i,j,min;        Node temp = null;        for( i = 0;i<nodes.length;i++) {            min = i;            for(j = i +1;j<nodes.length;j++) {                if(nodes[j].key < nodes[min].key) {                    min = j;                }            }            if(i != min) {                temp = nodes[min];                nodes[min] = nodes[i];                nodes[i] = temp;            }        }        }\n算法分析：\n被选中的关键字都是走了一条由叶子结点到根结点的比较的过程,由于含有n个叶子节点的完全二叉数的深度为log2n +1，则在树型选择排序中，每选择一个小关键字需要进行log2n次比较，因此其时间复杂度为O(nlog2n)。移动记录次数不超过比较次数，故总的算法时间复杂度为O(nlog2n)。\n3.  堆排序堆排序是对树型选择排序的进一步改进。采用堆排序时，只需要一个记录大小的辅助空间。堆排序是在排序过程中，将向量中存储的数据看成一棵完全二叉树，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择关键字最小的记录，即待排序记录仍采用向量数组方式存储，并非采用树的存储结构，而仅仅是采用完全二叉树的顺序结构的特征进行分析而已。 \n堆的含义：完全二叉树的所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。若系列是堆，则堆顶元素必定为序列中n个元素的最小值（或最大值）。\n 具体做法：\n 把待排序的记录的关键字存放在数组r[1..n]之中，将r看成是一棵完全二叉树的顺序表示，每个结点表示一个记录，第一个记录r[1]作为二叉树的根，以下各记录r[2…n]依次逐层从左到右顺序排列，任意结点r[i]的左孩子是r[2i],右孩子是r[2i+1],双亲是r[i/2]。对这棵完全二叉树进行调整，使各结点的关键字值满足下列条件：\nr[i].key≥r[2i].key并且r[i].key≥r[2i+1].key(i=1,2, …n/2 )，\n 满足这个条件的完全二叉树为堆。 \n\n堆排序二叉树图\n\n堆排序方块图\n堆排序的过程主要需要解决两个问题：\n  (1) 按堆定义建初堆\n 一个任意序列看成是对应的完全二叉树，由于叶结点可以视为单元素的堆，因而可以反复利用“筛选”法，自底向上逐层把所有子树调整为堆，直到将整个完全二叉树调整为堆。\n（2）去掉最大元之后重建堆，得到次大元。\n\n将堆顶元素和最后一个元素互换，此时根结点的左右子树均为大顶堆若根结点存在左右子树，则比较根结点和左右子树根结点的值，否则调整结束，跳到步骤1若根结点值依旧均大于左右子树的根结点的值，则跳转到第1步执行否则将根结点和左右子树根结点较大值互换，跳转到第2步，以被交换的子树的根结点作为第2步根结点执行\npublic class HeapSort {    // 交换两个位置    void swap(Node[] nodes, int n, int m) {        Node temp;        temp = nodes[n];        nodes[n] = nodes[m];        nodes[m] = temp;    }    //堆排序的主函数    void heapSort(Node arr[], int count) {        //从下往上构建初始堆        //从根节点的上一层结点开始向上遍历        for (int i = count / 2 - 1; i >= 0; i--) {            shiftDown(arr, count, i);          }        //从上往下调整堆，构建大根堆（循环每进行一次，都会把最大元素交换到堆顶）        for (int j = count - 1; j > 0; j--) {            swap(arr, 0, j);   //将堆顶元素与待排序的堆末元素交换            shiftDown(arr, j, 0);   //抛去大根堆最后一个元素，对前面元素进行建堆        }    }    //arr是待排序数组，count是未排序的个数，在count下标往后的已经排好序，    //currentRoot当前的种子下标    //作用：构建大根堆    void shiftDown(Node[] arr, int count, int currentRoot) {        int max;        while (2 * currentRoot + 1 < count) {   //该种子有左子树            max = 2 * currentRoot + 1;       //默认他的左孩子为最大值            if (max + 1 < count && arr[max + 1].key > arr[max].key) {                //如果他的右孩子也在未排序序列，并且右孩子比左孩子大，让右孩子为最大值                max = max + 1;            }            if (arr[currentRoot].key >= arr[max].key) {                //如果种子结点的值大于或等于左右孩子最大值，就退出循环                break;            }            swap(arr, currentRoot, max);   //否则，就让种子结点和他的左右孩子的最大结点交换            currentRoot = max;   //并且将种子下标换成最大结点下标，进行下一轮循环        }    }}\n堆排序在最坏情况下，其时间复杂度也为O(nlog2n)，这是堆排序的最大优点。\n堆排序是一种不稳定的排序方法，\n它不适用于待排序记录个数n较少的情况，但对于n较大的文件还是很有效的。\n', 0, 1);
INSERT INTO `t_article` VALUES (136, '07. 归并排序', 8, '\n\n## 1.  基本思想：\n\n​     是将两个或两个以上有序表合并成一个新的有序表。假设初始序列含有n个记录，首先将这n个记录看成n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2个长度为2（n为奇数时，最后一个序列的长度为1）的有序子序列；在此基础上，再进行两两归并，如此重复，直至得到一个长度为n的有序序列为止。这种方法被称作2-路归并排序。\n\n**采用了分治法的思想，分而治之，每个子问题的最优解最终组成大问题的最优解。**\n\n## **2. 归并操作：**\n\n**把两个已排序的序列从第一个元素开始比较，小的放到新的序列表，把指针移动到下一个元素，如此比较直到一个序列指针指向空（一个序列已经全部加入新序列），把另一个序列的剩余元素加入到新序列尾部。**\n\n例如：序列{5，3，9，7，6，1，0}\n\n初始状态：5，3，9，7，1，6，0\n\n第一次归并：{3，5}{7，9}{1，6}{0}    比较3次\n\n第二次归并：{3，5，7，9}{0，1，6}  比较3次\n\n第三次归并：{0，1，3，5，6，7，9}   比较5次\n\n总比较次数：N = 3+3+5 = 11次\n\n## 3.  算法描述\n\n1. 先申请一个可以放置两个序列大小的空间，作为这两个序列合并后的新序列。\n2. 用两个指针分别指向这两个序列的第一个元素。\n3. 比较两个指针指的元素的值，把值小的添加到新序列中，并把该指针向后移动一个。\n4. 重复第3步，直到一个指针指向空（即一个序列已经全部添加），把另一个序列的剩余元素逐个添加到新序列末尾。\n\n## 4.  Java实现代码\n\n```java\npublic class MergeSort {\n\n	// 自定义实现一次归并排序的函数\n	void merge(Node[] r, Node[] s, int x1, int x2, int x3) {\n		int i, j, k;\n		i = x1; // 第一部分的开始位置\n		j = x2 + 1; // 第二部分的开始位置\n		k = x1;\n		while (i <= x2 && j <= x3) {\n			// 当i和j都在两个要合并的部分中时\n			if (r[i].key <= r[j].key) {\n				// 筛选两部分中较小的元素放到数组s中\n				s[k] = r[i];\n				i++;\n				k++;\n			} else {\n				s[k] = r[j];\n				j++;\n				k++;\n			}\n		}\n\n		// 将x1~x2范围内未比较的数顺次加到数组s中\n		while (i <= x2) {\n			s[k++] = r[i++];\n		}\n\n		// 将x2+1~x3范围内未比较的数顺次加到数组s中\n		while (j <= x3) {\n			s[k++] = r[j++];\n		}\n\n	}\n\n	// 归并排序主函数\n	void mergeSort(Node[] r, Node[] s, int m, int n) {\n		int p = 0;\n		Node[] t = new Node[20];\n		if (m == n) {\n			s[m] = r[m];\n		} else {\n			p = (m + n) / 2;\n\n			// 递归调用mergeSort方法将r[m]~r[p]归并成有序的t[m]~t[p]\n			mergeSort(r, t, m, p);\n\n			// 递归调用mergeSort方法将r[p+1]~r[n]归并成有序的t[p+1]~t[n]\n			mergeSort(r, t, p + 1, n);\n\n			// 调用merge方法将前两部分归并到s[m]~s[n]\n			merge(t, s, m, p, n);\n		}\n	}\n}\n```\n\n## 5.  算法分析\n\n时间效率：O(*n*log*n*)\n\n空间复杂度：T（n)\n\n稳 定 性： 稳 定\n\n速度仅次于[快速排序](https://baike.baidu.com/item/快速排序)，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的[数列](https://baike.baidu.com/item/数列)', 0, 0, '2020-08-07 01:00:49', 2, 0, 1, '1.  基本思想：​     是将两个或两个以上有序表合并成一个新的有序表。假设初始序列含有n个记录，首先将这n个记录看成n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2个长度为2（n为奇数时，最后一个序列的长度为1）的有序子序列；在此基础上，再进行两两归并，如此重复，直至得到一个长度为n的有序序列为止。这种方法被称作2-路归并排序。\n采用了分治法的思想，分而治之，每个子问题的最优解最终组成大问题的最优解。\n2. 归并操作：把两个已排序的序列从第一个元素开始比较，小的放到新的序列表，把指针移动到下一个元素，如此比较直到一个序列指针指向空（一个序列已经全部加入新序列），把另一个序列的剩余元素加入到新序列尾部。\n例如：序列{5，3，9，7，6，1，0}\n初始状态：5，3，9，7，1，6，0\n第一次归并：{3，5}{7，9}{1，6}{0}    比较3次\n第二次归并：{3，5，7，9}{0，1，6}  比较3次\n第三次归并：{0，1，3，5，6，7，9}   比较5次\n总比较次数：N = 3+3+5 = 11次\n3.  算法描述\n先申请一个可以放置两个序列大小的空间，作为这两个序列合并后的新序列。用两个指针分别指向这两个序列的第一个元素。比较两个指针指的元素的值，把值小的添加到新序列中，并把该指针向后移动一个。重复第3步，直到一个指针指向空（即一个序列已经全部添加），把另一个序列的剩余元素逐个添加到新序列末尾。\n4.  Java实现代码public class MergeSort {    // 自定义实现一次归并排序的函数    void merge(Node[] r, Node[] s, int x1, int x2, int x3) {        int i, j, k;        i = x1; // 第一部分的开始位置        j = x2 + 1; // 第二部分的开始位置        k = x1;        while (i <= x2 && j <= x3) {            // 当i和j都在两个要合并的部分中时            if (r[i].key <= r[j].key) {                // 筛选两部分中较小的元素放到数组s中                s[k] = r[i];                i++;                k++;            } else {                s[k] = r[j];                j++;                k++;            }        }        // 将x1~x2范围内未比较的数顺次加到数组s中        while (i <= x2) {            s[k++] = r[i++];        }        // 将x2+1~x3范围内未比较的数顺次加到数组s中        while (j <= x3) {            s[k++] = r[j++];        }    }    // 归并排序主函数    void mergeSort(Node[] r, Node[] s, int m, int n) {        int p = 0;        Node[] t = new Node[20];        if (m == n) {            s[m] = r[m];        } else {            p = (m + n) / 2;            // 递归调用mergeSort方法将r[m]~r[p]归并成有序的t[m]~t[p]            mergeSort(r, t, m, p);            // 递归调用mergeSort方法将r[p+1]~r[n]归并成有序的t[p+1]~t[n]            mergeSort(r, t, p + 1, n);            // 调用merge方法将前两部分归并到s[m]~s[n]            merge(t, s, m, p, n);        }    }}\n5.  算法分析时间效率：O(nlogn)\n空间复杂度：T（n)\n稳 定 性： 稳 定\n速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列\n', 0, 1);
INSERT INTO `t_article` VALUES (137, 'KMP算法——寻找子串位置', 8, '\n## 1、KMP算法简介：\n\nKMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度时间复杂度)O(m+n)。\n\n\n\n## 2、什么是字符串匹配：\n\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。\n\n在Java中就是String的indexOf()方法。\n\n\n\n## 3、对比暴力法和KMP算法：\n\n首先我们可以比对一下暴力法和KMP算法的差距：\n\n**（1）暴力法**\n\n挨个截取遍历字符串，然后对比\n\n![image-20200807010349177](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807010349177.png)\n\n\n\n**（2）KMP算法**\n\n若遇到不匹配的，则会跳转到最小公共子串以后的地方进行匹配，会跳过中间不匹配的步骤，从而简化了时间复杂度。但是也都是空间换时间\n\n![image-20200807010427537](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807010427537.png)\n\n\n\n\n\n这块声明一下，暴力法中的每一个字符匹配（连接的黑色剪头）是挨个匹配的，我是写到了一起，其实是很多步的；而KMP是直接跳转到最后一步的，跳过了公共子串的判断，可能是案例比较经典，跳转过来之后，就可以直接排除当前情况了。\n\n**感受玩KMP算法的魅力，现在开始操作起来，接收这愉快的“解题”环节（更像是受虐）。**\n\n\n\n## 4、KMP算法实现：\n\n**KMP算法一般分为两步：**\n\n1. **提取加速匹配的信息（构造next数组），也是本算法中最难的部分。**\n2. **字符串的匹配**\n\n\n\n### 4.1、提取加速匹配的信息（构造next数组）\n\nKMP之所以可以跳过很多公共子串的匹配，是因为它的next数组里面记录了从当前下标位置，往前判断，找到最长公共子串的最后一个位置。\n\n**用数学语言表述：**本文中的**最小公共子串**的概念，不是官方的定义，就自己读起来顺畅。\n\n\n\n对于每模式串 t 的每个元素 t j，都存在一个实数 k ，使得模式串 t0 开头的 k 个字符\n$$\nt_{0} \\quad  t_{1}\\quad  t_{2}  \\cdots  t_{k-1}\n$$\n依次与 t j 前面的 k\n$$\nt_{j-k} \\quad  t_{j-k+1}\\quad  t_{j-k+2}  \\cdots  t_{j-1}\n$$\n，这里第一个字符 t j-k 最多从 t 1 开始，所以 k < j）个字符相同。如果这样的 k 有多个，则取最大的一个。\n\n**图解：**\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/20200529142413882.jpg)\n\n对于元素t5，存在一个实数2，使得模式串t0开头的2个字符 t0 t1，依次与t3和t4相同。\n\n如果在匹配过程中，到t5的时候，和目标串不匹配了，此时就可以模式串回调到t2的位置，接着判断匹配。\n\n因为t0 t1 是最大重复子串，所以就可以跳过判断，直接判断t2和当前目标字符串的字符是否匹配。\n\n**图解：**\n\n![image-20200807010923661](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807010923661.png)\n\n#### **首先，先需要了解一下next数组，存放的是什么东西？**\n\nnext数组其实就是存放着一个回调的位置，意思就是如果我匹配模式串的时候，假如到 t[i] 位置的时候不匹配了，那么我应该跳转到那个位置，接着对比匹配，可以跳过重复子串的判断。\n\n例如上述案例，next[5] = 2\n\n**注意：next数组只和模式串有关系，和目标串没有关系。就算没有目标串，模式串也有next数组。**\n\n如果看到这块，你能够理解next的功能，恭喜你，你已经完成成功路程的一半了。\n\n\n\n#### 下来我们来一起探索一下，next数组应该如何得到？\n\n首先，先拿到我们的模式串：我们的next数组的大小就是模式串pat的长度。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/20200529142440528.jpg)\n\n分为如下三种情况，来计算next的值：\n\n我们用j来遍历模式串pat，初始值为0，用k作为临时变量，初始值为-1，来计算next[j]的值。\n\n我们可以根据上面的理解可以直接写出来，next数组，但是，要怎样设置算法让计算机计算呢？\n\n![image-20200807011031905](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807011031905.png)\n\n**（1）特殊情况：**\n\n当j为0的时候，，next[0] = -1，目的是方便我们后面的计算。\n\n当j为1的时候，pat[0]就是他的最小子串，所以next[1] = 0;\n\n**（2）当 pat[j] == pat[k] 或者 k == -1 的情况:**\n\n说明目前遍历到字符串为首元素，或者就是遍历到的字符和k所指向的位置元素相同，每次都是从字符串串首开始的，所以k的含义，不仅是记录下标位置，还有最长公共子串的长度。\n\n这块的最长公共子串，是自己的定义，意思是pat[0] pat[1]…… pat[k]  字符串和 pat[j-k] pat[j-k+1]…… pat[j] 相同。\n\n![image-20200807011057851](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200807011057851.png)\n\n遇到这种情况，就让`j++，k++，next[j] = k`\n\n这块注意，为什么我们判断的是pat[j] == pat[k]，而要给next[j] = k++，因为我们next里面存放的是遇到不匹配的时候，要回调的位置，因为0到k的位置已经是匹配的了，所以我们直接跳转到k+1的位置，我们就给next[j] = k++。\n\n**（3）其他情况：**也就是k的位置与j的位置不匹配\n\n我们直到如果不匹配的话，就需要调用回调，让k的值回调。我们计算的next数组就是用来回调的。\n\n让 `k = next[k]`\n\n让k回调了之后，再次进入循环，若k的位置与j的位置还是不匹配，那么k就继续回调，直到k=-1，会满足第二种情况，即给next[j] = 0。\n\n\n\n因为逻辑性很强，所以希望参考代码理解。\n\n**代码：**\n\n```java\nvoid Getnext(int next[],String pat)\n{\n    if(pat.length()==0) {\n			next = new int[]{0};\n			return;\n	}\n    next = new int[pat.length()];\n    int j = 0, k = -1;\n    next[0] = -1;\n    while (j < pat.length() - 1) {\n        if (k == -1 || pat.charAt(j) == pat.charAt(k)) {\n            j++;\n            k++;\n            next[j] = k;     \n        } else\n            k = next[k];     //k回调\n    }\n}\n```\n\n\n\n### 4.2 **字符串的匹配**\n\n当我们拿到next数组的时候，后面使用的时候会十分简单！！！\n\n我们用 i 和 j 分别遍历 目标字符串s和模式串pat\n\n我们这次只需要一个单层循环，这也是和暴力法降低时间复杂度最根本的地方。\n\n单层循环：while( i<s.length()&&j<pat.length() )\n\n- 当`s[i] == pat[j]` 时，说明当前的字符匹配，`i++;j++；`\n- 当`s[i] != pat[j]` 时，说明当前的字符不匹配，让j进行回调，即 `j = next[j];`\n\n不满足条件退出循环\n\n- 当`j>=pat.length()`时，说明已经找到模式匹配的子串了，直接return 找到的位置，即`return i-pat.length();`\n- 否则，说明没有找到模式匹配的子串，直接 `return -1;`\n\n\n\n**代码：**\n\n```java\n	public int indexOf(String s)\n	{\n        if(pat.length()==0) {\n			return 0;\n		}\n        int i=0,j=0;\n\n        while(i<s.length()&&j<pat.length())\n        {\n            if(j==-1 || s.charAt(i) == pat.charAt(j))\n            {\n                i++;\n                j++;\n            }\n            else j=next[j];               //j回调\n        }\n        if(j>=pat.length())\n            return (i-pat.length());         //匹配成功，返回子串的位置\n        else\n            return (-1);                  //没找到\n    }\n```\n\n\n\n\n\n## 5、KMP完整代码：\n\n```java\n	void Getnext(int next[], String pat) {\n		next = new int[pat.length()];\n		int j = 0, k = -1;\n		next[0] = -1;\n		while (j < pat.length() - 1) {\n			if (k == -1 || pat.charAt(j) == pat.charAt(k)) {\n				j++;\n				k++;\n				next[j] = k;\n			} else\n				k = next[k]; // k回调\n		}\n	}\n\n	int indexOf(String s) {\n		int i = 0, j = 0;\n\n		while (i < s.length() && j < pat.length()) {\n			if (j == -1 || s.charAt(i) == pat.charAt(j)) {\n				i++;\n				j++;\n			} else\n				j = next[j]; // j回调\n		}\n		if (j >= pat.length())\n			return (i - pat.length()); // 匹配成功，返回子串的位置\n		else\n			return (-1); // 没找到\n	}\n```\n\n\n\n## 6、利用面向对象封装\n\n```java\npackage com.company.project.arithmetic;\n\npublic class KMP {\n\n	private int[] next;\n	private String pat;\n\n	/**\n	 * 在构造方法中计算next数组\n	 * @param pat 模式串\n	 */\n	public KMP(String pat) {\n		this.pat = pat;\n		if(pat.length()==0) {\n			next = new int[]{0};\n			return;\n		}\n		next = new int[pat.length()];\n		int j = 0, k = -1;\n		next[0] = -1;\n		while (j < pat.length() - 1) {\n			if (k == -1 || pat.charAt(j) == pat.charAt(k)) {\n				j++;\n				k++;\n				next[j] = k;\n			} else\n				k = next[k];\n		}\n		\n	}\n\n	/**\n	 * 寻找子串位置\n	 * @param s 目标串\n	 * @return\n	 */\n	public int indexOf(String s) {\n		if(pat.length()==0) {\n			return 0;\n		}\n		int i = 0, j = 0;\n\n		while (i < s.length() && j < pat.length()) {\n			if (j == -1 || s.charAt(i) == pat.charAt(j)) {\n				i++;\n				j++;\n			} else\n				j = next[j]; // j回退。。。\n		}\n		if (j >= pat.length())\n			return (i - pat.length()); // 匹配成功，返回子串的位置\n		else\n			return (-1); // 没找到\n	}\n\n	public static void main(String[] args) {\n		KMP kmp = new KMP(\"\");\n		for (int i = 0; i < kmp.next.length; i++) {\n			System.out.println(kmp.next[i]);\n		}\n		String s = \"abababcabd\";\n		System.out.println(\"result:\" + kmp.indexOf(s));\n	}\n}\n```\n\n', 0, 0, '2020-08-07 01:12:25', 2, 0, 1, '1、KMP算法简介：KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度时间复杂度)O(m+n)。\n2、什么是字符串匹配：给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。\n在Java中就是String的indexOf()方法。\n3、对比暴力法和KMP算法：首先我们可以比对一下暴力法和KMP算法的差距：\n（1）暴力法\n挨个截取遍历字符串，然后对比\n\n（2）KMP算法\n若遇到不匹配的，则会跳转到最小公共子串以后的地方进行匹配，会跳过中间不匹配的步骤，从而简化了时间复杂度。但是也都是空间换时间\n\n这块声明一下，暴力法中的每一个字符匹配（连接的黑色剪头）是挨个匹配的，我是写到了一起，其实是很多步的；而KMP是直接跳转到最后一步的，跳过了公共子串的判断，可能是案例比较经典，跳转过来之后，就可以直接排除当前情况了。\n感受玩KMP算法的魅力，现在开始操作起来，接收这愉快的“解题”环节（更像是受虐）。\n4、KMP算法实现：KMP算法一般分为两步：\n\n提取加速匹配的信息（构造next数组），也是本算法中最难的部分。字符串的匹配\n4.1、提取加速匹配的信息（构造next数组）KMP之所以可以跳过很多公共子串的匹配，是因为它的next数组里面记录了从当前下标位置，往前判断，找到最长公共子串的最后一个位置。\n用数学语言表述：本文中的最小公共子串的概念，不是官方的定义，就自己读起来顺畅。\n对于每模式串 t 的每个元素 t j，都存在一个实数 k ，使得模式串 t0 开头的 k 个字符t{0} \\quad  t{1}\\quad  t{2}  \\cdots  t{k-1}依次与 t j 前面的 kt{j-k} \\quad  t{j-k+1}\\quad  t{j-k+2}  \\cdots  t{j-1}，这里第一个字符 t j-k 最多从 t 1 开始，所以 k < j）个字符相同。如果这样的 k 有多个，则取最大的一个。\n图解：\n\n对于元素t5，存在一个实数2，使得模式串t0开头的2个字符 t0 t1，依次与t3和t4相同。\n如果在匹配过程中，到t5的时候，和目标串不匹配了，此时就可以模式串回调到t2的位置，接着判断匹配。\n因为t0 t1 是最大重复子串，所以就可以跳过判断，直接判断t2和当前目标字符串的字符是否匹配。\n图解：\n\n首先，先需要了解一下next数组，存放的是什么东西？next数组其实就是存放着一个回调的位置，意思就是如果我匹配模式串的时候，假如到 t[i] 位置的时候不匹配了，那么我应该跳转到那个位置，接着对比匹配，可以跳过重复子串的判断。\n例如上述案例，next[5] = 2\n注意：next数组只和模式串有关系，和目标串没有关系。就算没有目标串，模式串也有next数组。\n如果看到这块，你能够理解next的功能，恭喜你，你已经完成成功路程的一半了。\n下来我们来一起探索一下，next数组应该如何得到？首先，先拿到我们的模式串：我们的next数组的大小就是模式串pat的长度。\n\n分为如下三种情况，来计算next的值：\n我们用j来遍历模式串pat，初始值为0，用k作为临时变量，初始值为-1，来计算next[j]的值。\n我们可以根据上面的理解可以直接写出来，next数组，但是，要怎样设置算法让计算机计算呢？\n\n（1）特殊情况：\n当j为0的时候，，next[0] = -1，目的是方便我们后面的计算。\n当j为1的时候，pat[0]就是他的最小子串，所以next[1] = 0;\n（2）当 pat[j] == pat[k] 或者 k == -1 的情况:\n说明目前遍历到字符串为首元素，或者就是遍历到的字符和k所指向的位置元素相同，每次都是从字符串串首开始的，所以k的含义，不仅是记录下标位置，还有最长公共子串的长度。\n这块的最长公共子串，是自己的定义，意思是pat[0] pat[1]…… pat[k]  字符串和 pat[j-k] pat[j-k+1]…… pat[j] 相同。\n\n遇到这种情况，就让j++，k++，next[j] = k\n这块注意，为什么我们判断的是pat[j] == pat[k]，而要给next[j] = k++，因为我们next里面存放的是遇到不匹配的时候，要回调的位置，因为0到k的位置已经是匹配的了，所以我们直接跳转到k+1的位置，我们就给next[j] = k++。\n（3）其他情况：也就是k的位置与j的位置不匹配\n我们直到如果不匹配的话，就需要调用回调，让k的值回调。我们计算的next数组就是用来回调的。\n让 k = next[k]\n让k回调了之后，再次进入循环，若k的位置与j的位置还是不匹配，那么k就继续回调，直到k=-1，会满足第二种情况，即给next[j] = 0。\n因为逻辑性很强，所以希望参考代码理解。\n代码：\nvoid Getnext(int next[],String pat){    if(pat.length()==0) {            next = new int[]{0};            return;    }    next = new int[pat.length()];    int j = 0, k = -1;    next[0] = -1;    while (j < pat.length() - 1) {        if (k == -1 || pat.charAt(j) == pat.charAt(k)) {            j++;            k++;            next[j] = k;             } else            k = next[k];     //k回调    }}\n4.2 字符串的匹配当我们拿到next数组的时候，后面使用的时候会十分简单！！！\n我们用 i 和 j 分别遍历 目标字符串s和模式串pat\n我们这次只需要一个单层循环，这也是和暴力法降低时间复杂度最根本的地方。\n单层循环：while( i<s.length()&&j<pat.length() )\n\n当s[i] == pat[j] 时，说明当前的字符匹配，i++;j++；当s[i] != pat[j] 时，说明当前的字符不匹配，让j进行回调，即 j = next[j];\n不满足条件退出循环\n\n当j>=pat.length()时，说明已经找到模式匹配的子串了，直接return 找到的位置，即return i-pat.length();否则，说明没有找到模式匹配的子串，直接 return -1;\n代码：\n    public int indexOf(String s)    {        if(pat.length()==0) {            return 0;        }        int i=0,j=0;        while(i<s.length()&&j<pat.length())        {            if(j==-1 || s.charAt(i) == pat.charAt(j))            {                i++;                j++;            }            else j=next[j];               //j回调        }        if(j>=pat.length())            return (i-pat.length());         //匹配成功，返回子串的位置        else            return (-1);                  //没找到    }\n5、KMP完整代码：    void Getnext(int next[], String pat) {        next = new int[pat.length()];        int j = 0, k = -1;        next[0] = -1;        while (j < pat.length() - 1) {            if (k == -1 || pat.charAt(j) == pat.charAt(k)) {                j++;                k++;                next[j] = k;            } else                k = next[k]; // k回调        }    }    int indexOf(String s) {        int i = 0, j = 0;        while (i < s.length() && j < pat.length()) {            if (j == -1 || s.charAt(i) == pat.charAt(j)) {                i++;                j++;            } else                j = next[j]; // j回调        }        if (j >= pat.length())            return (i - pat.length()); // 匹配成功，返回子串的位置        else            return (-1); // 没找到    }\n6、利用面向对象封装package com.company.project.arithmetic;public class KMP {    private int[] next;    private String pat;    /**     * 在构造方法中计算next数组     * @param pat 模式串     */    public KMP(String pat) {        this.pat = pat;        if(pat.length()==0) {            next = new int[]{0};            return;        }        next = new int[pat.length()];        int j = 0, k = -1;        next[0] = -1;        while (j < pat.length() - 1) {            if (k == -1 || pat.charAt(j) == pat.charAt(k)) {                j++;                k++;                next[j] = k;            } else                k = next[k];        }    }    /**     * 寻找子串位置     * @param s 目标串     * @return     */    public int indexOf(String s) {        if(pat.length()==0) {            return 0;        }        int i = 0, j = 0;        while (i < s.length() && j < pat.length()) {            if (j == -1 || s.charAt(i) == pat.charAt(j)) {                i++;                j++;            } else                j = next[j]; // j回退。。。        }        if (j >= pat.length())            return (i - pat.length()); // 匹配成功，返回子串的位置        else            return (-1); // 没找到    }    public static void main(String[] args) {        KMP kmp = new KMP(\"\");        for (int i = 0; i < kmp.next.length; i++) {            System.out.println(kmp.next[i]);        }        String s = \"abababcabd\";        System.out.println(\"result:\" + kmp.indexOf(s));    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (138, '01. 数据库概述及数据准备', 8, '\n\n## 1、sql、DB、DBMS分别是什么，他们之间的关系?\n\n（1）DB：\n\n​	DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）\n\n（2）DBMS：	\n\n​	DataBase Management System（数据库管理系统，常见的有：MySQL、Oracle、DB2、Sybase、SqlServer）\n\n（3）SQL：\n\n- 结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。\n- SQL属于高级语言。\n- SQL语句在执行的适合，也是先进行编译，然后再执行sql。（sql语句的编译是由DBMS完成的）。\n\n关系：\n\nDBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。\n\nDBMS（执行） --> SQL（操作）--> DB\n\n## 2、什么是表？\n\n表：table\n\n表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。\n\n一个表包含行和列：\n\n​	行：被称为数据/记录（data）\n\n​	列：被称为字段（column）\n\n每一个字段应该包括那些属性？\n\n​	字段名、数据类型、相关的约束\n\n\n\n## 3、学习通用的sql语句\n\nDQL（数据查询语言）：查询语句，凡是select 语句都是DQL。\n\nDML（数据操作语言）：insert delete update，对表数据进行增删改\n\nDDL（数据定义语言）：create drop alter ，对表结构的增删改\n\nTCL（事务控制语言）：commit 提交事务，rollback回滚事务。（TCL：Transaction）\n\nDCL（数据控制语言）：grant授权、revoke撤销权限等\n\n## 4、导入数据\n\n- 第一步：登录mysql 数据库管理系统\n\n  - dos窗口命令：\n\n    ```\n    mysql> mysql -uroot -p123456\n    ```\n\n- 第二步：查看有那些数据库\n\n  - dos窗口命令：\n\n    ```\n    mysql> show databases;\n    +--------------------+\n    | Database           |\n    +--------------------+\n    | book               |\n    | db_diary           |\n    | information_schema |\n    | mysql              |\n    | performance_schema |\n    | sys                |\n    +--------------------+\n    6 rows in set (0.01 sec)\n    ```\n\n- 第三步：创建属于我们自己的数据库\n\n  - dos窗口命令：\n\n    ```\n    mysql> create database bookshop;\n    ```\n\n- 第四步：使用bookshop数据库数据\n\n  - dos窗口命令：\n\n    ```\n    mysql> use bookshop;\n    ```\n\n- 第五步：导入数据\n\n  - dos窗口命令\n\n    ```sql\n    source bookshop.sql\n    ```\n\n    其中，bookshop.sql为提前准备好的sql语句脚本，脚本内容在文章末尾\n\n- 第五步：查看当前使用的数据库中的那些表？\n\n  - dos窗口命令：\n\n    ```\n    mysql> show tables;\n    +--------------------+\n    | Tables_in_bookshop |\n    +--------------------+\n    | dept               |\n    | emp                |\n    | salgrade           |\n    +--------------------+\n    ```\n\n\n\n## 5、什么是sql脚本？\n\nbookshop.sql ，这个文件是以sql结尾的，这样的文件被称为\"sql脚本\"。\n\n注意：可以直接使用source命令可以执行sql脚本。\n\nsql脚本中数据量太大时，无法打开，请使用source命令完成初始化。\n\n\n\n## 6、删除数据库\n\n```mysql\nmysql> drop database bookshop;\n```\n\n## 7、查看表结构\n\n语法格式：\n\n​	mysql> desc 表名;\n\n```mysql\nmysql> desc dept;\n+--------+-------------+------+-----+---------+-------+\n| Field  | Type        | Null | Key | Default | Extra |\n+--------+-------------+------+-----+---------+-------+\n| DEPTNO | int(2)      | NO   | PRI | NULL    |       |\n| DNAME  | varchar(14) | YES  |     | NULL    |       |\n| LOC    | varchar(13) | YES  |     | NULL    |       |\n+--------+-------------+------+-----+---------+-------+\n\nmysql> desc emp;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| EMPNO    | int(4)      | NO   | PRI | NULL    |       |\n| ENAME    | varchar(10) | YES  |     | NULL    |       |\n| JOB      | varchar(9)  | YES  |     | NULL    |       |\n| MGR      | int(4)      | YES  |     | NULL    |       |\n| HIREDATE | date        | YES  |     | NULL    |       |\n| SAL      | double(7,2) | YES  |     | NULL    |       |\n| COMM     | double(7,2) | YES  |     | NULL    |       |\n| DEPTNO   | int(2)      | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n\nmysql> desc salgrade;\n+-------+---------+------+-----+---------+-------+\n| Field | Type    | Null | Key | Default | Extra |\n+-------+---------+------+-----+---------+-------+\n| GRADE | int(11) | YES  |     | NULL    |       |\n| LOSAL | int(11) | YES  |     | NULL    |       |\n| HISAL | int(11) | YES  |     | NULL    |       |\n+-------+---------+------+-----+---------+-------+\n```\n\n\n\n\n\n## 8、查看表数据\n\n语法格式：\n\n​	mysql> select * from 表名;\n\n```sql\nmysql> select * from dept;\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n+--------+------------+----------+\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n+--------+------------+----------+\n\nmysql> select * from emp;\n+-------+--------+-----------+------+------------+---------+---------+--------+\n| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |\n|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |\n|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |\n|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |\n|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |\n|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |\n|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |\n|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |\n|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |\n|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |\n|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |\n|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |\n|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |\n|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n\nmysql> select * from salgrade;\n+-------+-------+-------+\n| GRADE | LOSAL | HISAL |\n+-------+-------+-------+\n|     1 |   700 |  1200 |\n|     2 |  1201 |  1400 |\n|     3 |  1401 |  2000 |\n|     4 |  2001 |  3000 |\n|     5 |  3001 |  9999 |\n+-------+-------+-------+\n```\n\n\n\n## 9、查询当前使用那个数据库\n\n```\nmysql> select database();\n```\n\n## 10、查看数据库版本\n\n```\nmysql> select version();\n```\n\n## 11、结束一条语句\n\n```\n\\c\n```\n\n## 12、退出Mysql\n\n```\nexit\n```\n\n## 13、查看创建表的语句\n\n```sql\nmysql> show create table emp;\n```\n\n\n\n\n\n**附加：**\n\nbookshop.sql\n\n```sql\nDROP TABLE IF EXISTS EMP;\nDROP TABLE IF EXISTS DEPT;\nDROP TABLE IF EXISTS SALGRADE;\n\nCREATE TABLE DEPT\n       (DEPTNO int(2) not null ,\n	DNAME VARCHAR(14) ,\n	LOC VARCHAR(13),\n	primary key (DEPTNO)\n	);\nCREATE TABLE EMP\n       (EMPNO int(4)  not null ,\n	ENAME VARCHAR(10),\n	JOB VARCHAR(9),\n	MGR INT(4),\n	HIREDATE DATE  DEFAULT NULL,\n	SAL DOUBLE(7,2),\n	COMM DOUBLE(7,2),\n	primary key (EMPNO),\n	DEPTNO INT(2) \n	)\n	;\n\nCREATE TABLE SALGRADE\n      ( GRADE INT,\n	LOSAL INT,\n	HISAL INT );\n\n\nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( \n10, \'ACCOUNTING\', \'NEW YORK\'); \nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( \n20, \'RESEARCH\', \'DALLAS\'); \nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( \n30, \'SALES\', \'CHICAGO\'); \nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( \n40, \'OPERATIONS\', \'BOSTON\'); \ncommit;\n \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7369, \'SMITH\', \'CLERK\', 7902,  \'1980-12-17\'\n, 800, NULL, 20); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7499, \'ALLEN\', \'SALESMAN\', 7698,  \'1981-02-20\'\n, 1600, 300, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7521, \'WARD\', \'SALESMAN\', 7698,  \'1981-02-22\'\n, 1250, 500, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7566, \'JONES\', \'MANAGER\', 7839,  \'1981-04-02\'\n, 2975, NULL, 20); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7654, \'MARTIN\', \'SALESMAN\', 7698,  \'1981-09-28\'\n, 1250, 1400, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7698, \'BLAKE\', \'MANAGER\', 7839,  \'1981-05-01\'\n, 2850, NULL, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7782, \'CLARK\', \'MANAGER\', 7839,  \'1981-06-09\'\n, 2450, NULL, 10); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7788, \'SCOTT\', \'ANALYST\', 7566,  \'1987-04-19\'\n, 3000, NULL, 20); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7839, \'KING\', \'PRESIDENT\', NULL,  \'1981-11-17\'\n, 5000, NULL, 10); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7844, \'TURNER\', \'SALESMAN\', 7698,  \'1981-09-08\'\n, 1500, 0, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7876, \'ADAMS\', \'CLERK\', 7788,  \'1987-05-23\'\n, 1100, NULL, 20); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7900, \'JAMES\', \'CLERK\', 7698,  \'1981-12-03\'\n, 950, NULL, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7902, \'FORD\', \'ANALYST\', 7566,  \'1981-12-03\'\n, 3000, NULL, 20); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7934, \'MILLER\', \'CLERK\', 7782,  \'1982-01-23\'\n, 1300, NULL, 10); \ncommit;\n \nINSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( \n1, 700, 1200); \nINSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( \n2, 1201, 1400); \nINSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( \n3, 1401, 2000); \nINSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( \n4, 2001, 3000); \nINSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( \n5, 3001, 9999); \ncommit;\n```\n\n', 0, 0, '2020-08-07 01:14:39', 2, 0, 1, '1、sql、DB、DBMS分别是什么，他们之间的关系?（1）DB：\n​    DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）\n（2）DBMS：    \n​    DataBase Management System（数据库管理系统，常见的有：MySQL、Oracle、DB2、Sybase、SqlServer）\n（3）SQL：\n\n结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。SQL属于高级语言。SQL语句在执行的适合，也是先进行编译，然后再执行sql。（sql语句的编译是由DBMS完成的）。\n关系：\nDBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。\nDBMS（执行） —> SQL（操作）—> DB\n2、什么是表？表：table\n表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。\n一个表包含行和列：\n​    行：被称为数据/记录（data）\n​    列：被称为字段（column）\n每一个字段应该包括那些属性？\n​    字段名、数据类型、相关的约束\n3、学习通用的sql语句DQL（数据查询语言）：查询语句，凡是select 语句都是DQL。\nDML（数据操作语言）：insert delete update，对表数据进行增删改\nDDL（数据定义语言）：create drop alter ，对表结构的增删改\nTCL（事务控制语言）：commit 提交事务，rollback回滚事务。（TCL：Transaction）\nDCL（数据控制语言）：grant授权、revoke撤销权限等\n4、导入数据\n第一步：登录mysql 数据库管理系统\n\ndos窗口命令：\nmysql> mysql -uroot -p123456\n第二步：查看有那些数据库\n\ndos窗口命令：\nmysql> show databases;+--------------------+| Database           |+--------------------+| book               || db_diary           || information_schema || mysql              || performance_schema || sys                |+--------------------+6 rows in set (0.01 sec)\n第三步：创建属于我们自己的数据库\n\ndos窗口命令：\nmysql> create database bookshop;\n第四步：使用bookshop数据库数据\n\ndos窗口命令：\nmysql> use bookshop;\n第五步：导入数据\n\ndos窗口命令\nsource bookshop.sql\n其中，bookshop.sql为提前准备好的sql语句脚本，脚本内容在文章末尾\n\n第五步：查看当前使用的数据库中的那些表？\n\ndos窗口命令：\nmysql> show tables;+--------------------+| Tables_in_bookshop |+--------------------+| dept               || emp                || salgrade           |+--------------------+\n\n5、什么是sql脚本？bookshop.sql ，这个文件是以sql结尾的，这样的文件被称为”sql脚本”。\n注意：可以直接使用source命令可以执行sql脚本。\nsql脚本中数据量太大时，无法打开，请使用source命令完成初始化。\n6、删除数据库mysql> drop database bookshop;\n7、查看表结构语法格式：\n​    mysql> desc 表名;\nmysql> desc dept;+--------+-------------+------+-----+---------+-------+| Field  | Type        | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| DEPTNO | int(2)      | NO   | PRI | NULL    |       || DNAME  | varchar(14) | YES  |     | NULL    |       || LOC    | varchar(13) | YES  |     | NULL    |       |+--------+-------------+------+-----+---------+-------+mysql> desc emp;+----------+-------------+------+-----+---------+-------+| Field    | Type        | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| EMPNO    | int(4)      | NO   | PRI | NULL    |       || ENAME    | varchar(10) | YES  |     | NULL    |       || JOB      | varchar(9)  | YES  |     | NULL    |       || MGR      | int(4)      | YES  |     | NULL    |       || HIREDATE | date        | YES  |     | NULL    |       || SAL      | double(7,2) | YES  |     | NULL    |       || COMM     | double(7,2) | YES  |     | NULL    |       || DEPTNO   | int(2)      | YES  |     | NULL    |       |+----------+-------------+------+-----+---------+-------+mysql> desc salgrade;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| GRADE | int(11) | YES  |     | NULL    |       || LOSAL | int(11) | YES  |     | NULL    |       || HISAL | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+\n8、查看表数据语法格式：\n​    mysql> select * from 表名;\nmysql> select * from dept;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+mysql> select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+mysql> select * from salgrade;+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+|     1 |   700 |  1200 ||     2 |  1201 |  1400 ||     3 |  1401 |  2000 ||     4 |  2001 |  3000 ||     5 |  3001 |  9999 |+-------+-------+-------+\n9、查询当前使用那个数据库mysql> select database();10、查看数据库版本mysql> select version();11、结束一条语句\\c12、退出Mysqlexit13、查看创建表的语句mysql> show create table emp;\n附加：\nbookshop.sql\nDROP TABLE IF EXISTS EMP;DROP TABLE IF EXISTS DEPT;DROP TABLE IF EXISTS SALGRADE;CREATE TABLE DEPT       (DEPTNO int(2) not null ,    DNAME VARCHAR(14) ,    LOC VARCHAR(13),    primary key (DEPTNO)    );CREATE TABLE EMP       (EMPNO int(4)  not null ,    ENAME VARCHAR(10),    JOB VARCHAR(9),    MGR INT(4),    HIREDATE DATE  DEFAULT NULL,    SAL DOUBLE(7,2),    COMM DOUBLE(7,2),    primary key (EMPNO),    DEPTNO INT(2)     )    ;CREATE TABLE SALGRADE      ( GRADE INT,    LOSAL INT,    HISAL INT );INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 10, \'ACCOUNTING\', \'NEW YORK\'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 20, \'RESEARCH\', \'DALLAS\'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 30, \'SALES\', \'CHICAGO\'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 40, \'OPERATIONS\', \'BOSTON\'); commit;INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7369, \'SMITH\', \'CLERK\', 7902,  \'1980-12-17\', 800, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7499, \'ALLEN\', \'SALESMAN\', 7698,  \'1981-02-20\', 1600, 300, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7521, \'WARD\', \'SALESMAN\', 7698,  \'1981-02-22\', 1250, 500, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7566, \'JONES\', \'MANAGER\', 7839,  \'1981-04-02\', 2975, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7654, \'MARTIN\', \'SALESMAN\', 7698,  \'1981-09-28\', 1250, 1400, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7698, \'BLAKE\', \'MANAGER\', 7839,  \'1981-05-01\', 2850, NULL, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7782, \'CLARK\', \'MANAGER\', 7839,  \'1981-06-09\', 2450, NULL, 10); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7788, \'SCOTT\', \'ANALYST\', 7566,  \'1987-04-19\', 3000, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7839, \'KING\', \'PRESIDENT\', NULL,  \'1981-11-17\', 5000, NULL, 10); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7844, \'TURNER\', \'SALESMAN\', 7698,  \'1981-09-08\', 1500, 0, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7876, \'ADAMS\', \'CLERK\', 7788,  \'1987-05-23\', 1100, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7900, \'JAMES\', \'CLERK\', 7698,  \'1981-12-03\', 950, NULL, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7902, \'FORD\', \'ANALYST\', 7566,  \'1981-12-03\', 3000, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7934, \'MILLER\', \'CLERK\', 7782,  \'1982-01-23\', 1300, NULL, 10); commit;INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 1, 700, 1200); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 2, 1201, 1400); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 3, 1401, 2000); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 4, 2001, 3000); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 5, 3001, 9999); commit;\n', 0, 1);
INSERT INTO `t_article` VALUES (139, '02、数据查询（DQL）', 8, '\n\n## 1、简单的查询\n\n语法格式：\n\n（1）查询单个字段：\n\n​	select 字段名 from 表名;\n\n（2）查询多个字段：\n\n​	select 字段名1,字段名2,字段名3,…… from 表名;\n\n（3）查询所有字段：\n\n​	select * from 表名;\n\n提示：\n\n- 任何一条sql语句都要以\";\"结尾\n- sql语句不区分大小写\n\n\n\n案例：查询员工年薪？（月薪*12）\n\n字段可以参与数学运算\n\n```sql\nselect ename,sal*12 from emp;\n```\n\n```sql\n+--------+----------+\n| ename  | sal*12   |\n+--------+----------+\n| SMITH  |  9600.00 |\n| ALLEN  | 19200.00 |\n| WARD   | 15000.00 |\n| JONES  | 35700.00 |\n| MARTIN | 15000.00 |\n| BLAKE  | 34200.00 |\n| CLARK  | 29400.00 |\n| SCOTT  | 36000.00 |\n| KING   | 60000.00 |\n| TURNER | 18000.00 |\n| ADAMS  | 13200.00 |\n| JAMES  | 11400.00 |\n| FORD   | 36000.00 |\n| MILLER | 15600.00 |\n+--------+----------+\n14 rows in set (0.00 sec)\n```\n\n**给查询结果的列重命名**\n\n```sql\nselect ename,sal*12 as \'年薪\' from emp;\n```\n\n```sql\n+--------+----------+\n| ename  | 年薪     |\n+--------+----------+\n| SMITH  |  9600.00 |\n| ALLEN  | 19200.00 |\n| WARD   | 15000.00 |\n| JONES  | 35700.00 |\n| MARTIN | 15000.00 |\n| BLAKE  | 34200.00 |\n| CLARK  | 29400.00 |\n| SCOTT  | 36000.00 |\n| KING   | 60000.00 |\n| TURNER | 18000.00 |\n| ADAMS  | 13200.00 |\n| JAMES  | 11400.00 |\n| FORD   | 36000.00 |\n| MILLER | 15600.00 |\n+--------+----------+\n```\n\n注意：\n\n- 标准sql语句中要求字符串使用单引号括起来，虽然mysql数据库支持双引号，但是不建议使用，因为不通用。\n- as关键字可以省略\n\n\n\n## 2、条件查询\n\n语法格式：\n\n​	select 字段名1,字段名2,字段名3,…… from 表名 where 条件;\n\n执行顺序：\n\n​	先from ，然后where，最后select\n\n| 运算符          | 说明                                        |\n| --------------- | ------------------------------------------- |\n| =               | 等于                                        |\n| <> 或 !=        | 不等于                                      |\n| <               | 小于                                        |\n| <=              | 小于等于                                    |\n| >               | 大于                                        |\n| >=              | 大于等于                                    |\n| between … and … | 两个值之间，等同于>= and <=                 |\n| is null         | 为 null（is not null 不为空）               |\n| and             | 并且                                        |\n| or              | 或者                                        |\n| in              | 包含，相当于多个or（not in 不在这个范围中） |\n| not             | not 可以取非，主要用于is 或 in中。          |\n| like            | like 模糊查询，支持%或下划线匹配            |\n\n\n\n（1）查询工资等于5000的员工姓名？\n\n```sql\nmysql> select ename from emp where sal = 5000;\n+-------+\n| ename |\n+-------+\n| KING  |\n+-------+\n```\n\n（2）查询员工MARTIN的工资？\n\n```sql\nmysql> select ename,sal from emp where ename=\'MARTIN\';\n+--------+---------+\n| ename  | sal     |\n+--------+---------+\n| MARTIN | 1250.00 |\n+--------+---------+\n```\n\n（3）查询工资大于等于3000的员工？\n\n```sql\nmysql> select ename,sal from emp where sal >= 3000;\n+-------+---------+\n| ename | sal     |\n+-------+---------+\n| SCOTT | 3000.00 |\n| KING  | 5000.00 |\n| FORD  | 3000.00 |\n+-------+---------+\n```\n\n（4）查询工资不等于3000的员工？\n\n```sql\nmysql> select ename,sal from emp where sal <> 3000;\n+--------+---------+\n| ename  | sal     |\n+--------+---------+\n| SMITH  |  800.00 |\n| ALLEN  | 1600.00 |\n| WARD   | 1250.00 |\n| JONES  | 2975.00 |\n| MARTIN | 1250.00 |\n| BLAKE  | 2850.00 |\n| CLARK  | 2450.00 |\n| KING   | 5000.00 |\n| TURNER | 1500.00 |\n| ADAMS  | 1100.00 |\n| JAMES  |  950.00 |\n| MILLER | 1300.00 |\n+--------+---------+\n```\n\n（5）查询工资在1100到3000之间的员工？\n\n```sql\nmysql> select ename,sal from emp where sal >=1100 and sal <= 3000;\n+--------+---------+\n| ename  | sal     |\n+--------+---------+\n| ALLEN  | 1600.00 |\n| WARD   | 1250.00 |\n| JONES  | 2975.00 |\n| MARTIN | 1250.00 |\n| BLAKE  | 2850.00 |\n| CLARK  | 2450.00 |\n| SCOTT  | 3000.00 |\n| TURNER | 1500.00 |\n| ADAMS  | 1100.00 |\n| FORD   | 3000.00 |\n| MILLER | 1300.00 |\n+--------+---------+\n\n或者：\nmysql> select ename,sal from emp where sal between 1100 and 3000;\n```\n\n（6）查询名字是首字母A到C开头的员工，其中不包括C开头，只包括名字为C的员工\n\n```sql\nmysql> select ename,sal from emp where ename between \'a\' and \'c\';\n+-------+---------+\n| ename | sal     |\n+-------+---------+\n| ALLEN | 1600.00 |\n| BLAKE | 2850.00 |\n| ADAMS | 1100.00 |\n+-------+---------+\n```\n\n（7）查询那些人没有津贴？\n\n```sql\nmysql> select ename,sal,comm  from emp where comm is null or comm = 0;\n+--------+---------+------+\n| ename  | sal     | comm |\n+--------+---------+------+\n| SMITH  |  800.00 | NULL |\n| JONES  | 2975.00 | NULL |\n| BLAKE  | 2850.00 | NULL |\n| CLARK  | 2450.00 | NULL |\n| SCOTT  | 3000.00 | NULL |\n| KING   | 5000.00 | NULL |\n| TURNER | 1500.00 | 0.00 |\n| ADAMS  | 1100.00 | NULL |\n| JAMES  |  950.00 | NULL |\n| FORD   | 3000.00 | NULL |\n| MILLER | 1300.00 | NULL |\n+--------+---------+------+\n```\n\n（8）查询那些人有津贴\n\n```sql\nmysql> select ename,sal,comm  from emp where comm is not null and comm != 0;\n+--------+---------+---------+\n| ename  | sal     | comm    |\n+--------+---------+---------+\n| ALLEN  | 1600.00 |  300.00 |\n| WARD   | 1250.00 |  500.00 |\n| MARTIN | 1250.00 | 1400.00 |\n+--------+---------+---------+\n```\n\n（9）查询工作岗位为SALESMAN和MANAGER的员工\n\n```sql\nmysql> select ename,job from emp where job =\'SALESMAN\' or job=\'MANAGER\';\n+--------+----------+\n| ename  | job      |\n+--------+----------+\n| ALLEN  | SALESMAN |\n| WARD   | SALESMAN |\n| JONES  | MANAGER  |\n| MARTIN | SALESMAN |\n| BLAKE  | MANAGER  |\n| CLARK  | MANAGER  |\n| TURNER | SALESMAN |\n+--------+----------+\n```\n\n（10）查询薪资大于1000并且部门编号为20或30的员工\n\n```sql\nmysql> select ename,sal,DEPTNO from emp where sal > 1000 and (deptno = 20 or deptno = 30);\n+--------+---------+--------+\n| ename  | sal     | DEPTNO |\n+--------+---------+--------+\n| ALLEN  | 1600.00 |     30 |\n| WARD   | 1250.00 |     30 |\n| JONES  | 2975.00 |     20 |\n| MARTIN | 1250.00 |     30 |\n| BLAKE  | 2850.00 |     30 |\n| SCOTT  | 3000.00 |     20 |\n| TURNER | 1500.00 |     30 |\n| ADAMS  | 1100.00 |     20 |\n| FORD   | 3000.00 |     20 |\n+--------+---------+--------+\n```\n\n（11）查询部门编号为20或30的员工姓名\n\n```sql\nmysql> select ename,DEPTNO from emp where deptno in (20,30);\n+--------+--------+\n| ename  | DEPTNO |\n+--------+--------+\n| SMITH  |     20 |\n| ALLEN  |     30 |\n| WARD   |     30 |\n| JONES  |     20 |\n| MARTIN |     30 |\n| BLAKE  |     30 |\n| SCOTT  |     20 |\n| TURNER |     30 |\n| ADAMS  |     20 |\n| JAMES  |     30 |\n| FORD   |     20 |\n+--------+--------+\n```\n\n（13）查询名字为A开头的员工\n\n```sql\nmysql> select empno,ename from emp where ename like \'a%\';\n```\n\n（14）查询名字中含有A的员工\n\n```sql\nmysql> select empno,ename from emp where ename like \'%a%\';\n+-------+--------+\n| empno | ename  |\n+-------+--------+\n|  7499 | ALLEN  |\n|  7521 | WARD   |\n|  7654 | MARTIN |\n|  7698 | BLAKE  |\n|  7782 | CLARK  |\n|  7876 | ADAMS  |\n|  7900 | JAMES  |\n+-------+--------+\n```\n\n（16）查询名字第二位为a的员工\n\n```sql\nmysql> select empno,ename from emp where ename like \'_a%\';\n+-------+--------+\n| empno | ename  |\n+-------+--------+\n|  7521 | WARD   |\n|  7654 | MARTIN |\n|  7900 | JAMES  |\n+-------+--------+\n```\n\n（15）查询名字中含有下划线的员工\n\n```sql\nmysql> select empno,ename from emp where ename like \'%\\_%\';\n```\n\n注意：\n\n- 字符串应该用单引号括起来\n- 不等号：<> 或 !=\n- between and 是闭区间，包括边界。\n- between and 使用的时候，必须左小右大\n- between and 除了可以使用在数字，也可以使用在字符串，左闭右开\n- 数据库中null代表为空，不是一个值，不能用等号衡量，只能使用is null或者is not null\n- 当and和or一起使用的时候，and的优先级大于or的优先级\n- in等用于or\n- %代表0个或多个任意字符，_代表一个任意字符\n- \\ _ 为转义，表示 正常的下划线\n\n\n\n## 3、排序查询\n\n| 表达式 | 说明 |\n| ------ | ---- |\n| asc    | 升序 |\n| desc   | 降序 |\n\n按照工资升序排列员工表\n\n```sql\nmysql> select empno,sal from emp order by sal;\n或者\nmysql> select empno,sal from emp order by sal asc;\n+-------+---------+\n| empno | sal     |\n+-------+---------+\n|  7369 |  800.00 |\n|  7900 |  950.00 |\n|  7876 | 1100.00 |\n|  7521 | 1250.00 |\n|  7654 | 1250.00 |\n|  7934 | 1300.00 |\n|  7844 | 1500.00 |\n|  7499 | 1600.00 |\n|  7782 | 2450.00 |\n|  7698 | 2850.00 |\n|  7566 | 2975.00 |\n|  7788 | 3000.00 |\n|  7902 | 3000.00 |\n|  7839 | 5000.00 |\n+-------+---------+\n```\n\n按照工资升序排列员工表，当工资一样的时候按照名字的降序排列\n\n```sql\nmysql> select empno,ename,sal from emp order by sal asc ,ename  desc;\n+-------+--------+---------+\n| empno | ename  | sal     |\n+-------+--------+---------+\n|  7369 | SMITH  |  800.00 |\n|  7900 | JAMES  |  950.00 |\n|  7876 | ADAMS  | 1100.00 |\n|  7521 | WARD   | 1250.00 |\n|  7654 | MARTIN | 1250.00 |\n|  7934 | MILLER | 1300.00 |\n|  7844 | TURNER | 1500.00 |\n|  7499 | ALLEN  | 1600.00 |\n|  7782 | CLARK  | 2450.00 |\n|  7698 | BLAKE  | 2850.00 |\n|  7566 | JONES  | 2975.00 |\n|  7788 | SCOTT  | 3000.00 |\n|  7902 | FORD   | 3000.00 |\n|  7839 | KING   | 5000.00 |\n+-------+--------+---------+\n```\n\n找出工作岗位是SALESMAN的员工，并且按照薪资的降序排列\n\n```sql\nmysql> select empno,ename,job,sal from emp where job=\'SALESMAN\' order by sal desc;\n+-------+--------+----------+---------+\n| empno | ename  | job      | sal     |\n+-------+--------+----------+---------+\n|  7499 | ALLEN  | SALESMAN | 1600.00 |\n|  7844 | TURNER | SALESMAN | 1500.00 |\n|  7521 | WARD   | SALESMAN | 1250.00 |\n|  7654 | MARTIN | SALESMAN | 1250.00 |\n+-------+--------+----------+---------+\n```\n\n注意：\n\n- 默认为升序排列\n- 靠前的字段起主导作用\n- order by 数字，表示使用第几列排序\n\n\n\n## 4、分组函数\n\n| 表达式 | 含义   |\n| ------ | ------ |\n| count  | 计数   |\n| sum    | 求和   |\n| avg    | 平均值 |\n| max    | 最大值 |\n| min    | 最小值 |\n\n注意：\n\n- 所有的分组函数都是对”某一组“进行操作的。\n- 分组函数还有一个名字叫多行处理函数\n- 分组函数自动忽略空\n- 分组函数不可以用在where子句当中，原因：因为group by 在where之后运行，而分组函数在group by 之后执行。\n- count (*)：不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关）\n- count(字段)：统计字段不为null的总数量\n\n语句执行顺序\n\n```sql\nselect 		5\n..	\nfrom 		1\n..\nwhere		2\n..\ngroup by	3\n..\nhaving		4\n..\norder by 	6\n..\n```\n\n查询工资总和\n\n```sql\nmysql> select sum(sal) from emp;\n+----------+\n| sum(sal) |\n+----------+\n| 29025.00 |\n+----------+\n```\n\n查询最高工资\n\n```sql\nmysql> select max(sal) from emp;\n+----------+\n| max(sal) |\n+----------+\n|  5000.00 |\n+----------+\n```\n\n查询最低工资\n\n```sql\nmysql> select min(sal) from emp;\n+----------+\n| min(sal) |\n+----------+\n|   800.00 |\n+----------+\n```\n\n查询平均工资\n\n```sql\nmysql> select avg(sal) from emp;\n+-------------+\n| avg(sal)    |\n+-------------+\n| 2073.214286 |\n+-------------+\n```\n\n查询总人数\n\n```sql\nmysql> select count(ename) from emp;\n+--------------+\n| count(ename) |\n+--------------+\n|           14 |\n+--------------+\n```\n\n查询拥有奖金的人数\n\n```sql\nmysql> select count(comm) from emp;\n+-------------+\n| count(comm) |\n+-------------+\n|           4 |\n+-------------+\n```\n\n查询公司应该分发的工资总和（分组函数自动忽略null，若没有忽略的话，得到的结果应该为null）\n\n```sql\nmysql> select sum(comm) from emp;\n+-----------+\n| sum(comm) |\n+-----------+\n|   2200.00 |\n+-----------+\n```\n\n找出高出平均工资的员工（子查询）\n\n```sql\nmysql> select ename,sal from emp where sal > (select avg(sal) from emp);\n+-------+---------+\n| ename | sal     |\n+-------+---------+\n| JONES | 2975.00 |\n| BLAKE | 2850.00 |\n| CLARK | 2450.00 |\n| SCOTT | 3000.00 |\n| KING  | 5000.00 |\n| FORD  | 3000.00 |\n+-------+---------+\n```\n\n\n\n## **5、单行处理函数**\n\n| 表达式                               | 含义                                         |\n| ------------------------------------ | -------------------------------------------- |\n| ifnull(可能为null的数据，要替换的值) | 空处理函数，若值为null，则用另一个值进行替换 |\n\n计算每个员工的年薪（若数学表达式中有null，那么结果一定为null）\n\n```sql\nmysql> select ename,(sal + ifnull(comm,0))*12 as yearsal from emp;\n+--------+----------+\n| ename  | yearsal  |\n+--------+----------+\n| SMITH  |  9600.00 |\n| ALLEN  | 22800.00 |\n| WARD   | 21000.00 |\n| JONES  | 35700.00 |\n| MARTIN | 31800.00 |\n| BLAKE  | 34200.00 |\n| CLARK  | 29400.00 |\n| SCOTT  | 36000.00 |\n| KING   | 60000.00 |\n| TURNER | 18000.00 |\n| ADAMS  | 13200.00 |\n| JAMES  | 11400.00 |\n| FORD   | 36000.00 |\n| MILLER | 15600.00 |\n+--------+----------+\n```\n\n## 6、分组查询\n\n| 表达式   | 含义                             |\n| -------- | -------------------------------- |\n| group by | 按照某个字段或者某些字段进行分组 |\n| having   | 对分组之后的数据进行再次过滤     |\n\n（1）找出每个岗位的最高薪资\n\n```sql\nmysql> select job,max(sal) from emp group by job;\n+-----------+----------+\n| job       | max(sal) |\n+-----------+----------+\n| CLERK     |  1300.00 |\n| SALESMAN  |  1600.00 |\n| MANAGER   |  2975.00 |\n| ANALYST   |  3000.00 |\n| PRESIDENT |  5000.00 |\n+-----------+----------+\n```\n\n（2）每个工作岗位的平均工资\n\n```sql\nmysql>  select job,avg(sal) from emp group by job;\n+-----------+-------------+\n| job       | avg(sal)    |\n+-----------+-------------+\n| CLERK     | 1037.500000 |\n| SALESMAN  | 1400.000000 |\n| MANAGER   | 2758.333333 |\n| ANALYST   | 3000.000000 |\n| PRESIDENT | 5000.000000 |\n+-----------+-------------+\n```\n\n（3）找出每个部门不同工作岗位的最高新资\n\n```sql\nmysql> select deptno,job,max(sal) from emp group by deptno,job order by deptno;\n+--------+-----------+----------+\n| deptno | job       | max(sal) |\n+--------+-----------+----------+\n|     10 | CLERK     |  1300.00 |\n|     10 | MANAGER   |  2450.00 |\n|     10 | PRESIDENT |  5000.00 |\n|     20 | ANALYST   |  3000.00 |\n|     20 | CLERK     |  1100.00 |\n|     20 | MANAGER   |  2975.00 |\n|     30 | CLERK     |   950.00 |\n|     30 | MANAGER   |  2850.00 |\n|     30 | SALESMAN  |  1600.00 |\n+--------+-----------+----------+\n```\n\n（4）找出每个部门的最高薪资，要求显示薪资大于2900的数据\n\n```sql\n第一步：找出每个部门的最高薪资\nmysql> select deptno ,max(sal) from emp group by deptno;\n+--------+----------+\n| deptno | max(sal) |\n+--------+----------+\n|     20 |  3000.00 |\n|     30 |  2850.00 |\n|     10 |  5000.00 |\n+--------+----------+\n第二步：薪资大于2900的\nmysql> select deptno ,max(sal) from emp group by deptno having max(sal)>2900; //效率比较低\n+--------+----------+\n| deptno | max(sal) |\n+--------+----------+\n|     20 |  3000.00 |\n|     10 |  5000.00 |\n+--------+----------+\n\n最佳写法：\nmysql> select deptno ,max(sal) from emp where sal > 2900 group by deptno;\n+--------+----------+\n| deptno | max(sal) |\n+--------+----------+\n|     20 |  3000.00 |\n|     10 |  5000.00 |\n+--------+----------+\n```\n\n（5）找出每个部门的平均薪资，要求显示薪资大于2900的数据\n\n```sql\n第一步：找出每个部门的平均薪资\nmysql> select deptno ,avg(sal) from emp group by deptno;\n+--------+-------------+\n| deptno | avg(sal)    |\n+--------+-------------+\n|     20 | 2175.000000 |\n|     30 | 1566.666667 |\n|     10 | 2916.666667 |\n+--------+-------------+\n第二步：平均薪资大于2000的\nmysql> select deptno ,avg(sal) from emp group by deptno having avg(sal)>2000;\n+--------+-------------+\n| deptno | avg(sal)    |\n+--------+-------------+\n|     20 | 2175.000000 |\n|     10 | 2916.666667 |\n+--------+-------------+\n```\n\n\n\n注意：\n\n- 分组函数一般都会和group by一起使用\n- 分组函数会在group by之后执行。\n- 当一条sql语句中没有froup by 的时候，整张表会自动成为一组\n- 当sql语句中用group by的时候，select后面只能跟group by后面的列或者分组函数\n- 在mysql中，select后面可以跟不是group by后面的列的列，但是没有意义，在Oracle数据库中直接报错\n\n\n\n总结：\n\n一个完整的DQL语句怎么写？\n\n```sql\nselect 		5\n..\nfrom		1\n..\nwhere		2\n..\ngroup by	3\n..\nhaving		4\n..\norder by	6\n..\n```\n\n\n\n## 7、结果去重\n\n关于查询的结果如何去重？\n\n在所有字段的前面加上关键字distinct\n\n会把select所有字段作为一列进行去重\n\n```sql\nmysql> select distinct job from emp;\n+-----------+\n| job       |\n+-----------+\n| CLERK     |\n| SALESMAN  |\n| MANAGER   |\n| ANALYST   |\n| PRESIDENT |\n+-----------+\n```\n\n查询每个部门都有那些工作岗位\n\n```sql\nmysql> select distinct deptno, job from emp order by deptno;\n+--------+-----------+\n| deptno | job       |\n+--------+-----------+\n|     10 | CLERK     |\n|     10 | MANAGER   |\n|     10 | PRESIDENT |\n|     20 | ANALYST   |\n|     20 | CLERK     |\n|     20 | MANAGER   |\n|     30 | CLERK     |\n|     30 | MANAGER   |\n|     30 | SALESMAN  |\n+--------+-----------+\n```\n\n\n\n## 8、连接查询\n\n### **8.1 什么是连接查询？**\n\n在实际开发中，大部分情况都不是在单张表中进行查询，而是在多张表联合查询出结果。\n\n把一张表的结果作为另一张表的数据进行查询。\n\n### 8.2 连接查询的分类\n\n根据语法出现的年代来划分：\n\n- SQL92（一些老的DBA可能还在使用，DBA：DataBase Administrator，数据库管理员）\n- SQL99（比较新的语法）\n\n根据表的连接方式来划分，包括：\n\n- 内连接\n  - 等值连接\n  - 非等值连接\n  - 自连接\n- 外连接\n  - 左外连接（左连接）\n  - 右外连接（右连接）\n- 全连接（基本上用不到）\n\n### 8.3 笛卡尔积现象\n\n如果两张表进行连接查询，没有任何条件的话，得到的结果是两张表结果的乘积。\n\n```sql\nmysql> select ename,dname from emp,dept;      //两张表自连接得到了笛卡尔积\n+--------+------------+\n| ename  | dname      |\n+--------+------------+\n| SMITH  | ACCOUNTING |\n| SMITH  | RESEARCH   |\n| SMITH  | SALES      |\n| SMITH  | OPERATIONS |\n| ALLEN  | ACCOUNTING |\n| ALLEN  | RESEARCH   |\n| ALLEN  | SALES      |\n| ALLEN  | OPERATIONS |\n| WARD   | ACCOUNTING |\n| WARD   | RESEARCH   |\n| WARD   | SALES      |\n| WARD   | OPERATIONS |\n| JONES  | ACCOUNTING |\n| JONES  | RESEARCH   |\n| JONES  | SALES      |\n| JONES  | OPERATIONS |\n| MARTIN | ACCOUNTING |\n| MARTIN | RESEARCH   |\n| MARTIN | SALES      |\n| MARTIN | OPERATIONS |\n| BLAKE  | ACCOUNTING |\n| BLAKE  | RESEARCH   |\n| BLAKE  | SALES      |\n| BLAKE  | OPERATIONS |\n| CLARK  | ACCOUNTING |\n| CLARK  | RESEARCH   |\n| CLARK  | SALES      |\n| CLARK  | OPERATIONS |\n| SCOTT  | ACCOUNTING |\n| SCOTT  | RESEARCH   |\n| SCOTT  | SALES      |\n| SCOTT  | OPERATIONS |\n| KING   | ACCOUNTING |\n| KING   | RESEARCH   |\n| KING   | SALES      |\n| KING   | OPERATIONS |\n| TURNER | ACCOUNTING |\n| TURNER | RESEARCH   |\n| TURNER | SALES      |\n| TURNER | OPERATIONS |\n| ADAMS  | ACCOUNTING |\n| ADAMS  | RESEARCH   |\n| ADAMS  | SALES      |\n| ADAMS  | OPERATIONS |\n| JAMES  | ACCOUNTING |\n| JAMES  | RESEARCH   |\n| JAMES  | SALES      |\n| JAMES  | OPERATIONS |\n| FORD   | ACCOUNTING |\n| FORD   | RESEARCH   |\n| FORD   | SALES      |\n| FORD   | OPERATIONS |\n| MILLER | ACCOUNTING |\n| MILLER | RESEARCH   |\n| MILLER | SALES      |\n| MILLER | OPERATIONS |\n+--------+------------+\n```\n\n**如何避免笛卡尔积现象？**\n\n​	加条件过滤\n\n**避免笛卡尔积现象，就减少匹配次数吗？**\n\n​	不会，不会减少显示的有效记录，匹配次数还是之前的。\n\n\n\n**案例：找出每一个员工的部门名称，要求显示员工名和部门名**\n\n```\nmysql> select ename,dname from emp e,dept d where e.DEPTNO = d.deptno; //这是正确的写法\n+--------+------------+\n| ename  | dname      |\n+--------+------------+\n| SMITH  | RESEARCH   |\n| ALLEN  | SALES      |\n| WARD   | SALES      |\n| JONES  | RESEARCH   |\n| MARTIN | SALES      |\n| BLAKE  | SALES      |\n| CLARK  | ACCOUNTING |\n| SCOTT  | RESEARCH   |\n| KING   | ACCOUNTING |\n| TURNER | SALES      |\n| ADAMS  | RESEARCH   |\n| JAMES  | SALES      |\n| FORD   | RESEARCH   |\n| MILLER | ACCOUNTING |\n+--------+------------+\n```\n\n### 8.4 内连接\n\n什么是内连接？\n\n​	假设A和B进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接\n\n​	AB两张表没有主副之分，两种表是平等的。\n\n#### 8.4.1 内连接之等值连接\n\n最大特点：等值关系\n\n案例：查询每个员工的部门名称，要求显示员工名和部门名\n\nSQL92：（太老了，不用了）\n\n```sql\nmysql> select ename,dname from emp e,dept d where e.deptno = d.deptno;\n+--------+------------+\n| ename  | dname      |\n+--------+------------+\n| SMITH  | RESEARCH   |\n| ALLEN  | SALES      |\n| WARD   | SALES      |\n| JONES  | RESEARCH   |\n| MARTIN | SALES      |\n| BLAKE  | SALES      |\n| CLARK  | ACCOUNTING |\n| SCOTT  | RESEARCH   |\n| KING   | ACCOUNTING |\n| TURNER | SALES      |\n| ADAMS  | RESEARCH   |\n| JAMES  | SALES      |\n| FORD   | RESEARCH   |\n| MILLER | ACCOUNTING |\n+--------+------------+\n```\n\nSQL99：（常用）\n\n```sql\nmysql> select ename,dname from emp e inner join dept d on e.DEPTNO = d.deptno;\n+--------+------------+\n| ename  | dname      |\n+--------+------------+\n| SMITH  | RESEARCH   |\n| ALLEN  | SALES      |\n| WARD   | SALES      |\n| JONES  | RESEARCH   |\n| MARTIN | SALES      |\n| BLAKE  | SALES      |\n| CLARK  | ACCOUNTING |\n| SCOTT  | RESEARCH   |\n| KING   | ACCOUNTING |\n| TURNER | SALES      |\n| ADAMS  | RESEARCH   |\n| JAMES  | SALES      |\n| FORD   | RESEARCH   |\n| MILLER | ACCOUNTING |\n+--------+------------+\n```\n\n语法：\n\n```sql\nselect\n	..\nfrom\n	A表\ninner join         //inner可以省略\n	B表\non\n	连接条件\nwhere\n	过滤条件\n```\n\n\n\nSQL92 的缺点：\n\n​	把表的连接条件和where过滤添加写到一起了。\n\nSQL99的优点：\n\n​	把表的连接条件和where过滤添加分离了。\n\n\n\n#### 8.4.2 内连接之非等值连接\n\n最大特点：连接条件为非等值关系\n\n案例：找出每个员工的工资等级，要求显示员工名称、工资、工资等级\n\n```sql\nmysql> select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal>=s.losal and e.sal<=hisal;\n+--------+---------+-------+\n| ename  | sal     | grade |\n+--------+---------+-------+\n| SMITH  |  800.00 |     1 |\n| ALLEN  | 1600.00 |     3 |\n| WARD   | 1250.00 |     2 |\n| JONES  | 2975.00 |     4 |\n| MARTIN | 1250.00 |     2 |\n| BLAKE  | 2850.00 |     4 |\n| CLARK  | 2450.00 |     4 |\n| SCOTT  | 3000.00 |     4 |\n| KING   | 5000.00 |     5 |\n| TURNER | 1500.00 |     3 |\n| ADAMS  | 1100.00 |     1 |\n| JAMES  |  950.00 |     1 |\n| FORD   | 3000.00 |     4 |\n| MILLER | 1300.00 |     2 |\n+--------+---------+-------+\n```\n\n语法：\n\n```sql\nselect\n	..\nfrom\n	A表\ninner join         //inner可以省略\n	B表\non\n	连接条件（非等值条件）\nwhere\n	过滤条件\n```\n\n#### 8.4.3 内连接之自连接\n\n最大特点：一张表看成两张表，自己连接自己。\n\n案例：找出每个员工的上级领导，要求显示员工名和对应的领导名\n\n```sql\n步骤一：先查看所有员工和领导信息\nmysql> select empno, ename,mgr from emp;\n+-------+--------+------+\n| empno | ename  | mgr  |\n+-------+--------+------+\n|  7369 | SMITH  | 7902 |\n|  7499 | ALLEN  | 7698 |\n|  7521 | WARD   | 7698 |\n|  7566 | JONES  | 7839 |\n|  7654 | MARTIN | 7698 |\n|  7698 | BLAKE  | 7839 |\n|  7782 | CLARK  | 7839 |\n|  7788 | SCOTT  | 7566 |\n|  7839 | KING   | NULL |\n|  7844 | TURNER | 7698 |\n|  7876 | ADAMS  | 7788 |\n|  7900 | JAMES  | 7698 |\n|  7902 | FORD   | 7566 |\n|  7934 | MILLER | 7782 |\n+-------+--------+------+\n\n步骤二：查看所有领导的信息\nselect \n	empno,ename \nfrom \n	emp  \nwhere \n	empno \nin \n	(select mgr from emp );\n+-------+-------+\n| empno | ename |\n+-------+-------+\n|  7902 | FORD  |\n|  7698 | BLAKE |\n|  7839 | KING  |\n|  7566 | JONES |\n|  7788 | SCOTT |\n|  7782 | CLARK |\n+-------+-------+\n\n\n步骤三：把上述两张表连接\nselect \n	a.ename as \'员工名\' ,b.ename as \'领导名\' \nfrom \n	emp a \njoin \n	emp b \non \n	a.mgr =b.empno;\n+--------+--------+\n| 员工名 | 领导名 |\n+--------+--------+\n| SMITH  | FORD   |\n| ALLEN  | BLAKE  |\n| WARD   | BLAKE  |\n| JONES  | KING   |\n| MARTIN | BLAKE  |\n| BLAKE  | KING   |\n| CLARK  | KING   |\n| SCOTT  | JONES  |\n| TURNER | BLAKE  |\n| ADAMS  | SCOTT  |\n| JAMES  | BLAKE  |\n| FORD   | JONES  |\n| MILLER | CLARK  |\n+--------+--------+\n```\n\n\n\n### 8.5 外连接\n\n最大特点：主表数据无条件的全部输出\n\n什么是外连接，和内连接有什么区别？\n\n**内连接**\n\n​	假设A和B进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。\n\n​	AB两张表没有主副之分，两种表是平等的。\n\n**外连接**\n\n​	假设A和B表进行连接，使用外连接的话，AB两种表中有一张表是主表，一张表是副表，主要查询主表中的数据，顺便把副表中的数据捎带上，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出 NULL 与之匹配。\n\n**外连接的分类：**\n\n- 左外连接（左连接）：表示左边的这张表是主表。\n- 右外连接（右连接）：表示右边的这张表是主表。\n\n左连接有右连接的写法，右连接也有左连接的写法。\n\n语法：\n\n```sql\nselect \n	..\nfrom\n	A表\nleft/right outer join        //outer可以省略\n	B表\non\n	连接条件\nwhere \n	过滤条件\n```\n\n\n\n案例：找出每个员工的领导（所有员工必须全面查出来）\n\n```sql\n//这是之前的内连接，把king的员工丢了\nselect 	\n	a.ename as \'员工名\' ,b.ename as \'领导名\' \nfrom \n	emp a \njoin \n	emp b \non \n	a.mgr =b.empno;\n+--------+--------+\n| 员工名  | 领导名  |\n+--------+--------+\n| SMITH  | FORD   |\n| ALLEN  | BLAKE  |\n| WARD   | BLAKE  |\n| JONES  | KING   |\n| MARTIN | BLAKE  |\n| BLAKE  | KING   |\n| CLARK  | KING   |\n| SCOTT  | JONES  |\n| TURNER | BLAKE  |\n| ADAMS  | SCOTT  |\n| JAMES  | BLAKE  |\n| FORD   | JONES  |\n| MILLER | CLARK  |\n+--------+--------+\n\n//应使用外连接，把员工表作为主表（左外连接）\nselect \n	a.ename as \'员工名\' ,b.ename as \'领导名\' \nfrom \n	emp a \nleft join\n	emp b \non \n	a.mgr =b.empno;\n+--------+--------+\n| 员工名  | 领导名  |\n+--------+--------+\n| SMITH  | FORD   |\n| ALLEN  | BLAKE  |\n| WARD   | BLAKE  |\n| JONES  | KING   |\n| MARTIN | BLAKE  |\n| BLAKE  | KING   |\n| CLARK  | KING   |\n| SCOTT  | JONES  |\n| KING   | NULL   |\n| TURNER | BLAKE  |\n| ADAMS  | SCOTT  |\n| JAMES  | BLAKE  |\n| FORD   | JONES  |\n| MILLER | CLARK  |\n+--------+--------+\n\n//应使用外连接，把员工表作为主表（左=右外连接）\nselect \n	a.ename as \'员工名\' ,b.ename as \'领导名\' \nfrom \n	emp b \nright join \n	emp a \non \n	a.mgr =b.empno;\n+--------+--------+\n| 员工名  | 领导名  |\n+--------+--------+\n| SMITH  | FORD   |\n| ALLEN  | BLAKE  |\n| WARD   | BLAKE  |\n| JONES  | KING   |\n| MARTIN | BLAKE  |\n| BLAKE  | KING   |\n| CLARK  | KING   |\n| SCOTT  | JONES  |\n| KING   | NULL   |\n| TURNER | BLAKE  |\n| ADAMS  | SCOTT  |\n| JAMES  | BLAKE  |\n| FORD   | JONES  |\n| MILLER | CLARK  |\n+--------+--------+\n```\n\n\n\n案例：找出那个部门没有员工\n\n```sql\nselect \n	d.* \nfrom \n	emp e \nright join \n	dept d \non \n	e.deptno = d.deptno \nwhere \n	e.empno is null;\n+--------+------------+--------+\n| DEPTNO | DNAME      | LOC    |\n+--------+------------+--------+\n|     40 | OPERATIONS | BOSTON |\n+--------+------------+--------+\n```\n\n\n\n三张表的连接查询\n\n案例：找出每一个员工的部门名称和工资等级。\n\n```sql\n select \n 	e.empno,e.ename,d.deptno,d.dname,s.grade\n from\n 	emp e\n join\n 	dept d\n on\n 	e.deptno = d.deptno\n join\n 	salgrade s\n on\n	 e.sal >= s.losal and e.sal <= s.hisal;\n	 \n	 \n+-------+--------+--------+------------+-------+\n| empno | ename  | deptno | dname      | grade |\n+-------+--------+--------+------------+-------+\n|  7369 | SMITH  |     20 | RESEARCH   |     1 |\n|  7499 | ALLEN  |     30 | SALES      |     3 |\n|  7521 | WARD   |     30 | SALES      |     2 |\n|  7566 | JONES  |     20 | RESEARCH   |     4 |\n|  7654 | MARTIN |     30 | SALES      |     2 |\n|  7698 | BLAKE  |     30 | SALES      |     4 |\n|  7782 | CLARK  |     10 | ACCOUNTING |     4 |\n|  7788 | SCOTT  |     20 | RESEARCH   |     4 |\n|  7839 | KING   |     10 | ACCOUNTING |     5 |\n|  7844 | TURNER |     30 | SALES      |     3 |\n|  7876 | ADAMS  |     20 | RESEARCH   |     1 |\n|  7900 | JAMES  |     30 | SALES      |     1 |\n|  7902 | FORD   |     20 | RESEARCH   |     4 |\n|  7934 | MILLER |     10 | ACCOUNTING |     2 |\n+-------+--------+--------+------------+-------+	 \n```\n\n\n\n案例：找出每个员工的部门名称、工资等级、以及上级领导\n\n```sql\nselect \n	a.ename as \'员工姓名\',d.dname as \'部门名称\',s.grade as \'工资等级\',b.ename as \'上级领导\'\nfrom\n	emp a\njoin \n	dept d \non \n	a.deptno = d.deptno\njoin \n	salgrade s\non\n	a.sal >= s.losal and a.sal <= hisal\nleft join \n	emp b\non\n	a.mgr =b.empno;\n```\n\n\n\n## 9、子查询\n\n什么是子查询？子查询都可以出现在哪里？\n\nselect 语句当中嵌套select 语句，被嵌套的select语句是子查询。\n\n子查询可以出现在哪里？\n\n```\nselect \n	..(select)\nfrom \n	..(select)\nwhere \n	..(select)\n```\n\n### 9.1 where子句中使用子查询\n\n案例：找出高于平均薪资的员工信息\n\n```sql\nselect * from emp where sal > (select avg(sal) from emp);\n```\n\n### 9.2 from子句中使用子查询\n\n案例：找出每个部门平均薪水的薪资等级\n\n```sql\n第一步：找出每个部门的平均薪水\nselect deptno,avg(sal) as avgsal from emp group by deptno;\n\n+--------+-------------+\n| deptno | avgsal      |\n+--------+-------------+\n|     20 | 2175.000000 |\n|     30 | 1566.666667 |\n|     10 | 2916.666667 |\n+--------+-------------+\n\n第二步：找出每个部门平均薪水的薪资等级,将以上的查询结果作为临时表a，再让a和salgrade连接查询\nselect deptno,avgsal,grade\nfrom\n	(select deptno,avg(sal) as avgsal from emp group by deptno) as a\njoin \n	salgrade s\non \n	a.avgsal >= s.losal and a.avgsal <= s.hisal;\n	\n+--------+-------------+-------+\n| deptno | avgsal      | grade |\n+--------+-------------+-------+\n|     20 | 2175.000000 |     4 |\n|     30 | 1566.666667 |     3 |\n|     10 | 2916.666667 |     4 |\n+--------+-------------+-------+	\n```\n\n\n\n案例：找出每个部门薪水等级的平均值\n\n```sql\n第一步：先计算每个人的薪水等级\nselect \n	ename,s.grade as sgrade,deptno\nfrom \n	emp e \njoin \n	salgrade s\non \n	e.sal >= s.losal and e.sal <= s.hisal;\n	\n+--------+--------+--------+\n| ename  | sgrade | deptno |\n+--------+--------+--------+\n| SMITH  |      1 |     20 |\n| ALLEN  |      3 |     30 |\n| WARD   |      2 |     30 |\n| JONES  |      4 |     20 |\n| MARTIN |      2 |     30 |\n| BLAKE  |      4 |     30 |\n| CLARK  |      4 |     10 |\n| SCOTT  |      4 |     20 |\n| KING   |      5 |     10 |\n| TURNER |      3 |     30 |\n| ADAMS  |      1 |     20 |\n| JAMES  |      1 |     30 |\n| FORD   |      4 |     20 |\n| MILLER |      2 |     10 |\n+--------+--------+--------+	\n	\n第二步：对上述结果按照部门进行按照deptno分组，然后对grade求平均值\nselect ee.deptno, avg(sgrade)\nfrom \n (select \n	ename,s.grade as sgrade,deptno\n    from \n        emp e \n    join \n        salgrade s\n    on \n        e.sal >= s.losal and e.sal <= s.hisal) as ee\ngroup by \n	ee.deptno;\n	\n+--------+--------------+\n| deptno | avg(s.grade) |\n+--------+--------------+\n|     20 |       2.8000 |\n|     30 |       2.5000 |\n|     10 |       3.6667 |\n+--------+--------------+	\n	\n也可以不用子查询，直接进行分组\nselect \n	deptno, avg(s.grade)\nfrom \n	emp e \njoin \n	salgrade s\non \n	e.sal >= s.losal and e.sal <= s.hisal\ngroup by \n	deptno;\n```\n\n\n\n### 9.3 select 子句中使用子查询\n\n案例：找到每个员工所在的部门名称，要求显示员工名字和部门名\n\n```sql\n第一种方式：连接查询\nselect \n	e.ename,d.dname\nfrom \n	emp e\njoin\n	dept d \non \n	e.deptno = d.deptno;\n	\n第二种方式：子查询\nselect \n	e.ename, \n	(select d.dname from dept d where e.deptno = d.deptno) as dname\nfrom \n	emp e;\n\n\n+--------+------------+\n| ename  | dname      |\n+--------+------------+\n| SMITH  | RESEARCH   |\n| ALLEN  | SALES      |\n| WARD   | SALES      |\n| JONES  | RESEARCH   |\n| MARTIN | SALES      |\n| BLAKE  | SALES      |\n| CLARK  | ACCOUNTING |\n| SCOTT  | RESEARCH   |\n| KING   | ACCOUNTING |\n| TURNER | SALES      |\n| ADAMS  | RESEARCH   |\n| JAMES  | SALES      |\n| FORD   | RESEARCH   |\n| MILLER | ACCOUNTING |\n+--------+------------+\n```\n\n\n\n## 10、结果集集合处理\n\n### 10.1 union（对结果集进行相加）\n\n要求：两次查询结果的列的数目应该相同才可以拼接到一起，可以是两个毫不相干的结果集。\n\n案例：找出工作岗位是 CLERK和SALESMAN的员工\n\n```sql\n第一种方式：\nselect ename,job from emp where job = \'CLERK\' or job = \'SALESMAN\';\n第二种方式：\nselect ename,job from emp where job in (\'CLERK\',\'SALESMAN\');\n+--------+----------+\n| ename  | job      |\n+--------+----------+\n| SMITH  | CLERK    |\n| ALLEN  | SALESMAN |\n| WARD   | SALESMAN |\n| MARTIN | SALESMAN |\n| TURNER | SALESMAN |\n| ADAMS  | CLERK    |\n| JAMES  | CLERK    |\n| MILLER | CLERK    |\n+--------+----------+\n第三种方式：\nselect ename,job from emp where job = \'CLERK\'\nunion \nselect ename,job from emp where job = \'SALESMAN\';\n\n+--------+----------+\n| ename  | job      |\n+--------+----------+\n| SMITH  | CLERK    |\n| ADAMS  | CLERK    |\n| JAMES  | CLERK    |\n| MILLER | CLERK    |\n| ALLEN  | SALESMAN |\n| WARD   | SALESMAN |\n| MARTIN | SALESMAN |\n| TURNER | SALESMAN |\n+--------+----------+\n```\n\n\n\n## 11、limit（重点）\n\nlimit是mysql特有的，其他数据库都没有，不通用。\n\nlimit取结果集中的部分数据。\n\n**语法机制：**\n\n- limit startIndex,length\n- startIndex 表示起始位置，第一个元素下标是0\n- length 表示取几个\n\n\n\n案例：取出工资前5名的员工\n\n```sql\n步骤一：先对员工按照工资进行排序\nselect * from emp order by sal desc;\n\n+-------+--------+-----------+------+------------+---------+---------+--------+\n| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |\n|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |\n|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |\n|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |\n|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |\n|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |\n|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |\n|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |\n|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |\n|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |\n|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |\n|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |\n|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |\n|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n\n步骤二：取出前5名（下面两种结果一样）\nselect * from emp order by sal desc limit 0,5;\nselect * from emp order by sal desc limit 5;  //直接写一个5，前面第一个数字默认是0\n\n+-------+-------+-----------+------+------------+---------+------+--------+\n| EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |\n+-------+-------+-----------+------+------------+---------+------+--------+\n|  7839 | KING  | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 |\n|  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |\n|  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |\n|  7566 | JONES | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |\n|  7698 | BLAKE | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |\n+-------+-------+-----------+------+------------+---------+------+--------+\n```\n\n案例：找出工资排序在第4到第9名直接的员工？\n\n```sql\nselect * from emp order by sal desc limit 3,6;  //第4名的下标为3\n\n+-------+--------+----------+------+------------+---------+--------+--------+\n| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |\n+-------+--------+----------+------+------------+---------+--------+--------+\n|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |   NULL |     20 |\n|  7698 | BLAKE  | MANAGER  | 7839 | 1981-05-01 | 2850.00 |   NULL |     30 |\n|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |   NULL |     10 |\n|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 |     30 |\n|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |   0.00 |     30 |\n|  7934 | MILLER | CLERK    | 7782 | 1982-01-23 | 1300.00 |   NULL |     10 |\n+-------+--------+----------+------+------------+---------+--------+--------+\n```\n\n\n\n注意：\n\n- limit是sql语句最后执行的环节\n\n```\nselect 		5\n..\nfrom		1\n..\nwhere		2\n..\ngroup by	3\n..\nhaving		4\n..\norder by	6\n..\nlimit 		7\n..	;	\n```\n\n\n\n## 12、分页查询\n\n每页显示`pagesize`条记录\n\n第`pagenum`页：`limit (pagenum-1)*pagesize,pagesize;`\n\njava代码：\n\n```sql\nint pageNum = 5;\nint pageSize = 10;\nlimit (pageNum-1)*pageSize,pageSize;\n```\n\n', 0, 0, '2020-08-07 01:15:09', 2, 0, 1, '1、简单的查询语法格式：\n（1）查询单个字段：\n​    select 字段名 from 表名;\n（2）查询多个字段：\n​    select 字段名1,字段名2,字段名3,…… from 表名;\n（3）查询所有字段：\n​    select * from 表名;\n提示：\n\n任何一条sql语句都要以”;”结尾sql语句不区分大小写\n案例：查询员工年薪？（月薪*12）\n字段可以参与数学运算\nselect ename,sal*12 from emp;\n+--------+----------+| ename  | sal*12   |+--------+----------+| SMITH  |  9600.00 || ALLEN  | 19200.00 || WARD   | 15000.00 || JONES  | 35700.00 || MARTIN | 15000.00 || BLAKE  | 34200.00 || CLARK  | 29400.00 || SCOTT  | 36000.00 || KING   | 60000.00 || TURNER | 18000.00 || ADAMS  | 13200.00 || JAMES  | 11400.00 || FORD   | 36000.00 || MILLER | 15600.00 |+--------+----------+14 rows in set (0.00 sec)\n给查询结果的列重命名\nselect ename,sal*12 as \'年薪\' from emp;\n+--------+----------+| ename  | 年薪     |+--------+----------+| SMITH  |  9600.00 || ALLEN  | 19200.00 || WARD   | 15000.00 || JONES  | 35700.00 || MARTIN | 15000.00 || BLAKE  | 34200.00 || CLARK  | 29400.00 || SCOTT  | 36000.00 || KING   | 60000.00 || TURNER | 18000.00 || ADAMS  | 13200.00 || JAMES  | 11400.00 || FORD   | 36000.00 || MILLER | 15600.00 |+--------+----------+\n注意：\n\n标准sql语句中要求字符串使用单引号括起来，虽然mysql数据库支持双引号，但是不建议使用，因为不通用。as关键字可以省略\n2、条件查询语法格式：\n​    select 字段名1,字段名2,字段名3,…… from 表名 where 条件;\n执行顺序：\n​    先from ，然后where，最后select\n\n\n\n运算符\n说明\n\n\n\n\n=\n等于\n\n\n<> 或 !=\n不等于\n\n\n<\n小于\n\n\n<=\n小于等于\n\n\n>\n大于\n\n\n>=\n大于等于\n\n\nbetween … and …\n两个值之间，等同于>= and <=\n\n\nis null\n为 null（is not null 不为空）\n\n\nand\n并且\n\n\nor\n或者\n\n\nin\n包含，相当于多个or（not in 不在这个范围中）\n\n\nnot\nnot 可以取非，主要用于is 或 in中。\n\n\nlike\nlike 模糊查询，支持%或下划线匹配\n\n\n\n（1）查询工资等于5000的员工姓名？\nmysql> select ename from emp where sal = 5000;+-------+| ename |+-------+| KING  |+-------+\n（2）查询员工MARTIN的工资？\nmysql> select ename,sal from emp where ename=\'MARTIN\';+--------+---------+| ename  | sal     |+--------+---------+| MARTIN | 1250.00 |+--------+---------+\n（3）查询工资大于等于3000的员工？\nmysql> select ename,sal from emp where sal >= 3000;+-------+---------+| ename | sal     |+-------+---------+| SCOTT | 3000.00 || KING  | 5000.00 || FORD  | 3000.00 |+-------+---------+\n（4）查询工资不等于3000的员工？\nmysql> select ename,sal from emp where sal <> 3000;+--------+---------+| ename  | sal     |+--------+---------+| SMITH  |  800.00 || ALLEN  | 1600.00 || WARD   | 1250.00 || JONES  | 2975.00 || MARTIN | 1250.00 || BLAKE  | 2850.00 || CLARK  | 2450.00 || KING   | 5000.00 || TURNER | 1500.00 || ADAMS  | 1100.00 || JAMES  |  950.00 || MILLER | 1300.00 |+--------+---------+\n（5）查询工资在1100到3000之间的员工？\nmysql> select ename,sal from emp where sal >=1100 and sal <= 3000;+--------+---------+| ename  | sal     |+--------+---------+| ALLEN  | 1600.00 || WARD   | 1250.00 || JONES  | 2975.00 || MARTIN | 1250.00 || BLAKE  | 2850.00 || CLARK  | 2450.00 || SCOTT  | 3000.00 || TURNER | 1500.00 || ADAMS  | 1100.00 || FORD   | 3000.00 || MILLER | 1300.00 |+--------+---------+或者：mysql> select ename,sal from emp where sal between 1100 and 3000;\n（6）查询名字是首字母A到C开头的员工，其中不包括C开头，只包括名字为C的员工\nmysql> select ename,sal from emp where ename between \'a\' and \'c\';+-------+---------+| ename | sal     |+-------+---------+| ALLEN | 1600.00 || BLAKE | 2850.00 || ADAMS | 1100.00 |+-------+---------+\n（7）查询那些人没有津贴？\nmysql> select ename,sal,comm  from emp where comm is null or comm = 0;+--------+---------+------+| ename  | sal     | comm |+--------+---------+------+| SMITH  |  800.00 | NULL || JONES  | 2975.00 | NULL || BLAKE  | 2850.00 | NULL || CLARK  | 2450.00 | NULL || SCOTT  | 3000.00 | NULL || KING   | 5000.00 | NULL || TURNER | 1500.00 | 0.00 || ADAMS  | 1100.00 | NULL || JAMES  |  950.00 | NULL || FORD   | 3000.00 | NULL || MILLER | 1300.00 | NULL |+--------+---------+------+\n（8）查询那些人有津贴\nmysql> select ename,sal,comm  from emp where comm is not null and comm != 0;+--------+---------+---------+| ename  | sal     | comm    |+--------+---------+---------+| ALLEN  | 1600.00 |  300.00 || WARD   | 1250.00 |  500.00 || MARTIN | 1250.00 | 1400.00 |+--------+---------+---------+\n（9）查询工作岗位为SALESMAN和MANAGER的员工\nmysql> select ename,job from emp where job =\'SALESMAN\' or job=\'MANAGER\';+--------+----------+| ename  | job      |+--------+----------+| ALLEN  | SALESMAN || WARD   | SALESMAN || JONES  | MANAGER  || MARTIN | SALESMAN || BLAKE  | MANAGER  || CLARK  | MANAGER  || TURNER | SALESMAN |+--------+----------+\n（10）查询薪资大于1000并且部门编号为20或30的员工\nmysql> select ename,sal,DEPTNO from emp where sal > 1000 and (deptno = 20 or deptno = 30);+--------+---------+--------+| ename  | sal     | DEPTNO |+--------+---------+--------+| ALLEN  | 1600.00 |     30 || WARD   | 1250.00 |     30 || JONES  | 2975.00 |     20 || MARTIN | 1250.00 |     30 || BLAKE  | 2850.00 |     30 || SCOTT  | 3000.00 |     20 || TURNER | 1500.00 |     30 || ADAMS  | 1100.00 |     20 || FORD   | 3000.00 |     20 |+--------+---------+--------+\n（11）查询部门编号为20或30的员工姓名\nmysql> select ename,DEPTNO from emp where deptno in (20,30);+--------+--------+| ename  | DEPTNO |+--------+--------+| SMITH  |     20 || ALLEN  |     30 || WARD   |     30 || JONES  |     20 || MARTIN |     30 || BLAKE  |     30 || SCOTT  |     20 || TURNER |     30 || ADAMS  |     20 || JAMES  |     30 || FORD   |     20 |+--------+--------+\n（13）查询名字为A开头的员工\nmysql> select empno,ename from emp where ename like \'a%\';\n（14）查询名字中含有A的员工\nmysql> select empno,ename from emp where ename like \'%a%\';+-------+--------+| empno | ename  |+-------+--------+|  7499 | ALLEN  ||  7521 | WARD   ||  7654 | MARTIN ||  7698 | BLAKE  ||  7782 | CLARK  ||  7876 | ADAMS  ||  7900 | JAMES  |+-------+--------+\n（16）查询名字第二位为a的员工\nmysql> select empno,ename from emp where ename like \'_a%\';+-------+--------+| empno | ename  |+-------+--------+|  7521 | WARD   ||  7654 | MARTIN ||  7900 | JAMES  |+-------+--------+\n（15）查询名字中含有下划线的员工\nmysql> select empno,ename from emp where ename like \'%\\_%\';\n注意：\n\n字符串应该用单引号括起来不等号：<> 或 !=between and 是闭区间，包括边界。between and 使用的时候，必须左小右大between and 除了可以使用在数字，也可以使用在字符串，左闭右开数据库中null代表为空，不是一个值，不能用等号衡量，只能使用is null或者is not null当and和or一起使用的时候，and的优先级大于or的优先级in等用于or%代表0个或多个任意字符，_代表一个任意字符\\ _ 为转义，表示 正常的下划线\n3、排序查询\n\n\n表达式\n说明\n\n\n\n\nasc\n升序\n\n\ndesc\n降序\n\n\n\n按照工资升序排列员工表\nmysql> select empno,sal from emp order by sal;或者mysql> select empno,sal from emp order by sal asc;+-------+---------+| empno | sal     |+-------+---------+|  7369 |  800.00 ||  7900 |  950.00 ||  7876 | 1100.00 ||  7521 | 1250.00 ||  7654 | 1250.00 ||  7934 | 1300.00 ||  7844 | 1500.00 ||  7499 | 1600.00 ||  7782 | 2450.00 ||  7698 | 2850.00 ||  7566 | 2975.00 ||  7788 | 3000.00 ||  7902 | 3000.00 ||  7839 | 5000.00 |+-------+---------+\n按照工资升序排列员工表，当工资一样的时候按照名字的降序排列\nmysql> select empno,ename,sal from emp order by sal asc ,ename  desc;+-------+--------+---------+| empno | ename  | sal     |+-------+--------+---------+|  7369 | SMITH  |  800.00 ||  7900 | JAMES  |  950.00 ||  7876 | ADAMS  | 1100.00 ||  7521 | WARD   | 1250.00 ||  7654 | MARTIN | 1250.00 ||  7934 | MILLER | 1300.00 ||  7844 | TURNER | 1500.00 ||  7499 | ALLEN  | 1600.00 ||  7782 | CLARK  | 2450.00 ||  7698 | BLAKE  | 2850.00 ||  7566 | JONES  | 2975.00 ||  7788 | SCOTT  | 3000.00 ||  7902 | FORD   | 3000.00 ||  7839 | KING   | 5000.00 |+-------+--------+---------+\n找出工作岗位是SALESMAN的员工，并且按照薪资的降序排列\nmysql> select empno,ename,job,sal from emp where job=\'SALESMAN\' order by sal desc;+-------+--------+----------+---------+| empno | ename  | job      | sal     |+-------+--------+----------+---------+|  7499 | ALLEN  | SALESMAN | 1600.00 ||  7844 | TURNER | SALESMAN | 1500.00 ||  7521 | WARD   | SALESMAN | 1250.00 ||  7654 | MARTIN | SALESMAN | 1250.00 |+-------+--------+----------+---------+\n注意：\n\n默认为升序排列靠前的字段起主导作用order by 数字，表示使用第几列排序\n4、分组函数\n\n\n表达式\n含义\n\n\n\n\ncount\n计数\n\n\nsum\n求和\n\n\navg\n平均值\n\n\nmax\n最大值\n\n\nmin\n最小值\n\n\n\n注意：\n\n所有的分组函数都是对”某一组“进行操作的。分组函数还有一个名字叫多行处理函数分组函数自动忽略空分组函数不可以用在where子句当中，原因：因为group by 在where之后运行，而分组函数在group by 之后执行。count (*)：不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关）count(字段)：统计字段不为null的总数量\n语句执行顺序\nselect         5..    from         1..where        2..group by    3..having        4..order by     6..\n查询工资总和\nmysql> select sum(sal) from emp;+----------+| sum(sal) |+----------+| 29025.00 |+----------+\n查询最高工资\nmysql> select max(sal) from emp;+----------+| max(sal) |+----------+|  5000.00 |+----------+\n查询最低工资\nmysql> select min(sal) from emp;+----------+| min(sal) |+----------+|   800.00 |+----------+\n查询平均工资\nmysql> select avg(sal) from emp;+-------------+| avg(sal)    |+-------------+| 2073.214286 |+-------------+\n查询总人数\nmysql> select count(ename) from emp;+--------------+| count(ename) |+--------------+|           14 |+--------------+\n查询拥有奖金的人数\nmysql> select count(comm) from emp;+-------------+| count(comm) |+-------------+|           4 |+-------------+\n查询公司应该分发的工资总和（分组函数自动忽略null，若没有忽略的话，得到的结果应该为null）\nmysql> select sum(comm) from emp;+-----------+| sum(comm) |+-----------+|   2200.00 |+-----------+\n找出高出平均工资的员工（子查询）\nmysql> select ename,sal from emp where sal > (select avg(sal) from emp);+-------+---------+| ename | sal     |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING  | 5000.00 || FORD  | 3000.00 |+-------+---------+\n5、单行处理函数\n\n\n表达式\n含义\n\n\n\n\nifnull(可能为null的数据，要替换的值)\n空处理函数，若值为null，则用另一个值进行替换\n\n\n\n计算每个员工的年薪（若数学表达式中有null，那么结果一定为null）\nmysql> select ename,(sal + ifnull(comm,0))*12 as yearsal from emp;+--------+----------+| ename  | yearsal  |+--------+----------+| SMITH  |  9600.00 || ALLEN  | 22800.00 || WARD   | 21000.00 || JONES  | 35700.00 || MARTIN | 31800.00 || BLAKE  | 34200.00 || CLARK  | 29400.00 || SCOTT  | 36000.00 || KING   | 60000.00 || TURNER | 18000.00 || ADAMS  | 13200.00 || JAMES  | 11400.00 || FORD   | 36000.00 || MILLER | 15600.00 |+--------+----------+\n6、分组查询\n\n\n表达式\n含义\n\n\n\n\ngroup by\n按照某个字段或者某些字段进行分组\n\n\nhaving\n对分组之后的数据进行再次过滤\n\n\n\n（1）找出每个岗位的最高薪资\nmysql> select job,max(sal) from emp group by job;+-----------+----------+| job       | max(sal) |+-----------+----------+| CLERK     |  1300.00 || SALESMAN  |  1600.00 || MANAGER   |  2975.00 || ANALYST   |  3000.00 || PRESIDENT |  5000.00 |+-----------+----------+\n（2）每个工作岗位的平均工资\nmysql>  select job,avg(sal) from emp group by job;+-----------+-------------+| job       | avg(sal)    |+-----------+-------------+| CLERK     | 1037.500000 || SALESMAN  | 1400.000000 || MANAGER   | 2758.333333 || ANALYST   | 3000.000000 || PRESIDENT | 5000.000000 |+-----------+-------------+\n（3）找出每个部门不同工作岗位的最高新资\nmysql> select deptno,job,max(sal) from emp group by deptno,job order by deptno;+--------+-----------+----------+| deptno | job       | max(sal) |+--------+-----------+----------+|     10 | CLERK     |  1300.00 ||     10 | MANAGER   |  2450.00 ||     10 | PRESIDENT |  5000.00 ||     20 | ANALYST   |  3000.00 ||     20 | CLERK     |  1100.00 ||     20 | MANAGER   |  2975.00 ||     30 | CLERK     |   950.00 ||     30 | MANAGER   |  2850.00 ||     30 | SALESMAN  |  1600.00 |+--------+-----------+----------+\n（4）找出每个部门的最高薪资，要求显示薪资大于2900的数据\n第一步：找出每个部门的最高薪资mysql> select deptno ,max(sal) from emp group by deptno;+--------+----------+| deptno | max(sal) |+--------+----------+|     20 |  3000.00 ||     30 |  2850.00 ||     10 |  5000.00 |+--------+----------+第二步：薪资大于2900的mysql> select deptno ,max(sal) from emp group by deptno having max(sal)>2900; //效率比较低+--------+----------+| deptno | max(sal) |+--------+----------+|     20 |  3000.00 ||     10 |  5000.00 |+--------+----------+最佳写法：mysql> select deptno ,max(sal) from emp where sal > 2900 group by deptno;+--------+----------+| deptno | max(sal) |+--------+----------+|     20 |  3000.00 ||     10 |  5000.00 |+--------+----------+\n（5）找出每个部门的平均薪资，要求显示薪资大于2900的数据\n第一步：找出每个部门的平均薪资mysql> select deptno ,avg(sal) from emp group by deptno;+--------+-------------+| deptno | avg(sal)    |+--------+-------------+|     20 | 2175.000000 ||     30 | 1566.666667 ||     10 | 2916.666667 |+--------+-------------+第二步：平均薪资大于2000的mysql> select deptno ,avg(sal) from emp group by deptno having avg(sal)>2000;+--------+-------------+| deptno | avg(sal)    |+--------+-------------+|     20 | 2175.000000 ||     10 | 2916.666667 |+--------+-------------+\n注意：\n\n分组函数一般都会和group by一起使用分组函数会在group by之后执行。当一条sql语句中没有froup by 的时候，整张表会自动成为一组当sql语句中用group by的时候，select后面只能跟group by后面的列或者分组函数在mysql中，select后面可以跟不是group by后面的列的列，但是没有意义，在Oracle数据库中直接报错\n总结：\n一个完整的DQL语句怎么写？\nselect         5..from        1..where        2..group by    3..having        4..order by    6..\n7、结果去重关于查询的结果如何去重？\n在所有字段的前面加上关键字distinct\n会把select所有字段作为一列进行去重\nmysql> select distinct job from emp;+-----------+| job       |+-----------+| CLERK     || SALESMAN  || MANAGER   || ANALYST   || PRESIDENT |+-----------+\n查询每个部门都有那些工作岗位\nmysql> select distinct deptno, job from emp order by deptno;+--------+-----------+| deptno | job       |+--------+-----------+|     10 | CLERK     ||     10 | MANAGER   ||     10 | PRESIDENT ||     20 | ANALYST   ||     20 | CLERK     ||     20 | MANAGER   ||     30 | CLERK     ||     30 | MANAGER   ||     30 | SALESMAN  |+--------+-----------+\n8、连接查询8.1 什么是连接查询？在实际开发中，大部分情况都不是在单张表中进行查询，而是在多张表联合查询出结果。\n把一张表的结果作为另一张表的数据进行查询。\n8.2 连接查询的分类根据语法出现的年代来划分：\n\nSQL92（一些老的DBA可能还在使用，DBA：DataBase Administrator，数据库管理员）SQL99（比较新的语法）\n根据表的连接方式来划分，包括：\n\n内连接\n等值连接非等值连接自连接\n外连接\n左外连接（左连接）右外连接（右连接）\n全连接（基本上用不到）\n8.3 笛卡尔积现象如果两张表进行连接查询，没有任何条件的话，得到的结果是两张表结果的乘积。\nmysql> select ename,dname from emp,dept;      //两张表自连接得到了笛卡尔积+--------+------------+| ename  | dname      |+--------+------------+| SMITH  | ACCOUNTING || SMITH  | RESEARCH   || SMITH  | SALES      || SMITH  | OPERATIONS || ALLEN  | ACCOUNTING || ALLEN  | RESEARCH   || ALLEN  | SALES      || ALLEN  | OPERATIONS || WARD   | ACCOUNTING || WARD   | RESEARCH   || WARD   | SALES      || WARD   | OPERATIONS || JONES  | ACCOUNTING || JONES  | RESEARCH   || JONES  | SALES      || JONES  | OPERATIONS || MARTIN | ACCOUNTING || MARTIN | RESEARCH   || MARTIN | SALES      || MARTIN | OPERATIONS || BLAKE  | ACCOUNTING || BLAKE  | RESEARCH   || BLAKE  | SALES      || BLAKE  | OPERATIONS || CLARK  | ACCOUNTING || CLARK  | RESEARCH   || CLARK  | SALES      || CLARK  | OPERATIONS || SCOTT  | ACCOUNTING || SCOTT  | RESEARCH   || SCOTT  | SALES      || SCOTT  | OPERATIONS || KING   | ACCOUNTING || KING   | RESEARCH   || KING   | SALES      || KING   | OPERATIONS || TURNER | ACCOUNTING || TURNER | RESEARCH   || TURNER | SALES      || TURNER | OPERATIONS || ADAMS  | ACCOUNTING || ADAMS  | RESEARCH   || ADAMS  | SALES      || ADAMS  | OPERATIONS || JAMES  | ACCOUNTING || JAMES  | RESEARCH   || JAMES  | SALES      || JAMES  | OPERATIONS || FORD   | ACCOUNTING || FORD   | RESEARCH   || FORD   | SALES      || FORD   | OPERATIONS || MILLER | ACCOUNTING || MILLER | RESEARCH   || MILLER | SALES      || MILLER | OPERATIONS |+--------+------------+\n如何避免笛卡尔积现象？\n​    加条件过滤\n避免笛卡尔积现象，就减少匹配次数吗？\n​    不会，不会减少显示的有效记录，匹配次数还是之前的。\n案例：找出每一个员工的部门名称，要求显示员工名和部门名\nmysql> select ename,dname from emp e,dept d where e.DEPTNO = d.deptno; //这是正确的写法+--------+------------+| ename  | dname      |+--------+------------+| SMITH  | RESEARCH   || ALLEN  | SALES      || WARD   | SALES      || JONES  | RESEARCH   || MARTIN | SALES      || BLAKE  | SALES      || CLARK  | ACCOUNTING || SCOTT  | RESEARCH   || KING   | ACCOUNTING || TURNER | SALES      || ADAMS  | RESEARCH   || JAMES  | SALES      || FORD   | RESEARCH   || MILLER | ACCOUNTING |+--------+------------+8.4 内连接什么是内连接？\n​    假设A和B进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接\n​    AB两张表没有主副之分，两种表是平等的。\n8.4.1 内连接之等值连接最大特点：等值关系\n案例：查询每个员工的部门名称，要求显示员工名和部门名\nSQL92：（太老了，不用了）\nmysql> select ename,dname from emp e,dept d where e.deptno = d.deptno;+--------+------------+| ename  | dname      |+--------+------------+| SMITH  | RESEARCH   || ALLEN  | SALES      || WARD   | SALES      || JONES  | RESEARCH   || MARTIN | SALES      || BLAKE  | SALES      || CLARK  | ACCOUNTING || SCOTT  | RESEARCH   || KING   | ACCOUNTING || TURNER | SALES      || ADAMS  | RESEARCH   || JAMES  | SALES      || FORD   | RESEARCH   || MILLER | ACCOUNTING |+--------+------------+\nSQL99：（常用）\nmysql> select ename,dname from emp e inner join dept d on e.DEPTNO = d.deptno;+--------+------------+| ename  | dname      |+--------+------------+| SMITH  | RESEARCH   || ALLEN  | SALES      || WARD   | SALES      || JONES  | RESEARCH   || MARTIN | SALES      || BLAKE  | SALES      || CLARK  | ACCOUNTING || SCOTT  | RESEARCH   || KING   | ACCOUNTING || TURNER | SALES      || ADAMS  | RESEARCH   || JAMES  | SALES      || FORD   | RESEARCH   || MILLER | ACCOUNTING |+--------+------------+\n语法：\nselect    ..from    A表inner join         //inner可以省略    B表on    连接条件where    过滤条件\nSQL92 的缺点：\n​    把表的连接条件和where过滤添加写到一起了。\nSQL99的优点：\n​    把表的连接条件和where过滤添加分离了。\n8.4.2 内连接之非等值连接最大特点：连接条件为非等值关系\n案例：找出每个员工的工资等级，要求显示员工名称、工资、工资等级\nmysql> select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal>=s.losal and e.sal<=hisal;+--------+---------+-------+| ename  | sal     | grade |+--------+---------+-------+| SMITH  |  800.00 |     1 || ALLEN  | 1600.00 |     3 || WARD   | 1250.00 |     2 || JONES  | 2975.00 |     4 || MARTIN | 1250.00 |     2 || BLAKE  | 2850.00 |     4 || CLARK  | 2450.00 |     4 || SCOTT  | 3000.00 |     4 || KING   | 5000.00 |     5 || TURNER | 1500.00 |     3 || ADAMS  | 1100.00 |     1 || JAMES  |  950.00 |     1 || FORD   | 3000.00 |     4 || MILLER | 1300.00 |     2 |+--------+---------+-------+\n语法：\nselect    ..from    A表inner join         //inner可以省略    B表on    连接条件（非等值条件）where    过滤条件\n8.4.3 内连接之自连接最大特点：一张表看成两张表，自己连接自己。\n案例：找出每个员工的上级领导，要求显示员工名和对应的领导名\n步骤一：先查看所有员工和领导信息mysql> select empno, ename,mgr from emp;+-------+--------+------+| empno | ename  | mgr  |+-------+--------+------+|  7369 | SMITH  | 7902 ||  7499 | ALLEN  | 7698 ||  7521 | WARD   | 7698 ||  7566 | JONES  | 7839 ||  7654 | MARTIN | 7698 ||  7698 | BLAKE  | 7839 ||  7782 | CLARK  | 7839 ||  7788 | SCOTT  | 7566 ||  7839 | KING   | NULL ||  7844 | TURNER | 7698 ||  7876 | ADAMS  | 7788 ||  7900 | JAMES  | 7698 ||  7902 | FORD   | 7566 ||  7934 | MILLER | 7782 |+-------+--------+------+步骤二：查看所有领导的信息select     empno,ename from     emp  where     empno in     (select mgr from emp );+-------+-------+| empno | ename |+-------+-------+|  7902 | FORD  ||  7698 | BLAKE ||  7839 | KING  ||  7566 | JONES ||  7788 | SCOTT ||  7782 | CLARK |+-------+-------+步骤三：把上述两张表连接select     a.ename as \'员工名\' ,b.ename as \'领导名\' from     emp a join     emp b on     a.mgr =b.empno;+--------+--------+| 员工名 | 领导名 |+--------+--------+| SMITH  | FORD   || ALLEN  | BLAKE  || WARD   | BLAKE  || JONES  | KING   || MARTIN | BLAKE  || BLAKE  | KING   || CLARK  | KING   || SCOTT  | JONES  || TURNER | BLAKE  || ADAMS  | SCOTT  || JAMES  | BLAKE  || FORD   | JONES  || MILLER | CLARK  |+--------+--------+\n8.5 外连接最大特点：主表数据无条件的全部输出\n什么是外连接，和内连接有什么区别？\n内连接\n​    假设A和B进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。\n​    AB两张表没有主副之分，两种表是平等的。\n外连接\n​    假设A和B表进行连接，使用外连接的话，AB两种表中有一张表是主表，一张表是副表，主要查询主表中的数据，顺便把副表中的数据捎带上，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出 NULL 与之匹配。\n外连接的分类：\n\n左外连接（左连接）：表示左边的这张表是主表。右外连接（右连接）：表示右边的这张表是主表。\n左连接有右连接的写法，右连接也有左连接的写法。\n语法：\nselect     ..from    A表left/right outer join        //outer可以省略    B表on    连接条件where     过滤条件\n案例：找出每个员工的领导（所有员工必须全面查出来）\n//这是之前的内连接，把king的员工丢了select         a.ename as \'员工名\' ,b.ename as \'领导名\' from     emp a join     emp b on     a.mgr =b.empno;+--------+--------+| 员工名  | 领导名  |+--------+--------+| SMITH  | FORD   || ALLEN  | BLAKE  || WARD   | BLAKE  || JONES  | KING   || MARTIN | BLAKE  || BLAKE  | KING   || CLARK  | KING   || SCOTT  | JONES  || TURNER | BLAKE  || ADAMS  | SCOTT  || JAMES  | BLAKE  || FORD   | JONES  || MILLER | CLARK  |+--------+--------+//应使用外连接，把员工表作为主表（左外连接）select     a.ename as \'员工名\' ,b.ename as \'领导名\' from     emp a left join    emp b on     a.mgr =b.empno;+--------+--------+| 员工名  | 领导名  |+--------+--------+| SMITH  | FORD   || ALLEN  | BLAKE  || WARD   | BLAKE  || JONES  | KING   || MARTIN | BLAKE  || BLAKE  | KING   || CLARK  | KING   || SCOTT  | JONES  || KING   | NULL   || TURNER | BLAKE  || ADAMS  | SCOTT  || JAMES  | BLAKE  || FORD   | JONES  || MILLER | CLARK  |+--------+--------+//应使用外连接，把员工表作为主表（左=右外连接）select     a.ename as \'员工名\' ,b.ename as \'领导名\' from     emp b right join     emp a on     a.mgr =b.empno;+--------+--------+| 员工名  | 领导名  |+--------+--------+| SMITH  | FORD   || ALLEN  | BLAKE  || WARD   | BLAKE  || JONES  | KING   || MARTIN | BLAKE  || BLAKE  | KING   || CLARK  | KING   || SCOTT  | JONES  || KING   | NULL   || TURNER | BLAKE  || ADAMS  | SCOTT  || JAMES  | BLAKE  || FORD   | JONES  || MILLER | CLARK  |+--------+--------+\n案例：找出那个部门没有员工\nselect     d.* from     emp e right join     dept d on     e.deptno = d.deptno where     e.empno is null;+--------+------------+--------+| DEPTNO | DNAME      | LOC    |+--------+------------+--------+|     40 | OPERATIONS | BOSTON |+--------+------------+--------+\n三张表的连接查询\n案例：找出每一个员工的部门名称和工资等级。\n select      e.empno,e.ename,d.deptno,d.dname,s.grade from     emp e join     dept d on     e.deptno = d.deptno join     salgrade s on     e.sal >= s.losal and e.sal <= s.hisal;+-------+--------+--------+------------+-------+| empno | ename  | deptno | dname      | grade |+-------+--------+--------+------------+-------+|  7369 | SMITH  |     20 | RESEARCH   |     1 ||  7499 | ALLEN  |     30 | SALES      |     3 ||  7521 | WARD   |     30 | SALES      |     2 ||  7566 | JONES  |     20 | RESEARCH   |     4 ||  7654 | MARTIN |     30 | SALES      |     2 ||  7698 | BLAKE  |     30 | SALES      |     4 ||  7782 | CLARK  |     10 | ACCOUNTING |     4 ||  7788 | SCOTT  |     20 | RESEARCH   |     4 ||  7839 | KING   |     10 | ACCOUNTING |     5 ||  7844 | TURNER |     30 | SALES      |     3 ||  7876 | ADAMS  |     20 | RESEARCH   |     1 ||  7900 | JAMES  |     30 | SALES      |     1 ||  7902 | FORD   |     20 | RESEARCH   |     4 ||  7934 | MILLER |     10 | ACCOUNTING |     2 |+-------+--------+--------+------------+-------+\n案例：找出每个员工的部门名称、工资等级、以及上级领导\nselect     a.ename as \'员工姓名\',d.dname as \'部门名称\',s.grade as \'工资等级\',b.ename as \'上级领导\'from    emp ajoin     dept d on     a.deptno = d.deptnojoin     salgrade son    a.sal >= s.losal and a.sal <= hisalleft join     emp bon    a.mgr =b.empno;\n9、子查询什么是子查询？子查询都可以出现在哪里？\nselect 语句当中嵌套select 语句，被嵌套的select语句是子查询。\n子查询可以出现在哪里？\nselect     ..(select)from     ..(select)where     ..(select)9.1 where子句中使用子查询案例：找出高于平均薪资的员工信息\nselect * from emp where sal > (select avg(sal) from emp);\n9.2 from子句中使用子查询案例：找出每个部门平均薪水的薪资等级\n第一步：找出每个部门的平均薪水select deptno,avg(sal) as avgsal from emp group by deptno;+--------+-------------+| deptno | avgsal      |+--------+-------------+|     20 | 2175.000000 ||     30 | 1566.666667 ||     10 | 2916.666667 |+--------+-------------+第二步：找出每个部门平均薪水的薪资等级,将以上的查询结果作为临时表a，再让a和salgrade连接查询select deptno,avgsal,gradefrom    (select deptno,avg(sal) as avgsal from emp group by deptno) as ajoin     salgrade son     a.avgsal >= s.losal and a.avgsal <= s.hisal;+--------+-------------+-------+| deptno | avgsal      | grade |+--------+-------------+-------+|     20 | 2175.000000 |     4 ||     30 | 1566.666667 |     3 ||     10 | 2916.666667 |     4 |+--------+-------------+-------+\n案例：找出每个部门薪水等级的平均值\n第一步：先计算每个人的薪水等级select     ename,s.grade as sgrade,deptnofrom     emp e join     salgrade son     e.sal >= s.losal and e.sal <= s.hisal;+--------+--------+--------+| ename  | sgrade | deptno |+--------+--------+--------+| SMITH  |      1 |     20 || ALLEN  |      3 |     30 || WARD   |      2 |     30 || JONES  |      4 |     20 || MARTIN |      2 |     30 || BLAKE  |      4 |     30 || CLARK  |      4 |     10 || SCOTT  |      4 |     20 || KING   |      5 |     10 || TURNER |      3 |     30 || ADAMS  |      1 |     20 || JAMES  |      1 |     30 || FORD   |      4 |     20 || MILLER |      2 |     10 |+--------+--------+--------+    第二步：对上述结果按照部门进行按照deptno分组，然后对grade求平均值select ee.deptno, avg(sgrade)from  (select     ename,s.grade as sgrade,deptno    from         emp e     join         salgrade s    on         e.sal >= s.losal and e.sal <= s.hisal) as eegroup by     ee.deptno;+--------+--------------+| deptno | avg(s.grade) |+--------+--------------+|     20 |       2.8000 ||     30 |       2.5000 ||     10 |       3.6667 |+--------+--------------+    也可以不用子查询，直接进行分组select     deptno, avg(s.grade)from     emp e join     salgrade son     e.sal >= s.losal and e.sal <= s.hisalgroup by     deptno;\n9.3 select 子句中使用子查询案例：找到每个员工所在的部门名称，要求显示员工名字和部门名\n第一种方式：连接查询select     e.ename,d.dnamefrom     emp ejoin    dept d on     e.deptno = d.deptno;第二种方式：子查询select     e.ename,     (select d.dname from dept d where e.deptno = d.deptno) as dnamefrom     emp e;+--------+------------+| ename  | dname      |+--------+------------+| SMITH  | RESEARCH   || ALLEN  | SALES      || WARD   | SALES      || JONES  | RESEARCH   || MARTIN | SALES      || BLAKE  | SALES      || CLARK  | ACCOUNTING || SCOTT  | RESEARCH   || KING   | ACCOUNTING || TURNER | SALES      || ADAMS  | RESEARCH   || JAMES  | SALES      || FORD   | RESEARCH   || MILLER | ACCOUNTING |+--------+------------+\n10、结果集集合处理10.1 union（对结果集进行相加）要求：两次查询结果的列的数目应该相同才可以拼接到一起，可以是两个毫不相干的结果集。\n案例：找出工作岗位是 CLERK和SALESMAN的员工\n第一种方式：select ename,job from emp where job = \'CLERK\' or job = \'SALESMAN\';第二种方式：select ename,job from emp where job in (\'CLERK\',\'SALESMAN\');+--------+----------+| ename  | job      |+--------+----------+| SMITH  | CLERK    || ALLEN  | SALESMAN || WARD   | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN || ADAMS  | CLERK    || JAMES  | CLERK    || MILLER | CLERK    |+--------+----------+第三种方式：select ename,job from emp where job = \'CLERK\'union select ename,job from emp where job = \'SALESMAN\';+--------+----------+| ename  | job      |+--------+----------+| SMITH  | CLERK    || ADAMS  | CLERK    || JAMES  | CLERK    || MILLER | CLERK    || ALLEN  | SALESMAN || WARD   | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+\n11、limit（重点）limit是mysql特有的，其他数据库都没有，不通用。\nlimit取结果集中的部分数据。\n语法机制：\n\nlimit startIndex,lengthstartIndex 表示起始位置，第一个元素下标是0length 表示取几个\n案例：取出工资前5名的员工\n步骤一：先对员工按照工资进行排序select * from emp order by sal desc;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |+-------+--------+-----------+------+------------+---------+---------+--------+步骤二：取出前5名（下面两种结果一样）select * from emp order by sal desc limit 0,5;select * from emp order by sal desc limit 5;  //直接写一个5，前面第一个数字默认是0+-------+-------+-----------+------+------------+---------+------+--------+| EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |+-------+-------+-----------+------+------------+---------+------+--------+|  7839 | KING  | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 ||  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 ||  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 ||  7566 | JONES | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 ||  7698 | BLAKE | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |+-------+-------+-----------+------+------------+---------+------+--------+\n案例：找出工资排序在第4到第9名直接的员工？\nselect * from emp order by sal desc limit 3,6;  //第4名的下标为3+-------+--------+----------+------+------------+---------+--------+--------+| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |+-------+--------+----------+------+------------+---------+--------+--------+|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |   NULL |     20 ||  7698 | BLAKE  | MANAGER  | 7839 | 1981-05-01 | 2850.00 |   NULL |     30 ||  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |   NULL |     10 ||  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 |     30 ||  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |   0.00 |     30 ||  7934 | MILLER | CLERK    | 7782 | 1982-01-23 | 1300.00 |   NULL |     10 |+-------+--------+----------+------+------------+---------+--------+--------+\n注意：\n\nlimit是sql语句最后执行的环节\nselect         5..from        1..where        2..group by    3..having        4..order by    6..limit         7..    ;12、分页查询每页显示pagesize条记录\n第pagenum页：limit (pagenum-1)*pagesize,pagesize;\njava代码：\nint pageNum = 5;int pageSize = 10;limit (pageNum-1)*pageSize,pageSize;\n', 0, 1);
INSERT INTO `t_article` VALUES (140, '03、数据定义（DDL）', 8, '\n\n## 1、创建表（create）\n\n语法格式：\n\n```\ncreate table 表名{\n	字段名1 数据类型,\n	字段名2 数据类型,\n	字段名3 数据类型,\n	...\n}\n```\n\n**MySQL字段数据类型：**\n\n| 类型                          | 描述                                             | java的对应关系     |\n| ----------------------------- | ------------------------------------------------ | ------------------ |\n| Char(长度)                    | 定长字符串，存储空间大小固定，适合作为主键或外键 | char               |\n| double(有效数字位数，小数位)  | 数值型                                           | double             |\n| Float（有效数字位数，小数位） | 数值型                                           | float              |\n| Int（长度）                   | 整型                                             | int                |\n| bigint（长度）                | 长整型                                           | long               |\n| Date                          | 日期型 年月日                                    | java.sql.Date      |\n| DateTime                      | 日期型 年月日 时分秒 毫秒                        | java.sql.Timestamp |\n| time                          | 日期型 时分秒                                    | java.sql.Time      |\n| BLOB                          | 二进制大对象（存储图片，视频，等流媒体信息）     | Object             |\n| CLOB                          | 字符大对象（存储大文本，可以存储4G的字符串）     | Object             |\n\n\n\ndefault：默认\n\n\n\n**char和varchar如何选择？**\n\n当数据长度确定的情况下，是定长的，例如：性别、生日等采用char。\n\n当数据长度不确定的情况，不定长的，例如：简介、姓名等采用varchar。\n\n\n\n**表名格式：t_或者 tbl _开始。**\n\n\n\n**创建学生表：**\n\n学号：bigint \n\n姓名：varchar\n\n性别：sex\n\n班级编号：int\n\n生日：char\n\n普通创建：\n\n```sql\ncreate table t_student(\n	no bigint,\n	name varchar(255),\n	sex char(1),\n	classno varchar(255),\n	brith char(10)\n);\n```\n\n```sql\ndesc t_student;\n\n+---------+--------------+------+-----+---------+-------+\n| Field   | Type         | Null | Key | Default | Extra |\n+---------+--------------+------+-----+---------+-------+\n| no      | bigint(20)   | YES  |     | NULL    |       |\n| name    | varchar(255) | YES  |     | NULL    |       |\n| sex     | char(1)      | YES  |     | NULL    |       |\n| classno | varchar(255) | YES  |     | NULL    |       |\n| brith   | char(10)     | YES  |     | NULL    |       |\n+---------+--------------+------+-----+---------+-------+\n```\n\n\n\ndefault  定义默认值\n\n```\ncreate table t_student(\n	no bigint,\n	name varchar(255),\n	sex char(1) default 1,\n	classno varchar(255),\n	brith char(10)\n);\n```\n\n\n\n## 2、删除表（drop）\n\n```sql\ndrop table t_student;				//当表不存在的时候就会报错\ndrop table if exists t_student;		//当表存在的时候删除\n```\n\n\n\n## 3、复制表\n\n把后面的查询结果，当作一张表进行创建。\n\n语法格式：\n\n​	create table  新表名 as select ……\n\n\n\n复制emp表，重命名为emp1\n\n```sql\ncreate table emp1 as select * from emp;\nselect * from emp1;\n\n+-------+--------+-----------+------+------------+---------+---------+--------+\n| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |\n|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |\n|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |\n|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |\n|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |\n|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |\n|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |\n|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |\n|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |\n|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |\n|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |\n|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |\n|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |\n|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n```\n\n\n\n## 4、修改表（alter）\n\n使用工具，利用sql语句没有什么意义。', 0, 0, '2020-08-07 01:15:38', 2, 0, 1, '1、创建表（create）语法格式：\ncreate table 表名{    字段名1 数据类型,    字段名2 数据类型,    字段名3 数据类型,    ...}MySQL字段数据类型：\n\n\n\n类型\n描述\njava的对应关系\n\n\n\n\nChar(长度)\n定长字符串，存储空间大小固定，适合作为主键或外键\nchar\n\n\ndouble(有效数字位数，小数位)\n数值型\ndouble\n\n\nFloat（有效数字位数，小数位）\n数值型\nfloat\n\n\nInt（长度）\n整型\nint\n\n\nbigint（长度）\n长整型\nlong\n\n\nDate\n日期型 年月日\njava.sql.Date\n\n\nDateTime\n日期型 年月日 时分秒 毫秒\njava.sql.Timestamp\n\n\ntime\n日期型 时分秒\njava.sql.Time\n\n\nBLOB\n二进制大对象（存储图片，视频，等流媒体信息）\nObject\n\n\nCLOB\n字符大对象（存储大文本，可以存储4G的字符串）\nObject\n\n\n\ndefault：默认\nchar和varchar如何选择？\n当数据长度确定的情况下，是定长的，例如：性别、生日等采用char。\n当数据长度不确定的情况，不定长的，例如：简介、姓名等采用varchar。\n表名格式：t或者 tbl 开始。\n创建学生表：\n学号：bigint \n姓名：varchar\n性别：sex\n班级编号：int\n生日：char\n普通创建：\ncreate table t_student(    no bigint,    name varchar(255),    sex char(1),    classno varchar(255),    brith char(10));\ndesc t_student;+---------+--------------+------+-----+---------+-------+| Field   | Type         | Null | Key | Default | Extra |+---------+--------------+------+-----+---------+-------+| no      | bigint(20)   | YES  |     | NULL    |       || name    | varchar(255) | YES  |     | NULL    |       || sex     | char(1)      | YES  |     | NULL    |       || classno | varchar(255) | YES  |     | NULL    |       || brith   | char(10)     | YES  |     | NULL    |       |+---------+--------------+------+-----+---------+-------+\ndefault  定义默认值\ncreate table t_student(    no bigint,    name varchar(255),    sex char(1) default 1,    classno varchar(255),    brith char(10));2、删除表（drop）drop table t_student;                //当表不存在的时候就会报错drop table if exists t_student;        //当表存在的时候删除\n3、复制表把后面的查询结果，当作一张表进行创建。\n语法格式：\n​    create table  新表名 as select ……\n复制emp表，重命名为emp1\ncreate table emp1 as select * from emp;select * from emp1;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+\n4、修改表（alter）使用工具，利用sql语句没有什么意义。\n', 0, 1);
INSERT INTO `t_article` VALUES (141, '04、数据操作（DML）', 8, '\n\n增删改查有一个术语：CRUD操作\n\nCreate（增）  Retrieve（检索）  Update（修改） Delete（删除）\n\n## 1、插入：insert\n\ninsert 语句插入数据\n\n**语法格式：**\n\n​	insert into 表名 (字段名1，字段名2，字段名3，……) values (值1，值2，值3，……);\n\n要求：字段的数量和值的数量相同，并且数据类型要对应相同。\n\n```sql\n（1）一般的全列对应全values插入\ninsert into t_student (no,name,sex,classno,brith) values(1,\'张三\',\'1\',\'高三（1）班\',\'1999-11-24\');\n（2）部分列对应部分values插入\ninsert into t_student (name) values(\'王五\');	\n（3）省略列名全values插入\ninsert into t_student values(1,\'张三\',\'1\',\'高三（1）班\',\'1999-11-24\');		//后面values必须按顺序全写\n（4）多行数据一次插入\ninsert into t_student (no,name,sex,classno,brith) values(1,\'张三\',\'1\',\'高三（1）班\',\'1999-11-24\'),(2,\'李四\',\'2\',\'高三（2）班\',\'1998-10-10\');\n```\n\n注意：\n\n- 除了插入的字段，其他字段自动为NULL。\n- 如果没有写表名后面的列，那么插入数据就应该按照表中列的顺序写，而且每一列都要写不能省略。\n\n\n\n**把查询结果插入到一张表中**\n\n两张表的列的数目一定要相同\n\n```sql\ninsert into emp1 select * from emp;\n```\n\n\n\n## 2、修改数据：update\n\n语法格式：\n\n​	update 表名 set 字段名=值1，字段名=值2 ... where 条件;\n\n注意：没有条件整张表数据全部更新。\n\n案例：把dept1表中的deptno 为 10部门的loc改为 \'SHANGHAI\',dname改为 \'RENSHIBU\'。\n\n```sql\nupdate dept1 set loc = \'SHANGHAI\',dname = \'RENSHIBU\' where deptno = 10;\n```\n\n案例：更新所有的记录\n\n```sql\nupdate dept1 set loc = \'SHANGHAI\',dname = \'RENSHIBU\';\n```\n\n\n\n## 3、删除数据：delete / truncate\n\n语法格式：\n\n​	delete from 表名 where 条件;\n\n注意：没有条件全部删除\n\n\n\n案例：删除10部门的数据\n\n```sql\ndelete from dept1 where deptno = 10;\n```\n\n案例：删除所有记录\n\n```sql\ndelete from dept1;\n```\n\n案例：怎么删除大表(无法再恢复，表被截断，不可回滚，永久丢失)\n\n```sql\ntruncate table dept1;\n```\n\n', 0, 0, '2020-08-07 01:16:10', 2, 0, 1, '增删改查有一个术语：CRUD操作\nCreate（增）  Retrieve（检索）  Update（修改） Delete（删除）\n1、插入：insertinsert 语句插入数据\n语法格式：\n​    insert into 表名 (字段名1，字段名2，字段名3，……) values (值1，值2，值3，……);\n要求：字段的数量和值的数量相同，并且数据类型要对应相同。\n（1）一般的全列对应全values插入insert into t_student (no,name,sex,classno,brith) values(1,\'张三\',\'1\',\'高三（1）班\',\'1999-11-24\');（2）部分列对应部分values插入insert into t_student (name) values(\'王五\');    （3）省略列名全values插入insert into t_student values(1,\'张三\',\'1\',\'高三（1）班\',\'1999-11-24\');        //后面values必须按顺序全写（4）多行数据一次插入insert into t_student (no,name,sex,classno,brith) values(1,\'张三\',\'1\',\'高三（1）班\',\'1999-11-24\'),(2,\'李四\',\'2\',\'高三（2）班\',\'1998-10-10\');\n注意：\n\n除了插入的字段，其他字段自动为NULL。如果没有写表名后面的列，那么插入数据就应该按照表中列的顺序写，而且每一列都要写不能省略。\n把查询结果插入到一张表中\n两张表的列的数目一定要相同\ninsert into emp1 select * from emp;\n2、修改数据：update语法格式：\n​    update 表名 set 字段名=值1，字段名=值2 … where 条件;\n注意：没有条件整张表数据全部更新。\n案例：把dept1表中的deptno 为 10部门的loc改为 ‘SHANGHAI’,dname改为 ‘RENSHIBU’。\nupdate dept1 set loc = \'SHANGHAI\',dname = \'RENSHIBU\' where deptno = 10;\n案例：更新所有的记录\nupdate dept1 set loc = \'SHANGHAI\',dname = \'RENSHIBU\';\n3、删除数据：delete / truncate语法格式：\n​    delete from 表名 where 条件;\n注意：没有条件全部删除\n案例：删除10部门的数据\ndelete from dept1 where deptno = 10;\n案例：删除所有记录\ndelete from dept1;\n案例：怎么删除大表(无法再恢复，表被截断，不可回滚，永久丢失)\ntruncate table dept1;\n', 0, 1);
INSERT INTO `t_article` VALUES (142, '05、约束（constraint）', 8, '\n\n## 1、什么是约束？\n\n​	在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的合法性、有效性、完整性。\n\n​	常见的约束：\n\n| 表达式      | 作用                               |\n| ----------- | ---------------------------------- |\n| not null    | 非空约束，不能为NULL               |\n| unique      | 唯一约束，不能重复，但可以为NULL   |\n| primary key | 主键约束，就不能为NULL，也不能重复 |\n| foreign key | 外键约束                           |\n| check       | 检查约束，Oracle有，mysqk目前没有  |\n\n\n\n## 2、非空约束（not null）\n\n```\ndrop table if exists t_user;\n\ncreate table t_user(\n	id int,\n	username varchar(255) not null,\n	password varchar(255) \n);\n	\ninsert into t_user(id,password) values (1,\'123\');	//错误的\nERROR 1364 (HY000): Field \'username\' doesn\'t have a default value\n\ninsert into t_user(id,username,password) values(1,\'张三\',\'123\');\n```\n\n\n\n## 3、唯一性约束（unique）\n\n唯一性约束修饰的字段具有唯一性，不能重复。但可以为NULL。\n\n- 在列后面直接加unique约束是列级约束\n- 在列的下面加unique约束是表级约束\n\n\n\n```sql\ndrop table if exists t_user;\n\ncreate table t_user(\n	id int,\n	username varchar(255) unique,\n	password varchar(255) \n);\n	\ninsert into t_user(id,username,password) values (1,\'张三\',\'123\');	\n\ninsert into t_user(id,username,password) values(2,\'张三\',\'456\');	//错误\nERROR 1062 (23000): Duplicate entry \'张三\' for key \'username\'\n\ninsert into t_user(id,password) values(2,\'456\');	//唯一性可以为NULL\ninsert into t_user(id,password) values(2,\'456\');	//唯一性可以为NULL，因为NULL不是数值，所以不会比较重复性\n```\n\n案例：给一张表的两列添加唯一性约束\n\n```sql\ndrop table if exists t_user;\n\ncreate table t_user(\n	id int,\n	username varchar(255) ,\n	email varchar(255),\n    unique (username,email)\n);\ninsert into t_user(id,username,email) values (1,\'张三\',\'123\');\ninsert into t_user(id,username,email) values (1,\'张三\',\'456\');//不会报错，除非两列都重复了\n```\n\n\n\n## 4、主键约束（primary key）\n\n主键约束，代表着主键不能为NULL，也不能重复。\n\n以下是单一主键：\n\n```sql\ndrop table if exists t_user;\ncreate table t_user(\n	id int primary key,\n	username varchar(255),\n	email varchar(255)\n);\n\ninsert into t_user(id,username,email) values(1,\'zs\',\'zs@qq.com\');\ninsert into t_user(id,username,email) values(2,\'ls\',\'ls@qq.com\');\ninsert into t_user(id,username,email) values(3,\'ww\',\'ww@qq.com\');\n\ninsert into t_user(id,username,email) values(1,\'ml\',\'ml@qq.com\'); 		//错误的，主键不能重复\nERROR 1062 (23000): Duplicate entry \'1\' for key \'PRIMARY\'\n\ninsert into t_user(username,email) values(\'ml\',\'ml@qq.com\');\n//错误的，主键不能为NULL\nERROR 1364 (HY000): Field \'id\' doesn\'t have a default value\n```\n\n\n\n以下是复合主键：（不建议使用）\n\n```sql\ndrop table if exists t_user;\ncreate table t_user(\n	id int,\n	username varchar(255),\n	email varchar(255),\n	primary key (id,username)\n);\n\ninsert into t_user(id,username,email) values(1,\'zs\',\'zs@qq.com\');\ninsert into t_user(id,username,email) values(2,\'ls\',\'ls@qq.com\');\ninsert into t_user(id,username,email) values(3,\'ww\',\'ww@qq.com\');\n\ninsert into t_user(id,username,email) values(1,\'ml\',\'ml@qq.com\'); 		//正确的\n\ninsert into t_user(id,username,email) values(1,\'zs\',\'ml@qq.com\'); 		//错误的，主键重复\nERROR 1062 (23000): Duplicate entry \'1-zs\' for key \'PRIMARY\'\n\ninsert into t_user(username,email) values(\'zs\',\'ml@qq.com\'); 			//错误的，主键列为NULL\nERROR 1364 (HY000): Field \'id\' doesn\'t have a default value\n```\n\n\n\n**主键有什么作用？**\n\n- 表的设计三范式中有要求，第一范式就说要求任何一张表都应该有主键\n- 主键的作用：主键值是这行记录在这张表当中唯一的标识。\n\n\n\n**任何表的主键约束只能有一个。**\n\n**主键的分类：**\n\n- 根据主键字段和字段数量来划分：\n  - 单一主键\n  - 复合主键（多个字段联合到一起添加一个主键约束）（复合主键不建议使用，因为复合主键违背三范式）\n- 根据主键的性质来划分：\n  - 自然主键：主键值最好是与业务没有关系的自然数。\n  - 业务主键：主键值和系统 业务挂钩，比如：银行卡号，身份证号（不建议使用，最好不要把和业务挂钩的字段作为主键）。\n\n\n\n**mysql 提供的主键值自增：（primary key auto_increment）**\n\n提示：Oracle中也提供了一个自增的机制，叫做序列（sequence）\n\n```sql\ndrop table if exists t_user;\ncreate table t_user(\n	id int primary key auto_increment,	//id为主键，并且可以自增,从1开始，以1自增\n	username varchar(255),\n	email varchar(255)\n);\n\ninsert into t_user(username,email) values(\'zs\',\'zs@qq.com\');\ninsert into t_user(username,email) values(\'ls\',\'ls@qq.com\');\ninsert into t_user(username,email) values(\'ww\',\'ww@qq.com\');\n```\n\n\n\n## 5、外键约束（foreign key）\n\n子表中某一列将父表的某一列作为外键，那么子表中的这一列中的值，就只能是父表中对应列有的，如果父表中没有的话，就会报错。\n\n\n\n**外键必须是另一个表的主键吗？**\n\n不一定是主键，但必须是唯一性索引。\n\n\n\n外键值可以为NULL。\n\n\n\n**业务背景：**\n\n设计数据库表，来维护学生和班级信息：\n\n\n\n**班级表：t_class** \n\n| 列名      | 含义     |\n| --------- | -------- |\n| cno（pk） | 班级编号 |\n| cname     | 班级名称 |\n\n**学生表：t_student**\n\n| 列名          | 含义     |\n| ------------- | -------- |\n| sno（pk）     | 学生编号 |\n| sname         | 学生姓名 |\n| classno（fk） | 班级编号 |\n\n\n\nt_student 中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表，t_class表作为父表。\n\n注意：\n\n- 删除数据的时候，先删除子表，再删除父表。\n- 添加数据的时候，先添加父表，再添加子表。\n- 创建表的时候，先创建父表，再创建子表。\n- 删除表的时候，先删除父表，再删除子表。\n\n\n\n```sql\ndrop table if exists t_student;\ndrop table if exists t_class;\n\ncreate table t_class(\n	cno int primary key,\n	cname varchar(255)\n);\n\ncreate table t_student(\n	sno int primary key,\n    sname varchar(255),\n    classno int,\n    foreign key(classno) references t_class(cno)\n);\n\ninsert into t_class values(101,\'高三(1)班\');\ninsert into t_class values(102,\'高三(2)班\');\n\ninsert into t_student values(1,\'张三\',101);\ninsert into t_student values(2,\'李四\',101);\ninsert into t_student values(3,\'王五\',102);\ninsert into t_student values(4,\'麻六\',102);\n\ninsert into t_student values(5,\'唐三\',103);   //错误的，103在t_class中没有出现\nERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`bookshop`.`t_student`, CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`classno`) REFERENCES `t_class` (`cno`))\n\ninsert into t_student (sno,sname) values(5,\'唐三\'); //正确，外键值可以为NULL。\n\nselect * from t_class;\nselect * from t_student;\n```\n\n', 0, 0, '2020-08-07 01:16:35', 2, 0, 1, '1、什么是约束？​    在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的合法性、有效性、完整性。\n​    常见的约束：\n\n\n\n表达式\n作用\n\n\n\n\nnot null\n非空约束，不能为NULL\n\n\nunique\n唯一约束，不能重复，但可以为NULL\n\n\nprimary key\n主键约束，就不能为NULL，也不能重复\n\n\nforeign key\n外键约束\n\n\ncheck\n检查约束，Oracle有，mysqk目前没有\n\n\n\n2、非空约束（not null）drop table if exists t_user;create table t_user(    id int,    username varchar(255) not null,    password varchar(255) );insert into t_user(id,password) values (1,\'123\');    //错误的ERROR 1364 (HY000): Field \'username\' doesn\'t have a default valueinsert into t_user(id,username,password) values(1,\'张三\',\'123\');3、唯一性约束（unique）唯一性约束修饰的字段具有唯一性，不能重复。但可以为NULL。\n\n在列后面直接加unique约束是列级约束在列的下面加unique约束是表级约束\ndrop table if exists t_user;create table t_user(    id int,    username varchar(255) unique,    password varchar(255) );insert into t_user(id,username,password) values (1,\'张三\',\'123\');    insert into t_user(id,username,password) values(2,\'张三\',\'456\');    //错误ERROR 1062 (23000): Duplicate entry \'张三\' for key \'username\'insert into t_user(id,password) values(2,\'456\');    //唯一性可以为NULLinsert into t_user(id,password) values(2,\'456\');    //唯一性可以为NULL，因为NULL不是数值，所以不会比较重复性\n案例：给一张表的两列添加唯一性约束\ndrop table if exists t_user;create table t_user(    id int,    username varchar(255) ,    email varchar(255),    unique (username,email));insert into t_user(id,username,email) values (1,\'张三\',\'123\');insert into t_user(id,username,email) values (1,\'张三\',\'456\');//不会报错，除非两列都重复了\n4、主键约束（primary key）主键约束，代表着主键不能为NULL，也不能重复。\n以下是单一主键：\ndrop table if exists t_user;create table t_user(    id int primary key,    username varchar(255),    email varchar(255));insert into t_user(id,username,email) values(1,\'zs\',\'zs@qq.com\');insert into t_user(id,username,email) values(2,\'ls\',\'ls@qq.com\');insert into t_user(id,username,email) values(3,\'ww\',\'ww@qq.com\');insert into t_user(id,username,email) values(1,\'ml\',\'ml@qq.com\');         //错误的，主键不能重复ERROR 1062 (23000): Duplicate entry \'1\' for key \'PRIMARY\'insert into t_user(username,email) values(\'ml\',\'ml@qq.com\');//错误的，主键不能为NULLERROR 1364 (HY000): Field \'id\' doesn\'t have a default value\n以下是复合主键：（不建议使用）\ndrop table if exists t_user;create table t_user(    id int,    username varchar(255),    email varchar(255),    primary key (id,username));insert into t_user(id,username,email) values(1,\'zs\',\'zs@qq.com\');insert into t_user(id,username,email) values(2,\'ls\',\'ls@qq.com\');insert into t_user(id,username,email) values(3,\'ww\',\'ww@qq.com\');insert into t_user(id,username,email) values(1,\'ml\',\'ml@qq.com\');         //正确的insert into t_user(id,username,email) values(1,\'zs\',\'ml@qq.com\');         //错误的，主键重复ERROR 1062 (23000): Duplicate entry \'1-zs\' for key \'PRIMARY\'insert into t_user(username,email) values(\'zs\',\'ml@qq.com\');             //错误的，主键列为NULLERROR 1364 (HY000): Field \'id\' doesn\'t have a default value\n主键有什么作用？\n\n表的设计三范式中有要求，第一范式就说要求任何一张表都应该有主键主键的作用：主键值是这行记录在这张表当中唯一的标识。\n任何表的主键约束只能有一个。\n主键的分类：\n\n根据主键字段和字段数量来划分：\n单一主键复合主键（多个字段联合到一起添加一个主键约束）（复合主键不建议使用，因为复合主键违背三范式）\n根据主键的性质来划分：\n自然主键：主键值最好是与业务没有关系的自然数。业务主键：主键值和系统 业务挂钩，比如：银行卡号，身份证号（不建议使用，最好不要把和业务挂钩的字段作为主键）。\n\nmysql 提供的主键值自增：（primary key auto_increment）\n提示：Oracle中也提供了一个自增的机制，叫做序列（sequence）\ndrop table if exists t_user;create table t_user(    id int primary key auto_increment,    //id为主键，并且可以自增,从1开始，以1自增    username varchar(255),    email varchar(255));insert into t_user(username,email) values(\'zs\',\'zs@qq.com\');insert into t_user(username,email) values(\'ls\',\'ls@qq.com\');insert into t_user(username,email) values(\'ww\',\'ww@qq.com\');\n5、外键约束（foreign key）子表中某一列将父表的某一列作为外键，那么子表中的这一列中的值，就只能是父表中对应列有的，如果父表中没有的话，就会报错。\n外键必须是另一个表的主键吗？\n不一定是主键，但必须是唯一性索引。\n外键值可以为NULL。\n业务背景：\n设计数据库表，来维护学生和班级信息：\n班级表：t_class \n\n\n\n列名\n含义\n\n\n\n\ncno（pk）\n班级编号\n\n\ncname\n班级名称\n\n\n\n学生表：t_student\n\n\n\n列名\n含义\n\n\n\n\nsno（pk）\n学生编号\n\n\nsname\n学生姓名\n\n\nclassno（fk）\n班级编号\n\n\n\nt_student 中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表，t_class表作为父表。\n注意：\n\n删除数据的时候，先删除子表，再删除父表。添加数据的时候，先添加父表，再添加子表。创建表的时候，先创建父表，再创建子表。删除表的时候，先删除父表，再删除子表。\ndrop table if exists t_student;drop table if exists t_class;create table t_class(    cno int primary key,    cname varchar(255));create table t_student(    sno int primary key,    sname varchar(255),    classno int,    foreign key(classno) references t_class(cno));insert into t_class values(101,\'高三(1)班\');insert into t_class values(102,\'高三(2)班\');insert into t_student values(1,\'张三\',101);insert into t_student values(2,\'李四\',101);insert into t_student values(3,\'王五\',102);insert into t_student values(4,\'麻六\',102);insert into t_student values(5,\'唐三\',103);   //错误的，103在t_class中没有出现ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`bookshop`.`t_student`, CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`classno`) REFERENCES `t_class` (`cno`))insert into t_student (sno,sname) values(5,\'唐三\'); //正确，外键值可以为NULL。select * from t_class;select * from t_student;\n', 0, 1);
INSERT INTO `t_article` VALUES (143, '06、存储引擎', 8, '\n\n## 1、查看存储引擎和编码方式\n\n在安装文件的my.ini 文件可以查看默认的配置\n\nC:\\ProgramData\\MySQL\\MySQL Server 8.0\\my.ini\n\n```\ndefault-storage-engine=INNODB\n```\n\n\n\n查看建表语句\n\n```sql\nshow create table t_x;\n```\n\n完整的建表语句\n\n```sql\n CREATE TABLE `t_x` (\n  `id` int(11) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n```\n\n注意：\n\n- 在mysql中凡是标识符都可以使用飘号 `` 括起来。最好别用，不通用。\n- mysql默认使用的存储引擎是InnoDB方式。\n- 默认的采用的字符集是UTF8。\n\n查看表的引擎\n\n```sql\nSHOW TABLE STATUS LIKE \'表名\'\n```\n\n\n\n## 2、什么是存储引擎\n\n存储引擎只有在mysql中存在，在oracle中叫表的存储方式。\n\nmysql支持很多种存储方式，每一种存储方式都有优缺点，需要在合适的时机选择适合的存储引擎。\n\n\n\n## 3、查看mysql当前支持的存储引擎\n\n指令：show engines \\G\n\n共有如下9种存储引擎\n\n```sql\nshow engines \\G\n*************************** 1. row ***************************\n      Engine: MEMORY\n     Support: YES\n     Comment: Hash based, stored in memory, useful for temporary tables\nTransactions: NO\n          XA: NO\n  Savepoints: NO\n*************************** 2. row ***************************\n      Engine: MRG_MYISAM\n     Support: YES\n     Comment: Collection of identical MyISAM tables\nTransactions: NO\n          XA: NO\n  Savepoints: NO\n*************************** 3. row ***************************\n      Engine: CSV\n     Support: YES\n     Comment: CSV storage engine\nTransactions: NO\n          XA: NO\n  Savepoints: NO\n*************************** 4. row ***************************\n      Engine: FEDERATED\n     Support: NO\n     Comment: Federated MySQL storage engine\nTransactions: NULL\n          XA: NULL\n  Savepoints: NULL\n*************************** 5. row ***************************\n      Engine: PERFORMANCE_SCHEMA\n     Support: YES\n     Comment: Performance Schema\nTransactions: NO\n          XA: NO\n  Savepoints: NO\n*************************** 6. row ***************************\n      Engine: MyISAM\n     Support: YES\n     Comment: MyISAM storage engine\nTransactions: NO\n          XA: NO\n  Savepoints: NO\n*************************** 7. row ***************************\n      Engine: InnoDB\n     Support: DEFAULT\n     Comment: Supports transactions, row-level locking, and foreign keys\nTransactions: YES\n          XA: YES\n  Savepoints: YES\n*************************** 8. row ***************************\n      Engine: BLACKHOLE\n     Support: YES\n     Comment: /dev/null storage engine (anything you write to it disappears)\nTransactions: NO\n          XA: NO\n  Savepoints: NO\n*************************** 9. row ***************************\n      Engine: ARCHIVE\n     Support: YES\n     Comment: Archive storage engine\nTransactions: NO\n          XA: NO\n  Savepoints: NO\n```\n\n![image-20200712114137913](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/image-20200712114137913.png)\n\n\n\n## 4、常见的存储引擎\n\n### **MyISAM存储引擎**\n\n```sql\n      Engine: MyISAM\n     Support: YES\n     Comment: MyISAM storage engine\nTransactions: NO\n          XA: NO\n  Savepoints: NO\n```\n\nMyISAM存储引擎是mysql中最常用的引擎，适合少修改，多查询的表\n\n他管理的表的特点：\n\n- 使用三个文件来表示每个表\n  - 格式文件：存储表结构的定义（t_student.frm）\n  - 数据文件：存储表行的内容（t_student.MYD）\n  - 索引文件：存储表上的索引（t_student.MYI）\n- 灵活的AUTO_INCREMENT字段处理\n- 可转换为压缩、只读表来节省空间\n- 缺点：不支持事务，不支持外键\n\n\n\n### InnoDB存储引擎\n\n默认的存储引擎\n\n```sql\n      Engine: InnoDB\n     Support: DEFAULT\n     Comment: Supports transactions, row-level locking, and foreign keys\nTransactions: YES\n          XA: YES\n  Savepoints: YES\n```\n\n特点：\n\n- 优点：\n  - 支持事务、行级锁、外键约束\n  - 安全\n- 缺点：\n  - 数据存储在表空间tablespace，无法被压缩\n\n- 每个 InnoDB表在数据库目录中以.frm格式文件表示\n- InnoDB表空间tablespace 被用于存储表的内容\n- 提供一组用于记录事务性活动的日志文件\n- 用 COMMIT（提交）、SAVEPOINT 及 ROLLBACK（回滚）支持事务处理\n- 提供 全 ACID兼容\n- 在 mysql 服务器崩溃后会自动修复\n- 多版本（MVCC）和行级锁定\n- 支持外键及引用的完整性，包括级联删除和更新\n\n\n\n\n\n### MEMORY存储引擎\n\n```sql\n      Engine: MEMORY\n     Support: YES\n     Comment: Hash based, stored in memory, useful for temporary tables\nTransactions: NO\n          XA: NO\n  Savepoints: NO\n```\n\n特点：\n\n- 在数据库目录内，每个表均为.frm格式的文件表示\n- 表数据及索引被存储在内存中\n- 表级锁机制\n- 不能包含 TEXT 或 BLOB 字段\n- 优点：\n  - 速度快\n- 缺点：\n  - 数据容易丢失\n  - 不支持事务\n\n\n\n## 5、修改数据库表的存储引擎\n\n方式1:将mysql.ini中default-storage-engine=InnoDB，重启服务.\n\n方式2:建表时指定  CREATE TABLE 表名(...)ENGINE=MYISAM;\n\n方式3:建表后修改  ALTER TABLE 表名 ENGINE = INNODB;\n\n', 0, 0, '2020-08-07 01:16:59', 2, 0, 1, '1、查看存储引擎和编码方式在安装文件的my.ini 文件可以查看默认的配置\nC:\\ProgramData\\MySQL\\MySQL Server 8.0\\my.ini\ndefault-storage-engine=INNODB查看建表语句\nshow create table t_x;\n完整的建表语句\n CREATE TABLE `t_x` (  `id` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n注意：\n\n在mysql中凡是标识符都可以使用飘号 `` 括起来。最好别用，不通用。mysql默认使用的存储引擎是InnoDB方式。默认的采用的字符集是UTF8。\n查看表的引擎\nSHOW TABLE STATUS LIKE \'表名\'\n2、什么是存储引擎存储引擎只有在mysql中存在，在oracle中叫表的存储方式。\nmysql支持很多种存储方式，每一种存储方式都有优缺点，需要在合适的时机选择适合的存储引擎。\n3、查看mysql当前支持的存储引擎指令：show engines \\G\n共有如下9种存储引擎\nshow engines \\G*************************** 1. row ***************************      Engine: MEMORY     Support: YES     Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 2. row ***************************      Engine: MRG_MYISAM     Support: YES     Comment: Collection of identical MyISAM tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 3. row ***************************      Engine: CSV     Support: YES     Comment: CSV storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 4. row ***************************      Engine: FEDERATED     Support: NO     Comment: Federated MySQL storage engineTransactions: NULL          XA: NULL  Savepoints: NULL*************************** 5. row ***************************      Engine: PERFORMANCE_SCHEMA     Support: YES     Comment: Performance SchemaTransactions: NO          XA: NO  Savepoints: NO*************************** 6. row ***************************      Engine: MyISAM     Support: YES     Comment: MyISAM storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 7. row ***************************      Engine: InnoDB     Support: DEFAULT     Comment: Supports transactions, row-level locking, and foreign keysTransactions: YES          XA: YES  Savepoints: YES*************************** 8. row ***************************      Engine: BLACKHOLE     Support: YES     Comment: /dev/null storage engine (anything you write to it disappears)Transactions: NO          XA: NO  Savepoints: NO*************************** 9. row ***************************      Engine: ARCHIVE     Support: YES     Comment: Archive storage engineTransactions: NO          XA: NO  Savepoints: NO\n\n4、常见的存储引擎MyISAM存储引擎      Engine: MyISAM     Support: YES     Comment: MyISAM storage engineTransactions: NO          XA: NO  Savepoints: NO\nMyISAM存储引擎是mysql中最常用的引擎，适合少修改，多查询的表\n他管理的表的特点：\n\n使用三个文件来表示每个表\n格式文件：存储表结构的定义（t_student.frm）数据文件：存储表行的内容（t_student.MYD）索引文件：存储表上的索引（t_student.MYI）\n灵活的AUTO_INCREMENT字段处理可转换为压缩、只读表来节省空间缺点：不支持事务，不支持外键\nInnoDB存储引擎默认的存储引擎\n      Engine: InnoDB     Support: DEFAULT     Comment: Supports transactions, row-level locking, and foreign keysTransactions: YES          XA: YES  Savepoints: YES\n特点：\n\n优点：\n支持事务、行级锁、外键约束安全\n缺点：\n\n数据存储在表空间tablespace，无法被压缩\n每个 InnoDB表在数据库目录中以.frm格式文件表示\nInnoDB表空间tablespace 被用于存储表的内容提供一组用于记录事务性活动的日志文件用 COMMIT（提交）、SAVEPOINT 及 ROLLBACK（回滚）支持事务处理提供 全 ACID兼容在 mysql 服务器崩溃后会自动修复多版本（MVCC）和行级锁定支持外键及引用的完整性，包括级联删除和更新\nMEMORY存储引擎      Engine: MEMORY     Support: YES     Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO          XA: NO  Savepoints: NO\n特点：\n\n在数据库目录内，每个表均为.frm格式的文件表示表数据及索引被存储在内存中表级锁机制不能包含 TEXT 或 BLOB 字段优点：\n速度快\n缺点：\n数据容易丢失不支持事务\n\n5、修改数据库表的存储引擎方式1:将mysql.ini中default-storage-engine=InnoDB，重启服务.\n方式2:建表时指定  CREATE TABLE 表名(…)ENGINE=MYISAM;\n方式3:建表后修改  ALTER TABLE 表名 ENGINE = INNODB;\n', 0, 1);
INSERT INTO `t_article` VALUES (144, '07、事务（TCL）', 8, '\n\n## 1、什么是事务（Transaction）\n\n一个事务是一个完整的业务逻辑单元，不可拆分。\n\n比如：银行转账，A账户给B账户转账10000，需要执行2条update的语句。\n\n​	A余额减少10000\n\n​	B余额增加10000\n\n以上两条数据，要么同时成功，要么同时失败。\n\n要想保证以上两条数据，要么同时成功，要么同时失败，就需要使用数据库的事务机制。\n\n\n\n## 2、事务什么时候使用\n\n**和事务相关的语句只有DML语句。（insert，delete，update）**\n\n因为DML语句都是和数据库表当中的数据有关的，事务的存在就是为了保证数据的完整性、安全性。\n\n**如果所有的业务都可以一条DML语搞定，就不需要事务了。**\n\n\n\n## 3、事务的四大特性：ACID\n\n**1 、原子性** \n事务是数据库的逻辑工作单位， 不可再分。\n**2 、一致性** \n事务必须保证多条DML语句要么同时成功，要么同时失败。\n**3 、隔离性** \n事务必须是使数据库从一个一致性状态变到另一个一致性状态。\n**4 、持续性** \n持久性就是最终数据必须持久化到硬盘文件中，事务才算完成。\n\n\n\n## 4、事务之间的隔离性\n\n隔离级别包括4个：\n\n- 第一级别：读未提交（Read Uncommitted）\n  - 可以读取对方未提交的数据\n  - 存在脏读（Dirty Read）现象，读到了脏数据，读到的数据可能已经改变了。\n- 第二级别：读已提交（Read Committed）\n  - 大多数数据库系统默认的初始状态，Oracle数据库默认级别，mysql是第三级别初始。\n  - 可以读取对方提交后的数据\n  - 解决了脏读现象\n  - 存在不可重复读，不可重读读意味着我们同一事务执行完全相同的select语句时可能看到不一样的结果。\n- 第三级别：可重复读（Repeatable Read）\n  - 这是MySQL的默认事务隔离级别\n  - 它确保同一事务的多个实例在并发读取数据时，看到同样的数据行\n  - 解决了不可重复读\n  - 存在幻读现象（Phantom Read），当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行\n- 第四级别：可串行化/序列化（serializable）\n  - 最高的隔离级别\n  - 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它在每个读的数据行上加上共享锁。\n  - 缺点：\n    - 效率低\n    - 可能导致大量的超时现象和锁竞争\n\n## 5、演示事务\n\nmysql默认情况是自动提交的。\n\n关闭自动提交：\n\n```sql\nstart transaction;\n```\n\n\n\n准备表：\n\n```\ndrop table if exists t_user;\ncreate table t_user(\n	id int primary key auto_increment,\n	username varchar(255)\n);\n```\n\n\n\n演示：\n\n（1）mysql中事务是自动提交的：\n\n```sql\ninsert t_user (username) values(\'张三\');\nselect * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n+----+----------+\n\nrollback;\nselect * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n+----+----------+\n```\n\n（2）关闭自动提交事务：三种方式\n\n​				start transaction;\n\n​				set global autocommit=0;\n\n​				set session autocommit=0\n\n（3）rollback：  回滚到开始事务的地方\n\n```sql\nstart transaction;\ninsert t_user (username) values(\'李四\');\nselect * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n+----+----------+\n\nrollback;\nselect * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n+----+----------+\n```\n\n（3）提交 commit，把这次事务提交。\n\nrollback 只能回滚到这次事务的开始位置，如果已经提交了，就不能在回滚了。\n\n```sql\nstart transaction;\ninsert t_user (username) values(\'李四\');\ninsert t_user (username) values(\'王五\');\nselect * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n|  3 | 王五     |\n+----+----------+\n\ncommit;\nselect * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n|  3 | 王五     |\n+----+----------+\n\nrollback;\nselect * from t_user;\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n|  3 | 王五     |\n+----+----------+\n```\n\n\n\n**（4）演示隔离级别**\n\n设置事务的全局隔离级别：\n\n```sql\nset global transaction isolation level read uncommitted;\n```\n\n查看事务的全局隔离界别：\n\n```\nSELECT @@global.transaction_isolation;\n+--------------------------------+\n| @@global.transaction_isolation |\n+--------------------------------+\n| READ-UNCOMMITTED               |\n+--------------------------------+\n```\n\n\n\n**1）演示 读未提交（Read Uncommitted）**\n\nA事务 查询到了 B事务未提交的数据（脏读）\n\n先设置隔离界别：设置完成之后需要关闭\n\n```sql\nmysql -uroot -p123456\nuse bookshop\nset global transaction isolation level read uncommitted;\nSELECT @@global.transaction_isolation;\n+--------------------------------+\n| @@global.transaction_isolation |\n+--------------------------------+\n| READ-UNCOMMITTED               |\n+--------------------------------+\n```\n\n需要开启两个窗口演示\n\n窗口1：\n\n```sql\nmysql -uroot -p123456\nuse bookshop\nstart transaction;\nselect * from t_user;\ninsert t_user(username) values (\'麻六\');\n```\n\n\n\n窗口2：\n\n```sql\nmysql -uroot -p123456\nuse bookshop\n\nstart transaction;\n\nselect * from t_user;				//起始的查询\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n|  3 | 王五     |\n|  4 | 王五     |\n+----+----------+\nselect * from t_user;				//未提交之前的查询\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n|  3 | 王五     |\n|  4 | 王五     |\n|  5 | 麻六     |\n+----+----------+\n```\n\n\n\n\n\n**2）演示读已提交（Read Committed）**\n\n先设置隔离界别：设置完成之后需要关闭\n\n```sql\nmysql -uroot -p123456\nuse bookshop\nset global transaction isolation level read committed;\nSELECT @@global.transaction_isolation;\n+--------------------------------+\n| @@global.transaction_isolation |\n+--------------------------------+\n| READ-COMMITTED                 |\n+--------------------------------+\n```\n\n需要开启两个窗口演示\n\n窗口1：\n\n```sql\nmysql -uroot -p123456\nuse bookshop\nstart transaction;\nselect * from t_user;\ninsert t_user(username) values (\'唐三\');\ncommit;\n```\n\n\n\n窗口2：\n\n```sql\nmysql -uroot -p123456\nuse bookshop\n\nstart transaction;\n\nselect * from t_user;			//起始的查询\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n|  3 | 王五     |\n|  4 | 王五     |\n+----+----------+\nselect * from t_user;			//未提交之前的查询\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n|  3 | 王五     |\n|  4 | 王五     |\n+----+----------+\n\nselect * from t_user;			//提交之后的查询\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n|  3 | 王五     |\n|  4 | 王五     |\n|  6 | 唐三     |\n+----+----------+\n```\n\n\n\n**3）演示可重复读（Repeatable Read）**\n\n先设置隔离界别：设置完成之后需要关闭\n\n```sql\nmysql -uroot -p123456\nuse bookshop\nset global transaction isolation level Repeatable Read;\nSELECT @@global.transaction_isolation;\n+--------------------------------+\n| @@global.transaction_isolation |\n+--------------------------------+\n| REPEATABLE-READ                |\n+--------------------------------+\n```\n\n需要开启两个窗口演示\n\n窗口1：\n\n```sql\nmysql -uroot -p123456\nuse bookshop\nstart transaction;\nselect * from t_user;\ndelete from t_user;\ncommit;\n```\n\n\n\n窗口2：\n\n```sql\nmysql -uroot -p123456\nuse bookshop\nstart transaction;\nselect * from t_user;			//起始的查询\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n|  3 | 王五     |\n|  4 | 王五     |\n|  6 | 唐三     |\n+----+----------+\n\nselect * from t_user;			//提交之后的查询\n+----+----------+\n| id | username |\n+----+----------+\n|  1 | 张三     |\n|  2 | 李四     |\n|  3 | 王五     |\n|  4 | 王五     |\n|  6 | 唐三     |\n+----+----------+\n```\n\n\n\n**4）演示可串行化/序列化（serializable）**\n\n先设置隔离界别：设置完成之后需要关闭\n\n```sql\nmysql -uroot -p123456\nuse bookshop\nset global transaction isolation level serializable;\nSELECT @@global.transaction_isolation;\n+--------------------------------+\n| @@global.transaction_isolation |\n+--------------------------------+\n| SERIALIZABLE                   |\n+--------------------------------+\n```\n\n需要开启两个窗口演示\n\n窗口1：\n\n```sql\nmysql -uroot -p123456\nuse bookshop\nstart transaction;\ninsert t_user(username) values (\'唐三\');\ncommit;\n```\n\n\n\n窗口2：\n\n```sql\nmysql -uroot -p123456\nuse bookshop\nstart transaction;\nselect * from t_user;			//起始的查询\n+----+----------+\n| id | username |\n+----+----------+\n|  7 | 张三     |\n+----+----------+\n\nselect * from t_user;			//提交之前的查询\n//会一直卡在这块，当窗口一提交的时候，才能接着运行\n\n//提交之后\n+----+----------+\n| id | username |\n+----+----------+\n|  7 | 张三     |\n+----+----------+\n```\n\n\n\n## 6、锁机制\n\n  	首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。\n\n​      锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。\n\n**行锁与表锁：**\n\n 	按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。\n\n**读锁/写锁：**\n\n读锁：共享锁  乐观锁\n写锁：排它锁', 0, 0, '2020-08-07 01:17:42', 2, 0, 1, '1、什么是事务（Transaction）一个事务是一个完整的业务逻辑单元，不可拆分。\n比如：银行转账，A账户给B账户转账10000，需要执行2条update的语句。\n​    A余额减少10000\n​    B余额增加10000\n以上两条数据，要么同时成功，要么同时失败。\n要想保证以上两条数据，要么同时成功，要么同时失败，就需要使用数据库的事务机制。\n2、事务什么时候使用和事务相关的语句只有DML语句。（insert，delete，update）\n因为DML语句都是和数据库表当中的数据有关的，事务的存在就是为了保证数据的完整性、安全性。\n如果所有的业务都可以一条DML语搞定，就不需要事务了。\n3、事务的四大特性：ACID1 、原子性事务是数据库的逻辑工作单位， 不可再分。2 、一致性事务必须保证多条DML语句要么同时成功，要么同时失败。3 、隔离性事务必须是使数据库从一个一致性状态变到另一个一致性状态。4 、持续性持久性就是最终数据必须持久化到硬盘文件中，事务才算完成。\n4、事务之间的隔离性隔离级别包括4个：\n\n第一级别：读未提交（Read Uncommitted）\n可以读取对方未提交的数据存在脏读（Dirty Read）现象，读到了脏数据，读到的数据可能已经改变了。\n第二级别：读已提交（Read Committed）\n大多数数据库系统默认的初始状态，Oracle数据库默认级别，mysql是第三级别初始。可以读取对方提交后的数据解决了脏读现象存在不可重复读，不可重读读意味着我们同一事务执行完全相同的select语句时可能看到不一样的结果。\n第三级别：可重复读（Repeatable Read）\n这是MySQL的默认事务隔离级别它确保同一事务的多个实例在并发读取数据时，看到同样的数据行解决了不可重复读存在幻读现象（Phantom Read），当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行\n第四级别：可串行化/序列化（serializable）\n最高的隔离级别它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它在每个读的数据行上加上共享锁。缺点：\n效率低可能导致大量的超时现象和锁竞争\n\n\n5、演示事务mysql默认情况是自动提交的。\n关闭自动提交：\nstart transaction;\n准备表：\ndrop table if exists t_user;create table t_user(    id int primary key auto_increment,    username varchar(255));演示：\n（1）mysql中事务是自动提交的：\ninsert t_user (username) values(\'张三\');select * from t_user;+----+----------+| id | username |+----+----------+|  1 | 张三     |+----+----------+rollback;select * from t_user;+----+----------+| id | username |+----+----------+|  1 | 张三     |+----+----------+\n（2）关闭自动提交事务：三种方式\n​                start transaction;\n​                set global autocommit=0;\n​                set session autocommit=0\n（3）rollback：  回滚到开始事务的地方\nstart transaction;insert t_user (username) values(\'李四\');select * from t_user;+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     |+----+----------+rollback;select * from t_user;+----+----------+| id | username |+----+----------+|  1 | 张三     |+----+----------+\n（3）提交 commit，把这次事务提交。\nrollback 只能回滚到这次事务的开始位置，如果已经提交了，就不能在回滚了。\nstart transaction;insert t_user (username) values(\'李四\');insert t_user (username) values(\'王五\');select * from t_user;+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     ||  3 | 王五     |+----+----------+commit;select * from t_user;+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     ||  3 | 王五     |+----+----------+rollback;select * from t_user;+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     ||  3 | 王五     |+----+----------+\n（4）演示隔离级别\n设置事务的全局隔离级别：\nset global transaction isolation level read uncommitted;\n查看事务的全局隔离界别：\nSELECT @@global.transaction_isolation;+--------------------------------+| @@global.transaction_isolation |+--------------------------------+| READ-UNCOMMITTED               |+--------------------------------+1）演示 读未提交（Read Uncommitted）\nA事务 查询到了 B事务未提交的数据（脏读）\n先设置隔离界别：设置完成之后需要关闭\nmysql -uroot -p123456use bookshopset global transaction isolation level read uncommitted;SELECT @@global.transaction_isolation;+--------------------------------+| @@global.transaction_isolation |+--------------------------------+| READ-UNCOMMITTED               |+--------------------------------+\n需要开启两个窗口演示\n窗口1：\nmysql -uroot -p123456use bookshopstart transaction;select * from t_user;insert t_user(username) values (\'麻六\');\n窗口2：\nmysql -uroot -p123456use bookshopstart transaction;select * from t_user;                //起始的查询+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     ||  3 | 王五     ||  4 | 王五     |+----+----------+select * from t_user;                //未提交之前的查询+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     ||  3 | 王五     ||  4 | 王五     ||  5 | 麻六     |+----+----------+\n2）演示读已提交（Read Committed）\n先设置隔离界别：设置完成之后需要关闭\nmysql -uroot -p123456use bookshopset global transaction isolation level read committed;SELECT @@global.transaction_isolation;+--------------------------------+| @@global.transaction_isolation |+--------------------------------+| READ-COMMITTED                 |+--------------------------------+\n需要开启两个窗口演示\n窗口1：\nmysql -uroot -p123456use bookshopstart transaction;select * from t_user;insert t_user(username) values (\'唐三\');commit;\n窗口2：\nmysql -uroot -p123456use bookshopstart transaction;select * from t_user;            //起始的查询+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     ||  3 | 王五     ||  4 | 王五     |+----+----------+select * from t_user;            //未提交之前的查询+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     ||  3 | 王五     ||  4 | 王五     |+----+----------+select * from t_user;            //提交之后的查询+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     ||  3 | 王五     ||  4 | 王五     ||  6 | 唐三     |+----+----------+\n3）演示可重复读（Repeatable Read）\n先设置隔离界别：设置完成之后需要关闭\nmysql -uroot -p123456use bookshopset global transaction isolation level Repeatable Read;SELECT @@global.transaction_isolation;+--------------------------------+| @@global.transaction_isolation |+--------------------------------+| REPEATABLE-READ                |+--------------------------------+\n需要开启两个窗口演示\n窗口1：\nmysql -uroot -p123456use bookshopstart transaction;select * from t_user;delete from t_user;commit;\n窗口2：\nmysql -uroot -p123456use bookshopstart transaction;select * from t_user;            //起始的查询+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     ||  3 | 王五     ||  4 | 王五     ||  6 | 唐三     |+----+----------+select * from t_user;            //提交之后的查询+----+----------+| id | username |+----+----------+|  1 | 张三     ||  2 | 李四     ||  3 | 王五     ||  4 | 王五     ||  6 | 唐三     |+----+----------+\n4）演示可串行化/序列化（serializable）\n先设置隔离界别：设置完成之后需要关闭\nmysql -uroot -p123456use bookshopset global transaction isolation level serializable;SELECT @@global.transaction_isolation;+--------------------------------+| @@global.transaction_isolation |+--------------------------------+| SERIALIZABLE                   |+--------------------------------+\n需要开启两个窗口演示\n窗口1：\nmysql -uroot -p123456use bookshopstart transaction;insert t_user(username) values (\'唐三\');commit;\n窗口2：\nmysql -uroot -p123456use bookshopstart transaction;select * from t_user;            //起始的查询+----+----------+| id | username |+----+----------+|  7 | 张三     |+----+----------+select * from t_user;            //提交之前的查询//会一直卡在这块，当窗口一提交的时候，才能接着运行//提交之后+----+----------+| id | username |+----+----------+|  7 | 张三     |+----+----------+\n6、锁机制  首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。​      锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。\n行锁与表锁：\n 按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。读锁/写锁：\n读锁：共享锁  乐观锁写锁：排它锁\n', 0, 1);
INSERT INTO `t_article` VALUES (145, '08、索引', 8, '\n\n## 1、什么是索引？\n\n索引就相当于一本书的目录，通过目录可以快速找到对应的资源。\n\n在数据库，查询一张表的时候有两种检索方式：\n\n（1）全表扫描\n\n（2）根据索引扫描（效率很高）\n\n索引为什么可以提高检索效率呢？\n\n​	根本原理是缩小了扫描的范围。\n\n注意：\n\n- 索引虽然可以提高检索效率，但是不能随便添加索引\n- 因为索引也是数据库当中的对象，也需要数据库不断的维护，是有维护成本的。\n- 如果表中数据经常被修改，就不适合使用索引，因为表中数据一旦修改，索引需要重新排序，进行维护\n\n## 2、什么时候考虑给字段添加索引？\n\n- 数据量庞大（根据客户的需求，根据线上的环境）\n- 该字段的DML语句很少（因为字段进行修改操作，索引也需要维护）\n- 该字段经常出现在where子句中（经常根据那个字段查询）\n\n\n\n### 3、注意\n\n主键和具有unique约束的字段会自动添加索引\n\n根据主键查询效率高，尽量使用主键查询\n\n\n\n## 4、查看sql语句的执行情况\n\n```\nmysql> explain select ename ,sal from emp where sal = 5000;\n\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   14 |    10.00 | Using where |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n```\n\n\n\n## 5、如何创建索引\n\n语法：\n\n创建索引：\n\n```sql\ncreate index 索引名称 on 表名(字段名);\n```\n\n删除索引：\n\n```sql\ndrop index 索引名称 on 表名;\n```\n\n\n\n查看sql语句执行情况\n\n```sql\nmysql> create index emp_sal_index on emp(sal);\nmysql> explain select ename ,sal from emp where sal = 5000;\n+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+\n| id | select_type | table | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra |\n+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+\n|  1 | SIMPLE      | emp   | NULL       | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 |   100.00 | NULL  |\n+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+\n\nmysql> drop index emp_sal_index on emp;\nmysql> explain select ename ,sal from emp where sal = 5000;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   14 |    10.00 | Using where |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n\n```\n\n\n\n## 6、索引的底层结构\n\n底层的数据结构：B+Tree\n\n\n\n## 7、索引的原理\n\n![QQ截图20200617090420](./image/QQ截图20200617090420.jpg)\n\n\n\n通过B Tree缩小扫描范围，底层索引进行了排序、分区，索引会携带数据在表中的“物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位到表中的数据，效率得到提高。\n\nselect ename from emp where ename = \'SMITH\';\n\n通过索引转换为：\n\nselect ename from emp where 物理地址 = 0x3;\n\n\n\n## 8、索引的分类\n\n- 单一索引\n\n  - 给单个字段添加索引\n\n  ```mysql\n  CREATE INDEX index_sex ON  t_test(sex); \n  DROP INDEX index_sex ON t_test;\n  ```\n\n- 复合索引\n\n  - 给多个字段联合起来添加1个索引\n\n  ```mysql\n  CREATE INDEX index_account_sex ON t_test(account,sex); \n  ```\n\n- 唯一索引\n\n  - 有unique约束的字段会自动添加索引\n\n  ```mysql\n   CREATE UNIQUE INDEX index_account ON  t_test(account);\n  ```\n\n- 外键索引\n\n  - 给外键添加索引\n\n  ```mysql\n  ALTER TABLE t_user ADD FOREIGN KEY(dept_id) REFERENCES t_dept(id)\n  ```\n\n  \n\n\n\n## 9、索引什么时候失效\n\n```sql\nselect ename from emp ename like \'%A%\';\n```\n\n模糊查询的时候，第一个通配符使用的%，这个时候索引是失效的，只能全表查询。', 0, 0, '2020-08-07 01:18:14', 2, 0, 1, '1、什么是索引？索引就相当于一本书的目录，通过目录可以快速找到对应的资源。\n在数据库，查询一张表的时候有两种检索方式：\n（1）全表扫描\n（2）根据索引扫描（效率很高）\n索引为什么可以提高检索效率呢？\n​    根本原理是缩小了扫描的范围。\n注意：\n\n索引虽然可以提高检索效率，但是不能随便添加索引因为索引也是数据库当中的对象，也需要数据库不断的维护，是有维护成本的。如果表中数据经常被修改，就不适合使用索引，因为表中数据一旦修改，索引需要重新排序，进行维护\n2、什么时候考虑给字段添加索引？\n数据量庞大（根据客户的需求，根据线上的环境）该字段的DML语句很少（因为字段进行修改操作，索引也需要维护）该字段经常出现在where子句中（经常根据那个字段查询）\n3、注意主键和具有unique约束的字段会自动添加索引\n根据主键查询效率高，尽量使用主键查询\n4、查看sql语句的执行情况mysql> explain select ename ,sal from emp where sal = 5000;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   14 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+5、如何创建索引语法：\n创建索引：\ncreate index 索引名称 on 表名(字段名);\n删除索引：\ndrop index 索引名称 on 表名;\n查看sql语句执行情况\nmysql> create index emp_sal_index on emp(sal);mysql> explain select ename ,sal from emp where sal = 5000;+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+|  1 | SIMPLE      | emp   | NULL       | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+-------+mysql> drop index emp_sal_index on emp;mysql> explain select ename ,sal from emp where sal = 5000;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   14 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n6、索引的底层结构底层的数据结构：B+Tree\n7、索引的原理\n通过B Tree缩小扫描范围，底层索引进行了排序、分区，索引会携带数据在表中的“物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位到表中的数据，效率得到提高。\nselect ename from emp where ename = ‘SMITH’;\n通过索引转换为：\nselect ename from emp where 物理地址 = 0x3;\n8、索引的分类\n单一索引\n\n给单个字段添加索引\nCREATE INDEX index_sex ON  t_test(sex); DROP INDEX index_sex ON t_test;\n复合索引\n\n给多个字段联合起来添加1个索引\nCREATE INDEX index_account_sex ON t_test(account,sex);\n唯一索引\n\n有unique约束的字段会自动添加索引\n CREATE UNIQUE INDEX index_account ON  t_test(account);\n外键索引\n\n给外键添加索引\nALTER TABLE t_user ADD FOREIGN KEY(dept_id) REFERENCES t_dept(id)\n\n9、索引什么时候失效select ename from emp ename like \'%A%\';\n模糊查询的时候，第一个通配符使用的%，这个时候索引是失效的，只能全表查询。\n', 0, 1);
INSERT INTO `t_article` VALUES (146, '09、视图（view）', 8, '\n\n## 1、什么是视图？\n\n站在不同的角度看到数据。（同一张表的数据，通过不同的角度去看待）。\n\n\n\n## 2、视图的使用\n\n创建一张备用表\n\n```sql\ncreate table emp1 as select * from emp;\n```\n\n创建视图\n\n```sql\ncreate view myview as select empno,ename from emp1;\n```\n\n删除视图\n\n```sql\ndrop view myview;\n```\n\n注意：只有DQL语句才能以视图对象的形式创建出来。\n\n\n\n## 3、视图的操作\n\n对视图的操作，会影响到原表的数据。（通过视图影响原表数据的，不是直接操作的原表）\n\n可以对视图进行CRUD。\n\n对视图的查询：\n\n```sql\nselect * from myview;\n+-------+--------+\n| empno | ename  |\n+-------+--------+\n|  7369 | SMITH  |\n|  7499 | ALLEN  |\n|  7521 | WARD   |\n|  7566 | JONES  |\n|  7654 | MARTIN |\n|  7698 | BLAKE  |\n|  7782 | CLARK  |\n|  7788 | SCOTT  |\n|  7839 | KING   |\n|  7844 | TURNER |\n|  7876 | ADAMS  |\n|  7900 | JAMES  |\n|  7902 | FORD   |\n|  7934 | MILLER |\n+-------+--------+\n```\n\n插入：（通过视图插入数据）\n\n```sql\ninsert into myview(empno,ename) values (7777,\'李四\');\n```\n\n更新：（通过视图修改原表数据）\n\n```sql\nupdate myview set ename=\'张三\' where empno=7369;\n```\n\n删除：（通过视图删除原表数据）\n\n```sql\ndelete from myview where empno = 7499;\n```\n\n查询原表：\n\n```sql\nselect * from emp1;\n\n+-------+--------+-----------+------+------------+---------+---------+--------+\n| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n|  7369 | 张三   | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |\n|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |\n|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |\n|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |\n|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |\n|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |\n|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |\n|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |\n|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |\n|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |\n|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |\n|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |\n|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |\n|  7777 | 李四   | NULL      | NULL | NULL       |    NULL |    NULL |   NULL |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n```\n\n\n\n## 4、视图的作用\n\n视图可以隐藏表的实现细节，保密级别高的系统，数据库只对外开放视图，java程序员只对视图进行CRUD。', 0, 0, '2020-08-07 01:18:39', 2, 0, 1, '1、什么是视图？站在不同的角度看到数据。（同一张表的数据，通过不同的角度去看待）。\n2、视图的使用创建一张备用表\ncreate table emp1 as select * from emp;\n创建视图\ncreate view myview as select empno,ename from emp1;\n删除视图\ndrop view myview;\n注意：只有DQL语句才能以视图对象的形式创建出来。\n3、视图的操作对视图的操作，会影响到原表的数据。（通过视图影响原表数据的，不是直接操作的原表）\n可以对视图进行CRUD。\n对视图的查询：\nselect * from myview;+-------+--------+| empno | ename  |+-------+--------+|  7369 | SMITH  ||  7499 | ALLEN  ||  7521 | WARD   ||  7566 | JONES  ||  7654 | MARTIN ||  7698 | BLAKE  ||  7782 | CLARK  ||  7788 | SCOTT  ||  7839 | KING   ||  7844 | TURNER ||  7876 | ADAMS  ||  7900 | JAMES  ||  7902 | FORD   ||  7934 | MILLER |+-------+--------+\n插入：（通过视图插入数据）\ninsert into myview(empno,ename) values (7777,\'李四\');\n更新：（通过视图修改原表数据）\nupdate myview set ename=\'张三\' where empno=7369;\n删除：（通过视图删除原表数据）\ndelete from myview where empno = 7499;\n查询原表：\nselect * from emp1;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | 张三   | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 ||  7777 | 李四   | NULL      | NULL | NULL       |    NULL |    NULL |   NULL |+-------+--------+-----------+------+------------+---------+---------+--------+\n4、视图的作用视图可以隐藏表的实现细节，保密级别高的系统，数据库只对外开放视图，java程序员只对视图进行CRUD。\n', 0, 1);
INSERT INTO `t_article` VALUES (147, '10、DBA命令', 8, '\n\n## 1、新建用户\n\n语法：\n\n```sql\nCREATE USER username IDENTIFIED BY \'password\';\n```\n\n- username：你将创建的用户名,\n- password：该用户的登陆密码,密码可以为空,如果为空则该用户可以丌需要密码登陆服务器.\n\n示例：\n\n```sql\ncreate user 86god identified by \'123456\';\n```\n\n\n\n## 2、授权\n\n### 2.1 命令详解\n\n**语法格式：**\n\n```sql\ngrant all privileges on dbname.tbname to \'username\'@\'login ip\' identified by \'password\' with grant option;\n```\n\n1) dbname=*表示所有数据库\n\n2) tbname=*表示所有表\n\n3) login ip=%表示任何ip\n\n4) password为空，表示丌需要密码即可登录\n\n5) with grant option; 表示该用户还可以授权给其他用户\n\n**授权步骤：**\n\n1、首先以root用户进入mysql\n\n2、然后键入命令：\n\n```sql\ngrant select,insert,update,delete on *.* to \'86god\'@\'%\'; \n```\n\n3、如果希望该用户能够在任何机器上登陆mysql，则将localhost改为 \"%\" 。\n\n**我们测试用户一般使用该命令授权：**\n\n```sql\nGRANT ALL ON *.* TO \'86god\'@\'%\';\n```\n\n注意：用以上命令授权的用户丌能给其它用户授权,如果想让该用户可以授权,用以下命令:\n\n```sql\nGRANT ALL ON *.* TO \'86god\'@\'%\' WITH GRANT OPTION;\n```\n\n\n\n用户权限privileges：\n\n| 权限名 | 权限描述           |\n| ------ | ------------------ |\n| alter  | 修改数据库的表     |\n| create | 创建新的数据库戒表 |\n| delete | 删除表数据         |\n| drop   | 删除数据库/表      |\n| index  | 创建/删除索引      |\n| insert | 添加表数据         |\n| select | 查询表数据         |\n| update | 更新表数据         |\n| all    | 允许任何操作       |\n| usage  | 只允许登录         |\n\n\n\n### 2.2 回收授权\n\n命令格式：\n\n```sql\nrevoke privileges on dbname[.tbname] from username;\n```\n\n示例：\n\n```sql\nrevoke all privileges on *.* from 86god;\n```\n\n刷新权限:\n\n```sql\nflush privileges;\n```\n\n\n\n\n\n## 3、数据库导入导出\n\n### 3.1 导出：mysqldump\n\n在windows的dos命令窗口执行：\n\n导出整个数据库（注意是dos命令，应该退出mysql语句输入）\n\n```sql\nC:\\Users\\25849>mysqldump bookshop>D:\\bookshop.sql -uroot -p123456\n```\n\n导出指定库下的指定表\n\n```sql\nC:\\Users\\25849>mysqldump bookshop emp> D:\\ bookshop_emp.sql -uroot -p123456\n```\n\n\n\n### 3.2 导入：source\n\n```sql\nC:\\Users\\25849>mysql -uroot -p123456\nmysql>create database bookshop;\nmysql>use bookshop;\nmysql>source D:\\bookshop.sql\n```\n\n', 0, 0, '2020-08-07 01:19:18', 2, 0, 1, '1、新建用户语法：\nCREATE USER username IDENTIFIED BY \'password\';\n\nusername：你将创建的用户名,password：该用户的登陆密码,密码可以为空,如果为空则该用户可以丌需要密码登陆服务器.\n示例：\ncreate user 86god identified by \'123456\';\n2、授权2.1 命令详解语法格式：\ngrant all privileges on dbname.tbname to \'username\'@\'login ip\' identified by \'password\' with grant option;\n1) dbname=*表示所有数据库\n2) tbname=*表示所有表\n3) login ip=%表示任何ip\n4) password为空，表示丌需要密码即可登录\n5) with grant option; 表示该用户还可以授权给其他用户\n授权步骤：\n1、首先以root用户进入mysql\n2、然后键入命令：\ngrant select,insert,update,delete on *.* to \'86god\'@\'%\';\n3、如果希望该用户能够在任何机器上登陆mysql，则将localhost改为 “%” 。\n我们测试用户一般使用该命令授权：\nGRANT ALL ON *.* TO \'86god\'@\'%\';\n注意：用以上命令授权的用户丌能给其它用户授权,如果想让该用户可以授权,用以下命令:\nGRANT ALL ON *.* TO \'86god\'@\'%\' WITH GRANT OPTION;\n用户权限privileges：\n\n\n\n权限名\n权限描述\n\n\n\n\nalter\n修改数据库的表\n\n\ncreate\n创建新的数据库戒表\n\n\ndelete\n删除表数据\n\n\ndrop\n删除数据库/表\n\n\nindex\n创建/删除索引\n\n\ninsert\n添加表数据\n\n\nselect\n查询表数据\n\n\nupdate\n更新表数据\n\n\nall\n允许任何操作\n\n\nusage\n只允许登录\n\n\n\n2.2 回收授权命令格式：\nrevoke privileges on dbname[.tbname] from username;\n示例：\nrevoke all privileges on *.* from 86god;\n刷新权限:\nflush privileges;\n3、数据库导入导出3.1 导出：mysqldump在windows的dos命令窗口执行：\n导出整个数据库（注意是dos命令，应该退出mysql语句输入）\nC:\\Users\\25849>mysqldump bookshop>D:\\bookshop.sql -uroot -p123456\n导出指定库下的指定表\nC:\\Users\\25849>mysqldump bookshop emp> D:\\ bookshop_emp.sql -uroot -p123456\n3.2 导入：sourceC:\\Users\\25849>mysql -uroot -p123456mysql>create database bookshop;mysql>use bookshop;mysql>source D:\\bookshop.sql\n', 0, 1);
INSERT INTO `t_article` VALUES (148, '11、数据库设计三范式', 8, '\n\n## 1、什么是设计范式？\n\n设计表的依据，按照三范式设计的表不会出现数据冗余。\n\n\n\n## 2、三范式\n\n满足三范式的目的是，减少数据冗余。\n\n### 第一范式：\n\n任何一张表都应该有主键，并且每一个字段都不能再分。\n\n| 学生编号 | 学生姓名 | 联系方式                 |\n| -------- | -------- | ------------------------ |\n| 1001     | 张三     | zs@gmail.com,1359999999  |\n| 1002     | 李四     | ls@gmail.com,13699999999 |\n| 1003     | 王五     | ww@163.net,13488888888   |\n\n上表违背了第一范式：\n\n（1）没有主键\n\n（2）联系方式字段可以再分\n\n**解决方式：**\n\n| 学生编号(pk) | 学生姓名 | e-mail       | 联系电话    |\n| ------------ | -------- | ------------ | ----------- |\n| 1001         | 张三     | zs@gmail.com | 1359999999  |\n| 1002         | 李四     | ls@gmail.com | 13699999999 |\n| 1003         | 王五     | ww@163.net   | 13488888888 |\n\n\n\n### 第二范式：\n\n建立在第一范式的基础之上，所有非主键字段必须完全依赖主键，不能产生部分依赖。\n\n\n\n| 学生编号（pk） | 教师编号（pk） | 学生姓名 | 教师姓名 |\n| -------------- | -------------- | -------- | -------- |\n| 1              | 1              | 张三     | 张老师   |\n| 1              | 2              | 张三     | 李老师   |\n| 2              | 2              | 李四     | 李老师   |\n| 2              | 3              | 李四     | 王老师   |\n| 3              | 1              | 王五     | 张老师   |\n| 3              | 3              | 王五     | 王老师   |\n\n上表为多对多关系，并且是学生编号和教师编号形成的联合主键，并且每一列都不可再分，因此满足第一范式。但是学生姓名只依赖于学生编号，并非依赖教师编号，因此形成了部分依赖，所以不满足第二范式。\n\n**解决方法：**\n\n多对多，三张表，关系表两个外键。\n\n**t_student学生表：**\n\n| sno(pk) | sname |\n| ------- | ----- |\n| 1       | 张三  |\n| 2       | 李四  |\n| 3       | 王五  |\n\n**t_teacher教师表：**\n\n| tno(pk) | tname  |\n| ------- | ------ |\n| 1       | 张老师 |\n| 2       | 李老师 |\n| 3       | 王老师 |\n\n**t_student_t_teacher_relation 学生老师关系表：**\n\n| id(pk) | sno(fk) | tno(fk) |\n| ------ | ------- | ------- |\n| 1      | 1       | 3       |\n| 2      | 1       | 1       |\n| 3      | 2       | 1       |\n| 4      | 2       | 2       |\n| 5      | 3       | 3       |\n| 6      | 3       | 2       |\n\n\n\n### 第三范式：\n\n建立在第二范式之上，所有非主键字段直接依赖主键，不能产生传递依赖。\n\n学生信息表：\n\n| 学生编号(pk) | 学生姓名 | 班级编号 | 班级名      |\n| ------------ | -------- | -------- | ----------- |\n| 1001         | 张三     | 01       | 高三（1）班 |\n| 1002         | 李四     | 01       | 高三（1）班 |\n| 1003         | 王五     | 02       | 高三（2）班 |\n| 1004         | 麻六     | 02       | 高三（2）班 |\n\n上述表：\n\n- 有主键，而且数据列不可再分，因此满足第一范式。\n- 非主键列对主键是完全依赖关系，满足第二范式。\n- 但是，班级名依赖于班级编号，而班级编号依赖于主键学生编号，产生了传递依赖关系，因此不满足第三范式。\n\n\n\n**解决方式：**\n\n一对多，两张表，多的表加外键。\n\n班级表：t_class\n\n| 班级编号(pk) | 班级名      |\n| ------------ | ----------- |\n| 01           | 高三（1）班 |\n| 02           | 高三（2）班 |\n\n学生信息表：t_student\n\n| 学生编号(pk) | 学生姓名 | 班级编号(fk) |\n| ------------ | -------- | ------------ |\n| 1001         | 张三     | 01           |\n| 1002         | 李四     | 01           |\n| 1003         | 王五     | 02           |\n| 1004         | 麻六     | 02           |\n\n\n\n提醒：\n\n在实际开发中，以满足客户的需求为主，有的时候会拿数据的冗余来换执行速度。\n\n', 0, 0, '2020-08-07 01:19:48', 2, 0, 1, '1、什么是设计范式？设计表的依据，按照三范式设计的表不会出现数据冗余。\n2、三范式满足三范式的目的是，减少数据冗余。\n第一范式：任何一张表都应该有主键，并且每一个字段都不能再分。\n\n\n\n学生编号\n学生姓名\n联系方式\n\n\n\n\n1001\n张三\nzs@gmail.com,1359999999\n\n\n1002\n李四\nls@gmail.com,13699999999\n\n\n1003\n王五\nww@163.net,13488888888\n\n\n\n上表违背了第一范式：\n（1）没有主键\n（2）联系方式字段可以再分\n解决方式：\n\n\n\n学生编号(pk)\n学生姓名\ne-mail\n联系电话\n\n\n\n\n1001\n张三\nzs@gmail.com\n1359999999\n\n\n1002\n李四\nls@gmail.com\n13699999999\n\n\n1003\n王五\nww@163.net\n13488888888\n\n\n\n第二范式：建立在第一范式的基础之上，所有非主键字段必须完全依赖主键，不能产生部分依赖。\n\n\n\n学生编号（pk）\n教师编号（pk）\n学生姓名\n教师姓名\n\n\n\n\n1\n1\n张三\n张老师\n\n\n1\n2\n张三\n李老师\n\n\n2\n2\n李四\n李老师\n\n\n2\n3\n李四\n王老师\n\n\n3\n1\n王五\n张老师\n\n\n3\n3\n王五\n王老师\n\n\n\n上表为多对多关系，并且是学生编号和教师编号形成的联合主键，并且每一列都不可再分，因此满足第一范式。但是学生姓名只依赖于学生编号，并非依赖教师编号，因此形成了部分依赖，所以不满足第二范式。\n解决方法：\n多对多，三张表，关系表两个外键。\nt_student学生表：\n\n\n\nsno(pk)\nsname\n\n\n\n\n1\n张三\n\n\n2\n李四\n\n\n3\n王五\n\n\n\nt_teacher教师表：\n\n\n\ntno(pk)\ntname\n\n\n\n\n1\n张老师\n\n\n2\n李老师\n\n\n3\n王老师\n\n\n\nt_student_t_teacher_relation 学生老师关系表：\n\n\n\nid(pk)\nsno(fk)\ntno(fk)\n\n\n\n\n1\n1\n3\n\n\n2\n1\n1\n\n\n3\n2\n1\n\n\n4\n2\n2\n\n\n5\n3\n3\n\n\n6\n3\n2\n\n\n\n第三范式：建立在第二范式之上，所有非主键字段直接依赖主键，不能产生传递依赖。\n学生信息表：\n\n\n\n学生编号(pk)\n学生姓名\n班级编号\n班级名\n\n\n\n\n1001\n张三\n01\n高三（1）班\n\n\n1002\n李四\n01\n高三（1）班\n\n\n1003\n王五\n02\n高三（2）班\n\n\n1004\n麻六\n02\n高三（2）班\n\n\n\n上述表：\n\n有主键，而且数据列不可再分，因此满足第一范式。非主键列对主键是完全依赖关系，满足第二范式。但是，班级名依赖于班级编号，而班级编号依赖于主键学生编号，产生了传递依赖关系，因此不满足第三范式。\n解决方式：\n一对多，两张表，多的表加外键。\n班级表：t_class\n\n\n\n班级编号(pk)\n班级名\n\n\n\n\n01\n高三（1）班\n\n\n02\n高三（2）班\n\n\n\n学生信息表：t_student\n\n\n\n学生编号(pk)\n学生姓名\n班级编号(fk)\n\n\n\n\n1001\n张三\n01\n\n\n1002\n李四\n01\n\n\n1003\n王五\n02\n\n\n1004\n麻六\n02\n\n\n\n提醒：\n在实际开发中，以满足客户的需求为主，有的时候会拿数据的冗余来换执行速度。\n', 0, 1);
INSERT INTO `t_article` VALUES (149, '12、数据库表的设计', 8, '## 1、一对一\n\n两种方案：\n\n### 1.1 主键共享\n\nt_user_login  用户登录表\n\n| id(pk) | user_name | password |\n| ------ | --------- | -------- |\n| 1      | zs        | 123      |\n| 2      | ls        | 123456   |\n\nt_user_detail  用户信息表\n\n| id(pk+fk) | real_name | tel         |\n| --------- | --------- | ----------- |\n| 1         | 张三      | 18888888888 |\n| 2         | 李四      | 13888888888 |\n\n\n\n### 1.2 外键唯一\n\nt_user_login  用户登录表\n\n| id(pk) | user_name | password |\n| ------ | --------- | -------- |\n| 1      | zs        | 123      |\n| 2      | ls        | 123456   |\n\nt_user_detail  用户信息表\n\n| id(pk) | real_name | tel         | user_id(fk+unique) |\n| ------ | --------- | ----------- | ------------------ |\n| 1      | 张三      | 18888888888 | 1                  |\n| 2      | 李四      | 13888888888 | 2                  |\n\n\n\n## 2、一对多\n\n一对多，两张表，多的表加外键。\n\n班级表：t_class\n\n| 班级编号(pk) | 班级名      |\n| ------------ | ----------- |\n| 01           | 高三（1）班 |\n| 02           | 高三（2）班 |\n\n学生信息表：t_student\n\n| 学生编号(pk) | 学生姓名 | 班级编号(fk) |\n| ------------ | -------- | ------------ |\n| 1001         | 张三     | 01           |\n| 1002         | 李四     | 01           |\n| 1003         | 王五     | 02           |\n| 1004         | 麻六     | 02           |\n\n\n\n## 3、多对多\n\n多对多，三张表，关系表两个外键。\n\n**t_student学生表：**\n\n| sno(pk) | sname |\n| ------- | ----- |\n| 1       | 张三  |\n| 2       | 李四  |\n| 3       | 王五  |\n\n**t_teacher教师表：**\n\n| tno(pk) | tname  |\n| ------- | ------ |\n| 1       | 张老师 |\n| 2       | 李老师 |\n| 3       | 王老师 |\n\n**t_student_t_teacher_relation 学生老师关系表：**\n\n| id(pk) | sno(fk) | tno(fk) |\n| ------ | ------- | ------- |\n| 1      | 1       | 3       |\n| 2      | 1       | 1       |\n| 3      | 2       | 1       |\n| 4      | 2       | 2       |\n| 5      | 3       | 3       |\n| 6      | 3       | 2       |\n\n', 0, 0, '2020-08-07 01:20:34', 2, 0, 1, '1、一对一两种方案：\n1.1 主键共享t_user_login  用户登录表\n\n\n\nid(pk)\nuser_name\npassword\n\n\n\n\n1\nzs\n123\n\n\n2\nls\n123456\n\n\n\nt_user_detail  用户信息表\n\n\n\nid(pk+fk)\nreal_name\ntel\n\n\n\n\n1\n张三\n18888888888\n\n\n2\n李四\n13888888888\n\n\n\n1.2 外键唯一t_user_login  用户登录表\n\n\n\nid(pk)\nuser_name\npassword\n\n\n\n\n1\nzs\n123\n\n\n2\nls\n123456\n\n\n\nt_user_detail  用户信息表\n\n\n\nid(pk)\nreal_name\ntel\nuser_id(fk+unique)\n\n\n\n\n1\n张三\n18888888888\n1\n\n\n2\n李四\n13888888888\n2\n\n\n\n2、一对多一对多，两张表，多的表加外键。\n班级表：t_class\n\n\n\n班级编号(pk)\n班级名\n\n\n\n\n01\n高三（1）班\n\n\n02\n高三（2）班\n\n\n\n学生信息表：t_student\n\n\n\n学生编号(pk)\n学生姓名\n班级编号(fk)\n\n\n\n\n1001\n张三\n01\n\n\n1002\n李四\n01\n\n\n1003\n王五\n02\n\n\n1004\n麻六\n02\n\n\n\n3、多对多多对多，三张表，关系表两个外键。\nt_student学生表：\n\n\n\nsno(pk)\nsname\n\n\n\n\n1\n张三\n\n\n2\n李四\n\n\n3\n王五\n\n\n\nt_teacher教师表：\n\n\n\ntno(pk)\ntname\n\n\n\n\n1\n张老师\n\n\n2\n李老师\n\n\n3\n王老师\n\n\n\nt_student_t_teacher_relation 学生老师关系表：\n\n\n\nid(pk)\nsno(fk)\ntno(fk)\n\n\n\n\n1\n1\n3\n\n\n2\n1\n1\n\n\n3\n2\n1\n\n\n4\n2\n2\n\n\n5\n3\n3\n\n\n6\n3\n2\n\n\n\n', 0, 1);
INSERT INTO `t_article` VALUES (150, '13、练习题', 8, '\n\n下面练习题，用到的表的创建语句，可以把下面数据保存到bookshop.sql文件，然后使用命令导入数据库，具体如何导入在本专栏的第一节有教程。\n\nbookshop.sql\n\n```sql\nDROP TABLE IF EXISTS EMP;\nDROP TABLE IF EXISTS DEPT;\nDROP TABLE IF EXISTS SALGRADE;\n\nCREATE TABLE DEPT\n       (DEPTNO int(2) not null ,\n	DNAME VARCHAR(14) ,\n	LOC VARCHAR(13),\n	primary key (DEPTNO)\n	);\nCREATE TABLE EMP\n       (EMPNO int(4)  not null ,\n	ENAME VARCHAR(10),\n	JOB VARCHAR(9),\n	MGR INT(4),\n	HIREDATE DATE  DEFAULT NULL,\n	SAL DOUBLE(7,2),\n	COMM DOUBLE(7,2),\n	primary key (EMPNO),\n	DEPTNO INT(2) \n	)\n	;\n\nCREATE TABLE SALGRADE\n      ( GRADE INT,\n	LOSAL INT,\n	HISAL INT );\n\n\nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( \n10, \'ACCOUNTING\', \'NEW YORK\'); \nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( \n20, \'RESEARCH\', \'DALLAS\'); \nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( \n30, \'SALES\', \'CHICAGO\'); \nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( \n40, \'OPERATIONS\', \'BOSTON\'); \ncommit;\n \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7369, \'SMITH\', \'CLERK\', 7902,  \'1980-12-17\'\n, 800, NULL, 20); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7499, \'ALLEN\', \'SALESMAN\', 7698,  \'1981-02-20\'\n, 1600, 300, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7521, \'WARD\', \'SALESMAN\', 7698,  \'1981-02-22\'\n, 1250, 500, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7566, \'JONES\', \'MANAGER\', 7839,  \'1981-04-02\'\n, 2975, NULL, 20); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7654, \'MARTIN\', \'SALESMAN\', 7698,  \'1981-09-28\'\n, 1250, 1400, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7698, \'BLAKE\', \'MANAGER\', 7839,  \'1981-05-01\'\n, 2850, NULL, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7782, \'CLARK\', \'MANAGER\', 7839,  \'1981-06-09\'\n, 2450, NULL, 10); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7788, \'SCOTT\', \'ANALYST\', 7566,  \'1987-04-19\'\n, 3000, NULL, 20); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7839, \'KING\', \'PRESIDENT\', NULL,  \'1981-11-17\'\n, 5000, NULL, 10); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7844, \'TURNER\', \'SALESMAN\', 7698,  \'1981-09-08\'\n, 1500, 0, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7876, \'ADAMS\', \'CLERK\', 7788,  \'1987-05-23\'\n, 1100, NULL, 20); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7900, \'JAMES\', \'CLERK\', 7698,  \'1981-12-03\'\n, 950, NULL, 30); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7902, \'FORD\', \'ANALYST\', 7566,  \'1981-12-03\'\n, 3000, NULL, 20); \nINSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,\nDEPTNO ) VALUES ( \n7934, \'MILLER\', \'CLERK\', 7782,  \'1982-01-23\'\n, 1300, NULL, 10); \ncommit;\n \nINSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( \n1, 700, 1200); \nINSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( \n2, 1201, 1400); \nINSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( \n3, 1401, 2000); \nINSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( \n4, 2001, 3000); \nINSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( \n5, 3001, 9999); \ncommit;\n```\n\n表数据：\n\n```sql\nmysql> select * from dept;\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n+--------+------------+----------+\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n+--------+------------+----------+\n\nmysql> select * from emp;\n+-------+--------+-----------+------+------------+---------+---------+--------+\n| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |\n|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |\n|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |\n|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |\n|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |\n|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |\n|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |\n|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |\n|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |\n|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |\n|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |\n|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |\n|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |\n|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n\nmysql> select * from salgrade;\n+-------+-------+-------+\n| GRADE | LOSAL | HISAL |\n+-------+-------+-------+\n|     1 |   700 |  1200 |\n|     2 |  1201 |  1400 |\n|     3 |  1401 |  2000 |\n|     4 |  2001 |  3000 |\n|     5 |  3001 |  9999 |\n+-------+-------+-------+\n```\n\n\n\n## **1、取得每个部门最高薪水的人员名称**\n\n第一步：取得每个部分的最高薪水\n\n```sql\nselect deptno, max(sal) from emp group by deptno;\n\n+--------+----------+\n| deptno | max(sal) |\n+--------+----------+\n|     20 |  3000.00 |\n|     30 |  2850.00 |\n|     10 |  5000.00 |\n+--------+----------+\n```\n\n第二步：把上述结果作为临时表t，对应emp e表找出对应的人员名称\n\n```sql\nselect \n	e.deptno as deptno, e.ename as ename ,e.sal as sal\nfrom \n	emp e\njoin \n	(select deptno, max(sal) as maxsal from emp group by deptno) t\non \n	e.sal = t.maxsal and e.deptno = t.deptno;\n	\n	\n+--------+-------+---------+\n| deptno | ename | sal     |\n+--------+-------+---------+\n|     30 | BLAKE | 2850.00 |\n|     20 | SCOTT | 3000.00 |\n|     10 | KING  | 5000.00 |\n|     20 | FORD  | 3000.00 |\n+--------+-------+---------+	\n```\n\n\n\n## 2、哪些人的薪水在部门平均薪水之上\n\n第一步：先将emp表按部门分组，然后计算出部门的平均工资\n\n```sql\nselect deptno,avg(sal) from emp group by deptno;\n\n+--------+-------------+\n| deptno | avg(sal)    |\n+--------+-------------+\n|     20 | 2175.000000 |\n|     30 | 1566.666667 |\n|     10 | 2916.666667 |\n+--------+-------------+\n```\n\n第二步：将上表作为临时表，找到员工对应部门薪水大于平均薪水的\n\n```sql\nselect \n	a.empno,a.ename,a.deptno,a.sal,b.avgsal\nfrom \n	emp a\njoin \n	(select deptno,avg(sal) as avgsal from emp group by deptno) b\non\n 	a.deptno = b.deptno \nwhere\n	a.sal>b.avgsal;\n	\n	\n+-------+-------+--------+---------+-------------+\n| empno | ename | deptno | sal     | avgsal      |\n+-------+-------+--------+---------+-------------+\n|  7499 | ALLEN |     30 | 1600.00 | 1566.666667 |\n|  7566 | JONES |     20 | 2975.00 | 2175.000000 |\n|  7698 | BLAKE |     30 | 2850.00 | 1566.666667 |\n|  7788 | SCOTT |     20 | 3000.00 | 2175.000000 |\n|  7839 | KING  |     10 | 5000.00 | 2916.666667 |\n|  7902 | FORD  |     20 | 3000.00 | 2175.000000 |\n+-------+-------+--------+---------+-------------+	\n```\n\n\n\n## 3、平均薪水等级\n\n### 3.1 取得部门中（所有人的）平均薪水等级\n\n第一步：求出部门的平均工资\n\n```sql\nselect deptno,avg(sal) as avgsal from emp group by deptno;\n\n+--------+-------------+\n| deptno | avgsal      |\n+--------+-------------+\n|     20 | 2175.000000 |\n|     30 | 1566.666667 |\n|     10 | 2916.666667 |\n+--------+-------------+\n```\n\n第二步：连接薪资等级表，计算薪资等级\n\n```sql\nselect \n	a.deptno,a.avgsal,s.grade\nfrom \n	(select deptno,avg(sal) as avgsal from emp group by deptno) a\njoin \n	salgrade s\non \n	a.avgsal between s.losal and hisal;\n\n\n+--------+-------------+-------+\n| deptno | avgsal      | grade |\n+--------+-------------+-------+\n|     20 | 2175.000000 |     4 |\n|     30 | 1566.666667 |     3 |\n|     10 | 2916.666667 |     4 |\n+--------+-------------+-------+\n```\n\n\n\n### 3.2 取得部门中所有人的平均的薪水等级\n\n第一步：计算每个人的薪水等级\n\n```sql\nselect \n	e.ename,e.deptno,e.sal,s.grade \nfrom \n	emp e\njoin \n	salgrade s\non \n	e.sal between s.losal and s.hisal;\n	\n	\n+--------+--------+---------+-------+\n| ename  | deptno | sal     | grade |\n+--------+--------+---------+-------+\n| SMITH  |     20 |  800.00 |     1 |\n| ALLEN  |     30 | 1600.00 |     3 |\n| WARD   |     30 | 1250.00 |     2 |\n| JONES  |     20 | 2975.00 |     4 |\n| MARTIN |     30 | 1250.00 |     2 |\n| BLAKE  |     30 | 2850.00 |     4 |\n| CLARK  |     10 | 2450.00 |     4 |\n| SCOTT  |     20 | 3000.00 |     4 |\n| KING   |     10 | 5000.00 |     5 |\n| TURNER |     30 | 1500.00 |     3 |\n| ADAMS  |     20 | 1100.00 |     1 |\n| JAMES  |     30 |  950.00 |     1 |\n| FORD   |     20 | 3000.00 |     4 |\n| MILLER |     10 | 1300.00 |     2 |\n+--------+--------+---------+-------+	\n```\n\n第二步：将上表按部门分组，计算平均薪水等级\n\n```sql\nselect \n	e.deptno,avg(s.grade)\nfrom \n	emp e\njoin \n	salgrade s\non \n	e.sal between s.losal and s.hisal\ngroup by\n	e.deptno;	\n	\n\n+--------+--------------+\n| deptno | avg(s.grade) |\n+--------+--------------+\n|     20 |       2.8000 |\n|     30 |       2.5000 |\n|     10 |       3.6667 |\n+--------+--------------+\n```\n\n\n\n## 4、不准用组函数（MAX），取得最高薪水\n\n**方法一：**\n\n```sql\nselect sal from emp order by sal desc limit 1;\n\n+---------+\n| sal     |\n+---------+\n| 5000.00 |\n+---------+\n```\n\n**方法二：**\n\n步骤一：将两张emp连接，找到a表中有比b表中工资低的所有工资值，然后去重，即除了最高工资的那个人，其他的都在。\n\n```sql\nselect \n	distinct a.sal\nfrom \n	emp a\njoin \n	emp b\non\n	a.sal < b.sal;\n	\n+---------+\n| sal     |\n+---------+\n|  800.00 |\n| 1250.00 |\n| 1500.00 |\n| 1100.00 |\n|  950.00 |\n| 1300.00 |\n| 1600.00 |\n| 2850.00 |\n| 2450.00 |\n| 2975.00 |\n| 3000.00 |	\n+---------+	\n```\n\n\n\n步骤二：找到emp表中工资没有在上表中的，即工资最高的。\n\n```sql\nselect \n	e.sal\nfrom \n	emp e\nwhere e.sal \nnot in \n    (select \n        distinct a.sal\n    from \n        emp a\n    join \n        emp b\n    on\n        a.sal < b.sal);\n```\n\n## 5、取得平均薪水最高的部门的部门编号\n\n步骤一：先找到每个部门的平均工资\n\n```sql\nselect \n	deptno,avg(sal) as avgsal\nfrom \n 	emp\ngroup by\n	deptno;\n\n+--------+-------------+\n| deptno | avgsal      |\n+--------+-------------+\n|     20 | 2175.000000 |\n|     30 | 1566.666667 |\n|     10 | 2916.666667 |\n+--------+-------------+\n```\n\n步骤二：将上表作为临时表，找出平均工资最高的部门编号\n\n```sql\nselect a.deptno,max(a.avgsal) maxavgsal \n	from \n	(select \n        deptno,avg(sal) as avgsal\n    from \n        emp\n    group by\n        deptno) a;\n        \n+--------+-------------+\n| deptno | maxavgsal   |\n+--------+-------------+\n|     20 | 2916.666667 |     \n+--------+-------------+\n```\n\n\n\n## 6、取得平均薪水最高的部门的部门名称\n\n步骤一：先找到每个部门的平均工资\n\n```sql\nselect \n	deptno,avg(sal) as avgsal\nfrom \n 	emp\ngroup by\n	deptno;\n\n+--------+-------------+\n| deptno | avgsal      |\n+--------+-------------+\n|     20 | 2175.000000 |\n|     30 | 1566.666667 |\n|     10 | 2916.666667 |\n+--------+-------------+\n```\n\n步骤二：将上表作为临时表，找出平均工资最高的部门编号\n\n```sql\nselect a.deptno,max(a.avgsal) maxavgsal \n	from \n	(select \n        deptno,avg(sal) as avgsal\n    from \n        emp\n    group by\n        deptno) a;\n        \n+--------+-------------+\n| deptno | maxavgsal   |\n+--------+-------------+\n|     20 | 2916.666667 |     \n+--------+-------------+\n```\n\n步骤三：将上述结果连接部门表，找到部门名称\n\n```sql\nselect a.deptno,max(a.avgsal) maxavgsal ,d.dname\nfrom \n	(select \n        deptno,avg(sal) as avgsal\n    from \n        emp\n    group by\n        deptno) a\njoin \n	dept d\non \n	d.deptno = a.deptno;\n	\n	\n+--------+-------------+------------+\n| deptno | maxavgsal   | dname      |\n+--------+-------------+------------+\n|     10 | 2916.666667 | ACCOUNTING |\n+--------+-------------+------------+	\n```\n\n\n\n## 7、求平均薪水的等级最低的部门的部门名称\n\n步骤一：求出每个部门平均的薪水\n\n```sql\nselect \n	e.deptno,avg(e.sal) avgsal,d.dname\nfrom \n	emp e\njoin\n	dept  d\non \n	d.deptno = e.deptno\ngroup by \n	e.deptno,d.dname;	\n	\n+--------+-------------+------------+\n| deptno | avgsal      | dname      |\n+--------+-------------+------------+\n|     20 | 2175.000000 | RESEARCH   |\n|     30 | 1566.666667 | SALES      |\n|     10 | 2916.666667 | ACCOUNTING |\n+--------+-------------+------------+	\n```\n\n步骤二：求出上表的薪水等级，并打印最低薪水等级的部门信息\n\n```sql\nselect \n	a.deptno,a.avgsal,a.dname,min(s.grade)\nfrom \n	(select \n        e.deptno,avg(e.sal) avgsal,d.dname as dname\n    from \n        emp e\n    join\n        dept  d\n    on \n        d.deptno = e.deptno\n    group by \n        e.deptno,d.dname) a\njoin \n	salgrade s\non \n	a.avgsal between s.losal and s.hisal;\n	\n+--------+-------------+----------+--------------+\n| deptno | avgsal      | dname    | min(s.grade) |\n+--------+-------------+----------+--------------+\n|     20 | 2175.000000 | RESEARCH |            3 |\n+--------+-------------+----------+--------------+\n```\n\n\n\n## 8、取得比普通员工（员工代码没有在mgr上出现的）的最高薪水还要高的经理人姓名\n\n步骤一：找到所有的领导\n\n```sql\nselect distinct  b.mgr from emp b where b.mgr is not null;\n+------+\n| mgr  |\n+------+\n| 7902 |\n| 7698 |\n| 7839 |\n| 7566 |\n| 7788 |\n| 7782 |\n+------+\n```\n\n步骤二：找出所有的普通员工\n\n```sql\nselect \n	a.ename,a.sal\nfrom \n	emp a\nwhere \n	a.empno not in \n		(select distinct  b.mgr from emp b where b.mgr is not null);\n		\n+--------+---------+\n| ename  | sal     |\n+--------+---------+\n| SMITH  |  800.00 |\n| ALLEN  | 1600.00 |\n| WARD   | 1250.00 |\n| MARTIN | 1250.00 |\n| TURNER | 1500.00 |\n| ADAMS  | 1100.00 |\n| JAMES  |  950.00 |\n| MILLER | 1300.00 |\n+--------+---------+		\n```\n\n步骤三：找到普通员工的最高工资\n\n```sql\nselect \n	max(a.sal)\nfrom \n	emp a\nwhere \n	a.empno not in \n		(select distinct  b.mgr from emp b where b.mgr is not null);\n		\n+------------+\n| max(a.sal) |\n+------------+\n|    1600.00 |\n+------------+	\n```\n\n步骤四：找到比普通员工最高工资还要高的领导信息。\n\n```sql\nselect c.empno,c.ename,c.sal\nfrom \n 	emp c\njoin	\n	(select distinct  b.mgr as magno from emp b where b.mgr is not null) d\non\n	c.empno = d.magno\nwhere \n	c.sal > (select \n                max(a.sal)\n            from \n                emp a\n            where \n                a.empno not in \n                    (select distinct  b.mgr from emp b where b.mgr is not null));	\n\n	\n+-------+-------+---------+\n| empno | ename | sal     |\n+-------+-------+---------+\n|  7566 | JONES | 2975.00 |\n|  7698 | BLAKE | 2850.00 |\n|  7782 | CLARK | 2450.00 |\n|  7788 | SCOTT | 3000.00 |\n|  7839 | KING  | 5000.00 |\n|  7902 | FORD  | 3000.00 |\n+-------+-------+---------+	\n```\n\n\n\n## 9、取得薪水最高的前五名员工\n\n```sql\nselect * from emp order by sal desc limit 0,5;\n\n+-------+-------+-----------+------+------------+---------+------+--------+\n| EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |\n+-------+-------+-----------+------+------------+---------+------+--------+\n|  7839 | KING  | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 |\n|  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |\n|  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |\n|  7566 | JONES | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |\n|  7698 | BLAKE | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |\n+-------+-------+-----------+------+------------+---------+------+--------+\n```\n\n\n\n## 10、取得薪水最高的第六到第十名员工\n\n```sql\nselect * from emp order by sal desc limit 5,5;\n\n+-------+--------+----------+------+------------+---------+--------+--------+\n| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |\n+-------+--------+----------+------+------------+---------+--------+--------+\n|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |   NULL |     10 |\n|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 |     30 |\n|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |   0.00 |     30 |\n|  7934 | MILLER | CLERK    | 7782 | 1982-01-23 | 1300.00 |   NULL |     10 |\n|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 |     30 |\n+-------+--------+----------+------+------------+---------+--------+--------+\n```\n\n\n\n## 11、取得最后入职的5名员工\n\n```sql\nselect * from emp order by HIREDATE desc limit 0,5;\n\n+-------+--------+---------+------+------------+---------+------+--------+\n| EMPNO | ENAME  | JOB     | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |\n+-------+--------+---------+------+------------+---------+------+--------+\n|  7876 | ADAMS  | CLERK   | 7788 | 1987-05-23 | 1100.00 | NULL |     20 |\n|  7788 | SCOTT  | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |\n|  7934 | MILLER | CLERK   | 7782 | 1982-01-23 | 1300.00 | NULL |     10 |\n|  7900 | JAMES  | CLERK   | 7698 | 1981-12-03 |  950.00 | NULL |     30 |\n|  7902 | FORD   | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |\n+-------+--------+---------+------+------------+---------+------+--------+\n```\n\n\n\n## 12、取得每个薪水等级有多少员工\n\n步骤一：计算每个员工的薪水等级\n\n```sql\nselect \n	empno,grade \nfrom\n	emp e\njoin\n	salgrade s\non e.sal between s.losal and s.hisal;\n\n+-------+-------+\n| empno | grade |\n+-------+-------+\n|  7369 |     1 |\n|  7499 |     3 |\n|  7521 |     2 |\n|  7566 |     4 |\n|  7654 |     2 |\n|  7698 |     4 |\n|  7782 |     4 |\n|  7788 |     4 |\n|  7839 |     5 |\n|  7844 |     3 |\n|  7876 |     1 |\n|  7900 |     1 |\n|  7902 |     4 |\n|  7934 |     2 |\n+-------+-------+\n```\n\n步骤二：按薪水等级分组，计算出每组的人数\n\n```sql\nselect \n	grade,count(grade) as gradenum\nfrom\n	emp e\njoin\n	salgrade s\non \n	e.sal between s.losal and s.hisal\ngroup by \n	s.grade;\n	\n+-------+----------+\n| grade | gradenum |\n+-------+----------+\n|     1 |        3 |\n|     3 |        2 |\n|     2 |        3 |\n|     4 |        5 |\n|     5 |        1 |\n+-------+----------+	\n```\n\n\n\n## 13、列出所有员工及领导的名字\n\n```sql\nselect \n	a.ename,b.ename as leader\nfrom \n	emp a\nleft join \n	emp b\non \n	a.mgr = b.empno;  \n    \n    \n+--------+--------+\n| ename  | leader |\n+--------+--------+\n| SMITH  | FORD   |\n| ALLEN  | BLAKE  |\n| WARD   | BLAKE  |\n| JONES  | KING   |\n| MARTIN | BLAKE  |\n| BLAKE  | KING   |\n| CLARK  | KING   |\n| SCOTT  | JONES  |\n| KING   | NULL   |\n| TURNER | BLAKE  |\n| ADAMS  | SCOTT  |\n| JAMES  | BLAKE  |\n| FORD   | JONES  |\n| MILLER | CLARK  |\n+--------+--------+    \n```\n\n\n\n## 14、列出受雇日期早于其直接上级的所有员工编号、姓名、部门名称\n\n```sql\nselect \n	a.empno,a.ename,d.dname\nfrom \n	emp a\njoin \n	emp b\non \n	a.mgr = b.empno\njoin \n	dept d \non \n	d.deptno = a.deptno\nwhere \n	a.hiredate < b.hiredate;\n	\n+-------+-------+------------+\n| empno | ename | dname      |\n+-------+-------+------------+\n|  7369 | SMITH | RESEARCH   |\n|  7499 | ALLEN | SALES      |\n|  7521 | WARD  | SALES      |\n|  7566 | JONES | RESEARCH   |\n|  7698 | BLAKE | SALES      |\n|  7782 | CLARK | ACCOUNTING |\n+-------+-------+------------+	\n```\n\n\n\n## 15、列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门\n\n```sql\nselect \n	d.dname,e.*\nfrom \n	dept d \nleft join \n	emp e\non \n	d.deptno = e.deptno\norder by\n	d.dname;\n	\n	\n+------------+-------+--------+-----------+------+------------+---------+---------+--------+\n| dname      | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |\n+------------+-------+--------+-----------+------+------------+---------+---------+--------+\n| ACCOUNTING |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |\n| ACCOUNTING |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |\n| ACCOUNTING |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |\n| OPERATIONS |  NULL | NULL   | NULL      | NULL | NULL       |    NULL |    NULL |   NULL |\n| RESEARCH   |  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |\n| RESEARCH   |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |\n| RESEARCH   |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |\n| RESEARCH   |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |\n| RESEARCH   |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |\n| SALES      |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |\n| SALES      |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |\n| SALES      |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |\n| SALES      |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |\n| SALES      |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |\n| SALES      |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |\n+------------+-------+--------+-----------+------+------------+---------+---------+--------+\n```\n\n\n\n## 16、列出至少有5个员工的所有部门\n\n步骤一：列出每个部门的人数\n\n```sql\nselect \n	e.deptno deptno,d.dname dname,count(e.deptno) empnum\nfrom \n	emp e\njoin\n	dept d\non	\n	e.deptno = d.deptno\ngroup by\n	e.deptno;\n	\n+--------+------------+-----------------+\n| deptno | dname      | count(e.deptno) |\n+--------+------------+-----------------+\n|     20 | RESEARCH   |               5 |\n|     30 | SALES      |               6 |\n|     10 | ACCOUNTING |               3 |\n+--------+------------+-----------------+	\n```\n\n\n\n步骤二：列出至少有5个员工的所有部门\n\n```sql\nselect \n	a.deptno ,a.dname,a.empnum\nfrom \n	(select \n        e.deptno deptno,d.dname dname,count(e.deptno) empnum\n    from \n        emp e\n    join\n        dept d\n    on	\n        e.deptno = d.deptno\n    group by\n        e.deptno) a\nwhere \n	a.empnum >= 5;	\n	\n+--------+----------+--------+\n| deptno | dname    | empnum |\n+--------+----------+--------+\n|     20 | RESEARCH |      5 |\n|     30 | SALES    |      6 |\n+--------+----------+--------+	\n```\n\n\n\n## 17、列出薪水比“SMITH”多的所有员工信息\n\n```sql\nselect \n	*\nfrom \n	emp e\nwhere e.sal > (select sal from emp where ename = \'SMITH\');	\n\n\n+-------+--------+-----------+------+------------+---------+---------+--------+\n| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |\n|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |\n|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |\n|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |\n|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |\n|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |\n|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |\n|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |\n|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |\n|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |\n|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |\n|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |\n|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |\n+-------+--------+-----------+------+------------+---------+---------+--------+\n```\n\n\n\n## 18、列出所有“CLERK”（办事员）的姓名及其部门名称，部门人数\n\n步骤一：列出所有“CLERK”（办事员）的姓名及其部门名称\n\n```sql\nselect \n	e.ename,d.dname\nfrom \n	emp e\njoin \n	dept d\non \n	e.deptno = d.deptno\nwhere \n	e.job = \'CLERK\';\n	\n+--------+------------+\n| ename  | dname      |\n+--------+------------+\n| SMITH  | RESEARCH   |\n| ADAMS  | RESEARCH   |\n| JAMES  | SALES      |\n| MILLER | ACCOUNTING |\n+--------+------------+	\n```\n\n步骤二：计算部门人数\n\n```sql\nselect \n	d.dname,count(d.dname)\nfrom \n	emp e\njoin \n	dept d\non \n	e.deptno = d.deptno\nwhere \n	e.job = \'CLERK\'\ngroup by\n	d.dname;	\n	\n+------------+----------------+\n| dname      | count(d.dname) |\n+------------+----------------+\n| RESEARCH   |              2 |\n| SALES      |              1 |\n| ACCOUNTING |              1 |\n+------------+----------------+	\n```\n\n\n\n## 19、列出最低薪水大于1500的各种工作及从事此工作的全部雇员人数\n\n步骤一：计算所有工作的最低薪水以及人数\n\n```sql\nselect \n	e.job as job,min(e.sal) as minsal,count(e.job) jobnum\nfrom \n	emp e\ngroup by\n	e.job;\n	\n+-----------+---------+--------+\n| job       | minsal  | jobnum |\n+-----------+---------+--------+\n| CLERK     |  800.00 |      4 |\n| SALESMAN  | 1250.00 |      4 |\n| MANAGER   | 2450.00 |      3 |\n| ANALYST   | 3000.00 |      2 |\n| PRESIDENT | 5000.00 |      1 |\n+-----------+---------+--------+\n```\n\n步骤二：\n\n列出最低薪水大于1500的各种工作及从事此工作的全部雇员人数\n\n```sql\nselect \n	a.job,a.minsal,a.jobnum\nfrom	\n	(select \n	e.job as job,min(e.sal) as minsal,count(e.job) jobnum\nfrom \n	emp e\ngroup by\n	e.job) a\nwhere \n	a.minsal > 1500;\n	\n+-----------+---------+--------+\n| job       | minsal  | jobnum |\n+-----------+---------+--------+\n| MANAGER   | 2450.00 |      3 |\n| ANALYST   | 3000.00 |      2 |\n| PRESIDENT | 5000.00 |      1 |\n+-----------+---------+--------+	\n```\n\n\n\n## 20、列出在部门“SALES”<销售部>工作的员工的姓名，假定不知道销售部门的部门编号\n\n步骤一：先找到部门“SALES”<销售部>的部门编号\n\n```sql\nselect deptno from dept where dname = \'SALES\';\n\n+--------+\n| deptno |\n+--------+\n|     30 |\n+--------+\n```\n\n步骤二：列出在部门“SALES”<销售部>工作的员工的姓名\n\n```sql\nselect \n	ename\nfrom \n	emp e\nwhere\n	e.deptno = (select deptno from dept where dname = \'SALES\');\n\n+--------+\n| ename  |\n+--------+\n| ALLEN  |\n| WARD   |\n| MARTIN |\n| BLAKE  |\n| TURNER |\n| JAMES  |\n+--------+\n```\n\n\n\n## 21、列出薪金高于公司平均薪金的所有员工，所在部门、上级领导、雇员的工资等级\n\n步骤一：计算公司的平均薪资\n\n```sql\nselect avg(sal) from emp;	\n\n+-------------+\n| avg(sal)    |\n+-------------+\n| 2073.214286 |\n+-------------+	\n```\n\n步骤二：找到薪金高于公司平均薪金的所有员工\n\n```sql\nselect \n	e.ename,e.mgr,e.sal,e.deptno\nfrom \n	emp e\nwhere \n	e.sal > (select avg(sal) from emp);\n	\n+-------+------+---------+--------+\n| ename | mgr  | sal     | deptno |\n+-------+------+---------+--------+\n| JONES | 7839 | 2975.00 |     20 |\n| BLAKE | 7839 | 2850.00 |     30 |\n| CLARK | 7839 | 2450.00 |     10 |\n| SCOTT | 7566 | 3000.00 |     20 |\n| KING  | NULL | 5000.00 |     10 |\n| FORD  | 7566 | 3000.00 |     20 |\n+-------+------+---------+--------+	\n```\n\n步骤三：找到所在部门\n\n```sql\nselect \n	e.ename,e.mgr,e.sal,d.dname\nfrom \n	emp e\njoin \n	dept d\non\n	e.deptno = d.deptno\nwhere \n	e.sal > (select avg(sal) from emp);\n\n+-------+------+---------+------------+\n| ename | mgr  | sal     | dname      |\n+-------+------+---------+------------+\n| JONES | 7839 | 2975.00 | RESEARCH   |\n| BLAKE | 7839 | 2850.00 | SALES      |\n| CLARK | 7839 | 2450.00 | ACCOUNTING |\n| SCOTT | 7566 | 3000.00 | RESEARCH   |\n| KING  | NULL | 5000.00 | ACCOUNTING |\n| FORD  | 7566 | 3000.00 | RESEARCH   |\n+-------+------+---------+------------+\n```\n\n步骤四：找到上级领导\n\n```sql\nselect \n	e.ename,m.ename mgrname,e.sal,d.dname\nfrom \n	emp e\nleft join\n	emp m\non \n	e.mgr = m.empno\njoin \n	dept d\non\n	e.deptno = d.deptno\nwhere \n	e.sal > (select avg(sal) from emp);\n	\n+-------+---------+---------+------------+\n| ename | mgrname | sal     | dname      |\n+-------+---------+---------+------------+\n| JONES | KING    | 2975.00 | RESEARCH   |\n| BLAKE | KING    | 2850.00 | SALES      |\n| CLARK | KING    | 2450.00 | ACCOUNTING |\n| SCOTT | JONES   | 3000.00 | RESEARCH   |\n| KING  | NULL    | 5000.00 | ACCOUNTING |\n| FORD  | JONES   | 3000.00 | RESEARCH   |\n+-------+---------+---------+------------+\n```\n\n步骤四：计算雇员的工资等级\n\n```sql\nselect \n	e.ename,m.ename mgrname,e.sal,d.dname,s.grade\nfrom \n	emp e\nleft join\n	emp m\non \n	e.mgr = m.empno\njoin \n	dept d\non\n	e.deptno = d.deptno\njoin \n	salgrade s\non \n	e.sal between s.losal and s.hisal\nwhere \n	e.sal > (select avg(sal) from emp);\n	\n	\n+-------+---------+---------+------------+-------+\n| ename | mgrname | sal     | dname      | grade |\n+-------+---------+---------+------------+-------+\n| JONES | KING    | 2975.00 | RESEARCH   |     4 |\n| BLAKE | KING    | 2850.00 | SALES      |     4 |\n| CLARK | KING    | 2450.00 | ACCOUNTING |     4 |\n| SCOTT | JONES   | 3000.00 | RESEARCH   |     4 |\n| FORD  | JONES   | 3000.00 | RESEARCH   |     4 |\n| KING  | NULL    | 5000.00 | ACCOUNTING |     5 |\n+-------+---------+---------+------------+-------+	\n```\n\n\n\n## 22、列出与“SCOTT”从事相同工作的所有员工及部门名称\n\n步骤一：找到“SCOTT”从事的工作\n\n```sql\nselect job from emp where ename = \'SCOTT\';\n\n+---------+\n| job     |\n+---------+\n| ANALYST |\n+---------+\n```\n\n步骤二：列出与“SCOTT”从事相同工作的所有员工\n\n```sql\nselect \n	e.empno,e.deptno\nfrom \n	emp e\nwhere e.job = (select job from emp where ename = \'SCOTT\');	\n\n+-------+--------+\n| empno | deptno |\n+-------+--------+\n|  7788 |     20 |\n|  7902 |     20 |\n+-------+--------+\n```\n\n步骤三：列出与“SCOTT”从事相同工作的所有员工及部门名称\n\n```sql\nselect \n	e.empno,e.deptno,d.dname\nfrom \n	emp e\njoin \n	dept d\non	\n	e.deptno = d.deptno	\nwhere e.job = (select job from emp where ename = \'SCOTT\');	\n\n+-------+--------+----------+\n| empno | deptno | dname    |\n+-------+--------+----------+\n|  7788 |     20 | RESEARCH |\n|  7902 |     20 | RESEARCH |\n+-------+--------+----------+\n```\n\n\n\n## 23、列出薪金等于部门30中员工的薪金的其它员工的姓名和薪金\n\n步骤一：列出部门30中员工的薪资\n\n```sql\nselect  distinct sal from emp where deptno = 30;\n\n+---------+\n| sal     |\n+---------+\n| 1600.00 |\n| 1250.00 |\n| 2850.00 |\n| 1500.00 |\n|  950.00 |\n+---------+\n```\n\n步骤二：列出薪金等于部门30中员工的薪金的其它员工的姓名和薪金\n\n```sql\nselect \n	e.empno,e.ename,e.deptno,e.sal\nfrom \n	emp e\nwhere\n	e.sal in (select  distinct sal from emp where deptno = 30)\n	and\n	e.deptno <> 30;\n```\n\n\n\n## 24、列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金、部门名称\n\n步骤一：计算部门30员工的最高薪资\n\n```sql\nselect max(sal) maxsal from emp where deptno = 30;\n\n+---------+\n| maxsal  |\n+---------+\n| 2850.00 |\n+---------+\n```\n\n\n\n步骤二：列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金\n\n```sql\nselect \n	e.ename,e.sal,e.deptno\nfrom \n	emp e\nwhere\n	e.sal > (select max(sal) maxsal from emp where deptno = 30);\n\n+-------+---------+--------+\n| ename | sal     | deptno |\n+-------+---------+--------+\n| JONES | 2975.00 |     20 |\n| SCOTT | 3000.00 |     20 |\n| KING  | 5000.00 |     10 |\n| FORD  | 3000.00 |     20 |\n+-------+---------+--------+\n```\n\n步骤三：找到部门名称\n\n```sql\nselect \n	e.ename,e.sal,d.dname\nfrom \n	emp e\njoin \n	dept d \non\n	e.deptno = d.deptno\nwhere\n	e.sal > (select max(sal) maxsal from emp where deptno = 30);\n	\n+-------+---------+------------+\n| ename | sal     | dname      |\n+-------+---------+------------+\n| JONES | 2975.00 | RESEARCH   |\n| SCOTT | 3000.00 | RESEARCH   |\n| KING  | 5000.00 | ACCOUNTING |\n| FORD  | 3000.00 | RESEARCH   |\n+-------+---------+------------+	\n```\n\n\n\n## 25、列出在每个部门工作的员工数量、平均工资和平均服务期限\n\n```sql\nselect \n	deptno, count(deptno) deptnum,avg(sal),avg((to_days(now()) - to_days(hiredate))/365) as avgyears\nfrom \n	emp\ngroup by\n	deptno;\n\n+--------+---------+-------------+-------------+\n| deptno | deptnum | avg(sal)    | avgyears    |\n+--------+---------+-------------+-------------+\n|     20 |       5 | 2175.000000 | 36.72930000 |\n|     30 |       6 | 1566.666667 | 39.00091667 |\n|     10 |       3 | 2916.666667 | 38.70226667 |\n+--------+---------+-------------+-------------+\n```\n\n\n\n## 26、列出所有员工的姓名、部门名称和工资\n\n```sql\nselect \n	e.ename,d.dname,e.sal\nfrom \n	emp e\njoin \n	dept d\non \n	e.deptno = d.deptno;\n	\n+--------+------------+---------+\n| ename  | dname      | sal     |\n+--------+------------+---------+\n| SMITH  | RESEARCH   |  800.00 |\n| ALLEN  | SALES      | 1600.00 |\n| WARD   | SALES      | 1250.00 |\n| JONES  | RESEARCH   | 2975.00 |\n| MARTIN | SALES      | 1250.00 |\n| BLAKE  | SALES      | 2850.00 |\n| CLARK  | ACCOUNTING | 2450.00 |\n| SCOTT  | RESEARCH   | 3000.00 |\n| KING   | ACCOUNTING | 5000.00 |\n| TURNER | SALES      | 1500.00 |\n| ADAMS  | RESEARCH   | 1100.00 |\n| JAMES  | SALES      |  950.00 |\n| FORD   | RESEARCH   | 3000.00 |\n| MILLER | ACCOUNTING | 1300.00 |\n+--------+------------+---------+	\n```\n\n\n\n## 27、列出所有部门的详细信息和人数\n\n```sql\nselect \n	d.*,count(e.empno) as empnum\nfrom \n	dept d\nleft join\n	emp e\non\n	d.deptno = e.deptno\ngroup by\n	d.deptno;\n	\n+--------+------------+----------+--------+\n| DEPTNO | DNAME      | LOC      | empnum |\n+--------+------------+----------+--------+\n|     20 | RESEARCH   | DALLAS   |      5 |\n|     30 | SALES      | CHICAGO  |      6 |\n|     10 | ACCOUNTING | NEW YORK |      3 |\n|     40 | OPERATIONS | BOSTON   |      0 |\n+--------+------------+----------+--------+	\n```\n\n\n\n## 28、列出各种工作的最低工资及从事此工作的雇员姓名\n\n步骤一：找到各种工作的最低工资\n\n```sql\nselect \n	job,min(sal) minsal \nfrom \n	emp e\ngroup by \n	job;\n	\n+-----------+---------+\n| job       | minsal  |\n+-----------+---------+\n| CLERK     |  800.00 |\n| SALESMAN  | 1250.00 |\n| MANAGER   | 2450.00 |\n| ANALYST   | 3000.00 |\n| PRESIDENT | 5000.00 |\n+-----------+---------+	\n```\n\n步骤二：列出各种工作的最低工资及从事此工作的雇员姓名\n\n```sql\nselect \n	e.job,e.sal,e.ename\nfrom\n	emp e\njoin \n	(select \n        job,min(sal) minsal \n    from \n        emp e\n    group by \n        job) a\non \n	e.job = a.job and e.sal = a.minsal;\n	\n+-----------+---------+--------+\n| job       | sal     | ename  |\n+-----------+---------+--------+\n| CLERK     |  800.00 | SMITH  |\n| SALESMAN  | 1250.00 | WARD   |\n| SALESMAN  | 1250.00 | MARTIN |\n| MANAGER   | 2450.00 | CLARK  |\n| ANALYST   | 3000.00 | SCOTT  |\n| PRESIDENT | 5000.00 | KING   |\n| ANALYST   | 3000.00 | FORD   |\n+-----------+---------+--------+	\n```\n\n\n\n## 29、列出各个部门MANAGER的最低薪金\n\n```sql\nselect \n	deptno,min(sal)\nfrom \n	emp e\nwhere \n	job=\'MANAGER\'	\ngroup by\n	deptno;\n	\n+--------+----------+\n| deptno | min(sal) |\n+--------+----------+\n|     20 |  2975.00 |\n|     30 |  2850.00 |\n|     10 |  2450.00 |	\n+--------+----------+\n```\n\n\n\n## 30、列出所有员工的年工资，按年薪从低到高排序\n\n```sql\nselect \n	ename, (sal *12) yearsal \nfrom \n	emp\norder by sal;	\n\n+--------+----------+\n| ename  | yearsal  |\n+--------+----------+\n| SMITH  |  9600.00 |\n| JAMES  | 11400.00 |\n| ADAMS  | 13200.00 |\n| WARD   | 15000.00 |\n| MARTIN | 15000.00 |\n| MILLER | 15600.00 |\n| TURNER | 18000.00 |\n| ALLEN  | 19200.00 |\n| CLARK  | 29400.00 |\n| BLAKE  | 34200.00 |\n| JONES  | 35700.00 |\n| SCOTT  | 36000.00 |\n| FORD   | 36000.00 |\n| KING   | 60000.00 |\n+--------+----------+\n```\n\n\n\n## 31、求出员工领导的薪水超过3000的员工名称和领导名称\n\n```sql\nselect \n	e.ename,m.ename mgrname\nfrom \n	emp e\njoin \n	emp m\non\n	m.empno = e.mgr\nwhere \n	m.sal > 3000;\n	\n+-------+---------+\n| ename | mgrname |\n+-------+---------+\n| JONES | KING    |\n| BLAKE | KING    |\n| CLARK | KING    |\n+-------+---------+	\n```\n\n\n\n## 32、求部门名称中带“S”字符的部门员工的工资合计、部门人数\n\n步骤一：找到部门名称中带“S”字符的部门\n\n```sql\nselect * \nfrom dept d \nwhere d.dname like \'%S%\';\n```\n\n步骤二：求部门名称中带“S”字符的部门员工的工资合计、部门人数\n\n```sql\nselect \n	e.deptno,sum(sal),count(e.deptno)\nfrom \n	emp e\njoin \n	(select *  from dept d where d.dname like \'%S%\') d\non \n	e.deptno = d.deptno\ngroup by\n	e.deptno;\n	\n+--------+----------+-----------------+\n| deptno | sum(sal) | count(e.deptno) |\n+--------+----------+-----------------+\n|     20 | 10875.00 |               5 |\n|     30 |  9400.00 |               6 |\n+--------+----------+-----------------+	\n```\n\n\n\n## 33、给任职日期超过30年的员工加薪10%\n\n```sql\nselect \n	empno,ename,sal*1.1\nfrom \n	emp\nwhere 	((to_days(now())-to_days(hiredate))/365)>30;\n\n+-------+--------+---------+\n| empno | ename  | sal*1.1 |\n+-------+--------+---------+\n|  7369 | SMITH  |  880.00 |\n|  7499 | ALLEN  | 1760.00 |\n|  7521 | WARD   | 1375.00 |\n|  7566 | JONES  | 3272.50 |\n|  7654 | MARTIN | 1375.00 |\n|  7698 | BLAKE  | 3135.00 |\n|  7782 | CLARK  | 2695.00 |\n|  7788 | SCOTT  | 3300.00 |\n|  7839 | KING   | 5500.00 |\n|  7844 | TURNER | 1650.00 |\n|  7876 | ADAMS  | 1210.00 |\n|  7900 | JAMES  | 1045.00 |\n|  7902 | FORD   | 3300.00 |\n|  7934 | MILLER | 1430.00 |\n+-------+--------+---------+\n```\n\n', 0, 0, '2020-08-07 01:21:20', 2, 0, 1, '下面练习题，用到的表的创建语句，可以把下面数据保存到bookshop.sql文件，然后使用命令导入数据库，具体如何导入在本专栏的第一节有教程。\nbookshop.sql\nDROP TABLE IF EXISTS EMP;DROP TABLE IF EXISTS DEPT;DROP TABLE IF EXISTS SALGRADE;CREATE TABLE DEPT       (DEPTNO int(2) not null ,    DNAME VARCHAR(14) ,    LOC VARCHAR(13),    primary key (DEPTNO)    );CREATE TABLE EMP       (EMPNO int(4)  not null ,    ENAME VARCHAR(10),    JOB VARCHAR(9),    MGR INT(4),    HIREDATE DATE  DEFAULT NULL,    SAL DOUBLE(7,2),    COMM DOUBLE(7,2),    primary key (EMPNO),    DEPTNO INT(2)     )    ;CREATE TABLE SALGRADE      ( GRADE INT,    LOSAL INT,    HISAL INT );INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 10, \'ACCOUNTING\', \'NEW YORK\'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 20, \'RESEARCH\', \'DALLAS\'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 30, \'SALES\', \'CHICAGO\'); INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES ( 40, \'OPERATIONS\', \'BOSTON\'); commit;INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7369, \'SMITH\', \'CLERK\', 7902,  \'1980-12-17\', 800, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7499, \'ALLEN\', \'SALESMAN\', 7698,  \'1981-02-20\', 1600, 300, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7521, \'WARD\', \'SALESMAN\', 7698,  \'1981-02-22\', 1250, 500, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7566, \'JONES\', \'MANAGER\', 7839,  \'1981-04-02\', 2975, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7654, \'MARTIN\', \'SALESMAN\', 7698,  \'1981-09-28\', 1250, 1400, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7698, \'BLAKE\', \'MANAGER\', 7839,  \'1981-05-01\', 2850, NULL, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7782, \'CLARK\', \'MANAGER\', 7839,  \'1981-06-09\', 2450, NULL, 10); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7788, \'SCOTT\', \'ANALYST\', 7566,  \'1987-04-19\', 3000, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7839, \'KING\', \'PRESIDENT\', NULL,  \'1981-11-17\', 5000, NULL, 10); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7844, \'TURNER\', \'SALESMAN\', 7698,  \'1981-09-08\', 1500, 0, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7876, \'ADAMS\', \'CLERK\', 7788,  \'1987-05-23\', 1100, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7900, \'JAMES\', \'CLERK\', 7698,  \'1981-12-03\', 950, NULL, 30); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7902, \'FORD\', \'ANALYST\', 7566,  \'1981-12-03\', 3000, NULL, 20); INSERT INTO EMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM,DEPTNO ) VALUES ( 7934, \'MILLER\', \'CLERK\', 7782,  \'1982-01-23\', 1300, NULL, 10); commit;INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 1, 700, 1200); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 2, 1201, 1400); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 3, 1401, 2000); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 4, 2001, 3000); INSERT INTO SALGRADE ( GRADE, LOSAL, HISAL ) VALUES ( 5, 3001, 9999); commit;\n表数据：\nmysql> select * from dept;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+mysql> select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+mysql> select * from salgrade;+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+|     1 |   700 |  1200 ||     2 |  1201 |  1400 ||     3 |  1401 |  2000 ||     4 |  2001 |  3000 ||     5 |  3001 |  9999 |+-------+-------+-------+\n1、取得每个部门最高薪水的人员名称第一步：取得每个部分的最高薪水\nselect deptno, max(sal) from emp group by deptno;+--------+----------+| deptno | max(sal) |+--------+----------+|     20 |  3000.00 ||     30 |  2850.00 ||     10 |  5000.00 |+--------+----------+\n第二步：把上述结果作为临时表t，对应emp e表找出对应的人员名称\nselect     e.deptno as deptno, e.ename as ename ,e.sal as salfrom     emp ejoin     (select deptno, max(sal) as maxsal from emp group by deptno) ton     e.sal = t.maxsal and e.deptno = t.deptno;+--------+-------+---------+| deptno | ename | sal     |+--------+-------+---------+|     30 | BLAKE | 2850.00 ||     20 | SCOTT | 3000.00 ||     10 | KING  | 5000.00 ||     20 | FORD  | 3000.00 |+--------+-------+---------+\n2、哪些人的薪水在部门平均薪水之上第一步：先将emp表按部门分组，然后计算出部门的平均工资\nselect deptno,avg(sal) from emp group by deptno;+--------+-------------+| deptno | avg(sal)    |+--------+-------------+|     20 | 2175.000000 ||     30 | 1566.666667 ||     10 | 2916.666667 |+--------+-------------+\n第二步：将上表作为临时表，找到员工对应部门薪水大于平均薪水的\nselect     a.empno,a.ename,a.deptno,a.sal,b.avgsalfrom     emp ajoin     (select deptno,avg(sal) as avgsal from emp group by deptno) bon     a.deptno = b.deptno where    a.sal>b.avgsal;+-------+-------+--------+---------+-------------+| empno | ename | deptno | sal     | avgsal      |+-------+-------+--------+---------+-------------+|  7499 | ALLEN |     30 | 1600.00 | 1566.666667 ||  7566 | JONES |     20 | 2975.00 | 2175.000000 ||  7698 | BLAKE |     30 | 2850.00 | 1566.666667 ||  7788 | SCOTT |     20 | 3000.00 | 2175.000000 ||  7839 | KING  |     10 | 5000.00 | 2916.666667 ||  7902 | FORD  |     20 | 3000.00 | 2175.000000 |+-------+-------+--------+---------+-------------+\n3、平均薪水等级3.1 取得部门中（所有人的）平均薪水等级第一步：求出部门的平均工资\nselect deptno,avg(sal) as avgsal from emp group by deptno;+--------+-------------+| deptno | avgsal      |+--------+-------------+|     20 | 2175.000000 ||     30 | 1566.666667 ||     10 | 2916.666667 |+--------+-------------+\n第二步：连接薪资等级表，计算薪资等级\nselect     a.deptno,a.avgsal,s.gradefrom     (select deptno,avg(sal) as avgsal from emp group by deptno) ajoin     salgrade son     a.avgsal between s.losal and hisal;+--------+-------------+-------+| deptno | avgsal      | grade |+--------+-------------+-------+|     20 | 2175.000000 |     4 ||     30 | 1566.666667 |     3 ||     10 | 2916.666667 |     4 |+--------+-------------+-------+\n3.2 取得部门中所有人的平均的薪水等级第一步：计算每个人的薪水等级\nselect     e.ename,e.deptno,e.sal,s.grade from     emp ejoin     salgrade son     e.sal between s.losal and s.hisal;+--------+--------+---------+-------+| ename  | deptno | sal     | grade |+--------+--------+---------+-------+| SMITH  |     20 |  800.00 |     1 || ALLEN  |     30 | 1600.00 |     3 || WARD   |     30 | 1250.00 |     2 || JONES  |     20 | 2975.00 |     4 || MARTIN |     30 | 1250.00 |     2 || BLAKE  |     30 | 2850.00 |     4 || CLARK  |     10 | 2450.00 |     4 || SCOTT  |     20 | 3000.00 |     4 || KING   |     10 | 5000.00 |     5 || TURNER |     30 | 1500.00 |     3 || ADAMS  |     20 | 1100.00 |     1 || JAMES  |     30 |  950.00 |     1 || FORD   |     20 | 3000.00 |     4 || MILLER |     10 | 1300.00 |     2 |+--------+--------+---------+-------+\n第二步：将上表按部门分组，计算平均薪水等级\nselect     e.deptno,avg(s.grade)from     emp ejoin     salgrade son     e.sal between s.losal and s.hisalgroup by    e.deptno;    +--------+--------------+| deptno | avg(s.grade) |+--------+--------------+|     20 |       2.8000 ||     30 |       2.5000 ||     10 |       3.6667 |+--------+--------------+\n4、不准用组函数（MAX），取得最高薪水方法一：\nselect sal from emp order by sal desc limit 1;+---------+| sal     |+---------+| 5000.00 |+---------+\n方法二：\n步骤一：将两张emp连接，找到a表中有比b表中工资低的所有工资值，然后去重，即除了最高工资的那个人，其他的都在。\nselect     distinct a.salfrom     emp ajoin     emp bon    a.sal < b.sal;+---------+| sal     |+---------+|  800.00 || 1250.00 || 1500.00 || 1100.00 ||  950.00 || 1300.00 || 1600.00 || 2850.00 || 2450.00 || 2975.00 || 3000.00 |    +---------+\n步骤二：找到emp表中工资没有在上表中的，即工资最高的。\nselect     e.salfrom     emp ewhere e.sal not in     (select         distinct a.sal    from         emp a    join         emp b    on        a.sal < b.sal);\n5、取得平均薪水最高的部门的部门编号步骤一：先找到每个部门的平均工资\nselect     deptno,avg(sal) as avgsalfrom      empgroup by    deptno;+--------+-------------+| deptno | avgsal      |+--------+-------------+|     20 | 2175.000000 ||     30 | 1566.666667 ||     10 | 2916.666667 |+--------+-------------+\n步骤二：将上表作为临时表，找出平均工资最高的部门编号\nselect a.deptno,max(a.avgsal) maxavgsal     from     (select         deptno,avg(sal) as avgsal    from         emp    group by        deptno) a;+--------+-------------+| deptno | maxavgsal   |+--------+-------------+|     20 | 2916.666667 |     +--------+-------------+\n6、取得平均薪水最高的部门的部门名称步骤一：先找到每个部门的平均工资\nselect     deptno,avg(sal) as avgsalfrom      empgroup by    deptno;+--------+-------------+| deptno | avgsal      |+--------+-------------+|     20 | 2175.000000 ||     30 | 1566.666667 ||     10 | 2916.666667 |+--------+-------------+\n步骤二：将上表作为临时表，找出平均工资最高的部门编号\nselect a.deptno,max(a.avgsal) maxavgsal     from     (select         deptno,avg(sal) as avgsal    from         emp    group by        deptno) a;+--------+-------------+| deptno | maxavgsal   |+--------+-------------+|     20 | 2916.666667 |     +--------+-------------+\n步骤三：将上述结果连接部门表，找到部门名称\nselect a.deptno,max(a.avgsal) maxavgsal ,d.dnamefrom     (select         deptno,avg(sal) as avgsal    from         emp    group by        deptno) ajoin     dept don     d.deptno = a.deptno;+--------+-------------+------------+| deptno | maxavgsal   | dname      |+--------+-------------+------------+|     10 | 2916.666667 | ACCOUNTING |+--------+-------------+------------+\n7、求平均薪水的等级最低的部门的部门名称步骤一：求出每个部门平均的薪水\nselect     e.deptno,avg(e.sal) avgsal,d.dnamefrom     emp ejoin    dept  don     d.deptno = e.deptnogroup by     e.deptno,d.dname;    +--------+-------------+------------+| deptno | avgsal      | dname      |+--------+-------------+------------+|     20 | 2175.000000 | RESEARCH   ||     30 | 1566.666667 | SALES      ||     10 | 2916.666667 | ACCOUNTING |+--------+-------------+------------+\n步骤二：求出上表的薪水等级，并打印最低薪水等级的部门信息\nselect     a.deptno,a.avgsal,a.dname,min(s.grade)from     (select         e.deptno,avg(e.sal) avgsal,d.dname as dname    from         emp e    join        dept  d    on         d.deptno = e.deptno    group by         e.deptno,d.dname) ajoin     salgrade son     a.avgsal between s.losal and s.hisal;+--------+-------------+----------+--------------+| deptno | avgsal      | dname    | min(s.grade) |+--------+-------------+----------+--------------+|     20 | 2175.000000 | RESEARCH |            3 |+--------+-------------+----------+--------------+\n8、取得比普通员工（员工代码没有在mgr上出现的）的最高薪水还要高的经理人姓名步骤一：找到所有的领导\nselect distinct  b.mgr from emp b where b.mgr is not null;+------+| mgr  |+------+| 7902 || 7698 || 7839 || 7566 || 7788 || 7782 |+------+\n步骤二：找出所有的普通员工\nselect     a.ename,a.salfrom     emp awhere     a.empno not in         (select distinct  b.mgr from emp b where b.mgr is not null);+--------+---------+| ename  | sal     |+--------+---------+| SMITH  |  800.00 || ALLEN  | 1600.00 || WARD   | 1250.00 || MARTIN | 1250.00 || TURNER | 1500.00 || ADAMS  | 1100.00 || JAMES  |  950.00 || MILLER | 1300.00 |+--------+---------+\n步骤三：找到普通员工的最高工资\nselect     max(a.sal)from     emp awhere     a.empno not in         (select distinct  b.mgr from emp b where b.mgr is not null);+------------+| max(a.sal) |+------------+|    1600.00 |+------------+\n步骤四：找到比普通员工最高工资还要高的领导信息。\nselect c.empno,c.ename,c.salfrom      emp cjoin        (select distinct  b.mgr as magno from emp b where b.mgr is not null) don    c.empno = d.magnowhere     c.sal > (select                 max(a.sal)            from                 emp a            where                 a.empno not in                     (select distinct  b.mgr from emp b where b.mgr is not null));    +-------+-------+---------+| empno | ename | sal     |+-------+-------+---------+|  7566 | JONES | 2975.00 ||  7698 | BLAKE | 2850.00 ||  7782 | CLARK | 2450.00 ||  7788 | SCOTT | 3000.00 ||  7839 | KING  | 5000.00 ||  7902 | FORD  | 3000.00 |+-------+-------+---------+\n9、取得薪水最高的前五名员工select * from emp order by sal desc limit 0,5;+-------+-------+-----------+------+------------+---------+------+--------+| EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |+-------+-------+-----------+------+------------+---------+------+--------+|  7839 | KING  | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 ||  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 ||  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 ||  7566 | JONES | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 ||  7698 | BLAKE | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |+-------+-------+-----------+------+------------+---------+------+--------+\n10、取得薪水最高的第六到第十名员工select * from emp order by sal desc limit 5,5;+-------+--------+----------+------+------------+---------+--------+--------+| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |+-------+--------+----------+------+------------+---------+--------+--------+|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |   NULL |     10 ||  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 |     30 ||  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |   0.00 |     30 ||  7934 | MILLER | CLERK    | 7782 | 1982-01-23 | 1300.00 |   NULL |     10 ||  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 |     30 |+-------+--------+----------+------+------------+---------+--------+--------+\n11、取得最后入职的5名员工select * from emp order by HIREDATE desc limit 0,5;+-------+--------+---------+------+------------+---------+------+--------+| EMPNO | ENAME  | JOB     | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |+-------+--------+---------+------+------------+---------+------+--------+|  7876 | ADAMS  | CLERK   | 7788 | 1987-05-23 | 1100.00 | NULL |     20 ||  7788 | SCOTT  | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL |     20 ||  7934 | MILLER | CLERK   | 7782 | 1982-01-23 | 1300.00 | NULL |     10 ||  7900 | JAMES  | CLERK   | 7698 | 1981-12-03 |  950.00 | NULL |     30 ||  7902 | FORD   | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |+-------+--------+---------+------+------------+---------+------+--------+\n12、取得每个薪水等级有多少员工步骤一：计算每个员工的薪水等级\nselect     empno,grade from    emp ejoin    salgrade son e.sal between s.losal and s.hisal;+-------+-------+| empno | grade |+-------+-------+|  7369 |     1 ||  7499 |     3 ||  7521 |     2 ||  7566 |     4 ||  7654 |     2 ||  7698 |     4 ||  7782 |     4 ||  7788 |     4 ||  7839 |     5 ||  7844 |     3 ||  7876 |     1 ||  7900 |     1 ||  7902 |     4 ||  7934 |     2 |+-------+-------+\n步骤二：按薪水等级分组，计算出每组的人数\nselect     grade,count(grade) as gradenumfrom    emp ejoin    salgrade son     e.sal between s.losal and s.hisalgroup by     s.grade;+-------+----------+| grade | gradenum |+-------+----------+|     1 |        3 ||     3 |        2 ||     2 |        3 ||     4 |        5 ||     5 |        1 |+-------+----------+\n13、列出所有员工及领导的名字select     a.ename,b.ename as leaderfrom     emp aleft join     emp bon     a.mgr = b.empno;  +--------+--------+| ename  | leader |+--------+--------+| SMITH  | FORD   || ALLEN  | BLAKE  || WARD   | BLAKE  || JONES  | KING   || MARTIN | BLAKE  || BLAKE  | KING   || CLARK  | KING   || SCOTT  | JONES  || KING   | NULL   || TURNER | BLAKE  || ADAMS  | SCOTT  || JAMES  | BLAKE  || FORD   | JONES  || MILLER | CLARK  |+--------+--------+\n14、列出受雇日期早于其直接上级的所有员工编号、姓名、部门名称select     a.empno,a.ename,d.dnamefrom     emp ajoin     emp bon     a.mgr = b.empnojoin     dept d on     d.deptno = a.deptnowhere     a.hiredate < b.hiredate;+-------+-------+------------+| empno | ename | dname      |+-------+-------+------------+|  7369 | SMITH | RESEARCH   ||  7499 | ALLEN | SALES      ||  7521 | WARD  | SALES      ||  7566 | JONES | RESEARCH   ||  7698 | BLAKE | SALES      ||  7782 | CLARK | ACCOUNTING |+-------+-------+------------+\n15、列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门select     d.dname,e.*from     dept d left join     emp eon     d.deptno = e.deptnoorder by    d.dname;+------------+-------+--------+-----------+------+------------+---------+---------+--------+| dname      | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+------------+-------+--------+-----------+------+------------+---------+---------+--------+| ACCOUNTING |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 || ACCOUNTING |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 || ACCOUNTING |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 || OPERATIONS |  NULL | NULL   | NULL      | NULL | NULL       |    NULL |    NULL |   NULL || RESEARCH   |  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 || RESEARCH   |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 || RESEARCH   |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 || RESEARCH   |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 || RESEARCH   |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 || SALES      |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 || SALES      |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 || SALES      |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 || SALES      |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 || SALES      |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 || SALES      |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |+------------+-------+--------+-----------+------+------------+---------+---------+--------+\n16、列出至少有5个员工的所有部门步骤一：列出每个部门的人数\nselect     e.deptno deptno,d.dname dname,count(e.deptno) empnumfrom     emp ejoin    dept don        e.deptno = d.deptnogroup by    e.deptno;+--------+------------+-----------------+| deptno | dname      | count(e.deptno) |+--------+------------+-----------------+|     20 | RESEARCH   |               5 ||     30 | SALES      |               6 ||     10 | ACCOUNTING |               3 |+--------+------------+-----------------+\n步骤二：列出至少有5个员工的所有部门\nselect     a.deptno ,a.dname,a.empnumfrom     (select         e.deptno deptno,d.dname dname,count(e.deptno) empnum    from         emp e    join        dept d    on            e.deptno = d.deptno    group by        e.deptno) awhere     a.empnum >= 5;    +--------+----------+--------+| deptno | dname    | empnum |+--------+----------+--------+|     20 | RESEARCH |      5 ||     30 | SALES    |      6 |+--------+----------+--------+\n17、列出薪水比“SMITH”多的所有员工信息select     *from     emp ewhere e.sal > (select sal from emp where ename = \'SMITH\');    +-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+\n18、列出所有“CLERK”（办事员）的姓名及其部门名称，部门人数步骤一：列出所有“CLERK”（办事员）的姓名及其部门名称\nselect     e.ename,d.dnamefrom     emp ejoin     dept don     e.deptno = d.deptnowhere     e.job = \'CLERK\';+--------+------------+| ename  | dname      |+--------+------------+| SMITH  | RESEARCH   || ADAMS  | RESEARCH   || JAMES  | SALES      || MILLER | ACCOUNTING |+--------+------------+\n步骤二：计算部门人数\nselect     d.dname,count(d.dname)from     emp ejoin     dept don     e.deptno = d.deptnowhere     e.job = \'CLERK\'group by    d.dname;    +------------+----------------+| dname      | count(d.dname) |+------------+----------------+| RESEARCH   |              2 || SALES      |              1 || ACCOUNTING |              1 |+------------+----------------+\n19、列出最低薪水大于1500的各种工作及从事此工作的全部雇员人数步骤一：计算所有工作的最低薪水以及人数\nselect     e.job as job,min(e.sal) as minsal,count(e.job) jobnumfrom     emp egroup by    e.job;+-----------+---------+--------+| job       | minsal  | jobnum |+-----------+---------+--------+| CLERK     |  800.00 |      4 || SALESMAN  | 1250.00 |      4 || MANAGER   | 2450.00 |      3 || ANALYST   | 3000.00 |      2 || PRESIDENT | 5000.00 |      1 |+-----------+---------+--------+\n步骤二：\n列出最低薪水大于1500的各种工作及从事此工作的全部雇员人数\nselect     a.job,a.minsal,a.jobnumfrom        (select     e.job as job,min(e.sal) as minsal,count(e.job) jobnumfrom     emp egroup by    e.job) awhere     a.minsal > 1500;+-----------+---------+--------+| job       | minsal  | jobnum |+-----------+---------+--------+| MANAGER   | 2450.00 |      3 || ANALYST   | 3000.00 |      2 || PRESIDENT | 5000.00 |      1 |+-----------+---------+--------+\n20、列出在部门“SALES”<销售部>工作的员工的姓名，假定不知道销售部门的部门编号步骤一：先找到部门“SALES”<销售部>的部门编号\nselect deptno from dept where dname = \'SALES\';+--------+| deptno |+--------+|     30 |+--------+\n步骤二：列出在部门“SALES”<销售部>工作的员工的姓名\nselect     enamefrom     emp ewhere    e.deptno = (select deptno from dept where dname = \'SALES\');+--------+| ename  |+--------+| ALLEN  || WARD   || MARTIN || BLAKE  || TURNER || JAMES  |+--------+\n21、列出薪金高于公司平均薪金的所有员工，所在部门、上级领导、雇员的工资等级步骤一：计算公司的平均薪资\nselect avg(sal) from emp;    +-------------+| avg(sal)    |+-------------+| 2073.214286 |+-------------+\n步骤二：找到薪金高于公司平均薪金的所有员工\nselect     e.ename,e.mgr,e.sal,e.deptnofrom     emp ewhere     e.sal > (select avg(sal) from emp);+-------+------+---------+--------+| ename | mgr  | sal     | deptno |+-------+------+---------+--------+| JONES | 7839 | 2975.00 |     20 || BLAKE | 7839 | 2850.00 |     30 || CLARK | 7839 | 2450.00 |     10 || SCOTT | 7566 | 3000.00 |     20 || KING  | NULL | 5000.00 |     10 || FORD  | 7566 | 3000.00 |     20 |+-------+------+---------+--------+\n步骤三：找到所在部门\nselect     e.ename,e.mgr,e.sal,d.dnamefrom     emp ejoin     dept don    e.deptno = d.deptnowhere     e.sal > (select avg(sal) from emp);+-------+------+---------+------------+| ename | mgr  | sal     | dname      |+-------+------+---------+------------+| JONES | 7839 | 2975.00 | RESEARCH   || BLAKE | 7839 | 2850.00 | SALES      || CLARK | 7839 | 2450.00 | ACCOUNTING || SCOTT | 7566 | 3000.00 | RESEARCH   || KING  | NULL | 5000.00 | ACCOUNTING || FORD  | 7566 | 3000.00 | RESEARCH   |+-------+------+---------+------------+\n步骤四：找到上级领导\nselect     e.ename,m.ename mgrname,e.sal,d.dnamefrom     emp eleft join    emp mon     e.mgr = m.empnojoin     dept don    e.deptno = d.deptnowhere     e.sal > (select avg(sal) from emp);+-------+---------+---------+------------+| ename | mgrname | sal     | dname      |+-------+---------+---------+------------+| JONES | KING    | 2975.00 | RESEARCH   || BLAKE | KING    | 2850.00 | SALES      || CLARK | KING    | 2450.00 | ACCOUNTING || SCOTT | JONES   | 3000.00 | RESEARCH   || KING  | NULL    | 5000.00 | ACCOUNTING || FORD  | JONES   | 3000.00 | RESEARCH   |+-------+---------+---------+------------+\n步骤四：计算雇员的工资等级\nselect     e.ename,m.ename mgrname,e.sal,d.dname,s.gradefrom     emp eleft join    emp mon     e.mgr = m.empnojoin     dept don    e.deptno = d.deptnojoin     salgrade son     e.sal between s.losal and s.hisalwhere     e.sal > (select avg(sal) from emp);+-------+---------+---------+------------+-------+| ename | mgrname | sal     | dname      | grade |+-------+---------+---------+------------+-------+| JONES | KING    | 2975.00 | RESEARCH   |     4 || BLAKE | KING    | 2850.00 | SALES      |     4 || CLARK | KING    | 2450.00 | ACCOUNTING |     4 || SCOTT | JONES   | 3000.00 | RESEARCH   |     4 || FORD  | JONES   | 3000.00 | RESEARCH   |     4 || KING  | NULL    | 5000.00 | ACCOUNTING |     5 |+-------+---------+---------+------------+-------+\n22、列出与“SCOTT”从事相同工作的所有员工及部门名称步骤一：找到“SCOTT”从事的工作\nselect job from emp where ename = \'SCOTT\';+---------+| job     |+---------+| ANALYST |+---------+\n步骤二：列出与“SCOTT”从事相同工作的所有员工\nselect     e.empno,e.deptnofrom     emp ewhere e.job = (select job from emp where ename = \'SCOTT\');    +-------+--------+| empno | deptno |+-------+--------+|  7788 |     20 ||  7902 |     20 |+-------+--------+\n步骤三：列出与“SCOTT”从事相同工作的所有员工及部门名称\nselect     e.empno,e.deptno,d.dnamefrom     emp ejoin     dept don        e.deptno = d.deptno    where e.job = (select job from emp where ename = \'SCOTT\');    +-------+--------+----------+| empno | deptno | dname    |+-------+--------+----------+|  7788 |     20 | RESEARCH ||  7902 |     20 | RESEARCH |+-------+--------+----------+\n23、列出薪金等于部门30中员工的薪金的其它员工的姓名和薪金步骤一：列出部门30中员工的薪资\nselect  distinct sal from emp where deptno = 30;+---------+| sal     |+---------+| 1600.00 || 1250.00 || 2850.00 || 1500.00 ||  950.00 |+---------+\n步骤二：列出薪金等于部门30中员工的薪金的其它员工的姓名和薪金\nselect     e.empno,e.ename,e.deptno,e.salfrom     emp ewhere    e.sal in (select  distinct sal from emp where deptno = 30)    and    e.deptno <> 30;\n24、列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金、部门名称步骤一：计算部门30员工的最高薪资\nselect max(sal) maxsal from emp where deptno = 30;+---------+| maxsal  |+---------+| 2850.00 |+---------+\n步骤二：列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金\nselect     e.ename,e.sal,e.deptnofrom     emp ewhere    e.sal > (select max(sal) maxsal from emp where deptno = 30);+-------+---------+--------+| ename | sal     | deptno |+-------+---------+--------+| JONES | 2975.00 |     20 || SCOTT | 3000.00 |     20 || KING  | 5000.00 |     10 || FORD  | 3000.00 |     20 |+-------+---------+--------+\n步骤三：找到部门名称\nselect     e.ename,e.sal,d.dnamefrom     emp ejoin     dept d on    e.deptno = d.deptnowhere    e.sal > (select max(sal) maxsal from emp where deptno = 30);+-------+---------+------------+| ename | sal     | dname      |+-------+---------+------------+| JONES | 2975.00 | RESEARCH   || SCOTT | 3000.00 | RESEARCH   || KING  | 5000.00 | ACCOUNTING || FORD  | 3000.00 | RESEARCH   |+-------+---------+------------+\n25、列出在每个部门工作的员工数量、平均工资和平均服务期限select     deptno, count(deptno) deptnum,avg(sal),avg((to_days(now()) - to_days(hiredate))/365) as avgyearsfrom     empgroup by    deptno;+--------+---------+-------------+-------------+| deptno | deptnum | avg(sal)    | avgyears    |+--------+---------+-------------+-------------+|     20 |       5 | 2175.000000 | 36.72930000 ||     30 |       6 | 1566.666667 | 39.00091667 ||     10 |       3 | 2916.666667 | 38.70226667 |+--------+---------+-------------+-------------+\n26、列出所有员工的姓名、部门名称和工资select     e.ename,d.dname,e.salfrom     emp ejoin     dept don     e.deptno = d.deptno;+--------+------------+---------+| ename  | dname      | sal     |+--------+------------+---------+| SMITH  | RESEARCH   |  800.00 || ALLEN  | SALES      | 1600.00 || WARD   | SALES      | 1250.00 || JONES  | RESEARCH   | 2975.00 || MARTIN | SALES      | 1250.00 || BLAKE  | SALES      | 2850.00 || CLARK  | ACCOUNTING | 2450.00 || SCOTT  | RESEARCH   | 3000.00 || KING   | ACCOUNTING | 5000.00 || TURNER | SALES      | 1500.00 || ADAMS  | RESEARCH   | 1100.00 || JAMES  | SALES      |  950.00 || FORD   | RESEARCH   | 3000.00 || MILLER | ACCOUNTING | 1300.00 |+--------+------------+---------+\n27、列出所有部门的详细信息和人数select     d.*,count(e.empno) as empnumfrom     dept dleft join    emp eon    d.deptno = e.deptnogroup by    d.deptno;+--------+------------+----------+--------+| DEPTNO | DNAME      | LOC      | empnum |+--------+------------+----------+--------+|     20 | RESEARCH   | DALLAS   |      5 ||     30 | SALES      | CHICAGO  |      6 ||     10 | ACCOUNTING | NEW YORK |      3 ||     40 | OPERATIONS | BOSTON   |      0 |+--------+------------+----------+--------+\n28、列出各种工作的最低工资及从事此工作的雇员姓名步骤一：找到各种工作的最低工资\nselect     job,min(sal) minsal from     emp egroup by     job;+-----------+---------+| job       | minsal  |+-----------+---------+| CLERK     |  800.00 || SALESMAN  | 1250.00 || MANAGER   | 2450.00 || ANALYST   | 3000.00 || PRESIDENT | 5000.00 |+-----------+---------+\n步骤二：列出各种工作的最低工资及从事此工作的雇员姓名\nselect     e.job,e.sal,e.enamefrom    emp ejoin     (select         job,min(sal) minsal     from         emp e    group by         job) aon     e.job = a.job and e.sal = a.minsal;+-----------+---------+--------+| job       | sal     | ename  |+-----------+---------+--------+| CLERK     |  800.00 | SMITH  || SALESMAN  | 1250.00 | WARD   || SALESMAN  | 1250.00 | MARTIN || MANAGER   | 2450.00 | CLARK  || ANALYST   | 3000.00 | SCOTT  || PRESIDENT | 5000.00 | KING   || ANALYST   | 3000.00 | FORD   |+-----------+---------+--------+\n29、列出各个部门MANAGER的最低薪金select     deptno,min(sal)from     emp ewhere     job=\'MANAGER\'    group by    deptno;+--------+----------+| deptno | min(sal) |+--------+----------+|     20 |  2975.00 ||     30 |  2850.00 ||     10 |  2450.00 |    +--------+----------+\n30、列出所有员工的年工资，按年薪从低到高排序select     ename, (sal *12) yearsal from     emporder by sal;    +--------+----------+| ename  | yearsal  |+--------+----------+| SMITH  |  9600.00 || JAMES  | 11400.00 || ADAMS  | 13200.00 || WARD   | 15000.00 || MARTIN | 15000.00 || MILLER | 15600.00 || TURNER | 18000.00 || ALLEN  | 19200.00 || CLARK  | 29400.00 || BLAKE  | 34200.00 || JONES  | 35700.00 || SCOTT  | 36000.00 || FORD   | 36000.00 || KING   | 60000.00 |+--------+----------+\n31、求出员工领导的薪水超过3000的员工名称和领导名称select     e.ename,m.ename mgrnamefrom     emp ejoin     emp mon    m.empno = e.mgrwhere     m.sal > 3000;+-------+---------+| ename | mgrname |+-------+---------+| JONES | KING    || BLAKE | KING    || CLARK | KING    |+-------+---------+\n32、求部门名称中带“S”字符的部门员工的工资合计、部门人数步骤一：找到部门名称中带“S”字符的部门\nselect * from dept d where d.dname like \'%S%\';\n步骤二：求部门名称中带“S”字符的部门员工的工资合计、部门人数\nselect     e.deptno,sum(sal),count(e.deptno)from     emp ejoin     (select *  from dept d where d.dname like \'%S%\') don     e.deptno = d.deptnogroup by    e.deptno;+--------+----------+-----------------+| deptno | sum(sal) | count(e.deptno) |+--------+----------+-----------------+|     20 | 10875.00 |               5 ||     30 |  9400.00 |               6 |+--------+----------+-----------------+\n33、给任职日期超过30年的员工加薪10%select     empno,ename,sal*1.1from     empwhere     ((to_days(now())-to_days(hiredate))/365)>30;+-------+--------+---------+| empno | ename  | sal*1.1 |+-------+--------+---------+|  7369 | SMITH  |  880.00 ||  7499 | ALLEN  | 1760.00 ||  7521 | WARD   | 1375.00 ||  7566 | JONES  | 3272.50 ||  7654 | MARTIN | 1375.00 ||  7698 | BLAKE  | 3135.00 ||  7782 | CLARK  | 2695.00 ||  7788 | SCOTT  | 3300.00 ||  7839 | KING   | 5500.00 ||  7844 | TURNER | 1650.00 ||  7876 | ADAMS  | 1210.00 ||  7900 | JAMES  | 1045.00 ||  7902 | FORD   | 3300.00 ||  7934 | MILLER | 1430.00 |+-------+--------+---------+\n', 0, 1);
INSERT INTO `t_article` VALUES (151, '14、存储过程', 8, '\n\n## 1、什么是存储过程？\n\n   	如果实现用户的某些需求时，需要编写一组复杂的SQL语句才能实现，那么可以将这组复杂的SQL语句集编写在数据库中，由JDBC调用来执行这组SQL语句。把编写在数据库中的SQL语句集称为存储过程。\n        存储过程（PROCEDURE）是事先经过编译并存储在数据库中的一段 SQL 语句的集合。调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。\n         存储过程类似于JAVA语言中的方法，需要先定义，使用时需要调用。存储过程可以定义参数，参数分为IN、OUT、INOUT 类型三种类型。IN类型的参数表示接收调用者传入的数据，OUT类型的参数表示向调用者返回数据，INOUT类型的参数既可以接收调用者传入的参数，也可以向调用者返回数据。\n\n\n\n## 2、存储过程的语法格式\n\n### 2.1 定义\n\n```mysql\nDELIMITER$$\ncreate procedure 存储过程名（in 变量名 类型，out 参数2，…）\nbegin\n   declare   变量名 类型 [DEFAULT  值];\n   set 变量名 = 值;\n   存储过程语句块;\nEND$$\n```\n\n演示存储过程参数使用\n\n```mysql\nDELIMITER$$                                       -- out 从存储过程向调用处输出\nCREATE PROCEDURE test3(IN p_account VARCHAR(10),IN p_sex VARCHAR(1),OUT p_num INT)\nBEGIN\n   DECLARE v_num INT;\n   SET v_num  = 10;\n   SET p_num = v_num;\n   INSERT INTO t_test(account,sex)VALUES(p_account,p_sex);\n   SELECT p_num;\nEND$$ \n```\n\n\n\n### 2.2 调用\n\n```mysql\nCALL 存储过程名([形参]);\n```\n\n\n\n### 2.3 删除\n\n```mysql\nDROP PROCEDURE 存储过程名\n```\n\n\n\n## 3、语法解析\n\n1.存储过程的参数分为in，out，inout三种类型。\n\n2.in代表输入参数（默认情况下为in参数），表示该参数的值必须由调用程序指定。\n\n3.out代表输出参数，表示该参数的值经存储过程计算后，将out参数的计算结果返回给调用程序。\n\n4.inout代表即是输入参数，又是输出参数，表示该参数的值即可以由调用程序指定，又可以将 inout参数的计算结果返回给调用程序。\n\n5.存储过程中的语句必须包含在begin和end之间。\n\n6.declare 中用来声明变量,变量默认赋值使用default,语句块中改变变量值,使用set  变量=值;\n\n\n\n## 4、 流程控制\n\n### 4.1 选择语句：\n\n（1）if选择\n\n```mysql\nIF  条件  THEN\n       语句\n   ELSEIF  条件   THEN\n        语句\n  ELSE \n        语句\n  END IF;\n\n```\n\n在存储过程中判断账号是否存在,不存在保存,返回0  存在不保存返回1\n\n```mysql\nDELIMITER$$\nCREATE PROCEDURE test8(IN p_account VARCHAR(10),IN p_sex VARCHAR(1),OUT p_mark INT)\nBEGIN\nDECLARE v_count INT;\n   SELECT COUNT(*) INTO v_count FROM t_test WHERE account = p_account;\n    IF v_count=0 THEN \n      INSERT INTO t_test(account,sex)VALUES(p_account,p_sex);\n      SET p_mark = 0;\n    ELSE \n      SET p_mark = 1;\n    END IF;\n    SELECT p_mark;\nEND$$ \n```\n\n```mysql\nCALL test8(\'admin2\',\'男\',@p)\n```\n\n\n\n（2）case选择\n\n```mysql\nCASE WHEN   条件  THEN\n      语句      \n  ELSE \n      语句\n  END CASE;\n```\n\n演示：\n\n```mysql\nDELIMITER$$\nCREATE PROCEDURE test9(IN p_day INT)\nBEGIN\n   CASE WHEN p_day=0 THEN \n          SELECT \"星期天\";\n        WHEN p_day=1 THEN  \n          SELECT \"星期一\";\n        ELSE \n          SELECT \"无效日期\";\n   END CASE;\nEND$$ \n```\n\n```mysql\nCALL test9(2)\n```\n\n\n\n### 4.2 循环语句\n\nloop 必须配合 leave 使用，loop没有停止语句，使用leave跳出被标注的流程控制语句\n\n```mysql\nIF 条件 THEN LEAVE 标记;\nEND IF;\nend loop 标记;\n```\n\n示例：\n\n```mysql\nDELIMITER$$\nCREATE PROCEDURE test10()\nBEGIN\nDECLARE v_num INT DEFAULT 0;\n    addnum:LOOP\n       SET v_num = v_num+1;\n       IF v_num=10 THEN\n          LEAVE addnum; \n       END IF;\n      END LOOP addnum;\n     SELECT v_num;\nEND$$ \n```\n\n```mysql\nCALL test10();\n```\n\n\n\n## 5、在Java中调用存储过程\n\n### 5.1 jdbc中调用\n\n```java\npackage com.ff.mybatisPro.test;\n\nimport java.sql.CallableStatement;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Types;\n\npublic class TestJdbcCall {\n	\n	public static void main(String[] args) throws SQLException {\n		 Connection  connection = null;\n		 CallableStatement  call = null;\n		try {\n			Class.forName(\"com.mysql.jdbc.Driver\");//创建Driver类的对象\n			  connection = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/kj_db?characterEncoding=utf8\", \"root\", \"root\");\n			    //jdbc调用存储过程\n			    call =   connection.prepareCall(\"{call test8(?,?,?)}\");\n			    //设置输入参数\n		        call.setString(1,\"admin3\");\n		        call.setString(2, \"男\");\n		        //输出参数注册\n		        call.registerOutParameter(3, Types.INTEGER);\n		        call.executeUpdate();\n		        //获得输出参数\n		        System.out.println(call.getInt(3));\n		} catch (SQLException e) {\n			e.printStackTrace();\n			System.out.println(\"链接数据库异常\");\n		}catch (ClassNotFoundException e) {\n			e.printStackTrace();\n			System.out.println(\"类找不到异常\");\n		}finally{\n			if(connection!=null){\n				connection.close();\n			}\n			if(call!=null){\n				call.close();\n			}\n			\n		}\n	}\n}\n```\n\n\n\n### 5.2 MyBatis中调用\n\nUserMapper.xml\n\n```xml\n<parameterMap type=\"map\" id=\"usermap\">\n    <parameter property=\"account\" jdbcType=\"VARCHAR\" mode=\"IN\"/>\n    <parameter property=\"sex\" jdbcType=\"VARCHAR\" mode=\"IN\"/>\n    <parameter property=\"res\" jdbcType=\"INTEGER\" mode=\"OUT\"/>\n</parameterMap>\n\n<insert id=\"save\" parameterMap=\"usermap\" 		statementType=\"CALLABLE\">\n	{call test8(?,?,?)}\n</insert>\n```\n\nTestMybatisCall.java\n\n```java\npackage com.ff.mybatisPro.test;\n\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.junit.Test;\nimport com.ff.mybatisPro.bean.User;\nimport com.ff.mybatisPro.dao.UserDao;\nimport com.ff.mybatisPro.util.MybatisUtil;\n\npublic class TestMybatisCall {\n	\n	@Test\n	public void save(){\n		SqlSession sqlSession1=MybatisUtil.getSqlSession();\n		UserDao userdao1 = sqlSession1.getMapper(UserDao.class);\n		Map<String, Object> parms = new HashMap<String, Object>();  \n		parms.put(\"account\",\"admin6\");\n		parms.put(\"sex\",\"男\");\n		userdao1.save(parms);  \n		System.out.println(parms.get(\"res\"));//输出参数\n		  \n		sqlSession1.commit();\n		sqlSession1.close();\n	}	 \n}\n```\n\n', 0, 0, '2020-08-07 01:21:49', 2, 0, 1, '1、什么是存储过程？   如果实现用户的某些需求时，需要编写一组复杂的SQL语句才能实现，那么可以将这组复杂的SQL语句集编写在数据库中，由JDBC调用来执行这组SQL语句。把编写在数据库中的SQL语句集称为存储过程。    存储过程（PROCEDURE）是事先经过编译并存储在数据库中的一段 SQL 语句的集合。调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。     存储过程类似于JAVA语言中的方法，需要先定义，使用时需要调用。存储过程可以定义参数，参数分为IN、OUT、INOUT 类型三种类型。IN类型的参数表示接收调用者传入的数据，OUT类型的参数表示向调用者返回数据，INOUT类型的参数既可以接收调用者传入的参数，也可以向调用者返回数据。2、存储过程的语法格式2.1 定义DELIMITER$$create procedure 存储过程名（in 变量名 类型，out 参数2，…）begin   declare   变量名 类型 [DEFAULT  值];   set 变量名 = 值;   存储过程语句块;END$$\n演示存储过程参数使用\nDELIMITER$$                                       -- out 从存储过程向调用处输出CREATE PROCEDURE test3(IN p_account VARCHAR(10),IN p_sex VARCHAR(1),OUT p_num INT)BEGIN   DECLARE v_num INT;   SET v_num  = 10;   SET p_num = v_num;   INSERT INTO t_test(account,sex)VALUES(p_account,p_sex);   SELECT p_num;END$$\n2.2 调用CALL 存储过程名([形参]);\n2.3 删除DROP PROCEDURE 存储过程名\n3、语法解析1.存储过程的参数分为in，out，inout三种类型。\n2.in代表输入参数（默认情况下为in参数），表示该参数的值必须由调用程序指定。\n3.out代表输出参数，表示该参数的值经存储过程计算后，将out参数的计算结果返回给调用程序。\n4.inout代表即是输入参数，又是输出参数，表示该参数的值即可以由调用程序指定，又可以将 inout参数的计算结果返回给调用程序。\n5.存储过程中的语句必须包含在begin和end之间。\n6.declare 中用来声明变量,变量默认赋值使用default,语句块中改变变量值,使用set  变量=值;\n4、 流程控制4.1 选择语句：（1）if选择\nIF  条件  THEN       语句   ELSEIF  条件   THEN        语句  ELSE         语句  END IF;\n在存储过程中判断账号是否存在,不存在保存,返回0  存在不保存返回1\nDELIMITER$$CREATE PROCEDURE test8(IN p_account VARCHAR(10),IN p_sex VARCHAR(1),OUT p_mark INT)BEGINDECLARE v_count INT;   SELECT COUNT(*) INTO v_count FROM t_test WHERE account = p_account;    IF v_count=0 THEN       INSERT INTO t_test(account,sex)VALUES(p_account,p_sex);      SET p_mark = 0;    ELSE       SET p_mark = 1;    END IF;    SELECT p_mark;END$$\nCALL test8(\'admin2\',\'男\',@p)\n（2）case选择\nCASE WHEN   条件  THEN      语句        ELSE       语句  END CASE;\n演示：\nDELIMITER$$CREATE PROCEDURE test9(IN p_day INT)BEGIN   CASE WHEN p_day=0 THEN           SELECT \"星期天\";        WHEN p_day=1 THEN            SELECT \"星期一\";        ELSE           SELECT \"无效日期\";   END CASE;END$$\nCALL test9(2)\n4.2 循环语句loop 必须配合 leave 使用，loop没有停止语句，使用leave跳出被标注的流程控制语句\nIF 条件 THEN LEAVE 标记;END IF;end loop 标记;\n示例：\nDELIMITER$$CREATE PROCEDURE test10()BEGINDECLARE v_num INT DEFAULT 0;    addnum:LOOP       SET v_num = v_num+1;       IF v_num=10 THEN          LEAVE addnum;        END IF;      END LOOP addnum;     SELECT v_num;END$$\nCALL test10();\n5、在Java中调用存储过程5.1 jdbc中调用package com.ff.mybatisPro.test;import java.sql.CallableStatement;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Types;public class TestJdbcCall {    public static void main(String[] args) throws SQLException {         Connection  connection = null;         CallableStatement  call = null;        try {            Class.forName(\"com.mysql.jdbc.Driver\");//创建Driver类的对象              connection = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/kj_db?characterEncoding=utf8\", \"root\", \"root\");                //jdbc调用存储过程                call =   connection.prepareCall(\"{call test8(?,?,?)}\");                //设置输入参数                call.setString(1,\"admin3\");                call.setString(2, \"男\");                //输出参数注册                call.registerOutParameter(3, Types.INTEGER);                call.executeUpdate();                //获得输出参数                System.out.println(call.getInt(3));        } catch (SQLException e) {            e.printStackTrace();            System.out.println(\"链接数据库异常\");        }catch (ClassNotFoundException e) {            e.printStackTrace();            System.out.println(\"类找不到异常\");        }finally{            if(connection!=null){                connection.close();            }            if(call!=null){                call.close();            }        }    }}\n5.2 MyBatis中调用UserMapper.xml\n<parameterMap type=\"map\" id=\"usermap\">    <parameter property=\"account\" jdbcType=\"VARCHAR\" mode=\"IN\"/>    <parameter property=\"sex\" jdbcType=\"VARCHAR\" mode=\"IN\"/>    <parameter property=\"res\" jdbcType=\"INTEGER\" mode=\"OUT\"/></parameterMap><insert id=\"save\" parameterMap=\"usermap\"         statementType=\"CALLABLE\">    {call test8(?,?,?)}</insert>\nTestMybatisCall.java\npackage com.ff.mybatisPro.test;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import com.ff.mybatisPro.bean.User;import com.ff.mybatisPro.dao.UserDao;import com.ff.mybatisPro.util.MybatisUtil;public class TestMybatisCall {    @Test    public void save(){        SqlSession sqlSession1=MybatisUtil.getSqlSession();        UserDao userdao1 = sqlSession1.getMapper(UserDao.class);        Map<String, Object> parms = new HashMap<String, Object>();          parms.put(\"account\",\"admin6\");        parms.put(\"sex\",\"男\");        userdao1.save(parms);          System.out.println(parms.get(\"res\"));//输出参数        sqlSession1.commit();        sqlSession1.close();    }     }\n', 0, 1);
INSERT INTO `t_article` VALUES (152, '15、函数', 8, '\n\n## 1、函数语法\n\n```mysql\ncreate function 函数名([参数列表]) returns 数据类型\nbegin\n      sql语句;\n return 值;\nend;\n```\n\n 注意：\n        1.参数列表包含两部分：参数名 参数类型\n        2.函数体：肯定会有return语句，如果没有会报错\n            如果return语句放在函数的最后也不报错，但不建议\n            return 值;\n        3.函数题中仅有一句话，则可以省略begin end\n        4.使用 delimter语句设置结束标记\n\n## 2、删除函数\n\n```mysql\nDROP FUNCTION myf2;\n```\n\n\n\n## 3、案例\n\n```mysql\nDELIMITER$$\nCREATE FUNCTION checktype(ptype VARCHAR(15)) RETURNS VARCHAR(30)\nBEGIN \n    IF ptype = \'0\' THEN\n      RETURN \'超管\';\n    ELSE\n      RETURN \'普通用户\';\n    END IF;\nEND$$\n```\n\n调用：\n\n```mysql\nSELECT checktype(TYPE) FROM t_user;\n```\n\n', 0, 0, '2020-08-07 01:22:19', 2, 0, 1, '1、函数语法create function 函数名([参数列表]) returns 数据类型begin      sql语句; return 值;end;\n 注意：        1.参数列表包含两部分：参数名 参数类型        2.函数体：肯定会有return语句，如果没有会报错            如果return语句放在函数的最后也不报错，但不建议            return 值;        3.函数题中仅有一句话，则可以省略begin end        4.使用 delimter语句设置结束标记\n2、删除函数DROP FUNCTION myf2;\n3、案例DELIMITER$$CREATE FUNCTION checktype(ptype VARCHAR(15)) RETURNS VARCHAR(30)BEGIN     IF ptype = \'0\' THEN      RETURN \'超管\';    ELSE      RETURN \'普通用户\';    END IF;END$$\n调用：\nSELECT checktype(TYPE) FROM t_user;\n', 0, 1);
INSERT INTO `t_article` VALUES (153, '16、触发器', 8, '\n\n## 1、触发器的定义\n\n触发器（trigger）是一种特殊的存储过程，其特殊性在于它并不需要用户直接调用，而是在对表添加、修改、删除之前或者之后自动执行的存储过程。\n使用触发器实现注册业务时，JDBC可以对表实现添加信息，添加成功后自动激活触发器。\n\n\n\n## 2、触发器的特点\n\n 1.与表相关联\n	触发器定义在特定的表上，这个表称为触发器表。\n\n 2.自动激活触发器\n\n​	当对表中的数据执行 INSERT、UPDATE 或 DELETE 操作时，如果对表上的这个特定操作定义了触发器，该触发器自动执行，这是不可撤销的。\n\n3.不能直接调\n\n​	与存储过程不同，触发器不能被直接调用，也不能传递或接受参数。\n\n4.作为事务的一部分\n\n​	触发器与激活触发器的语句一起做为对一个单一的事务来对待，可以从触发器中的任何位置回滚。\n在触发器中可以使用两个特殊的临时表，即OLD表和NEW表。OLD表用于存储UPDATE语句和DELETE语句中影响的记录，NEW表用于存储INSERT语句和UPDATE语句影响的记录。\n\n\n\n## 3、触发器的语法\n\n```mysql\nCREATE   TRIGGER   触发器名称    \n触发时机   \n触发事件 ON 表名称 FOR EACH ROW      	--行级事件\nBEGIN\n    语句								--触发的语句\nEND;\n```\n\n语法解析：\n\n1.触发器名称：是用来标识触发器的，由用户自定义。\n2.触发时机：其值是before或after。\n3.触发事件：其值是insert，update和delete\n4.表名称：标识建立触发器的表名，即在哪张表上建立触发器\n5.语句：是触发器程序体，触发器程序可以使用begin和end作为开始和结束，中间包含多条语句；\n\n\n\n## 4、案例\n\n删除用户时,自动触发删除用户菜单关系\n\n```\nDELIMITER $$\nCREATE  TRIGGER    tr_delete_user_menu\nAFTER \nDELETE ON t_user FOR EACH ROW \nBEGIN\n  DELETE FROM t_user_menu WHERE user_id  = old.id;\nEND $$\n```\n\n- 在行级触发器代码中，可以使用:old和:new访问到该行的旧数据和新数据，old和new是对应表的行记录类型变量。\n- 对于不同的DML语句，触发器代码中的old 和new记录中的值：\n  new.column \n  old.column \n\n', 0, 0, '2020-08-07 13:31:38', 3, 0, 1, '1、触发器的定义触发器（trigger）是一种特殊的存储过程，其特殊性在于它并不需要用户直接调用，而是在对表添加、修改、删除之前或者之后自动执行的存储过程。使用触发器实现注册业务时，JDBC可以对表实现添加信息，添加成功后自动激活触发器。\n2、触发器的特点 1.与表相关联    触发器定义在特定的表上，这个表称为触发器表。\n 2.自动激活触发器\n​    当对表中的数据执行 INSERT、UPDATE 或 DELETE 操作时，如果对表上的这个特定操作定义了触发器，该触发器自动执行，这是不可撤销的。\n3.不能直接调\n​    与存储过程不同，触发器不能被直接调用，也不能传递或接受参数。\n4.作为事务的一部分\n​    触发器与激活触发器的语句一起做为对一个单一的事务来对待，可以从触发器中的任何位置回滚。在触发器中可以使用两个特殊的临时表，即OLD表和NEW表。OLD表用于存储UPDATE语句和DELETE语句中影响的记录，NEW表用于存储INSERT语句和UPDATE语句影响的记录。\n3、触发器的语法CREATE   TRIGGER   触发器名称    触发时机   触发事件 ON 表名称 FOR EACH ROW          --行级事件BEGIN    语句                                --触发的语句END;\n语法解析：\n1.触发器名称：是用来标识触发器的，由用户自定义。2.触发时机：其值是before或after。3.触发事件：其值是insert，update和delete4.表名称：标识建立触发器的表名，即在哪张表上建立触发器5.语句：是触发器程序体，触发器程序可以使用begin和end作为开始和结束，中间包含多条语句；\n4、案例删除用户时,自动触发删除用户菜单关系\nDELIMITER $$CREATE  TRIGGER    tr_delete_user_menuAFTER DELETE ON t_user FOR EACH ROW BEGIN  DELETE FROM t_user_menu WHERE user_id  = old.id;END $$\n在行级触发器代码中，可以使用:old和:new访问到该行的旧数据和新数据，old和new是对应表的行记录类型变量。对于不同的DML语句，触发器代码中的old 和new记录中的值：new.columnold.column \n', 0, 1);
INSERT INTO `t_article` VALUES (154, '01.eclipse中Web项目的创建及服务器Tomcat 9.0配置', 8, '## 目录：\n\n一、创建Web项目\n\n二、查看项目结构\n\n三、添加服务器Tomcat 9.0\n\n四、配置服务器Tomcat 9.0\n\n五、删除服务器\n\n## 一、创建Web项目\n\n\\1. 创建项目\n\n![img](https://pic3.zhimg.com/v2-cc68ed24e97a90de2fd02c1c4c99fb5e_b.png)\n\n2.Dynamic Web Project配置\n\n![img](https://pic3.zhimg.com/v2-d3e98a223acf823418edd68a02ee26b2_b.png)\n\n3.点击New Runtime选择服务器类型，我选择的是Apache旗下的Tomcat v9.0版本，选择完后，点击Next。\n\n![img](https://pic2.zhimg.com/v2-415efbeb2ed7d3314de0d0bff5817dbd_b.png)\n\n4.然后点击Browse选择TomCat的安装路径，我的是D:\\Program Files\\Apache Software Foundation\\Tomcat 9.0，精确到Tomcat的文件位置就好。此处的JRE可以选中Eclipse默认的，也可以选择自己安装JDK中的JRE。完成后点击Finish。\n\n![img](https://pic3.zhimg.com/v2-69a5463de505f8ae5ecd4eee1de379be_b.png)\n\n5.点击Next\n\n![img](https://pic1.zhimg.com/v2-01df05bf868f1015a0a0deb78a3f7a98_b.png)\n\n6.默认，点击Next\n\n![img](https://pic3.zhimg.com/v2-e1e40adcb46df01b8f7814b0d05fba52_b.png)\n\n7.选择默认的，点击Finish完成项目创建，我们可以不勾选下面的Generate web.xml，我们也可以通过后面的操作把这个加上。\n\n![img](https://pic3.zhimg.com/v2-cb8fde68ef388a00d16f5ac06695859e_b.png)\n\n## 二、查看项目结构\n\n1.查看项目结构\n\n![img](https://pic4.zhimg.com/v2-9b805c65939a55940adc7ceaa72c04a3_b.png)\n\n2.打开Java EE 的开放视图\n\n![img](https://pic2.zhimg.com/v2-4fd5d7971bc65176e294db0e7b861479_b.png)\n\n![img](https://pic4.zhimg.com/v2-59e8747052d8570692160beb4a6610ff_b.png)\n\n3.添加web.xml文件及相关的文件。\n\n![img](https://pic2.zhimg.com/v2-cbc956bda2ca8d9a1658c4bfa92021d1_b.png)\n\n4.检测库文件是否需要添加\n\n![img](https://pic1.zhimg.com/v2-f25aa2a1d9c9e07bad069c3d738e9d74_b.png)\n\n![img](https://pic4.zhimg.com/v2-78941ef2e5189d41d54a11ed28be8e93_b.png)\n\n![img](https://pic2.zhimg.com/v2-8ee0bf0bc3d4a6ffb61cd4e8634db5ed_b.png)\n\n![img](https://pic1.zhimg.com/v2-d670f359109019287720ebc32b571df8_b.png)\n\n## 三、添加服务器Tomcat9.0\n\n1.点击创建服务器\n\n![img](https://pic2.zhimg.com/v2-3d5a59b041c8756e0096d3bbfc2e5f3d_b.png)\n\n2.选择Tomcat v9.0 Server，点击Next\n\n![img](https://pic3.zhimg.com/v2-0dda351a1f46bb3830c73b992ac95b8e_b.png)\n\n3.点击选择项目，最好只选择一个项目，防止后期调试会报错，不好寻找错误的来源。\n\n![img](https://pic3.zhimg.com/v2-ec22716cce3f60e22e591339c187f162_b.png)\n\n4.点击Finish，完成服务器的选择。\n\n![img](https://pic2.zhimg.com/v2-661692a0605d96d812884fa523cc1039_b.png)\n\n5.检测\n\n![img](https://pic3.zhimg.com/v2-7a6defcdd4bba64e12ad787530ec7856_b.png)\n\n## 四、配置服务器TomCat\n\n1.打开服务器配置\n\n![img](https://pic1.zhimg.com/v2-24284bc89947eab41b02825c029b4ef4_b.png)\n\n2.配置服务器\n\n![img](https://pic4.zhimg.com/v2-4294acc0f75bc0e1cb637675e58f31e3_b.png)\n\n3.配置完一定要保存\n\n![img](https://pic4.zhimg.com/v2-233d958df7c8a7b10c8edf15b90cd8cf_b.png)\n\n4.运行服务器\n\n![img](https://pic2.zhimg.com/v2-66de7013d4bbd5a0f159170ae2698ed1_b.png)\n\n5.关闭服务器\n\n![img](https://pic1.zhimg.com/v2-85036c55d293df94d266c4022e06ba80_b.png)\n\n## 五、如何删除服务器（如果一旦发现服务器有问题，删除重装一定是最好的选择）\n\n删除一定要删除干净。\n\n![img](https://pic4.zhimg.com/v2-88e833153a3d8cd8a18bcceac278979b_b.png)\n\n![img](https://pic2.zhimg.com/v2-fd525d16447a6f019d6d08c52fe742b9_b.png)\n\n![img](https://pic1.zhimg.com/v2-946d5e71680a5a203e55cfb6f9847960_b.png)\n\n', 0, 0, '2020-08-07 14:14:07', 2, 0, 1, '目录：一、创建Web项目\n二、查看项目结构\n三、添加服务器Tomcat 9.0\n四、配置服务器Tomcat 9.0\n五、删除服务器\n一、创建Web项目\\1. 创建项目\n\n2.Dynamic Web Project配置\n\n3.点击New Runtime选择服务器类型，我选择的是Apache旗下的Tomcat v9.0版本，选择完后，点击Next。\n\n4.然后点击Browse选择TomCat的安装路径，我的是D:\\Program Files\\Apache Software Foundation\\Tomcat 9.0，精确到Tomcat的文件位置就好。此处的JRE可以选中Eclipse默认的，也可以选择自己安装JDK中的JRE。完成后点击Finish。\n\n5.点击Next\n\n6.默认，点击Next\n\n7.选择默认的，点击Finish完成项目创建，我们可以不勾选下面的Generate web.xml，我们也可以通过后面的操作把这个加上。\n\n二、查看项目结构1.查看项目结构\n\n2.打开Java EE 的开放视图\n\n\n3.添加web.xml文件及相关的文件。\n\n4.检测库文件是否需要添加\n\n\n\n\n三、添加服务器Tomcat9.01.点击创建服务器\n\n2.选择Tomcat v9.0 Server，点击Next\n\n3.点击选择项目，最好只选择一个项目，防止后期调试会报错，不好寻找错误的来源。\n\n4.点击Finish，完成服务器的选择。\n\n5.检测\n\n四、配置服务器TomCat1.打开服务器配置\n\n2.配置服务器\n\n3.配置完一定要保存\n\n4.运行服务器\n\n5.关闭服务器\n\n五、如何删除服务器（如果一旦发现服务器有问题，删除重装一定是最好的选择）删除一定要删除干净。\n\n\n\n', 0, 1);
INSERT INTO `t_article` VALUES (155, '02.《Java EE学习笔记》Servlet', 8, '## 目录：\n\n一、Servlet的基本概念\n\n二、Servlet的三种使用方式\n\n三、Servlet 的生命周期\n\n四、Servlet 的配置\n\n五、访问Servlet的三种方式\n\n六、Servlet获取请求数据\n\n七、响应重定向和请求转发\n\n## 一、Servlet的基本概念\n\nServlet（Servlet Applet），全称Java Servlet,是用Java编写的服务器端程序。而这些Servlet继承HttpServlet类。其主要功能在于交互式的浏览和修改数据，生成动态Web内容。Servlet运行于支持Java的应用服务器中。\n\nHttpServlet 重写doGet 和 doPost 方法或者你也可以重写service方法完成对get和post请求响应。\n\n使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。\n\n**Servlet的主要任务：**\n\n- 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。\n- 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。\n- 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。\n- 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。\n- 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。\n\n## 二、Servlet的三种使用方式\n\n### 2.1  实现 Servlet 接口\n\n```java\npackage servlet;\n\nimport java.io.IOException;\n\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\npublic class servlet implements Servlet {\n\n	\n	\n	//返回一个 ServletConfig对象,它包含了servlet的初始化和起始参数。\n	@Override\n	public ServletConfig getServletConfig() {\n		// TODO Auto-generated method stub\n		return null;\n	}\n	\n	//返回有关servlet的信息，例如作者、版本、版权。\n	@Override\n	public String getServletInfo() {\n		// TODO Auto-generated method stub\n		return null;\n	}\n\n	//生命周期方法:当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次\n	@Override\n	public void init(ServletConfig arg0) throws ServletException {\n		System.out.println(\"init...\");\n	}\n\n	//生命周期方法:对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法\n	@Override\n	public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {\n		System.out.println(\"service...\");\n		\n	}\n\n        //生命周期方法:Servlet被销毁时调用\n	@Override\n	public void destroy() {\n		// TODO Auto-generated method stub\n		\n	}\n\n}\n```\n\n### 2.2 **继承 GenericServlet 类**\n\n它实现了 Servlet 接口除了 service 的方法，不过这种方法我们极少用。\n\n```java\npackage servlet;\n\nimport java.io.IOException;\n\nimport javax.servlet.GenericServlet;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\npublic class SecondServlet extends GenericServlet {\n\n	@Override\n	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n		// TODO Auto-generated method stub\n		System.out.println(\"Hello World\");\n	}\n	\n}\n```\n\n### 2.3 **继承 HttpServlet 方法**\n\n创建 Servlet 的第三种方法，也是我们经常用的方法。\n\n![img](https://pic3.zhimg.com/v2-fc4005f4509d7e4d345bf2dc43b1aec6_b.png)\n\n```java\npackage servlet;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Servlet implementation class ThirdServlet\n */\n@WebServlet(\"/ThirdServlet\")\npublic class ThirdServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n       \n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public ThirdServlet() {\n        super();\n        // TODO Auto-generated constructor stub\n    }\n\n	/**\n	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n	 */\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		// TODO Auto-generated method stub\n		response.getWriter().append(\"Served at: \").append(request.getContextPath());\n	}\n\n	/**\n	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n	 */\n	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		// TODO Auto-generated method stub\n		doGet(request, response);\n	}\n}\n```\n\n## 三、Servlet 的生命周期\n\nServlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：\n\n- Servlet 通过调用 **init ()** 方法进行初始化。\n- Servlet 调用 **service()** 方法来处理客户端的请求。\n- Servlet 通过调用 **destroy()** 方法终止（结束）。\n- 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。\n\n### 四、Servlet 的配置\n\n两种方式：\n\n### 4.1 在web.xml中配置\n\n插入下述代码：\n\n```java\n  <servlet>\n    <servlet-name>firstServlet</servlet-name>\n    <servlet-class>com.company.project.servlet.FirstServlet</servlet-class>\n  </servlet>\n  \n  <servlet-mapping>\n    <servlet-name>firstServlet</servlet-name>\n    <url-pattern>/first</url-pattern>\n  </servlet-mapping>\n```\n\n其中，<servlet-class>标签中间的为这个Servlet类的根目录，可以通过下述方法获取：\n\n![img](https://pic1.zhimg.com/v2-40f85eda9e911eae827225c2e106410c_b.png)\n\n最终web.xml代码：\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"4.0\">\n  <display-name>JavaEE03ServletTest</display-name>\n  \n  <welcome-file-list>\n    <welcome-file>index.html</welcome-file>\n    <welcome-file>index.htm</welcome-file>\n    <welcome-file>index.jsp</welcome-file>\n    <welcome-file>default.html</welcome-file>\n    <welcome-file>default.htm</welcome-file>\n    <welcome-file>default.jsp</welcome-file> \n  </welcome-file-list>\n\n  <servlet>\n    <servlet-name>firstServlet</servlet-name>\n    <servlet-class>com.company.project.servlet.FirstServlet</servlet-class>\n  </servlet>\n  \n  <servlet-mapping>\n    <servlet-name>firstServlet</servlet-name>\n    <url-pattern>/first</url-pattern>\n  </servlet-mapping>\n\n</web-app>\n```\n\n### 4.2 在Servlet中添加注释标签\n\n@WebServlet(\"/FirstServlet\")\n\n里面的\"/\"后面的名字是可以随便写的\n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/FirstServlet\")\npublic class FirstServlet extends HttpServlet {\n\n	@Override\n	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n		//测试get方法是否被调用\n		System.out.println(\"doGet...\");\n		\n		//设置相应内容类型\n		resp.setContentType(\"text/html;charset=utf-8\");\n		resp.setCharacterEncoding(\"utf-8\");\n		\n		//获取输出流对象\n		PrintWriter out = resp.getWriter();\n		\n		//生成相应内容\n		out.println(\"<html>\");\n		out.println(\"<head>\");\n		out.println(\"</head>\");\n		out.println(\"<body bgcolor=\\\"deepskyblue\\\">\");\n		out.println(\"<p>Hello World...</p>\");\n		out.println(\"<p>你好 世界</p>\");\n		out.println(\"<p>\" + Math.random() + \"</p>\");\n		out.println(\"</html>\");\n		\n		//关闭输出流对象\n		out.close();\n	}\n\n	@Override\n	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n		System.out.println(\"doPost...\");\n	}	\n}\n```\n\n## 五、访问Servlet的三种方式\n\n上面的两种配置Servlet的方法，其中的web.xml中的配置用到的<url-pattern>/first</url-pattern>，和备注标签@WebServlet(\"/FirstServlet\") ，所以用first和FirstServlet都可以对Servlet进行访问。\n\n### 5.1 通过地址访问\n\n在地址栏输入Servlet的URL直接访问Servlet。通过地址栏中访问，是GET方式，将调用doGet方法。\n\n**格式：**http://localhost:端口号/项目名称/url-pattern\n\n例如：http://localhost:8888/JavaEE05Servlet/first\n\n![img](https://pic3.zhimg.com/v2-7258e35fb2ceff8f090f30326828128a_b.png)\n\n### 5.2 通过超链接进行访问\n\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n<a href=\"first\">First</a>\n</body>\n</html>\n```\n\n其中，first即web.xml中配置的url-pattern，此处不需要/。\n\n### 5.3 通过提交表单访问\n\n把Servlet作为表单的响应事件，可以接受表单的数据，并进行操作。\n\nindex.jsp文件代码：\n\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n<form action=\"first\" method=\"post\">\n账号：<input name = \"userId\" type=\"text\"><br>\n密码：<input name = \"pw\" type=\"password\"><br>\n<input type=\"submit\" value=\"登录\">\n</form>\n</body>\n</html>\n```\n\nFirstServlet.java代码：\n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FirstServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n       \n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public FirstServlet() {\n        super();\n        // TODO Auto-generated constructor stub\n    }\n\n	/**\n	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n	 */\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		//测试get方法是否被调用\n				System.out.println(\"doGet...\");\n				\n				//设置相应内容类型\n				response.setContentType(\"text/html;charset=utf-8\");\n				response.setCharacterEncoding(\"utf-8\");\n				\n                                //通过getParameter(name)方法可以获取表单的数据\n				String userId = request.getParameter(\"userId\");\n				String pw = request.getParameter(\"pw\");\n				\n				if(userId != null && userId != \"\" && pw != null && pw != \"\" ) {\n					System.out.println(userId);\n					System.out.println(pw);\n				}				\n	}\n\n	/**\n	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n	 */\n	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		// TODO Auto-generated method stub\n		doGet(request, response);\n	}\n}\n```\n\n## 六、Servlet获取请求数据\n\n### 6.1 getParameter:通过name获得某请求参数的value\n\n```java\nString userId = request.getParameter(\"userId\");\nString pw = request.getParameter(\"pw\");\n				\nif(userId != null && userId != \"\" && pw != null && pw != \"\" ) {\n	out.println(userId);\n	out.println(pw);\n}\n```\n\n### 6.2 getParameterValues：通过name获得某请求参数的所有value\n\nindex.jsp文件代码：\n\n```java\n<form action=\"first\" method=\"get\">\n<input name = \"language\" type=\"checkbox\" value=\"C语言\">C语言<br>\n<input name = \"language\" type=\"checkbox\" value=\"Java语言\">Java语言<br>\n<input name = \"language\" type=\"checkbox\" value=\"Python语言\">Python语言<br>\n<input type=\"submit\" value=\"提交\">\n</form>\n```\n\nFirstServlet.java代码：\n\n```java\nString[] language = request.getParameterValues(\"language\");\nif (language != null && language[0] != \"\") {\n	for (String string : language) {\n		ut.println(string);\n	}\n}\n```\n\n## 七、响应重定向和请求转发\n\n在B/C系统中，我们很多时候会进行这个servlet跳转到另一个servlet，比如说我们在一个官网的首页，然后需要进行登陆的话，会弹出登录页面，我们登录之后就又回到首页，这样的话需要servlet之间的跳转。那么我们有两种方式做这个事情。\n\n### 7.1、页面重定向\n\n页面重定向是我们浏览器给服务器发送了一个请求，然后servlet1响应给浏览器一个特殊的响应，告诉浏览器重新发送一个请求给servlet2，然后浏览器重新发送了一个请求给servlet2.\n\nHttpServletResponse中定义了响应重定向的方法sendRedirect(String path)响应重定向是向目标资源重新发送请求，响应重定向是使用GET方式提交请求，所以调用目标资源的doGet方法。\n\n响应重定向生成新的请求，所以当前请求中的数据不会再传到目标资源中。\n\n```java\n//利用网页重定向跳转至欢迎界面\nresponse.sendRedirect(\"HelloServlet\");\n```\n\n### 7.2、请求转发\n\n请求转发实现的原理是servlet与servlet之间在tomcat服务器中进行请求的转发，浏览器中之发送一个请求，这个转发的行为是web服务器内部做的，就相当于是tomcat做的。\n\n**使用步骤**：\n\n1. 先使用请求中getRequestDispatcher(String path)方法获得请求转发器对象RequestDispatcher。\n2. 然后调用RequestDispatcher的forward(request,response)方法进行跳转。\n3. 修改LoginServlet中的跳转方法。\n\n```java\nrequest.getRequestDispatcher(\"WEB-INF/page/login.jsp\").forward(request, response);\n```\n\n例：登录界面\n\n在index.jsp中输入账号密码，提交表单，\n\nindex.jsp\n\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n<form action=\"first\" method=\"post\">\n账号：<input name = \"userId\" type=\"text\"><br>\n密码：<input name = \"pw\" type=\"password\"><br>\n<input type=\"submit\" value=\"登录\">\n</form>\n\n</body>\n</html>\n```\n\nFirstServlet.java\n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class FirstServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n\n	public FirstServlet() {\n		super();\n		// TODO Auto-generated constructor stub\n	}\n\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n\n		String userId = request.getParameter(\"userId\");\n		String pw = request.getParameter(\"pw\");\n\n		if (userId != null && userId != \"\" && pw != null && pw != \"\") {\n			request.getRequestDispatcher(\"LoginServlet\").forward(request, response);\n		}else {\n			out.println(\"账号、密码不能为空\");\n		}\n	}\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		// TODO Auto-generated method stub\n		doGet(request, response);\n	}\n}\n```\n\nLoginServlet.java\n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/LoginServlet\")\npublic class LoginServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n\n	public LoginServlet() {\n		super();\n		// TODO Auto-generated constructor stub\n	}\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n\n		// 设置相应内容类型\n		response.setContentType(\"text/html;charset=utf-8\");\n		response.setCharacterEncoding(\"utf-8\");\n\n		// 获取输出流对象\n		PrintWriter out = response.getWriter();\n\n		String userId = request.getParameter(\"userId\");\n		String pw = request.getParameter(\"pw\");\n\n		if (userId.equals(\"2584966199\") && pw.equals(\"zgy\")) {\n			out.println(\"恭喜你登录成功\");\n			//利用网页重定向跳转至欢迎界面\n			response.sendRedirect(\"HelloServlet\");\n		} else {\n			out.println(\"输入的账号密码有误\");\n		}\n\n		// 关闭输出流对象\n		out.close();\n	}\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		// TODO Auto-generated method stub\n		doGet(request, response);\n	}\n}\n```\n\n### 7.3 单控制器多业务处理Servlet实现\n\nindex.jsp\n\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"\n    pageEncoding=\"utf-8\"%>\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>首页</title>\n	</head>\n	<body>\n		<h1>请选择你的操作</h1>\n		<form action=\"http://localhost:8888/JavaEE03ServletTest/OperationServlet\" method=\"get\">\n		<input type=\"radio\" name = \"operation\" value=\"login\">登录<br>\n		<input type=\"radio\" name = \"operation\" value=\"register\">注册<br>\n		<input type=\"radio\" name = \"operation\" value=\"changePW\">改密<br>\n		<input type=\"radio\" name = \"operation\" value=\"personal\">个人资料<br>\n		<input type=\"submit\" name = \"submit\" value=\"提交\"> \n		\n		</form>\n	</body>\n</html>\n```\n\nOperationServlet.java   \n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\n\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/OperationServlet\")\npublic class OperationServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n\n	public OperationServlet() {\n		super();\n	}\n	protected void doGet(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		String oper = request.getParameter(\"operation\");\n		if (oper != null || oper != \"\")\n			switch (oper) {\n			case \"login\":\n				request.getRequestDispatcher(\"WEB-INF/page/login.jsp\").forward(request, response);\n				break;\n			case \"register\":\n				request.getRequestDispatcher(\"WEB-INF/page/register.jsp\").forward(request, response);\n				break;\n			case \"changePW\":\n				request.getRequestDispatcher(\"WEB-INF/page/changePW.jsp\").forward(request, response);\n				break;\n			case \"personal\":\n				request.getRequestDispatcher(\"WEB-INF/page/personal-data.jsp\").forward(request, response);\n				break;\n			default:\n				request.getRequestDispatcher(\"WEB-INF/page/index.jsp\").forward(request, response);\n			}\n\n	}\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n\n		doGet(request, response);\n	}\n}\n```', 0, 0, '2020-08-07 14:14:45', 2, 0, 1, '目录：一、Servlet的基本概念\n二、Servlet的三种使用方式\n三、Servlet 的生命周期\n四、Servlet 的配置\n五、访问Servlet的三种方式\n六、Servlet获取请求数据\n七、响应重定向和请求转发\n一、Servlet的基本概念Servlet（Servlet Applet），全称Java Servlet,是用Java编写的服务器端程序。而这些Servlet继承HttpServlet类。其主要功能在于交互式的浏览和修改数据，生成动态Web内容。Servlet运行于支持Java的应用服务器中。\nHttpServlet 重写doGet 和 doPost 方法或者你也可以重写service方法完成对get和post请求响应。\n使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。\nServlet的主要任务：\n\n读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。\n二、Servlet的三种使用方式2.1  实现 Servlet 接口package servlet;import java.io.IOException;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class servlet implements Servlet {    //返回一个 ServletConfig对象,它包含了servlet的初始化和起始参数。    @Override    public ServletConfig getServletConfig() {        // TODO Auto-generated method stub        return null;    }    //返回有关servlet的信息，例如作者、版本、版权。    @Override    public String getServletInfo() {        // TODO Auto-generated method stub        return null;    }    //生命周期方法:当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次    @Override    public void init(ServletConfig arg0) throws ServletException {        System.out.println(\"init...\");    }    //生命周期方法:对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法    @Override    public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {        System.out.println(\"service...\");    }        //生命周期方法:Servlet被销毁时调用    @Override    public void destroy() {        // TODO Auto-generated method stub    }}\n2.2 继承 GenericServlet 类它实现了 Servlet 接口除了 service 的方法，不过这种方法我们极少用。\npackage servlet;import java.io.IOException;import javax.servlet.GenericServlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class SecondServlet extends GenericServlet {    @Override    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        // TODO Auto-generated method stub        System.out.println(\"Hello World\");    }}\n2.3 继承 HttpServlet 方法创建 Servlet 的第三种方法，也是我们经常用的方法。\n\npackage servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class ThirdServlet */@WebServlet(\"/ThirdServlet\")public class ThirdServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    /**     * @see HttpServlet#HttpServlet()     */    public ThirdServlet() {        super();        // TODO Auto-generated constructor stub    }    /**     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)     */    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // TODO Auto-generated method stub        response.getWriter().append(\"Served at: \").append(request.getContextPath());    }    /**     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)     */    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // TODO Auto-generated method stub        doGet(request, response);    }}\n三、Servlet 的生命周期Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：\n\nServlet 通过调用 init () 方法进行初始化。Servlet 调用 service() 方法来处理客户端的请求。Servlet 通过调用 destroy() 方法终止（结束）。最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。\n四、Servlet 的配置两种方式：\n4.1 在web.xml中配置插入下述代码：\n  <servlet>    <servlet-name>firstServlet</servlet-name>    <servlet-class>com.company.project.servlet.FirstServlet</servlet-class>  </servlet>  <servlet-mapping>    <servlet-name>firstServlet</servlet-name>    <url-pattern>/first</url-pattern>  </servlet-mapping>\n其中，<servlet-class>标签中间的为这个Servlet类的根目录，可以通过下述方法获取：\n\n最终web.xml代码：\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"4.0\">  <display-name>JavaEE03ServletTest</display-name>  <welcome-file-list>    <welcome-file>index.html</welcome-file>    <welcome-file>index.htm</welcome-file>    <welcome-file>index.jsp</welcome-file>    <welcome-file>default.html</welcome-file>    <welcome-file>default.htm</welcome-file>    <welcome-file>default.jsp</welcome-file>   </welcome-file-list>  <servlet>    <servlet-name>firstServlet</servlet-name>    <servlet-class>com.company.project.servlet.FirstServlet</servlet-class>  </servlet>  <servlet-mapping>    <servlet-name>firstServlet</servlet-name>    <url-pattern>/first</url-pattern>  </servlet-mapping></web-app>\n4.2 在Servlet中添加注释标签@WebServlet(“/FirstServlet”)\n里面的”/“后面的名字是可以随便写的\npackage com.company.project.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/FirstServlet\")public class FirstServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //测试get方法是否被调用        System.out.println(\"doGet...\");        //设置相应内容类型        resp.setContentType(\"text/html;charset=utf-8\");        resp.setCharacterEncoding(\"utf-8\");        //获取输出流对象        PrintWriter out = resp.getWriter();        //生成相应内容        out.println(\"<html>\");        out.println(\"<head>\");        out.println(\"</head>\");        out.println(\"<body bgcolor=\\\"deepskyblue\\\">\");        out.println(\"<p>Hello World...</p>\");        out.println(\"<p>你好 世界</p>\");        out.println(\"<p>\" + Math.random() + \"</p>\");        out.println(\"</html>\");        //关闭输出流对象        out.close();    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println(\"doPost...\");    }    }\n五、访问Servlet的三种方式上面的两种配置Servlet的方法，其中的web.xml中的配置用到的<url-pattern>/first</url-pattern>，和备注标签@WebServlet(“/FirstServlet”) ，所以用first和FirstServlet都可以对Servlet进行访问。\n5.1 通过地址访问在地址栏输入Servlet的URL直接访问Servlet。通过地址栏中访问，是GET方式，将调用doGet方法。\n格式：http://localhost:端口号/项目名称/url-pattern\n例如：http://localhost:8888/JavaEE05Servlet/first\n\n5.2 通过超链接进行访问<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>Insert title here</title></head><body><a href=\"first\">First</a></body></html>\n其中，first即web.xml中配置的url-pattern，此处不需要/。\n5.3 通过提交表单访问把Servlet作为表单的响应事件，可以接受表单的数据，并进行操作。\nindex.jsp文件代码：\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>Insert title here</title></head><body><form action=\"first\" method=\"post\">账号：<input name = \"userId\" type=\"text\"><br>密码：<input name = \"pw\" type=\"password\"><br><input type=\"submit\" value=\"登录\"></form></body></html>\nFirstServlet.java代码：\npackage com.company.project.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class FirstServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    /**     * @see HttpServlet#HttpServlet()     */    public FirstServlet() {        super();        // TODO Auto-generated constructor stub    }    /**     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)     */    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //测试get方法是否被调用                System.out.println(\"doGet...\");                //设置相应内容类型                response.setContentType(\"text/html;charset=utf-8\");                response.setCharacterEncoding(\"utf-8\");                                //通过getParameter(name)方法可以获取表单的数据                String userId = request.getParameter(\"userId\");                String pw = request.getParameter(\"pw\");                if(userId != null && userId != \"\" && pw != null && pw != \"\" ) {                    System.out.println(userId);                    System.out.println(pw);                }                    }    /**     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)     */    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // TODO Auto-generated method stub        doGet(request, response);    }}\n六、Servlet获取请求数据6.1 getParameter:通过name获得某请求参数的valueString userId = request.getParameter(\"userId\");String pw = request.getParameter(\"pw\");if(userId != null && userId != \"\" && pw != null && pw != \"\" ) {    out.println(userId);    out.println(pw);}\n6.2 getParameterValues：通过name获得某请求参数的所有valueindex.jsp文件代码：\n<form action=\"first\" method=\"get\"><input name = \"language\" type=\"checkbox\" value=\"C语言\">C语言<br><input name = \"language\" type=\"checkbox\" value=\"Java语言\">Java语言<br><input name = \"language\" type=\"checkbox\" value=\"Python语言\">Python语言<br><input type=\"submit\" value=\"提交\"></form>\nFirstServlet.java代码：\nString[] language = request.getParameterValues(\"language\");if (language != null && language[0] != \"\") {    for (String string : language) {        ut.println(string);    }}\n七、响应重定向和请求转发在B/C系统中，我们很多时候会进行这个servlet跳转到另一个servlet，比如说我们在一个官网的首页，然后需要进行登陆的话，会弹出登录页面，我们登录之后就又回到首页，这样的话需要servlet之间的跳转。那么我们有两种方式做这个事情。\n7.1、页面重定向页面重定向是我们浏览器给服务器发送了一个请求，然后servlet1响应给浏览器一个特殊的响应，告诉浏览器重新发送一个请求给servlet2，然后浏览器重新发送了一个请求给servlet2.\nHttpServletResponse中定义了响应重定向的方法sendRedirect(String path)响应重定向是向目标资源重新发送请求，响应重定向是使用GET方式提交请求，所以调用目标资源的doGet方法。\n响应重定向生成新的请求，所以当前请求中的数据不会再传到目标资源中。\n//利用网页重定向跳转至欢迎界面response.sendRedirect(\"HelloServlet\");\n7.2、请求转发请求转发实现的原理是servlet与servlet之间在tomcat服务器中进行请求的转发，浏览器中之发送一个请求，这个转发的行为是web服务器内部做的，就相当于是tomcat做的。\n使用步骤：\n\n先使用请求中getRequestDispatcher(String path)方法获得请求转发器对象RequestDispatcher。然后调用RequestDispatcher的forward(request,response)方法进行跳转。修改LoginServlet中的跳转方法。\nrequest.getRequestDispatcher(\"WEB-INF/page/login.jsp\").forward(request, response);\n例：登录界面\n在index.jsp中输入账号密码，提交表单，\nindex.jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>Insert title here</title></head><body><form action=\"first\" method=\"post\">账号：<input name = \"userId\" type=\"text\"><br>密码：<input name = \"pw\" type=\"password\"><br><input type=\"submit\" value=\"登录\"></form></body></html>\nFirstServlet.java\npackage com.company.project.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class FirstServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    public FirstServlet() {        super();        // TODO Auto-generated constructor stub    }    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        String userId = request.getParameter(\"userId\");        String pw = request.getParameter(\"pw\");        if (userId != null && userId != \"\" && pw != null && pw != \"\") {            request.getRequestDispatcher(\"LoginServlet\").forward(request, response);        }else {            out.println(\"账号、密码不能为空\");        }    }    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        // TODO Auto-generated method stub        doGet(request, response);    }}\nLoginServlet.java\npackage com.company.project.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/LoginServlet\")public class LoginServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    public LoginServlet() {        super();        // TODO Auto-generated constructor stub    }    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        // 设置相应内容类型        response.setContentType(\"text/html;charset=utf-8\");        response.setCharacterEncoding(\"utf-8\");        // 获取输出流对象        PrintWriter out = response.getWriter();        String userId = request.getParameter(\"userId\");        String pw = request.getParameter(\"pw\");        if (userId.equals(\"2584966199\") && pw.equals(\"zgy\")) {            out.println(\"恭喜你登录成功\");            //利用网页重定向跳转至欢迎界面            response.sendRedirect(\"HelloServlet\");        } else {            out.println(\"输入的账号密码有误\");        }        // 关闭输出流对象        out.close();    }    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        // TODO Auto-generated method stub        doGet(request, response);    }}\n7.3 单控制器多业务处理Servlet实现index.jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"    pageEncoding=\"utf-8\"%><!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>首页</title>    </head>    <body>        <h1>请选择你的操作</h1>        <form action=\"http://localhost:8888/JavaEE03ServletTest/OperationServlet\" method=\"get\">        <input type=\"radio\" name = \"operation\" value=\"login\">登录<br>        <input type=\"radio\" name = \"operation\" value=\"register\">注册<br>        <input type=\"radio\" name = \"operation\" value=\"changePW\">改密<br>        <input type=\"radio\" name = \"operation\" value=\"personal\">个人资料<br>        <input type=\"submit\" name = \"submit\" value=\"提交\">         </form>    </body></html>\nOperationServlet.java   \npackage com.company.project.servlet;import java.io.IOException;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/OperationServlet\")public class OperationServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    public OperationServlet() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        String oper = request.getParameter(\"operation\");        if (oper != null || oper != \"\")            switch (oper) {            case \"login\":                request.getRequestDispatcher(\"WEB-INF/page/login.jsp\").forward(request, response);                break;            case \"register\":                request.getRequestDispatcher(\"WEB-INF/page/register.jsp\").forward(request, response);                break;            case \"changePW\":                request.getRequestDispatcher(\"WEB-INF/page/changePW.jsp\").forward(request, response);                break;            case \"personal\":                request.getRequestDispatcher(\"WEB-INF/page/personal-data.jsp\").forward(request, response);                break;            default:                request.getRequestDispatcher(\"WEB-INF/page/index.jsp\").forward(request, response);            }    }    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        doGet(request, response);    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (156, '03.《Java EE学习笔记》JSP', 8, '> 参考链接：https://www.runoob.com/jsp/jsp-architecture.html\n\n## 一、JSP 的简介\n\n### 1.1  什么是 JSP？\n\nJSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以<%开头以%>结束。\n\nJSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。\n\nJSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。\n\nJSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。\n\n### 1.2  JSP 的运行过程\n\n**Web 服务器是如何使用JSP来创建网页的：**\n\n- 就像其他普通的网页一样，您的浏览器发送一个 HTTP 请求给服务器。\n- Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成。\n- JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码。\n- JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎。\n- Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。\n- Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。\n- 最终，Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样。\n\n总结：\n\n一般情况下，JSP 引擎会检查 JSP 文件对应的 Servlet 是否已经存在，并且检查 JSP 文件的修改日期是否早于 Servlet。如果 JSP 文件的修改日期早于对应的 Servlet，那么容器就可以确定 JSP 文件没有被修改过并且 Servlet 有效。这使得整个流程与其他脚本语言（比如 PHP）相比要高效快捷一些。\n\n总的来说，JSP 网页就是用另一种方式来编写 Servlet。除了解释阶段外，JSP 网页几乎可以被当成一个普通的 Servlet 来对待。\n\n### 1.3  JSP 的生命周期\n\nJSP 的生命周期大概就是以下4个阶段：\n\n- **编译阶段：** servlet容器编译servlet源文件，生成servlet类\n- **初始化阶段：**加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法\n- **执行阶段：**调用与JSP对应的servlet实例的服务方法\n- **销毁阶段：**调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例\n\n**（1）JSP 编译阶段**\n\n当浏览器请求JSP页面的时候，JSP引擎先去检查是否编译过这个文件或者上次编译后进行过修改，确认需要重新编译了以后，再去编译这个JSP文件，否则，直接跳过编译阶段，去引用之前生成的Servlet文件。\n\n编译过程为三个阶段：\n\n- 解析JSP文件\n- 将JSP文件转换为Servlet（所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码）\n- 编译Servlet\n\n**（2）JSP初始化阶段**\n\n容器载入JSP文件后，先调用jspInit()方法，如果需要在初始化的时候进行自定义的操作，则需要重写该方法。\n\n一般来讲程序只初始化一次，servlet也是如此。通常情况下您可以在jspInit()方法中初始化数据库连接、打开文件和创建查询表。\n\n```jsp\n<%!\npublic void _jspInit(){\n	  // 初始化代码\n	System.out.print(\"初始化\");\n}\n%>\n```\n\n**（3）JSP 执行阶段**\n\n这一阶段描述了JSP生命周期中一切与请求相关的交互行为，直到被销毁。\n\n当JSP网页完成初始化后，JSP引擎将会调用_jspService()方法。\n\n_jspService()方法需要一个HttpServletRequest对象和一个HttpServletResponse对象作为它的参数，就像下面这样：\n\n```java\nvoid _jspService(HttpServletRequest request,\n                 HttpServletResponse response)\n{\n   // 服务端处理代码\n}\n```\n\n_jspService()方法在每个request中被调用一次并且负责产生与之相对应的response，并且它还负责产生所有7个HTTP方法的回应，比如GET、POST、DELETE等等。\n\n**（4）JSP的销毁阶段**\n\nJSP生命周期的销毁阶段描述了当一个JSP网页从容器中被移除时所发生的一切。\n\njspDestroy()方法在JSP中等价于servlet中的销毁方法。当您需要执行任何清理工作时复写jspDestroy()方法，比如释放数据库连接或者关闭文件夹等等。\n\n```java\n  public void _jspDestroy() {\n  }\n```\n\n## 二、JSP的语法\n\n### 2.1  中文编码\n\n如果我们要在页面正常显示中文，我们需要在 JSP 文件头部添加以下代码：\n\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n```\n\n### 2.2  插入脚本代码java\n\n脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。\n\n脚本程序的语法格式：\n\n```jsp\n<% 代码片段 %>\n```\n\n或者，您也可以编写与其等价的XML语句：\n\n```jsp\n<jsp:scriptlet>\n   代码片段\n</jsp:scriptlet>\n```\n\n示例：\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<%@ page isErrorPage=\"true\" %>\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n	<%\n		for(int i = 1; i <10 ; i++){\n			out.print(i  + \"<br / >\");	\n		}\n	%>\n\n	<% for(int i = 1; i <10 ; i++){ %>\n	<p>\n		<%= i  %>\n	</p>\n	<%} %>\n</body>\n</html>\n```\n\n### 2.3  JSP声明\n\n一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，您必须先声明这些变量和方法然后才能使用它们。\n\nJSP声明的语法格式：\n\n```jsp\n<%! declaration; [ declaration; ]+ ... %>\n```\n\n或者，您也可以编写与其等价的XML语句，就像下面这样：\n\n```jsp\n<jsp:declaration>\n   代码片段\n</jsp:declaration>\n```\n\n示例：\n\n```jsp\n<%! int i = 0; %> \n```\n\n### 2.4  JSP表达式\n\n一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。\n\n由于表达式的值会被转化成String，所以您可以在一个文本行中使用表达式而不用去管它是否是HTML标签。\n\n表达式元素中可以包含任何符合Java语言规范的表达式，但是不能使用分号来结束表达式。\n\nJSP表达式的语法格式：\n\n```jsp\n<%= 表达式 %>\n```\n\n同样，您也可以编写与之等价的XML语句：\n\n```jsp\n<jsp:expression>\n   表达式\n</jsp:expression>\n```\n\n### 2.5 JSP注释\n\nJSP注释主要有两个作用：为代码作注释以及将某段代码注释掉。\n\nJSP注释的语法格式：\n\n> <%-- 注释 --%>	JSP注释，注释内容不会被发送至浏览器甚至不会被编译 <!-- 注释 -->	        HTML注释，通过浏览器查看网页源代码时可以看见注释内容 <\\%	                        代表静态 <%常量 %\\>	                        代表静态 %> 常量 \\\'	                        在属性中使用的单引号 \\\"	                        在属性中使用的双引号\n\n### 2.6 JSP指令\n\nJSP指令用来设置与整个JSP页面相关的属性。\n\nJSP指令语法格式：\n\n```jsp\n<%@ directive attribute=\"value\" %>\n```\n\n常用的指令标签：\n\n> <%@ page ... %>        定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等 <%@ include ... %>    包含其他文件 <%@ taglib ... %>       引入标签库的定义，可以是自定义标签\n\n### 2.7 JSP行为\n\nJSP行为标签使用XML语法结构来控制servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。\n\n行为标签只有一种语法格式，它严格遵守XML标准：\n\n```jsp\n<jsp:action_name attribute=\"value\" />\n```\n\n行为标签基本上是一些预先就定义好的函数，下表罗列出了一些可用的JSP行为标签：：\n\n> jsp:include用于在当前页面中包含静态或动态资源 jsp:useBean寻找和初始化一个JavaBean组件 jsp:setProperty设置 JavaBean组件的值 jsp:getProperty将 JavaBean组件的值插入到 output中 jsp:forward从一个JSP文件向另一个文件传递一个包含用户请求的request对象 jsp:plugin用于在生成的HTML页面中包含Applet和JavaBean对象 jsp:element动态创建一个XML元素 jsp:attribute定义动态创建的XML元素的属性 jsp:body定义动态创建的XML元素的主体 jsp:text用于封装模板数据\n\n## 三、JSP的九大内置对象\n\nJSP支持九个自动定义的变量，江湖人称隐含对象。\n\n- request：**HttpServletRequest**类的实例\n- response：**HttpServletResponse**类的实例\n- out：**PrintWriter**类的实例，用于把结果输出至网页上\n- session：**HttpSession**类的实例\n- application：**ServletContext**类的实例，与应用上下文有关\n- config：**ServletConfig**类的实例\n- pageContext：**PageContext**类的实例，提供对JSP页面所有对象以及命名空间的访问\n- page：类似于Java类中的this关键字\n- Exception：**Exception**类的对象，代表发生错误的JSP页面中对应的异常对象\n\n这九大内置对象，在JSP编译后生成的java代码中都可以看到。', 0, 0, '2020-08-07 14:15:42', 2, 0, 1, '\n参考链接：https://www.runoob.com/jsp/jsp-architecture.html\n\n一、JSP 的简介1.1  什么是 JSP？JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以<%开头以%>结束。\nJSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。\nJSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。\nJSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。\n1.2  JSP 的运行过程Web 服务器是如何使用JSP来创建网页的：\n\n就像其他普通的网页一样，您的浏览器发送一个 HTTP 请求给服务器。Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成。JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码。JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎。Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。最终，Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样。\n总结：\n一般情况下，JSP 引擎会检查 JSP 文件对应的 Servlet 是否已经存在，并且检查 JSP 文件的修改日期是否早于 Servlet。如果 JSP 文件的修改日期早于对应的 Servlet，那么容器就可以确定 JSP 文件没有被修改过并且 Servlet 有效。这使得整个流程与其他脚本语言（比如 PHP）相比要高效快捷一些。\n总的来说，JSP 网页就是用另一种方式来编写 Servlet。除了解释阶段外，JSP 网页几乎可以被当成一个普通的 Servlet 来对待。\n1.3  JSP 的生命周期JSP 的生命周期大概就是以下4个阶段：\n\n编译阶段： servlet容器编译servlet源文件，生成servlet类初始化阶段：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法执行阶段：调用与JSP对应的servlet实例的服务方法销毁阶段：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例\n（1）JSP 编译阶段\n当浏览器请求JSP页面的时候，JSP引擎先去检查是否编译过这个文件或者上次编译后进行过修改，确认需要重新编译了以后，再去编译这个JSP文件，否则，直接跳过编译阶段，去引用之前生成的Servlet文件。\n编译过程为三个阶段：\n\n解析JSP文件将JSP文件转换为Servlet（所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码）编译Servlet\n（2）JSP初始化阶段\n容器载入JSP文件后，先调用jspInit()方法，如果需要在初始化的时候进行自定义的操作，则需要重写该方法。\n一般来讲程序只初始化一次，servlet也是如此。通常情况下您可以在jspInit()方法中初始化数据库连接、打开文件和创建查询表。\n<%!public void _jspInit(){      // 初始化代码    System.out.print(\"初始化\");}%>\n（3）JSP 执行阶段\n这一阶段描述了JSP生命周期中一切与请求相关的交互行为，直到被销毁。\n当JSP网页完成初始化后，JSP引擎将会调用_jspService()方法。\n_jspService()方法需要一个HttpServletRequest对象和一个HttpServletResponse对象作为它的参数，就像下面这样：\nvoid _jspService(HttpServletRequest request,                 HttpServletResponse response){   // 服务端处理代码}\n_jspService()方法在每个request中被调用一次并且负责产生与之相对应的response，并且它还负责产生所有7个HTTP方法的回应，比如GET、POST、DELETE等等。\n（4）JSP的销毁阶段\nJSP生命周期的销毁阶段描述了当一个JSP网页从容器中被移除时所发生的一切。\njspDestroy()方法在JSP中等价于servlet中的销毁方法。当您需要执行任何清理工作时复写jspDestroy()方法，比如释放数据库连接或者关闭文件夹等等。\n  public void _jspDestroy() {  }\n二、JSP的语法2.1  中文编码如果我们要在页面正常显示中文，我们需要在 JSP 文件头部添加以下代码：\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%>\n2.2  插入脚本代码java脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。\n脚本程序的语法格式：\n<% 代码片段 %>\n或者，您也可以编写与其等价的XML语句：\n<jsp:scriptlet>   代码片段</jsp:scriptlet>\n示例：\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><%@ page isErrorPage=\"true\" %><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>Insert title here</title></head><body>    <%        for(int i = 1; i <10 ; i++){            out.print(i  + \"<br / >\");            }    %>    <% for(int i = 1; i <10 ; i++){ %>    <p>        <%= i  %>    </p>    <%} %></body></html>\n2.3  JSP声明一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，您必须先声明这些变量和方法然后才能使用它们。\nJSP声明的语法格式：\n<%! declaration; [ declaration; ]+ ... %>\n或者，您也可以编写与其等价的XML语句，就像下面这样：\n<jsp:declaration>   代码片段</jsp:declaration>\n示例：\n<%! int i = 0; %>\n2.4  JSP表达式一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。\n由于表达式的值会被转化成String，所以您可以在一个文本行中使用表达式而不用去管它是否是HTML标签。\n表达式元素中可以包含任何符合Java语言规范的表达式，但是不能使用分号来结束表达式。\nJSP表达式的语法格式：\n<%= 表达式 %>\n同样，您也可以编写与之等价的XML语句：\n<jsp:expression>   表达式</jsp:expression>\n2.5 JSP注释JSP注释主要有两个作用：为代码作注释以及将某段代码注释掉。\nJSP注释的语法格式：\n\n<%— 注释 —%>    JSP注释，注释内容不会被发送至浏览器甚至不会被编译 <!-- 注释 -->            HTML注释，通过浏览器查看网页源代码时可以看见注释内容 <\\%                            代表静态 <%常量 %>                            代表静态 %> 常量 \\’                            在属性中使用的单引号 \\”                            在属性中使用的双引号\n\n2.6 JSP指令JSP指令用来设置与整个JSP页面相关的属性。\nJSP指令语法格式：\n<%@ directive attribute=\"value\" %>\n常用的指令标签：\n\n<%@ page … %>        定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等 <%@ include … %>    包含其他文件 <%@ taglib … %>       引入标签库的定义，可以是自定义标签\n\n2.7 JSP行为JSP行为标签使用XML语法结构来控制servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。\n行为标签只有一种语法格式，它严格遵守XML标准：\n<jsp:action_name attribute=\"value\" />\n行为标签基本上是一些预先就定义好的函数，下表罗列出了一些可用的JSP行为标签：：\n\njsp:include用于在当前页面中包含静态或动态资源 jsp:useBean寻找和初始化一个JavaBean组件 jsp:setProperty设置 JavaBean组件的值 jsp:getProperty将 JavaBean组件的值插入到 output中 jsp:forward从一个JSP文件向另一个文件传递一个包含用户请求的request对象 jsp:plugin用于在生成的HTML页面中包含Applet和JavaBean对象 jsp:element动态创建一个XML元素 jsp:attribute定义动态创建的XML元素的属性 jsp:body定义动态创建的XML元素的主体 jsp:text用于封装模板数据\n\n三、JSP的九大内置对象JSP支持九个自动定义的变量，江湖人称隐含对象。\n\nrequest：HttpServletRequest类的实例response：HttpServletResponse类的实例out：PrintWriter类的实例，用于把结果输出至网页上session：HttpSession类的实例application：ServletContext类的实例，与应用上下文有关config：ServletConfig类的实例pageContext：PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问page：类似于Java类中的this关键字Exception：Exception类的对象，代表发生错误的JSP页面中对应的异常对象\n这九大内置对象，在JSP编译后生成的java代码中都可以看到。\n', 0, 1);
INSERT INTO `t_article` VALUES (157, '04.《JavaEE 学习笔记》MVC设计模式', 8, '> 参考链接：https://blog.csdn.net/wx1528159409/article/details/83549291 https://blog.csdn.net/sunforraining/article/details/79015227\n\n## 1、Web应用运行流程：\n\n（1）浏览器发送请求到收到响应，简要的过程如下： 浏览器发送请求后，由Web.xml中规定的协议，进入TomCat中特定的Servlet，服务器先到Web-Content中找有没有对应的html/jsp页面，如果没有再到WEB-INF目录下的xml配置文件中找映射，通过映射找到响应文件html/jsp，响应给浏览器。\n\n（2）浏览器再点击JSP页面后，再次发送请求。\n\n## 2、什么是MVC？\n\nMVC，全称Model View Controller，即模型-视图-控制器；\n\n**（1）Model（模型）：** 是Web应用中用于处理数据逻辑的部分，包括Service层和Dao层； Service层用于和数据库联动，放置业务逻辑代码，处理数据库的增删改查， Dao层用于放各种接口，以备调用；\n\n**（2）View（视图）：** 是Web应用中处理响应给客户的页面的部分，例如我们写的html静态页面，jsp动态页面，这些最终响应给浏览器的页面都是视图； 通常视图是依据模型数据来创建的；\n\n**（3）Controller（控制器）：** 在Web应用中，简而言之，就是Servlet，或者SpringMVC框架中加了注解@Controller的方法（实际上一个方法就相当于一个对应的Servlet）；\n\n**Web开发过程中的MVC设计模式：**\n\n首先，浏览器发送请求，JSP页面响应给客户，客户点击JSP页面上的内容，再次提交请求； 这一次，请求到Controller控制器模块，也就是Servlet服务器中，Servlet服务器通过分析请求，判断客户的需求，然后调用Model模型，用Service层处理数据库的增删改查，用Dao层提供接口支持，然后Servlet将数据驱动到View视图层也就是JSP页面中，将JSP页面响应给浏览器，客户看到动态的内容。\n\n在这个过程中，最典型的的MVC模型就是 JavaBean + JSP + Servlet的模式，各司其职，分工合作；这种设计理念可以把html代码块和业务逻辑代码块分开，让代码更清晰，便于开发。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/v2-2eee47e1aee8e2225913ba14f7a707b9_b.png)\n\n## 3、JavaWeb经典三层框架\n\n**（1） 表现层，UI，User Interface：** 主要接受用户的请求和把相应的页面响应给用户浏览器； 其中aspx页面，对应MVC中的视图（View），即JSP页面； 而aspx.cs页面，对应MVC中的控制器（Controller），即Servlet服务器；\n\n**（2） 业务逻辑层，BLL，Business Logic Layer:** 对应MVC中模型（Model）中的Service层，与数据库联动处理增删改查；\n\n**（3） 数据访问层/持久层，DAL，Data Access Layer：** 对应MVC中模型（Model）中的Dao层，提供接口支持；\n\n## 4、MVC设计模式的具体开发流程\n\n**（1）创建项目**\n\n创建Dynamic Web Project，并完成初始化配置，能正常启动。\n\n**（2）JDBC**\n\n将JDBC数据库驱动导入或者引入（Maven）项目。\n\n**（3）DBUtil**\n\n在项目中创建数据库连接类，这是Java程序和数据库直接通信的唯一方式。我们可以将该程序理解为数据库系统的自定义客户端。\n\n**（4）Model**\n\n构建Model类，注意映射关系。\n\n**（5）DAO和IMPL**\n\n定义DAO，并实现IMPL。\n\n**（6）Biz**\n\n定义Biz，并实现IMPL。\n\n**（7）Controller**\n\n构建Controller类，受理业务请求。\n\n**（8）View**\n\n构建View，接受用户的输入，并且能显示Controller返回的响应数据。\n\n## 5、 MVC的优缺点\n\n**（1）优点：**\n\n- 分层，结构清晰，耦合性低\n- 大型项目代码的复用性得到极大的提高，开发人员分工明确，提高了开发的效率\n- 维护方便，降低了维护成本。\n\n**（2）缺点：**\n\n- 简单的小型项目，使用MVC设计反而会降低开发效率\n- 层和层虽然相互分离，但是之间关联性太强，没有做到独立的重用。', 0, 0, '2020-08-07 14:16:33', 2, 0, 1, '\n参考链接：https://blog.csdn.net/wx1528159409/article/details/83549291 https://blog.csdn.net/sunforraining/article/details/79015227\n\n1、Web应用运行流程：（1）浏览器发送请求到收到响应，简要的过程如下： 浏览器发送请求后，由Web.xml中规定的协议，进入TomCat中特定的Servlet，服务器先到Web-Content中找有没有对应的html/jsp页面，如果没有再到WEB-INF目录下的xml配置文件中找映射，通过映射找到响应文件html/jsp，响应给浏览器。\n（2）浏览器再点击JSP页面后，再次发送请求。\n2、什么是MVC？MVC，全称Model View Controller，即模型-视图-控制器；\n（1）Model（模型）： 是Web应用中用于处理数据逻辑的部分，包括Service层和Dao层； Service层用于和数据库联动，放置业务逻辑代码，处理数据库的增删改查， Dao层用于放各种接口，以备调用；\n（2）View（视图）： 是Web应用中处理响应给客户的页面的部分，例如我们写的html静态页面，jsp动态页面，这些最终响应给浏览器的页面都是视图； 通常视图是依据模型数据来创建的；\n（3）Controller（控制器）： 在Web应用中，简而言之，就是Servlet，或者SpringMVC框架中加了注解@Controller的方法（实际上一个方法就相当于一个对应的Servlet）；\nWeb开发过程中的MVC设计模式：\n首先，浏览器发送请求，JSP页面响应给客户，客户点击JSP页面上的内容，再次提交请求； 这一次，请求到Controller控制器模块，也就是Servlet服务器中，Servlet服务器通过分析请求，判断客户的需求，然后调用Model模型，用Service层处理数据库的增删改查，用Dao层提供接口支持，然后Servlet将数据驱动到View视图层也就是JSP页面中，将JSP页面响应给浏览器，客户看到动态的内容。\n在这个过程中，最典型的的MVC模型就是 JavaBean + JSP + Servlet的模式，各司其职，分工合作；这种设计理念可以把html代码块和业务逻辑代码块分开，让代码更清晰，便于开发。\n\n3、JavaWeb经典三层框架（1） 表现层，UI，User Interface： 主要接受用户的请求和把相应的页面响应给用户浏览器； 其中aspx页面，对应MVC中的视图（View），即JSP页面； 而aspx.cs页面，对应MVC中的控制器（Controller），即Servlet服务器；\n（2） 业务逻辑层，BLL，Business Logic Layer: 对应MVC中模型（Model）中的Service层，与数据库联动处理增删改查；\n（3） 数据访问层/持久层，DAL，Data Access Layer： 对应MVC中模型（Model）中的Dao层，提供接口支持；\n4、MVC设计模式的具体开发流程（1）创建项目\n创建Dynamic Web Project，并完成初始化配置，能正常启动。\n（2）JDBC\n将JDBC数据库驱动导入或者引入（Maven）项目。\n（3）DBUtil\n在项目中创建数据库连接类，这是Java程序和数据库直接通信的唯一方式。我们可以将该程序理解为数据库系统的自定义客户端。\n（4）Model\n构建Model类，注意映射关系。\n（5）DAO和IMPL\n定义DAO，并实现IMPL。\n（6）Biz\n定义Biz，并实现IMPL。\n（7）Controller\n构建Controller类，受理业务请求。\n（8）View\n构建View，接受用户的输入，并且能显示Controller返回的响应数据。\n5、 MVC的优缺点（1）优点：\n\n分层，结构清晰，耦合性低大型项目代码的复用性得到极大的提高，开发人员分工明确，提高了开发的效率维护方便，降低了维护成本。\n（2）缺点：\n\n简单的小型项目，使用MVC设计反而会降低开发效率层和层虽然相互分离，但是之间关联性太强，没有做到独立的重用。\n', 0, 1);
INSERT INTO `t_article` VALUES (158, '05.《JavaEE 学习笔记》JDBC', 8, '> 参考链接：https://www.runoob.com/w3cnote/jdbc-use-guide.html https://blog.csdn.net/goldentec/article/details/105334686\n\n## 1、JDBC 简述\n\nJDBC API 允许用户访问任何形式的表格数据，尤其是存储在关系数据库中的数据。\n\n执行流程：\n\n- 连接数据源，如：数据库。\n- 为数据库传递查询和更新指令。\n- 处理数据库响应并返回的结果。\n\n## 2、JDBC构架\n\n分为双层架构和三层架构。\n\n### （1）双层\n\n![img](https://pic3.zhimg.com/v2-d1b2b83fce250b86f25c62f28ccaca4e_b.gif)\n\n作用：此架构中，Java Applet 或应用直接访问数据源。这需要一个JDBC驱动程序，它可以与被访问的特定数据源进行通信。\n\n条件：要求 Driver 能与访问的数据库交互。\n\n机制：用户命令传给数据库或其他数据源，随之结果被返回。\n\n部署：数据源可以在另一台机器上，用户通过网络连接，称为 C/S配置（可以是内联网或互联网）。用户的机器是客户机，容纳数据源的机器是服务器。网络可以是内部网，例如连接公司内部的员工，也可以是Internet。。\n\n### （2）三层\n\n![img](https://pic4.zhimg.com/v2-3a5a9b7ccdbb097509cb77ea6c067e07_b.gif)\n\n侧架构特殊之处在于，引入中间层服务。\n\n流程：命令和结构都会经过该层。\n\n吸引：可以增加企业数据的访问控制，以及多种类型的更新；另外，也可简化应用的部署，并在多数情况下有性能优势。\n\n历史趋势： 以往，因性能问题，中间层都用 C 或 C++ 编写，随着优化编译器（将 Java 字节码 转为 高效的 特定机器码）和技术的发展，如EJB，Java 开始用于中间层的开发这也让 Java 的优势突显出现出来，使用 Java 作为服务器代码语言，JDBC随之被重视。\n\n## 3、JDBC 连接数据库\n\n（1）加载驱动程序（通过反射找到对应的re包）\n\n```\n// 加载Oracle“驱动类” SPI\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n\n//加载MySql驱动 SPI\nClass.forName(\"com.mysql.jdbc.Driver\")\n```\n\n![img](https://pic1.zhimg.com/v2-528de1a4fff9514dfd05cf70085cd918_b.png)\n\n（2）获取数据库连接：\n\n```java\n// 创建“URL连接字符串”。格式：jdbc:oracle:thin:@ 主机名/IP : 端口号 ：服务名称\nString url = \"jdbc:oracle:thin:@localhost:1521:XE\";\n\n// 创建“用户名”\nString username = \"scott\";\n\n// 创建“密码”\nString password = \"123456\";\n\n// 初始化“数据库连接对象”\nConnection conn = DriverManager.getConnection(url, username, password);\n```\n\n完整的数据库连接：\n\n```java\npackage com.company.project.util;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class DBUtil {\n	// 声明“数据库连接对象”，单例模式\n	private static Connection conn;\n\n	// 方法：获取“数据库连接对象”，单例模式。\n	public static Connection getConnection() {\n		// 判断“数据库连接对象”是否存在\n		try {\n			// 判断条件：连接对象不为空 并且 连接对象不是关闭的\n			if (conn != null && !conn.isClosed()) {\n				return conn;\n				// 返回成功后，后面的代码将不会被执行。\n			}\n\n			// 加载“驱动类” SPI\n			Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n			// 创建“URL连接字符串”。格式：jdbc:oracle:thin:@ 主机名/IP : 端口号 ：服务名称\n			String url = \"jdbc:oracle:thin:@localhost:1521:XE\";\n\n			// 创建“用户名”\n			String username = \"scott\";\n			// 创建“密码”\n			String password = \"123456\";\n\n			// 初始化“数据库连接对象”\n			conn = DriverManager.getConnection(url, username, password);\n			if (conn != null) {\n				System.out.println(\"[操作提示]恭喜您，数据库连接成功！\");\n			}\n\n		} catch (SQLException e) {\n			e.printStackTrace();\n		} catch (ClassNotFoundException e) {\n			e.printStackTrace();\n		}\n\n		return conn;\n	}\n}\n```\n\n## 4、JDBC 对数据库操作\n\n### 4.1 Connection接口\n\nConnection是与特定数据库的链接对象，通过DriverManager类取得。通常使用链接对象获得语句对象，常用的语句对象有两种，所以有两个方法获得。\n\n（1）createStatement()  返回Statement对象，否则抛出SQLException异常，必须捕捉。\n\n```java\nStatement createStatement(  ) throws SQLException\n```\n\n（2）prepareStatement(String sql)  返回PrepareStatement对象，有可能抛异常，必须捕捉。参数sql是要执行的SQL语句。\n\n```java\nPreparedStatement  prepareStatement(String sql)  throws SQLException\n```\n\n### 4.2 Statement 对象（对静态sql的执行）\n\nStatement对象可以用来执行SQL语句，**使用executeQuery执行查询语句**，返回结果集，**使用executeUpdate执行增删改**，返回操作的行数。\n\n常用方法：\n\n（1）executeUpdate(String sql)   执行执行增删改语句，返回返回受影响的行数\n\n```java\nint executeUpdate(String sql)  throws SQLException\n```\n\n（2）executeQuery(String sql)   执行查询语句，返回结果集\n\n```java\nResultSet executeQuery(String sql)  throws SQLException\n```\n\n**例子：**\n\n```java\nConnection conn = DBUtil.getConnection();\nString sql = \"select * from books\";\nStatement statement = conn.createStatement();\nResultSet rs = statement.executeQuery(sql);\n```\n\n### 4.3 PreparedStatment 对象（对动态sql的执行）\n\n如果要多次执行相似的SQL语句，可以使用PreparedStatemend（预编译语句对象）对象来执行，进行了预编译，效率较高；可以执行带？的SQL语句，？使用setX方法赋值。\n\n常用方法：\n\n（1）executeUpdate(String sql)   执行执行增删改语句，返回返回受影响的行数\n\n```java\nint executeUpdate()  throws SQLException\n```\n\n（2）executeQuery(String sql)   执行查询语句，返回结果集\n\n```java\nResultSet executQuery()  throws SQLException\n```\n\n（3）setX(int parameterIndex, X x)  \n\n介绍：将parameterIndex指定的“?”位置指定为x的值，这里X可以指代任意数据类型， “?”的索引从1开始。\n\n```java\nvoid setX(int parameterIndex, X x)  throws SQLException\n```\n\n**例子：插入订单**\n\n```java\n	Connection conn = null;\n	PreparedStatement pstmt = null;\n	ResultSet rs = null;	\n\n        public boolean insert(OrderForm orderForm) {\n		boolean flag = false;\n		conn = DBUtil.getConnection();\n		String sql = \"insert into order_form (id,user_id,book_id) values (?,?,?)\";		\n		try {\n			pstmt = conn.prepareStatement(sql);\n			pstmt.setLong(1, orderForm.getId());\n			pstmt.setLong(2, orderForm.getUser_id());\n			pstmt.setLong(3, orderForm.getBook_id());\n			\n			int rs = pstmt.executeUpdate();\n			if(rs > 0) {\n				flag = true;\n				System.out.println(\"成功插入\" + rs + \"条记录\");\n			}\n		} catch (SQLException e) {\n			// TODO Auto-generated catch block\n			e.printStackTrace();\n		}\n		return flag;\n	}\n```\n\n### 4.4 ResultSet接口\n\nResultSet对象用来封装查询得到的结果集，常用的方法有next以及getXXX方法。注意：必须使用next()方法，才能处理结果集。\n\n常用方法：\n\n（1）next() \n\n说明：将结果集游标往下移动一行，如果已经到达结果集最后，将会返回false，有可能抛异常，必须捕捉\n\n```java\nboolean next()  throws SQLException\n```\n\n（2）getX(String columnName)\n\n说明：获得某个字段的值，X是指具体的数据类型，视数据库表中字段的具体情况而定，该方法有一组，并且每个都有两种重载方法，一种是以字段名称为参数，另一种是以字段索引为参数（字段索引从1开始），有可能抛异常，必须捕捉。\n\n```java\nX getX(int columnIndex)  throws SQLException\n```\n\n例子：查询所有商品\n\n```java\n	public ArrayList<Goods> displayGoods(){\n		ArrayList<Goods> goodsList = new ArrayList<>();\n		conn = DbConnect.getconn();\n		String sql = \"select * from goods\";\n		try {\n			pstmt = conn.prepareStatement(sql);\n			rs = pstmt.executeQuery();\n			\n			while(rs.next()) {\n				int gid = rs.getInt(\"gid\");\n				String gname = rs.getString(2);\n				double gprice = rs.getDouble(\"gprice\");\n				int gnum = rs.getInt(4);\n				\n				Goods goods = new Goods(gid, gname, gprice, gnum);\n				goodsList.add(goods);\n			}\n		} catch (SQLException e) {\n			e.printStackTrace();\n		} finally {\n			DbClose.queryClose(pstmt, rs, conn);\n		}\n		return goodsList;\n	}\n```', 0, 0, '2020-08-07 14:17:10', 2, 0, 1, '\n参考链接：https://www.runoob.com/w3cnote/jdbc-use-guide.html https://blog.csdn.net/goldentec/article/details/105334686\n\n1、JDBC 简述JDBC API 允许用户访问任何形式的表格数据，尤其是存储在关系数据库中的数据。\n执行流程：\n\n连接数据源，如：数据库。为数据库传递查询和更新指令。处理数据库响应并返回的结果。\n2、JDBC构架分为双层架构和三层架构。\n（1）双层\n作用：此架构中，Java Applet 或应用直接访问数据源。这需要一个JDBC驱动程序，它可以与被访问的特定数据源进行通信。\n条件：要求 Driver 能与访问的数据库交互。\n机制：用户命令传给数据库或其他数据源，随之结果被返回。\n部署：数据源可以在另一台机器上，用户通过网络连接，称为 C/S配置（可以是内联网或互联网）。用户的机器是客户机，容纳数据源的机器是服务器。网络可以是内部网，例如连接公司内部的员工，也可以是Internet。。\n（2）三层\n侧架构特殊之处在于，引入中间层服务。\n流程：命令和结构都会经过该层。\n吸引：可以增加企业数据的访问控制，以及多种类型的更新；另外，也可简化应用的部署，并在多数情况下有性能优势。\n历史趋势： 以往，因性能问题，中间层都用 C 或 C++ 编写，随着优化编译器（将 Java 字节码 转为 高效的 特定机器码）和技术的发展，如EJB，Java 开始用于中间层的开发这也让 Java 的优势突显出现出来，使用 Java 作为服务器代码语言，JDBC随之被重视。\n3、JDBC 连接数据库（1）加载驱动程序（通过反射找到对应的re包）\n// 加载Oracle“驱动类” SPIClass.forName(\"oracle.jdbc.driver.OracleDriver\");//加载MySql驱动 SPIClass.forName(\"com.mysql.jdbc.Driver\")\n（2）获取数据库连接：\n// 创建“URL连接字符串”。格式：jdbc:oracle:thin:@ 主机名/IP : 端口号 ：服务名称String url = \"jdbc:oracle:thin:@localhost:1521:XE\";// 创建“用户名”String username = \"scott\";// 创建“密码”String password = \"123456\";// 初始化“数据库连接对象”Connection conn = DriverManager.getConnection(url, username, password);\n完整的数据库连接：\npackage com.company.project.util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class DBUtil {    // 声明“数据库连接对象”，单例模式    private static Connection conn;    // 方法：获取“数据库连接对象”，单例模式。    public static Connection getConnection() {        // 判断“数据库连接对象”是否存在        try {            // 判断条件：连接对象不为空 并且 连接对象不是关闭的            if (conn != null && !conn.isClosed()) {                return conn;                // 返回成功后，后面的代码将不会被执行。            }            // 加载“驱动类” SPI            Class.forName(\"oracle.jdbc.driver.OracleDriver\");            // 创建“URL连接字符串”。格式：jdbc:oracle:thin:@ 主机名/IP : 端口号 ：服务名称            String url = \"jdbc:oracle:thin:@localhost:1521:XE\";            // 创建“用户名”            String username = \"scott\";            // 创建“密码”            String password = \"123456\";            // 初始化“数据库连接对象”            conn = DriverManager.getConnection(url, username, password);            if (conn != null) {                System.out.println(\"[操作提示]恭喜您，数据库连接成功！\");            }        } catch (SQLException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }        return conn;    }}\n4、JDBC 对数据库操作4.1 Connection接口Connection是与特定数据库的链接对象，通过DriverManager类取得。通常使用链接对象获得语句对象，常用的语句对象有两种，所以有两个方法获得。\n（1）createStatement()  返回Statement对象，否则抛出SQLException异常，必须捕捉。\nStatement createStatement(  ) throws SQLException\n（2）prepareStatement(String sql)  返回PrepareStatement对象，有可能抛异常，必须捕捉。参数sql是要执行的SQL语句。\nPreparedStatement  prepareStatement(String sql)  throws SQLException\n4.2 Statement 对象（对静态sql的执行）Statement对象可以用来执行SQL语句，使用executeQuery执行查询语句，返回结果集，使用executeUpdate执行增删改，返回操作的行数。\n常用方法：\n（1）executeUpdate(String sql)   执行执行增删改语句，返回返回受影响的行数\nint executeUpdate(String sql)  throws SQLException\n（2）executeQuery(String sql)   执行查询语句，返回结果集\nResultSet executeQuery(String sql)  throws SQLException\n例子：\nConnection conn = DBUtil.getConnection();String sql = \"select * from books\";Statement statement = conn.createStatement();ResultSet rs = statement.executeQuery(sql);\n4.3 PreparedStatment 对象（对动态sql的执行）如果要多次执行相似的SQL语句，可以使用PreparedStatemend（预编译语句对象）对象来执行，进行了预编译，效率较高；可以执行带？的SQL语句，？使用setX方法赋值。\n常用方法：\n（1）executeUpdate(String sql)   执行执行增删改语句，返回返回受影响的行数\nint executeUpdate()  throws SQLException\n（2）executeQuery(String sql)   执行查询语句，返回结果集\nResultSet executQuery()  throws SQLException\n（3）setX(int parameterIndex, X x)  \n介绍：将parameterIndex指定的“?”位置指定为x的值，这里X可以指代任意数据类型， “?”的索引从1开始。\nvoid setX(int parameterIndex, X x)  throws SQLException\n例子：插入订单\n    Connection conn = null;    PreparedStatement pstmt = null;    ResultSet rs = null;            public boolean insert(OrderForm orderForm) {        boolean flag = false;        conn = DBUtil.getConnection();        String sql = \"insert into order_form (id,user_id,book_id) values (?,?,?)\";                try {            pstmt = conn.prepareStatement(sql);            pstmt.setLong(1, orderForm.getId());            pstmt.setLong(2, orderForm.getUser_id());            pstmt.setLong(3, orderForm.getBook_id());            int rs = pstmt.executeUpdate();            if(rs > 0) {                flag = true;                System.out.println(\"成功插入\" + rs + \"条记录\");            }        } catch (SQLException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        return flag;    }\n4.4 ResultSet接口ResultSet对象用来封装查询得到的结果集，常用的方法有next以及getXXX方法。注意：必须使用next()方法，才能处理结果集。\n常用方法：\n（1）next() \n说明：将结果集游标往下移动一行，如果已经到达结果集最后，将会返回false，有可能抛异常，必须捕捉\nboolean next()  throws SQLException\n（2）getX(String columnName)\n说明：获得某个字段的值，X是指具体的数据类型，视数据库表中字段的具体情况而定，该方法有一组，并且每个都有两种重载方法，一种是以字段名称为参数，另一种是以字段索引为参数（字段索引从1开始），有可能抛异常，必须捕捉。\nX getX(int columnIndex)  throws SQLException\n例子：查询所有商品\n    public ArrayList<Goods> displayGoods(){        ArrayList<Goods> goodsList = new ArrayList<>();        conn = DbConnect.getconn();        String sql = \"select * from goods\";        try {            pstmt = conn.prepareStatement(sql);            rs = pstmt.executeQuery();            while(rs.next()) {                int gid = rs.getInt(\"gid\");                String gname = rs.getString(2);                double gprice = rs.getDouble(\"gprice\");                int gnum = rs.getInt(4);                Goods goods = new Goods(gid, gname, gprice, gnum);                goodsList.add(goods);            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            DbClose.queryClose(pstmt, rs, conn);        }        return goodsList;    }\n', 0, 1);
INSERT INTO `t_article` VALUES (159, '06.《Java EE笔记》JSP Cookie 技术', 8, '> 参考链接：https://www.runoob.com/jsp/jsp-cookies.html\n\n## 1. 概念\n\nCookie 是存储在客户机的文本文件，它们保存了大量轨迹信息。在 Servlet 技术基础上，JSP 显然能够提供对 HTTP cookie 的支持。\n\nCookie是保存在客户端的小文本，保存的位置分两种\n\n- Cookie可能保存在客户端浏览器的所占内存中，关闭浏览器后，Cookie就不再存在\n- Cookie也可能保存在客户PC机的硬盘上，设置有效时间，超过有效时间后失效\n\n## 2. Servlet 中 Cookie的方法 \n\n- **public void setDomain(String pattern)**\n- 设置 cookie 的域名，比如 [runoob.com](http://runoob.com/)\n- **public String getDomain()**\n- 获取 cookie 的域名，比如 [runoob.com](http://runoob.com/)\n- **public void setMaxAge(int expiry)**\n- 设置 cookie 有效期，以秒为单位，默认有效期为当前session的存活时间\n- **public int getMaxAge()**\n- 获取 cookie 有效期，以秒为单位，默认为-1 ，表明cookie会活到浏览器关闭为\n- **public String getName()**\n- 返回 cookie 的名称，名称创建后将不能被修改\n- **public void setValue(String newValue)**\n- 设置 cookie 的值\n- **public String getValue()**\n- 获取cookie的值\n- **public void setPath(String uri)**设置 cookie 的路径，默认为当前页面目录下的所有 URL，还有此目录下的所有子目录\n- **public String getPath()**\n- 获取 cookie 的路径\n- **public void setSecure(boolean flag)**\n- 指明 cookie 是否要加密传输\n- **public void setComment(String purpose)**\n- 设置注释描述 cookie 的目的。当浏览器将 cookie 展现给用户时，注释将会变得非常有用\n- **public String getComment()**\n- 返回描述 cookie 目的的注释，若没有则返回 null\n\n### 2.1 Servlet 中设置 cookie\n\n**（1）创建一个 cookie 对象：**\n\nCookie cookie = new Cookie(\"key\",\"value\");\n\n```java\n//创建Cookie对象\nCookie userNameCookie = new Cookie(\"username\", \"86_god\");\nCookie passwordCookie = new Cookie(\"password\", \"123456\");\n```\n\n**注意：名称和值中都不能包含空格或者如下的字符：[ ] ( ) = , \" / ? @ : ;**\n\n**（2）设置有效期：**setMaxAge() 函数表明 cookie 在多长时间（以秒为单位）内有效。\n\n```java\n//设置有效期\nuserNameCookie.setMaxAge(60*60*24*7);\npasswordCookie.setMaxAge(60*60*24*7);\n```\n\n**（3）将 cookie 发送至 HTTP 响应头中：**调用 response.addCookie() 函数来向 HTTP 响应头中添加 cookie。\n\n```java\n//发给浏览器保存\nresponse.addCookie(userNameCookie);\nresponse.addCookie(passwordCookie);\n```\n\n代码演示：（利用servlet设置cookie和查询cookie）\n\nAddCookieServlet.java文件 设置cookie\n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/add-cookie-servlet\")\npublic class AddCookieServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n       \n        public AddCookieServlet() {\n            super();\n\n        }\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n		//创建Cookie对象\n		Cookie userNameCookie = new Cookie(\"username\", \"张三\");\n		Cookie passwordCookie = new Cookie(\"password\", \"23456\");\n		\n		//设置有效期\n		userNameCookie.setMaxAge(60*60*24*7);\n		passwordCookie.setMaxAge(60*60*24*7);\n\n		//发给浏览器保存\n		response.addCookie(userNameCookie);\n		response.addCookie(passwordCookie);	\n	}\n\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		// TODO Auto-generated method stub\n		doGet(request, response);\n	}\n\n}\n```\n\nReadCookieServlet.java查询cookie\n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/read-cookie-servlet\")\npublic class ReadCookieServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n       \n  \n    public ReadCookieServlet() {\n        super();\n        \n    }\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		//获取Cookie\n		Cookie[] cookies = request.getCookies();\n		for (Cookie cookie : cookies) {\n			//打印cookie对象\n			System.out.println(\"cookie对象:\" + cookie);\n			\n			//返回描述 cookie 目的的注释，若没有则返回 null\n			System.out.println(\"cookie 目的的注释:\"+cookie.getComment());\n			\n			//获取 cookie 的域名，比如 runoob.com\n			System.out.println(\"cookie 的域名:\"+cookie.getDomain());\n			\n			//获取 cookie 有效期\n			System.out.println(\"cookie 有效期:\"+cookie.getMaxAge());\n			\n			//返回 cookie 的名称\n			System.out.println(\"cookie cookie 的名称:\"+cookie.getName());\n			\n			//获取 cookie 的路径\n			System.out.println(\"cookie 的路径:\" + cookie.getPath());\n			\n			//获取 cookie 是否是加密传输\n			System.out.println(\" cookie 是否是加密传输:\"+cookie.getSecure());\n			\n			//获取cookie的值\n			System.out.println(\"cookie的值:\"+cookie.getValue());\n			\n			//获取cookie的版本\n			System.out.println(\"cookie的版本:\"+cookie.getVersion());\n		}\n		\n	}\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n	\n		doGet(request, response);\n	}\n}\n```\n\n**（4）使用 JSP 删除 cookie**\n\n删除 cookie 非常简单。如果您想要删除一个 cookie，按照下面给的步骤来做就行了：\n\n- 获取一个已经存在的 cookie 然后存储在 Cookie 对象中。\n- 将 cookie 的有效期设置为 0。\n- 将这个 cookie 重新添加进响应头中。\n\n（2）代码演示：模拟登录界面（登录成功后自动保存用户名和密码，方便页面读取用户信息）\n\nlogin.html 表单提交数据\n\n```java\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>登录</title>\n</head>\n<body>\n\n<form action=\"main.jsp\" method=\"post\">\n用户名: <input type=\"text\" name=\"username\">\n<br />\n密码: <input type=\"password\" name=\"password\" />\n<input type=\"submit\" value=\"提交\" />\n</form>\n\n</body>\n</html>\n```\n\n注销LogoutServlet.java，删除cookie的用户数据\n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/logout-servlet\")\npublic class LogoutServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n\n	public LogoutServlet() {\n		super();\n\n	}\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		request.setCharacterEncoding(\"utf-8\");\n		response.setCharacterEncoding(\"utf-8\");\n		response.setContentType(\"text/html;charset=utf-8\");\n		Cookie[] cookies = request.getCookies();\n		if (cookies != null) {\n			for (int i = 0; i < cookies.length; i++) {\n				if (cookies[i].getName().equals(\"username\")) {\n					cookies[i].setMaxAge(0);\n				}\n				if (cookies[i].getName().equals(\"password\")) {\n					cookies[i].setMaxAge(0);\n				}\n			}\n		}\n		request.getRequestDispatcher(\"main.jsp\").forward(request, response);\n	}\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n\n		doGet(request, response);\n	}\n}\n```\n\n通过main.jsp设置和获取cookie\n\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<%@ page import=\"java.net.*\" %>\n<%\n   // 编码，解决中文乱码   \n   request.setCharacterEncoding(\"utf-8\");\n   response.setCharacterEncoding(\"utf-8\"); \n   response.setContentType(\"text/html;charset=utf-8\");\n   // 设置 name 和 url cookie \n   Cookie username = new Cookie(\"username\",\n		   request.getParameter(\"username\"));\n   Cookie password = new Cookie(\"password\",\n              request.getParameter(\"password\"));\n\n   // 设置cookie过期时间为24小时。\n   username.setMaxAge(60*60*24); \n   password.setMaxAge(60*60*24); \n\n   // 在响应头部添加cookie\n   response.addCookie( username );\n   response.addCookie( password );\n%>\n<html>\n<head>\n<title>设置 Cookie</title>\n</head>\n<body>\n\n\n\n<% \nString name = \"\";\nCookie[] cookies = request.getCookies();\nif(cookies != null){\n	for(int i = 0;i<cookies.length;i++){\n		if(cookies[i].getName().equals(\"username\")){\n			name = cookies[i].getValue();\n		}\n	}\n}\n%>\n\n<h1>欢迎，\n<%\nif(name.equals(\"\")){\n%>\n	<a href = \"login.html\">点击登录</a>\n<%\n}else{\n%>\n<%=name%>\n<a href=\"logout-servlet\">注销</a>	\n<%\n}\n%>\n\n</body>\n</html>\n```', 0, 0, '2020-08-07 14:17:52', 3, 0, 1, '\n参考链接：https://www.runoob.com/jsp/jsp-cookies.html\n\n1. 概念Cookie 是存储在客户机的文本文件，它们保存了大量轨迹信息。在 Servlet 技术基础上，JSP 显然能够提供对 HTTP cookie 的支持。\nCookie是保存在客户端的小文本，保存的位置分两种\n\nCookie可能保存在客户端浏览器的所占内存中，关闭浏览器后，Cookie就不再存在Cookie也可能保存在客户PC机的硬盘上，设置有效时间，超过有效时间后失效\n2. Servlet 中 Cookie的方法\npublic void setDomain(String pattern)设置 cookie 的域名，比如 runoob.compublic String getDomain()获取 cookie 的域名，比如 runoob.compublic void setMaxAge(int expiry)设置 cookie 有效期，以秒为单位，默认有效期为当前session的存活时间public int getMaxAge()获取 cookie 有效期，以秒为单位，默认为-1 ，表明cookie会活到浏览器关闭为public String getName()返回 cookie 的名称，名称创建后将不能被修改public void setValue(String newValue)设置 cookie 的值public String getValue()获取cookie的值public void setPath(String uri)设置 cookie 的路径，默认为当前页面目录下的所有 URL，还有此目录下的所有子目录public String getPath()获取 cookie 的路径public void setSecure(boolean flag)指明 cookie 是否要加密传输public void setComment(String purpose)设置注释描述 cookie 的目的。当浏览器将 cookie 展现给用户时，注释将会变得非常有用public String getComment()返回描述 cookie 目的的注释，若没有则返回 null\n2.1 Servlet 中设置 cookie（1）创建一个 cookie 对象：\nCookie cookie = new Cookie(“key”,”value”);\n//创建Cookie对象Cookie userNameCookie = new Cookie(\"username\", \"86_god\");Cookie passwordCookie = new Cookie(\"password\", \"123456\");\n注意：名称和值中都不能包含空格或者如下的字符：[ ] ( ) = , “ / ? @ : ;\n（2）设置有效期：setMaxAge() 函数表明 cookie 在多长时间（以秒为单位）内有效。\n//设置有效期userNameCookie.setMaxAge(60*60*24*7);passwordCookie.setMaxAge(60*60*24*7);\n（3）将 cookie 发送至 HTTP 响应头中：调用 response.addCookie() 函数来向 HTTP 响应头中添加 cookie。\n//发给浏览器保存response.addCookie(userNameCookie);response.addCookie(passwordCookie);\n代码演示：（利用servlet设置cookie和查询cookie）\nAddCookieServlet.java文件 设置cookie\npackage com.company.project.servlet;import java.io.IOException;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/add-cookie-servlet\")public class AddCookieServlet extends HttpServlet {    private static final long serialVersionUID = 1L;        public AddCookieServlet() {            super();        }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //创建Cookie对象        Cookie userNameCookie = new Cookie(\"username\", \"张三\");        Cookie passwordCookie = new Cookie(\"password\", \"23456\");        //设置有效期        userNameCookie.setMaxAge(60*60*24*7);        passwordCookie.setMaxAge(60*60*24*7);        //发给浏览器保存        response.addCookie(userNameCookie);        response.addCookie(passwordCookie);        }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // TODO Auto-generated method stub        doGet(request, response);    }}\nReadCookieServlet.java查询cookie\npackage com.company.project.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/read-cookie-servlet\")public class ReadCookieServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    public ReadCookieServlet() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //获取Cookie        Cookie[] cookies = request.getCookies();        for (Cookie cookie : cookies) {            //打印cookie对象            System.out.println(\"cookie对象:\" + cookie);            //返回描述 cookie 目的的注释，若没有则返回 null            System.out.println(\"cookie 目的的注释:\"+cookie.getComment());            //获取 cookie 的域名，比如 runoob.com            System.out.println(\"cookie 的域名:\"+cookie.getDomain());            //获取 cookie 有效期            System.out.println(\"cookie 有效期:\"+cookie.getMaxAge());            //返回 cookie 的名称            System.out.println(\"cookie cookie 的名称:\"+cookie.getName());            //获取 cookie 的路径            System.out.println(\"cookie 的路径:\" + cookie.getPath());            //获取 cookie 是否是加密传输            System.out.println(\" cookie 是否是加密传输:\"+cookie.getSecure());            //获取cookie的值            System.out.println(\"cookie的值:\"+cookie.getValue());            //获取cookie的版本            System.out.println(\"cookie的版本:\"+cookie.getVersion());        }    }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        doGet(request, response);    }}\n（4）使用 JSP 删除 cookie\n删除 cookie 非常简单。如果您想要删除一个 cookie，按照下面给的步骤来做就行了：\n\n获取一个已经存在的 cookie 然后存储在 Cookie 对象中。将 cookie 的有效期设置为 0。将这个 cookie 重新添加进响应头中。\n（2）代码演示：模拟登录界面（登录成功后自动保存用户名和密码，方便页面读取用户信息）\nlogin.html 表单提交数据\n<!DOCTYPE html><html><head><meta charset=\"utf-8\"><title>登录</title></head><body><form action=\"main.jsp\" method=\"post\">用户名: <input type=\"text\" name=\"username\"><br />密码: <input type=\"password\" name=\"password\" /><input type=\"submit\" value=\"提交\" /></form></body></html>\n注销LogoutServlet.java，删除cookie的用户数据\npackage com.company.project.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/logout-servlet\")public class LogoutServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    public LogoutServlet() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        request.setCharacterEncoding(\"utf-8\");        response.setCharacterEncoding(\"utf-8\");        response.setContentType(\"text/html;charset=utf-8\");        Cookie[] cookies = request.getCookies();        if (cookies != null) {            for (int i = 0; i < cookies.length; i++) {                if (cookies[i].getName().equals(\"username\")) {                    cookies[i].setMaxAge(0);                }                if (cookies[i].getName().equals(\"password\")) {                    cookies[i].setMaxAge(0);                }            }        }        request.getRequestDispatcher(\"main.jsp\").forward(request, response);    }    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        doGet(request, response);    }}\n通过main.jsp设置和获取cookie\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><%@ page import=\"java.net.*\" %><%   // 编码，解决中文乱码      request.setCharacterEncoding(\"utf-8\");   response.setCharacterEncoding(\"utf-8\");    response.setContentType(\"text/html;charset=utf-8\");   // 设置 name 和 url cookie    Cookie username = new Cookie(\"username\",           request.getParameter(\"username\"));   Cookie password = new Cookie(\"password\",              request.getParameter(\"password\"));   // 设置cookie过期时间为24小时。   username.setMaxAge(60*60*24);    password.setMaxAge(60*60*24);    // 在响应头部添加cookie   response.addCookie( username );   response.addCookie( password );%><html><head><title>设置 Cookie</title></head><body><% String name = \"\";Cookie[] cookies = request.getCookies();if(cookies != null){    for(int i = 0;i<cookies.length;i++){        if(cookies[i].getName().equals(\"username\")){            name = cookies[i].getValue();        }    }}%><h1>欢迎，<%if(name.equals(\"\")){%>    <a href = \"login.html\">点击登录</a><%}else{%><%=name%><a href=\"logout-servlet\">注销</a>    <%}%></body></html>\n', 0, 1);
INSERT INTO `t_article` VALUES (160, '07.《JavaEE 笔记》Session会话', 8, '## 1、会话的概念\n\n客户端向服务器端发送请求，服务器端接受请求并生成响应返回给客户端，客户端对服务器端这样一次连续的调用过程，被称为会话（session）。\n\n**Session：记录一系列状态**\n\n**Session与cookie功能效果相同。**Session与Cookie的区别在于Session是记录在服务端的，而Cookie是记录在客户端的。\n\n**Cookie与Session的区别**\n\n- session是在服务器端保存用户信息，Cookie是在客户端保存用户信息\n- session中保存的是任意对象，Cookie保存的是字符串\n- session随会话结束而关闭，Cookie可以长期保存在客户端硬盘上，也可以临时保存在浏览器内存中\n- Cookie通常用于保存不重要的用户信息，重要的信息使用session保存\n\n**解释session**：当访问服务器某个网页的时候，会在服务器端的内存里开辟一块内存，这块内存就叫做session，而这个内存是跟浏览器关联在一起的。这个浏览器指的是浏览器窗口，或者是浏览器的子窗口，意思就是，只允许当前这个session对应的浏览器访问，就算是在同一个机器上新启的浏览器也是无法访问的。而另外一个浏览器也需要记录session的话，就会再启一个属于自己的session\n\n**原理：**HTTP协议是非连接性的，取完当前浏览器的内容，然后关闭浏览器后，链接就断开了，而没有任何机制去记录取出后的信息。而当需要访问同一个网站的另外一个页面时(就好比如在第一个页面选择购买的商品后，跳转到第二个页面去进行付款)这个时候取出来的信息，就读不出来了。所以必须要有一种机制让页面知道原理页面的session内容。\n\n## 2. HttpSession接口\n\nServlet 提供了 HttpSession 接口，该接口提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。\n\nServlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。\n\n### 2.1 如何获取Session接口对象\n\nServlet API中，定义了HttpSession接口，用来封装会话对象。\n\nHttpSession是接口，不能直接用new创建对象，会话对象是容器创建的，使用HttpServletRequest中的方法获得会话对象。\n\n- **public HttpSession getSession()**：获取跟当前请求相关的session，如果不存在session，就创建一个新的session对象返回。\n- **public HttpSession getSession(boolean create)**:如果参数create值为true，与无参的getSession方法等同。如果参数create的值是false，那么如果不存在与当前请求相关的session对象，则返回null，如果存在则直接返回会话对象。\n- JSP文件中有内置对象session，可以直接调用HttpSession接口中任意方法\n\n获取当前请求的session会话对象：\n\n```java\nHttpSession session = request.getSession();\n```\n\n### 2.2 常用方法\n\n1. **public Object getAttribute(String name)** 通过key获取对象值 。\n2. **public void setAttribute(String name, Object value)** 以key/value的形式保存对象值。\n3. **public Enumeration getAttributeNames()** 该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。\n4. **public long getCreationTime()** 该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。\n5. **public String getId()** 获取session对象的编号。\n6. **public long getLastAccessedTime()** 该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。\n7. **public int getMaxInactiveInterval()** 获取session的有效非活动时间，以秒为单位。\n8. **public void setMaxInactiveInterval(int interval)**  该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。\n9. **public void invalidate()** 设置session对象失效，并解除绑定到它上面的任何对象。\n10. **public boolean isNew()** 判断一个session是不是一个新创建的会话对象。\n11. **public void removeAttribute(String name)** 通过key删除属性。\n\n### 2.3 会话属性与请求属性区别\n\n- 主要区别是有效范围不同。请求中的属性只在当前的请求对象中有效。只有通过请求转发时，才能把当前请求对象转发到下一个资源，其他情况都生成新的请求，所以请求属性也不再可用\n- 会话属性在会话对象中有效。客户端与服务器连接后，只要没有关闭浏览器，服务器也没有出现异常，就是一次会话，会话属性就一直有效。\n- 由于会话对象有效时间长，所以安全性相对低，所占资源相对多，因此：请求属性可以解决的问题就用请求，必须用会话的才用会话。\n\n### 2.4 删除 Session 会话数据\n\n当您完成了一个用户的 session 会话数据，您有以下几种选择：\n\n- **移除一个特定的属性：**您可以调用 *public void removeAttribute(String name)* 方法来删除与特定的键相关联的值。\n- **删除整个 session 会话：**您可以调用 *public void invalidate()* 方法来丢弃整个 session 会话。\n- **设置 session 会话过期时间：**您可以调用 *public void setMaxInactiveInterval(int interval)* 方法来单独设置 session 会话超时。\n- **注销用户：**如果使用的是支持 servlet 2.4 的服务器，您可以调用 **logout** 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。\n- **web.xml 配置：**如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：\n\n```xml\n  <session-config>\n    <session-timeout>15</session-timeout>\n  </session-config>\n```\n\n案例：登录界面、欢迎界面、退出界面\n\nlogin.jsp（登录界面）\n\n```jsp\n<%@page import=\"java.util.Date\"%>\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Session</title>\n</head>\n<body>\n<form action=\"login-servlet\" method=\"post\">\n用户名: <input type=\"text\" name=\"username\">\n<br />\n密码: <input type=\"password\" name=\"password\" />\n<br>\n<input type=\"submit\" value=\"提交\" />\n</form>\n</body>\n</html>\n```\n\nLoginServlet.java（登录处理）\n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/login-servlet\")\npublic class LoginServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n\n	public LoginServlet() {\n		super();\n	}\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		request.setCharacterEncoding(\"utf-8\");\n		response.setCharacterEncoding(\"utf-8\");\n		response.setContentType(\"text/html;charset=utf-8\");\n		// 假设已经拿到了用户名和密码\n		String serverUserName = \"86_god\";\n		String serverPassword = \"123456\";\n\n		// 获取到客户端的数据\n		String username = \"\";\n		String password = \"\";\n\n		username = request.getParameter(\"username\");\n		password = request.getParameter(\"password\");\n		System.out.println(username);\n		System.out.println(password);\n		\n		if (username != null && password != null && username.equals(serverUserName)\n				&& password.equals(serverPassword)) {\n			System.out.println(\"登录成功\");\n			HttpSession session = request.getSession();\n			session.setAttribute(\"username\", username);\n			request.getRequestDispatcher(\"welcome.jsp\").forward(request, response);\n		}\n		else {\n			//获取输出流\n			PrintWriter out = response.getWriter();\n			//生成登录失败界面\n			out.println(\"<html>\");\n			out.println(\"<head>\");\n			out.println(\"</head>\");\n			out.println(\"<body bgcolor=\\\"deepskyblue\\\">\");\n			out.println(\"<h1>登陆失败</h1>\");\n			out.println(\"<p>您输入的用户名或密码不正确，请重新输入</p>\");\n			out.println(\"<a href=\\\"login.jsp\\\">\");\n			out.println(\"<button>重新登录</button>\");\n			out.println(\"</a>\");\n			out.println(\"</body>\");\n			out.println(\"</html>\");\n			out.close();\n		}\n	}\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n\n		doGet(request, response);\n	}\n}\n```\n\nwelcome.jsp（欢迎界面）\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n    \n<%boolean flag = false;\nString username = \"\";\nusername = (String)session.getAttribute(\"username\");\nif(username != null && username !=\"\"){\n	flag = true;\n}\n\n%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>欢迎</title>\n</head>\n<body>\n欢迎，\n<%\nif(flag){\n%>\n<%= username %>\n<a href=\"logout-servlet\">退出</a>\n<%	\n}else{\n%>\n<a href=\"login.jsp\">点击登录</a>\n<%\n}\n%>\n</body>\n</html>\n```\n\nLogoutServlet.java\n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n\n@WebServlet(\"/logout-servlet\")\npublic class LogoutServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n\n    public LogoutServlet() {\n        super();\n      \n    }\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		HttpSession session = request.getSession();\n		session.invalidate();\n		request.getRequestDispatcher(\"welcome.jsp\").forward(request, response);\n		\n	}\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		\n		doGet(request, response);\n	}\n}\n```', 0, 0, '2020-08-07 14:19:04', 2, 0, 1, '1、会话的概念客户端向服务器端发送请求，服务器端接受请求并生成响应返回给客户端，客户端对服务器端这样一次连续的调用过程，被称为会话（session）。\nSession：记录一系列状态\nSession与cookie功能效果相同。Session与Cookie的区别在于Session是记录在服务端的，而Cookie是记录在客户端的。\nCookie与Session的区别\n\nsession是在服务器端保存用户信息，Cookie是在客户端保存用户信息session中保存的是任意对象，Cookie保存的是字符串session随会话结束而关闭，Cookie可以长期保存在客户端硬盘上，也可以临时保存在浏览器内存中Cookie通常用于保存不重要的用户信息，重要的信息使用session保存\n解释session：当访问服务器某个网页的时候，会在服务器端的内存里开辟一块内存，这块内存就叫做session，而这个内存是跟浏览器关联在一起的。这个浏览器指的是浏览器窗口，或者是浏览器的子窗口，意思就是，只允许当前这个session对应的浏览器访问，就算是在同一个机器上新启的浏览器也是无法访问的。而另外一个浏览器也需要记录session的话，就会再启一个属于自己的session\n原理：HTTP协议是非连接性的，取完当前浏览器的内容，然后关闭浏览器后，链接就断开了，而没有任何机制去记录取出后的信息。而当需要访问同一个网站的另外一个页面时(就好比如在第一个页面选择购买的商品后，跳转到第二个页面去进行付款)这个时候取出来的信息，就读不出来了。所以必须要有一种机制让页面知道原理页面的session内容。\n2. HttpSession接口Servlet 提供了 HttpSession 接口，该接口提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。\nServlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。\n2.1 如何获取Session接口对象Servlet API中，定义了HttpSession接口，用来封装会话对象。\nHttpSession是接口，不能直接用new创建对象，会话对象是容器创建的，使用HttpServletRequest中的方法获得会话对象。\n\npublic HttpSession getSession()：获取跟当前请求相关的session，如果不存在session，就创建一个新的session对象返回。public HttpSession getSession(boolean create):如果参数create值为true，与无参的getSession方法等同。如果参数create的值是false，那么如果不存在与当前请求相关的session对象，则返回null，如果存在则直接返回会话对象。JSP文件中有内置对象session，可以直接调用HttpSession接口中任意方法\n获取当前请求的session会话对象：\nHttpSession session = request.getSession();\n2.2 常用方法\npublic Object getAttribute(String name) 通过key获取对象值 。public void setAttribute(String name, Object value) 以key/value的形式保存对象值。public Enumeration getAttributeNames() 该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。public long getCreationTime() 该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。public String getId() 获取session对象的编号。public long getLastAccessedTime() 该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。public int getMaxInactiveInterval() 获取session的有效非活动时间，以秒为单位。public void setMaxInactiveInterval(int interval)  该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。public void invalidate() 设置session对象失效，并解除绑定到它上面的任何对象。public boolean isNew() 判断一个session是不是一个新创建的会话对象。public void removeAttribute(String name) 通过key删除属性。\n2.3 会话属性与请求属性区别\n主要区别是有效范围不同。请求中的属性只在当前的请求对象中有效。只有通过请求转发时，才能把当前请求对象转发到下一个资源，其他情况都生成新的请求，所以请求属性也不再可用会话属性在会话对象中有效。客户端与服务器连接后，只要没有关闭浏览器，服务器也没有出现异常，就是一次会话，会话属性就一直有效。由于会话对象有效时间长，所以安全性相对低，所占资源相对多，因此：请求属性可以解决的问题就用请求，必须用会话的才用会话。\n2.4 删除 Session 会话数据当您完成了一个用户的 session 会话数据，您有以下几种选择：\n\n移除一个特定的属性：您可以调用 public void removeAttribute(String name) 方法来删除与特定的键相关联的值。删除整个 session 会话：您可以调用 public void invalidate() 方法来丢弃整个 session 会话。设置 session 会话过期时间：您可以调用 public void setMaxInactiveInterval(int interval) 方法来单独设置 session 会话超时。注销用户：如果使用的是支持 servlet 2.4 的服务器，您可以调用 logout 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。web.xml 配置：如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：\n  <session-config>    <session-timeout>15</session-timeout>  </session-config>\n案例：登录界面、欢迎界面、退出界面\nlogin.jsp（登录界面）\n<%@page import=\"java.util.Date\"%><%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>Session</title></head><body><form action=\"login-servlet\" method=\"post\">用户名: <input type=\"text\" name=\"username\"><br />密码: <input type=\"password\" name=\"password\" /><br><input type=\"submit\" value=\"提交\" /></form></body></html>\nLoginServlet.java（登录处理）\npackage com.company.project.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@WebServlet(\"/login-servlet\")public class LoginServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    public LoginServlet() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        request.setCharacterEncoding(\"utf-8\");        response.setCharacterEncoding(\"utf-8\");        response.setContentType(\"text/html;charset=utf-8\");        // 假设已经拿到了用户名和密码        String serverUserName = \"86_god\";        String serverPassword = \"123456\";        // 获取到客户端的数据        String username = \"\";        String password = \"\";        username = request.getParameter(\"username\");        password = request.getParameter(\"password\");        System.out.println(username);        System.out.println(password);        if (username != null && password != null && username.equals(serverUserName)                && password.equals(serverPassword)) {            System.out.println(\"登录成功\");            HttpSession session = request.getSession();            session.setAttribute(\"username\", username);            request.getRequestDispatcher(\"welcome.jsp\").forward(request, response);        }        else {            //获取输出流            PrintWriter out = response.getWriter();            //生成登录失败界面            out.println(\"<html>\");            out.println(\"<head>\");            out.println(\"</head>\");            out.println(\"<body bgcolor=\\\"deepskyblue\\\">\");            out.println(\"<h1>登陆失败</h1>\");            out.println(\"<p>您输入的用户名或密码不正确，请重新输入</p>\");            out.println(\"<a href=\\\"login.jsp\\\">\");            out.println(\"<button>重新登录</button>\");            out.println(\"</a>\");            out.println(\"</body>\");            out.println(\"</html>\");            out.close();        }    }    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        doGet(request, response);    }}\nwelcome.jsp（欢迎界面）\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><%boolean flag = false;String username = \"\";username = (String)session.getAttribute(\"username\");if(username != null && username !=\"\"){    flag = true;}%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>欢迎</title></head><body>欢迎，<%if(flag){%><%= username %><a href=\"logout-servlet\">退出</a><%    }else{%><a href=\"login.jsp\">点击登录</a><%}%></body></html>\nLogoutServlet.java\npackage com.company.project.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;@WebServlet(\"/logout-servlet\")public class LogoutServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    public LogoutServlet() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        HttpSession session = request.getSession();        session.invalidate();        request.getRequestDispatcher(\"welcome.jsp\").forward(request, response);    }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        doGet(request, response);    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (161, '08.《JavaEE 笔记》ServletContext 上下文（实现多人在线聊天室）', 8, '## 1、ServletContext 概念\n\nServletContext官方叫servlet上下文。服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象。\n\n**Web应用程序**是Servlet、JSP页面和内容的集合，被Eclipse自动部署在Tomcat服务器URL名称空间的特定目录(如/catalog)下。注意，有时候可能通过.war文件部署。\n\n对于在其部署描述符中标记为distributed的Web应用程序，每个虚拟机中都有一个上下文实例，这个实例称为上下文对象。例如，当前的Tomcat中部署了WebProject01，WebProject02……WebProject07共7个Web应用程序，那么，在启动Tomcat时，将分别为每一个Web应用程序创建一个上下文对象。\n\n在这种情况下，上下文不能用作共享全局信息的位置而使用外部资源，比如数据库、或者文件服务器等。因为这些信息不是真正的全局信息。\n\n**作用：**\n\n1. 是一个域对象\n2. 可以读取全局配置参数\n3. 可以搜索当前工程目录下面的资源文件\n4. 可以获取当前工程名字（了解）\n\n## 2. ServletContext接口\n\n### 2.1 获取ServletContext对象\n\n- ServletConfig接口中定义的getServletContext方法\n- 由于自定义的Servlet类间接实现了ServletConfig接口，因此可以直接调用getServletContext方法返回ServletContext对象 JSP文件中使用上下文对象的方法\n- JSP文件的内置对象application即上下文对象，可以调用ServletContext接口中的任意方法\n\nServlet中获取：（以下两种都可以）\n\n```java\n	protected void doPost(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		// 获取Servlet上下文引用\n		ServletContext context1 = this.getServletContext();\n                ServletContext context2 = request.getServletContext();\n	}\n```\n\njsp中获取：\n\n```jsp\n<%  \nServletContext context1 = this.getServletContext();\nServletContext context2 = request.getServletContext();\n%> \n```\n\n### 2.2 域对象常用方法：\n\n1. void setAttribute(String key,Object value) 往域对象里面添加数据，添加时以key-value形式添加\n2. Object getAttribute(String key) 根据指定的key读取域对象里面的数据\n3. void removeAttribute(name); 根据指定的key从域对象里面删除数据\n\n### 2.3 读取全局配置参数方法：\n\n1. String getInitParameter(String path) 返回上下文参数的值\n2. Enumeration<String> getInitParameterNames() 获取所有参数名称列表\n\n代码案例：\n\n（1）在web.xml中配置全局参数\n\n```xml\n  <!-- 全局配置参数，因为不属于任何一个servlet，但是所有的servlet都可以通过servletContext读取\n这个数据 -->  \n\n  <context-param>\n    <param-name>userName</param-name>\n    <param-value>86_god</param-value>\n  </context-param>\n  <context-param>\n    <param-name>e-mail</param-name>\n    <param-value>2584966199@qq.com</param-value>\n  </context-param>\n  <context-param>\n    <param-name>url</param-name>\n    <param-value>https://www.zhihu.com/people/he-lai-xin-huan</param-value>\n  </context-param>\n```\n\n（2）在Servlet中获取全局变量\n\n```java\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		ServletContext context = this.getServletContext();\n		String userName = context.getInitParameter(\"userName\");\n		System.out.println(userName);\n		\n		//获取所有全局变量的参数名称\n		Enumeration<String> list = context.getInitParameterNames();\n		\n		//遍历所有参数\n		while (list.hasMoreElements()) {\n			String name = list.nextElement();\n			String value = getServletContext().getInitParameter(name);\n			System.out.println(name + \":\" + value );\n			\n		}\n	}\n```\n\n### 2.4 可以搜索当前工程目录下面的资源文件\n\n1. getServletContext().getRealPath(path) 根据相对路径获取服务器上资源的绝对路径\n2. getServletContext().getResourceAsStream(path) 根据相对路径获取服务器上资源的输入字节流\n3. getServletContext().getContextPath() 获取项目名称\n\n```java\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {		\n		//根据相对路径获取服务器上资源的绝对路径\n		System.out.println(getServletContext().getRealPath(\"web.xml\"));\n		\n		//根据相对路径获取服务器上资源的输入字节流\n		System.out.println(getServletContext().getResourceAsStream(\"web.xml\"));\n		\n		//获取项目名称\n		System.out.println(getServletContext().getContextPath());\n	}\n```\n\n## 3. 代码案例（实现网络聊天室）\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/v2-47e047f7660e02a5d1b06bbfc188ed7f_b.png)\n\n实现一个网上在线多人聊天室，页面比较丑，主要写后端\n\n直接上代码！！！\n\n### 页面部分代码：\n\n（1）index.jsp\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n\n<frameset cols=\"80%,*\">\n		<frame name=\"index\" src=\"chatFrame.jsp\" scrolling=\"no\" />\n		<frame name=\"onlineList\" src=\"onlineList.jsp\" scrolling=\"no\" />\n		\n		<noframes>\n			<body>\n				对不起，您的浏览器不支持框架,请使用更好的浏览器。\n			</body>\n		</noframes>\n</frameset>\n\n</html>\n```\n\n（2）chatFrame.jsp\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>聊天室</title>\n</head>\n<frameset rows=\"80%,*\">\n		<frame name=\"chattingRecords\" src=\"chattingRecords.jsp\" scrolling=\"no\" />\n		<frame name=\"inputFrame\" src=\"inputFrame.jsp\" scrolling=\"no\" />\n		\n		<noframes>\n			<body>\n				对不起，您的浏览器不支持框架,请使用更好的浏览器。\n			</body>\n		</noframes>\n</frameset>\n</html>\n```\n\n（3）chattingRecords.jsp\n\n```jsp\n<%@page import=\"java.util.Date\"%>\n<%@page import=\"java.text.SimpleDateFormat\"%>\n<%@page import=\"com.company.project.po.Message\"%>\n<%@page import=\"java.util.ArrayList\"%>\n<%@page import=\"org.apache.jasper.tagplugins.jstl.core.ForEach\"%>\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n	pageEncoding=\"UTF-8\"%>\n\n<%\n	ArrayList<Message> messages = (ArrayList<Message>) getServletContext().getAttribute(\"messages\");\n	ArrayList<String> userList = (ArrayList<String>) getServletContext().getAttribute(\"userList\");\n	String userId = request.getSession().getId();\n	\n	if (messages == null) {\n		messages = new ArrayList();\n	}\n	\n	if(userList == null){\n		userList = new ArrayList();\n	}\n	if(!userList.contains(userId)){\n		userList.add(userId);\n		SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式\n		String sendTime = df.format(new Date());// new Date()为获取当前系统时间\n	\n		Message message = new Message();\n		message.setUserName(\"系统提示\");\n		message.setContent(\"欢迎\"+request.getSession().getId()+\"加入\");\n		message.setSendTime(sendTime);\n		messages.add(message);\n	}	\n	getServletContext().setAttribute(\"userList\", userList);\n	getServletContext().setAttribute(\"messages\", messages);\n%>\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>聊天记录</title>\n<script>\nfunction fresh() {\n	location.reload();\n}\n\nwindow.setInterval(function() {\n	fresh();\n}, 1000);\n</script>\n</head>\n<body>\n	<%\n		if (messages != null)\n			for (Message message : messages) {\n	%>\n	<%=message.getSendTime()%>&nbsp;<%=message.getUserName()%>说：<%=message.getContent() %>\n	<br>\n	<%\n		}\n	%>\n</body>\n</html>\n```\n\n（4）inputFrame.jsp\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n    \n<%\nString path = request.getContextPath();\nString basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort()\n		+ path;\n%>    \n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>输入框</title>\n<script type=\"text/javascript\">\nfunction IsNull() {\n	var mess = document.getElementById(\"inputText\").value;\n	var send = document.getElementById(\"sendForm\");\n	console.log(mess);\n	console.log(send);\n	if(mess != null && mess != \"\"){\n		send.submit();\n	}\n}\n</script>\n\n</head>\n<body>\n\n<form action=\"<%=basePath %>/send-message\" method=\"get\" id=\"sendForm\">\n<textarea id=\"inputText\" name =\"inputText\" style=\"width: 100%\">\n</textarea>\n<input type=\"button\" value=\"发送\" onclick=\"IsNull()\"> \n</form>\n</body>\n</html>\n```\n\n（5）onlineList.jsp\n\n```jsp\n<%@page import=\"java.util.ArrayList\"%>\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n    \n<% \nArrayList<String> userList = (ArrayList<String>) getServletContext().getAttribute(\"userList\");\nif(userList == null){\n	userList = new ArrayList();\n}\n%>    \n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>在线列表</title>\n<script>\nfunction fresh() {\n	location.reload();\n}\n\nwindow.setInterval(function() {\n	fresh();\n}, 1000);\n</script>\n</head>\n<body>\n<h2>在线用户列表(目前在线人数：<%=userList.size() %>)<h2>\n<%\nfor(String user:userList){\n	%>\n	<%=user %><br>\n	<%\n}\n%>\n\n</body>\n</html>\n```\n\n### 模型model代码：\n\nMessage.java\n\n```java\npackage com.company.project.po;\n\npublic class Message {\n	private String userName;\n	private String sendTime;\n	private String content;\n	public String getUserName() {\n		return userName;\n	}\n\n	public String getContent() {\n		return content;\n	}\n	public void setUserName(String userName) {\n		this.userName = userName;\n	}\n\n	public void setContent(String content) {\n		this.content = content;\n	}\n\n	public String getSendTime() {\n		return sendTime;\n	}\n\n	public void setSendTime(String sendTime) {\n		this.sendTime = sendTime;\n	}\n\n	@Override\n	public String toString() {\n		return \"Message [userName=\" + userName + \", sendTime=\" + sendTime + \", content=\" + content + \"]\";\n	}\n}\n```\n\n### Servlet代码\n\nSendMessage.java\n\n```java\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\nimport com.company.project.po.Message;\n\n@WebServlet(\"/send-message\")\npublic class SendMessage extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n       \n \n    public SendMessage() {\n        super();\n        // TODO Auto-generated constructor stub\n    }\n\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		\n		// 设置相应内容类型\n		request.setCharacterEncoding(\"utf-8\");\n		response.setContentType(\"text/html;charset=utf-8\");\n		response.setCharacterEncoding(\"utf-8\");\n		\n		HttpSession session = request.getSession();\n		String inputText = (String)request.getParameter(\"inputText\");\n		\n		SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式\n		String sendTime = df.format(new Date());// new Date()为获取当前系统时间\n		\n		\n		Message message = new Message();\n		message.setUserName(session.getId());\n		message.setContent(inputText);\n		message.setSendTime(sendTime);\n		\n		ArrayList<Message> messages = (ArrayList<Message>)getServletContext().getAttribute(\"messages\");\n		if(messages == null) {\n			messages = new ArrayList<>();	\n		}\n		messages.add(message);\n		getServletContext().setAttribute(\"messages\", messages);\n		response.sendRedirect(\"page/inputFrame.jsp\");\n	}\n\n	\n	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		\n		doGet(request, response);\n	}\n}\n```\n\n> 越努力，越幸运 我们亦是拾光者！！！', 0, 0, '2020-08-07 14:22:03', 2, 0, 1, '1、ServletContext 概念ServletContext官方叫servlet上下文。服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象。\nWeb应用程序是Servlet、JSP页面和内容的集合，被Eclipse自动部署在Tomcat服务器URL名称空间的特定目录(如/catalog)下。注意，有时候可能通过.war文件部署。\n对于在其部署描述符中标记为distributed的Web应用程序，每个虚拟机中都有一个上下文实例，这个实例称为上下文对象。例如，当前的Tomcat中部署了WebProject01，WebProject02……WebProject07共7个Web应用程序，那么，在启动Tomcat时，将分别为每一个Web应用程序创建一个上下文对象。\n在这种情况下，上下文不能用作共享全局信息的位置而使用外部资源，比如数据库、或者文件服务器等。因为这些信息不是真正的全局信息。\n作用：\n\n是一个域对象可以读取全局配置参数可以搜索当前工程目录下面的资源文件可以获取当前工程名字（了解）\n2. ServletContext接口2.1 获取ServletContext对象\nServletConfig接口中定义的getServletContext方法由于自定义的Servlet类间接实现了ServletConfig接口，因此可以直接调用getServletContext方法返回ServletContext对象 JSP文件中使用上下文对象的方法JSP文件的内置对象application即上下文对象，可以调用ServletContext接口中的任意方法\nServlet中获取：（以下两种都可以）\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        // 获取Servlet上下文引用        ServletContext context1 = this.getServletContext();                ServletContext context2 = request.getServletContext();    }\njsp中获取：\n<%  ServletContext context1 = this.getServletContext();ServletContext context2 = request.getServletContext();%>\n2.2 域对象常用方法：\nvoid setAttribute(String key,Object value) 往域对象里面添加数据，添加时以key-value形式添加Object getAttribute(String key) 根据指定的key读取域对象里面的数据void removeAttribute(name); 根据指定的key从域对象里面删除数据\n2.3 读取全局配置参数方法：\nString getInitParameter(String path) 返回上下文参数的值Enumeration<String> getInitParameterNames() 获取所有参数名称列表\n代码案例：\n（1）在web.xml中配置全局参数\n  <!-- 全局配置参数，因为不属于任何一个servlet，但是所有的servlet都可以通过servletContext读取这个数据 -->    <context-param>    <param-name>userName</param-name>    <param-value>86_god</param-value>  </context-param>  <context-param>    <param-name>e-mail</param-name>    <param-value>2584966199@qq.com</param-value>  </context-param>  <context-param>    <param-name>url</param-name>    <param-value>https://www.zhihu.com/people/he-lai-xin-huan</param-value>  </context-param>\n（2）在Servlet中获取全局变量\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        ServletContext context = this.getServletContext();        String userName = context.getInitParameter(\"userName\");        System.out.println(userName);        //获取所有全局变量的参数名称        Enumeration<String> list = context.getInitParameterNames();        //遍历所有参数        while (list.hasMoreElements()) {            String name = list.nextElement();            String value = getServletContext().getInitParameter(name);            System.out.println(name + \":\" + value );        }    }\n2.4 可以搜索当前工程目录下面的资源文件\ngetServletContext().getRealPath(path) 根据相对路径获取服务器上资源的绝对路径getServletContext().getResourceAsStream(path) 根据相对路径获取服务器上资源的输入字节流getServletContext().getContextPath() 获取项目名称\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {                //根据相对路径获取服务器上资源的绝对路径        System.out.println(getServletContext().getRealPath(\"web.xml\"));        //根据相对路径获取服务器上资源的输入字节流        System.out.println(getServletContext().getResourceAsStream(\"web.xml\"));        //获取项目名称        System.out.println(getServletContext().getContextPath());    }\n3. 代码案例（实现网络聊天室）\n实现一个网上在线多人聊天室，页面比较丑，主要写后端\n直接上代码！！！\n页面部分代码：（1）index.jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>Insert title here</title></head><frameset cols=\"80%,*\">        <frame name=\"index\" src=\"chatFrame.jsp\" scrolling=\"no\" />        <frame name=\"onlineList\" src=\"onlineList.jsp\" scrolling=\"no\" />        <noframes>            <body>                对不起，您的浏览器不支持框架,请使用更好的浏览器。            </body>        </noframes></frameset></html>\n（2）chatFrame.jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>聊天室</title></head><frameset rows=\"80%,*\">        <frame name=\"chattingRecords\" src=\"chattingRecords.jsp\" scrolling=\"no\" />        <frame name=\"inputFrame\" src=\"inputFrame.jsp\" scrolling=\"no\" />        <noframes>            <body>                对不起，您的浏览器不支持框架,请使用更好的浏览器。            </body>        </noframes></frameset></html>\n（3）chattingRecords.jsp\n<%@page import=\"java.util.Date\"%><%@page import=\"java.text.SimpleDateFormat\"%><%@page import=\"com.company.project.po.Message\"%><%@page import=\"java.util.ArrayList\"%><%@page import=\"org.apache.jasper.tagplugins.jstl.core.ForEach\"%><%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><%    ArrayList<Message> messages = (ArrayList<Message>) getServletContext().getAttribute(\"messages\");    ArrayList<String> userList = (ArrayList<String>) getServletContext().getAttribute(\"userList\");    String userId = request.getSession().getId();    if (messages == null) {        messages = new ArrayList();    }    if(userList == null){        userList = new ArrayList();    }    if(!userList.contains(userId)){        userList.add(userId);        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式        String sendTime = df.format(new Date());// new Date()为获取当前系统时间        Message message = new Message();        message.setUserName(\"系统提示\");        message.setContent(\"欢迎\"+request.getSession().getId()+\"加入\");        message.setSendTime(sendTime);        messages.add(message);    }        getServletContext().setAttribute(\"userList\", userList);    getServletContext().setAttribute(\"messages\", messages);%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>聊天记录</title><script>function fresh() {    location.reload();}window.setInterval(function() {    fresh();}, 1000);</script></head><body>    <%        if (messages != null)            for (Message message : messages) {    %>    <%=message.getSendTime()%>&nbsp;<%=message.getUserName()%>说：<%=message.getContent() %>    <br>    <%        }    %></body></html>\n（4）inputFrame.jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><%String path = request.getContextPath();String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort()        + path;%>    <!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>输入框</title><script type=\"text/javascript\">function IsNull() {    var mess = document.getElementById(\"inputText\").value;    var send = document.getElementById(\"sendForm\");    console.log(mess);    console.log(send);    if(mess != null && mess != \"\"){        send.submit();    }}</script></head><body><form action=\"<%=basePath %>/send-message\" method=\"get\" id=\"sendForm\"><textarea id=\"inputText\" name =\"inputText\" style=\"width: 100%\"></textarea><input type=\"button\" value=\"发送\" onclick=\"IsNull()\"> </form></body></html>\n（5）onlineList.jsp\n<%@page import=\"java.util.ArrayList\"%><%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><% ArrayList<String> userList = (ArrayList<String>) getServletContext().getAttribute(\"userList\");if(userList == null){    userList = new ArrayList();}%>    <!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>在线列表</title><script>function fresh() {    location.reload();}window.setInterval(function() {    fresh();}, 1000);</script></head><body><h2>在线用户列表(目前在线人数：<%=userList.size() %>)<h2><%for(String user:userList){    %>    <%=user %><br>    <%}%></body></html>\n模型model代码：Message.java\npackage com.company.project.po;public class Message {    private String userName;    private String sendTime;    private String content;    public String getUserName() {        return userName;    }    public String getContent() {        return content;    }    public void setUserName(String userName) {        this.userName = userName;    }    public void setContent(String content) {        this.content = content;    }    public String getSendTime() {        return sendTime;    }    public void setSendTime(String sendTime) {        this.sendTime = sendTime;    }    @Override    public String toString() {        return \"Message [userName=\" + userName + \", sendTime=\" + sendTime + \", content=\" + content + \"]\";    }}\nServlet代码SendMessage.java\npackage com.company.project.servlet;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.company.project.po.Message;@WebServlet(\"/send-message\")public class SendMessage extends HttpServlet {    private static final long serialVersionUID = 1L;    public SendMessage() {        super();        // TODO Auto-generated constructor stub    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // 设置相应内容类型        request.setCharacterEncoding(\"utf-8\");        response.setContentType(\"text/html;charset=utf-8\");        response.setCharacterEncoding(\"utf-8\");        HttpSession session = request.getSession();        String inputText = (String)request.getParameter(\"inputText\");        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式        String sendTime = df.format(new Date());// new Date()为获取当前系统时间        Message message = new Message();        message.setUserName(session.getId());        message.setContent(inputText);        message.setSendTime(sendTime);        ArrayList<Message> messages = (ArrayList<Message>)getServletContext().getAttribute(\"messages\");        if(messages == null) {            messages = new ArrayList<>();            }        messages.add(message);        getServletContext().setAttribute(\"messages\", messages);        response.sendRedirect(\"page/inputFrame.jsp\");    }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        doGet(request, response);    }}\n\n越努力，越幸运 我们亦是拾光者！！！\n\n', 0, 1);
INSERT INTO `t_article` VALUES (162, '09.《JavaEE 学习笔记》Listener监听器', 8, '## 1、6种监听事件类型\n\n- ServletContextEvent **上下文事件**，当应用上下文对象发生改变，如创建或销毁上下文对象时，将触发上下文事件。\n- ServletContextAttributeEvent **上下文属性事件**，当应用上下文的属性改变，如增加、删除、覆盖上下文中的属性时，将触发上下文属性事件。\n- ServletRequestEvent **请求事件**，当请求对象发生改变，如创建或销毁请求对象时，触发请求事件。\n- ServletRequestAttributeEvent **请求属性事件**，当请求中的属性改变，如增加、删除、覆盖请求中的属性时，触发请求属性事件。\n- HttpSessionEvent **会话事件**，当会话对象发生改变，如创建或销毁会话对象，活化或钝化会话对象时，将触发会话事件。\n- HttpSessionBindingEvent **会话绑定事件**，当会话中的属性发生变化时，如增加、删除、覆盖会话中的属性时，将触发会话绑定事件。\n\n## 2、8种监听器接口\n\n- ServletContextListener **上下文监听器**，监听ServletContextEvent事件。\n- ServletContextAttributeListener **上下文属性监听器**，用来监听ServletContextAttribute事件。\n- ServletRequestListener **请求监听器**，监听ServletRequestEvent事件。\n- ServletRequestAttributeListener **请求属性监听器**，用来监听ServletRequestAttributeEvent事件。\n- HttpSessionListener **会话监听器**，监听HttpSessionEvent。\n- HttpSessionActivationListener **会话活化监听器**，监听HttpSessionEvent事件。\n- HttpSessionAttributeListener **会话属性监听器**，监听HttpSessionAttributeEvent事件。\n- HttpSessionBindingListener **会话绑定监听器**，监听HttpSessionAttributeEvent事件。\n\n## 3. 利用监听器把前面的聊天室进行改进\n\n上下文的创建与销毁监听器，记录聊天室的创建和解散\n\n```java\npackage com.company.project.listener;\n\nimport java.util.ArrayList;\n\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.annotation.WebListener;\n\nimport com.company.project.po.Message;\n\n@WebListener\npublic class ServletContextListenerImpl implements ServletContextListener {\n	@Override\n	public void contextDestroyed(ServletContextEvent sce) {\n		ServletContextListener.super.contextDestroyed(sce);\n		System.out.println(\"聊天室已解散\");\n	}\n\n	@Override\n	public void contextInitialized(ServletContextEvent sce) {\n		ServletContextListener.super.contextInitialized(sce);\n		System.out.println(\"聊天室创建成功\");\n		ArrayList<Message> messages = new ArrayList<>();\n		ArrayList<String> userList = new ArrayList<>();\n		sce.getServletContext().setAttribute(\"userList\", userList);\n		sce.getServletContext().setAttribute(\"messages\", messages);\n		\n	}\n}\n```\n\n会话的创建与销毁监听器，记录在线的用户。\n\n```java\npackage com.company.project.listener;\n\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.annotation.WebListener;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\n\nimport com.company.project.po.Message;\n\n@WebListener\npublic class HttpSessionListenerImpl implements HttpSessionListener {\n\n	@Override\n	public void sessionCreated(HttpSessionEvent se) {\n		se.getSession().setMaxInactiveInterval(2);\n		ServletContext servletContext = se.getSession().getServletContext();\n		System.out.println(\"用户加入\");\n		ArrayList<Message> messages = (ArrayList<Message>) servletContext.getAttribute(\"messages\");\n		ArrayList<String> userList = (ArrayList<String>) servletContext.getAttribute(\"userList\");\n		String userId = se.getSession().getId();\n		userList.add(userId);		\n		SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式\n		String sendTime = df.format(new Date());// new Date()为获取当前系统时间	\n		Message message = new Message();\n		message.setUserName(\"系统提示\");\n		message.setContent(\"欢迎\"+userId+\"加入\");\n		message.setSendTime(sendTime);\n		messages.add(message);\n		servletContext.setAttribute(\"userList\", userList);\n		servletContext.setAttribute(\"messages\", messages);	\n	}\n\n	@Override\n	public void sessionDestroyed(HttpSessionEvent se) {\n		ServletContext servletContext = se.getSession().getServletContext();\n		System.out.println(\"用户退出\");\n		ArrayList<Message> messages = (ArrayList<Message>) servletContext.getAttribute(\"messages\");\n		ArrayList<String> userList = (ArrayList<String>) servletContext.getAttribute(\"userList\");\n		String userId = se.getSession().getId();\n		userList.remove(userId);		\n		SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式\n		String sendTime = df.format(new Date());// new Date()为获取当前系统时间	\n		Message message = new Message();\n		message.setUserName(\"系统提示\");\n		message.setContent(\"用户\"+userId+\"已退出聊天室\");\n		message.setSendTime(sendTime);\n		messages.add(message);	\n		servletContext.setAttribute(\"userList\", userList);\n		servletContext.setAttribute(\"messages\", messages);\n	}\n}\n```', 0, 0, '2020-08-07 14:22:28', 2, 0, 1, '1、6种监听事件类型\nServletContextEvent 上下文事件，当应用上下文对象发生改变，如创建或销毁上下文对象时，将触发上下文事件。ServletContextAttributeEvent 上下文属性事件，当应用上下文的属性改变，如增加、删除、覆盖上下文中的属性时，将触发上下文属性事件。ServletRequestEvent 请求事件，当请求对象发生改变，如创建或销毁请求对象时，触发请求事件。ServletRequestAttributeEvent 请求属性事件，当请求中的属性改变，如增加、删除、覆盖请求中的属性时，触发请求属性事件。HttpSessionEvent 会话事件，当会话对象发生改变，如创建或销毁会话对象，活化或钝化会话对象时，将触发会话事件。HttpSessionBindingEvent 会话绑定事件，当会话中的属性发生变化时，如增加、删除、覆盖会话中的属性时，将触发会话绑定事件。\n2、8种监听器接口\nServletContextListener 上下文监听器，监听ServletContextEvent事件。ServletContextAttributeListener 上下文属性监听器，用来监听ServletContextAttribute事件。ServletRequestListener 请求监听器，监听ServletRequestEvent事件。ServletRequestAttributeListener 请求属性监听器，用来监听ServletRequestAttributeEvent事件。HttpSessionListener 会话监听器，监听HttpSessionEvent。HttpSessionActivationListener 会话活化监听器，监听HttpSessionEvent事件。HttpSessionAttributeListener 会话属性监听器，监听HttpSessionAttributeEvent事件。HttpSessionBindingListener 会话绑定监听器，监听HttpSessionAttributeEvent事件。\n3. 利用监听器把前面的聊天室进行改进上下文的创建与销毁监听器，记录聊天室的创建和解散\npackage com.company.project.listener;import java.util.ArrayList;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;import com.company.project.po.Message;@WebListenerpublic class ServletContextListenerImpl implements ServletContextListener {    @Override    public void contextDestroyed(ServletContextEvent sce) {        ServletContextListener.super.contextDestroyed(sce);        System.out.println(\"聊天室已解散\");    }    @Override    public void contextInitialized(ServletContextEvent sce) {        ServletContextListener.super.contextInitialized(sce);        System.out.println(\"聊天室创建成功\");        ArrayList<Message> messages = new ArrayList<>();        ArrayList<String> userList = new ArrayList<>();        sce.getServletContext().setAttribute(\"userList\", userList);        sce.getServletContext().setAttribute(\"messages\", messages);    }}\n会话的创建与销毁监听器，记录在线的用户。\npackage com.company.project.listener;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import javax.servlet.ServletContext;import javax.servlet.annotation.WebListener;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;import com.company.project.po.Message;@WebListenerpublic class HttpSessionListenerImpl implements HttpSessionListener {    @Override    public void sessionCreated(HttpSessionEvent se) {        se.getSession().setMaxInactiveInterval(2);        ServletContext servletContext = se.getSession().getServletContext();        System.out.println(\"用户加入\");        ArrayList<Message> messages = (ArrayList<Message>) servletContext.getAttribute(\"messages\");        ArrayList<String> userList = (ArrayList<String>) servletContext.getAttribute(\"userList\");        String userId = se.getSession().getId();        userList.add(userId);                SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式        String sendTime = df.format(new Date());// new Date()为获取当前系统时间            Message message = new Message();        message.setUserName(\"系统提示\");        message.setContent(\"欢迎\"+userId+\"加入\");        message.setSendTime(sendTime);        messages.add(message);        servletContext.setAttribute(\"userList\", userList);        servletContext.setAttribute(\"messages\", messages);        }    @Override    public void sessionDestroyed(HttpSessionEvent se) {        ServletContext servletContext = se.getSession().getServletContext();        System.out.println(\"用户退出\");        ArrayList<Message> messages = (ArrayList<Message>) servletContext.getAttribute(\"messages\");        ArrayList<String> userList = (ArrayList<String>) servletContext.getAttribute(\"userList\");        String userId = se.getSession().getId();        userList.remove(userId);                SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式        String sendTime = df.format(new Date());// new Date()为获取当前系统时间            Message message = new Message();        message.setUserName(\"系统提示\");        message.setContent(\"用户\"+userId+\"已退出聊天室\");        message.setSendTime(sendTime);        messages.add(message);            servletContext.setAttribute(\"userList\", userList);        servletContext.setAttribute(\"messages\", messages);    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (163, '10.《JavaEE 学习笔记》filter过滤器', 8, '## 1、概念\n\n**过滤器**（filter）是一种代码重用的技术，它可以改变HTTP请求的内容，响应，及Header信息。过滤器通常不产生响应或像Servlet那样对请求作出响应，而是修改或调整到资源的请求，以及来自资源的响应。过滤器可以作用于所有Web资源，即动态或静态内容。\n\n过滤器是指拦截请求，并对传给被请求资源的ServletRequest 或 ServletResponse 进行处理的一个对象。过滤器可以用于登录、加密和解密、会话检查等等。过滤器可以配置为拦截一个或多个资源。如果同一个资源或同一组资源中应用了多个过滤器，则调用顺序有显示显得比较重要，这时候就需要部署描述符(web.xml)来控制其先后顺序。\n\n## 2、Filter 相关的API\n\n### 2.1 Filter接口\n\n方法：\n\n- init(FilterConfig filterConfig) 该方法是对filter对象进行初始化的方法，仅在容器初始化filter对象结束后被调用一次。参数FilterConfig可以获得filter的初始化参数（初始化参数参见下面章节）。\n- doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 该方法是filter进行过滤操作的方法，是最重要的方法。过滤器实现类必须实现该方法。方法体中可以对request和response进行预处理。其中FilterChain可以将处理后的request和response对象传递到过滤链上的下一个资\n- destroy() 该方法在容器销毁过滤器对象前被调用。\n\n### 2.2 FilterChain接口\n\n该接口类型作为Filter接口中doFilter方法的参数使用。\n\n方法：\n\n- doFilter(ServletRequest request,ServletResponse response) 该方法可以将当前的请求和响应传递到过滤链上的下一个资源，可能是下一个过滤器，也可能是目标资源。\n\n### 2.3 FilterConfig接口\n\n该接口类型作为Filter接口中的init方法的参数使用。\n\n**方法**：\n\n- getInitParameter(String name) 该方法用来获得过滤器的初始化参数值。在web.xml中，可以为每一个filter配置需要的初始化参数，与Servlet的类似。过滤器的初始化参数即可通过FilterConfig中的getInitParameter方法获取。\n\n代码案例：\n\n解决中文乱码过滤器：\n\n```java\npackage com.company.project.filter;\n\nimport java.io.IOException;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class CharacterEncodingFilter implements Filter {\n\n	@Override\n	public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain chain)\n			throws IOException, ServletException {\n		System.out.println(\"正在初始化过滤器\");\n		\n		HttpServletRequest request = (HttpServletRequest) arg0;\n		HttpServletResponse response = (HttpServletResponse) arg1;\n		\n		if (request.getRequestURI().contains(\".css\") || request.getRequestURI().contains(\".js\"))\n	    {\n	      chain.doFilter(request, response);\n	    }\n	    else\n	    {\n	    	response.setContentType(\"text/html;charset=utf-8\");\n		response.setCharacterEncoding(\"utf-8\");\n		request.setCharacterEncoding(\"utf-8\");			\n		chain.doFilter(request, response);\n	    }	\n	}\n}\n```\n\n## 3、 XML配置过滤器\n\n**配置项说明**：\n\n```xml\n<filter>中配置项:\n    <filter-name>：过滤器的名称\n    <filter-class>：该过滤器对应的配置类\n    <init-param>：初始化参数\n    <param-name>：参数名称\n    <param-value>：参数值 \n<filter-mapping>中配置项：\n    <filter-name>：过滤器名称，和<filter>中的<filter-name>相同\n    <url-pattern>：过滤器过滤的资源路径\n    <dispatcher>：指定过滤器过滤的资源的调用方式，默认为REQUEST\n```\n\n**dispatcher取值和意义**：\n\n- REQUEST:如果资源的调用方式是RequestDispatcher的forward()或include()，那么该资源路径即使匹配，过滤器也不会起作用\n- FORWARD:调用方式是RequestDispatcher的forward()起作用\n- INCLUDE：调用方式是RequestDispatcher的include()起作用\n- ERROR：如果该资源适配异常处理机制调用，则该过滤器起作用\n\n```xml\n  <!-- 配置过滤器对象名称,过滤器类的路径,初始化参数 -->\n  <filter>\n  	<filter-name>characterFilter</filter-name>\n  	<filter-class>com.company.project.filter.CharacterEncodingFilter</filter-class>\n  	<init-param>\n  		<param-name>author</param-name>\n  		<param-value>86_god</param-value>\n  	</init-param>\n  \n  </filter>\n  \n  <!-- 配置过滤器处理的作用域和类型  -->\n  <filter-mapping>\n  	<filter-name>characterFilter</filter-name>\n  	<url-pattern>*</url-pattern>\n  	<dispatcher>REQUEST</dispatcher>\n  </filter-mapping>\n```\n\n获取过滤器初始化参数：\n\n```java\npackage com.company.project.filter;\n\nimport java.io.IOException;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class CharacterEncodingFilter implements Filter {\n	private String author;\n	\n	@Override\n	public void init(FilterConfig filterConfig) throws ServletException {\n		Filter.super.init(filterConfig);		\n		//获取初始化参数,使用filterConfig.getInitParameter(\"filter-name\")方法获取\n		this.author = filterConfig.getInitParameter(\"author\");\n		System.out.println(\"author:\"+this.author);\n	}\n}\n```\n\n## 4. 网页错误处理页面\n\n我们的web通常404，500等错误，可能会暴露我们的源码，这是我们不希望让用户看见的，我们可以利用web.xml中配置错误页面来捕捉和处理这种错误页面，让用户看见和谐的页面。\n\n![img](https://pic4.zhimg.com/v2-b99911c2112723b760a5b1dc7513a913_b.png)\n\n![img](https://pic3.zhimg.com/v2-f9b15f7ce3641d5158d1b0ec2c41ef5a_b.png)\n\n处理方案：\n\n在web.xml文件中配置错误页面，在<web-app></web-app>中间加上如下代码。还需要在location相关的页面的前面加上指令元素<%@page{iserrorPage=\"true\"}  %>\n\n```xml\n  <error-page>\n  <!--exception-type是异常的类型  -->\n  <!--location是遇到异常应该显示的页面  -->\n    <exception-type>java.lang.Exception</exception-type>\n    <location>/error.jsp</location>\n  </error-page>\n  <error-page>\n    <!--error-code是网页异常的代号编码  -->\n    <error-code>404</error-code>\n    <location>/404.jsp</location>\n  </error-page>\n  <error-page>\n    <error-code>500</error-code>\n    <location>/500.jsp</location>\n  </error-page>\n```\n\n**每日心语：**\n\n> 山有山的高度，水有水的深度，没必要攀比，每个人都有自己的长处；风有风的自由，云有云的温柔，没必要模仿，每个人都有自己的个性。你认为快乐的，就去寻找；你认为值得的，就去守候；你认为幸福的，就去珍惜。没有不被评说的事，没有不被猜测的人。做最真实的自己，依心而行，无憾今生。', 0, 0, '2020-08-07 14:22:53', 2, 0, 1, '1、概念过滤器（filter）是一种代码重用的技术，它可以改变HTTP请求的内容，响应，及Header信息。过滤器通常不产生响应或像Servlet那样对请求作出响应，而是修改或调整到资源的请求，以及来自资源的响应。过滤器可以作用于所有Web资源，即动态或静态内容。\n过滤器是指拦截请求，并对传给被请求资源的ServletRequest 或 ServletResponse 进行处理的一个对象。过滤器可以用于登录、加密和解密、会话检查等等。过滤器可以配置为拦截一个或多个资源。如果同一个资源或同一组资源中应用了多个过滤器，则调用顺序有显示显得比较重要，这时候就需要部署描述符(web.xml)来控制其先后顺序。\n2、Filter 相关的API2.1 Filter接口方法：\n\ninit(FilterConfig filterConfig) 该方法是对filter对象进行初始化的方法，仅在容器初始化filter对象结束后被调用一次。参数FilterConfig可以获得filter的初始化参数（初始化参数参见下面章节）。doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 该方法是filter进行过滤操作的方法，是最重要的方法。过滤器实现类必须实现该方法。方法体中可以对request和response进行预处理。其中FilterChain可以将处理后的request和response对象传递到过滤链上的下一个资destroy() 该方法在容器销毁过滤器对象前被调用。\n2.2 FilterChain接口该接口类型作为Filter接口中doFilter方法的参数使用。\n方法：\n\ndoFilter(ServletRequest request,ServletResponse response) 该方法可以将当前的请求和响应传递到过滤链上的下一个资源，可能是下一个过滤器，也可能是目标资源。\n2.3 FilterConfig接口该接口类型作为Filter接口中的init方法的参数使用。\n方法：\n\ngetInitParameter(String name) 该方法用来获得过滤器的初始化参数值。在web.xml中，可以为每一个filter配置需要的初始化参数，与Servlet的类似。过滤器的初始化参数即可通过FilterConfig中的getInitParameter方法获取。\n代码案例：\n解决中文乱码过滤器：\npackage com.company.project.filter;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class CharacterEncodingFilter implements Filter {    @Override    public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain chain)            throws IOException, ServletException {        System.out.println(\"正在初始化过滤器\");        HttpServletRequest request = (HttpServletRequest) arg0;        HttpServletResponse response = (HttpServletResponse) arg1;        if (request.getRequestURI().contains(\".css\") || request.getRequestURI().contains(\".js\"))        {          chain.doFilter(request, response);        }        else        {            response.setContentType(\"text/html;charset=utf-8\");        response.setCharacterEncoding(\"utf-8\");        request.setCharacterEncoding(\"utf-8\");                    chain.doFilter(request, response);        }        }}\n3、 XML配置过滤器配置项说明：\n<filter>中配置项:    <filter-name>：过滤器的名称    <filter-class>：该过滤器对应的配置类    <init-param>：初始化参数    <param-name>：参数名称    <param-value>：参数值 <filter-mapping>中配置项：    <filter-name>：过滤器名称，和<filter>中的<filter-name>相同    <url-pattern>：过滤器过滤的资源路径    <dispatcher>：指定过滤器过滤的资源的调用方式，默认为REQUEST\ndispatcher取值和意义：\n\nREQUEST:如果资源的调用方式是RequestDispatcher的forward()或include()，那么该资源路径即使匹配，过滤器也不会起作用FORWARD:调用方式是RequestDispatcher的forward()起作用INCLUDE：调用方式是RequestDispatcher的include()起作用ERROR：如果该资源适配异常处理机制调用，则该过滤器起作用\n  <!-- 配置过滤器对象名称,过滤器类的路径,初始化参数 -->  <filter>      <filter-name>characterFilter</filter-name>      <filter-class>com.company.project.filter.CharacterEncodingFilter</filter-class>      <init-param>          <param-name>author</param-name>          <param-value>86_god</param-value>      </init-param>  </filter>  <!-- 配置过滤器处理的作用域和类型  -->  <filter-mapping>      <filter-name>characterFilter</filter-name>      <url-pattern>*</url-pattern>      <dispatcher>REQUEST</dispatcher>  </filter-mapping>\n获取过滤器初始化参数：\npackage com.company.project.filter;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class CharacterEncodingFilter implements Filter {    private String author;    @Override    public void init(FilterConfig filterConfig) throws ServletException {        Filter.super.init(filterConfig);                //获取初始化参数,使用filterConfig.getInitParameter(\"filter-name\")方法获取        this.author = filterConfig.getInitParameter(\"author\");        System.out.println(\"author:\"+this.author);    }}\n4. 网页错误处理页面我们的web通常404，500等错误，可能会暴露我们的源码，这是我们不希望让用户看见的，我们可以利用web.xml中配置错误页面来捕捉和处理这种错误页面，让用户看见和谐的页面。\n\n\n处理方案：\n在web.xml文件中配置错误页面，在<web-app></web-app>中间加上如下代码。还需要在location相关的页面的前面加上指令元素<%@page{iserrorPage=”true”}  %>\n  <error-page>  <!--exception-type是异常的类型  -->  <!--location是遇到异常应该显示的页面  -->    <exception-type>java.lang.Exception</exception-type>    <location>/error.jsp</location>  </error-page>  <error-page>    <!--error-code是网页异常的代号编码  -->    <error-code>404</error-code>    <location>/404.jsp</location>  </error-page>  <error-page>    <error-code>500</error-code>    <location>/500.jsp</location>  </error-page>\n每日心语：\n\n山有山的高度，水有水的深度，没必要攀比，每个人都有自己的长处；风有风的自由，云有云的温柔，没必要模仿，每个人都有自己的个性。你认为快乐的，就去寻找；你认为值得的，就去守候；你认为幸福的，就去珍惜。没有不被评说的事，没有不被猜测的人。做最真实的自己，依心而行，无憾今生。\n\n', 0, 1);
INSERT INTO `t_article` VALUES (164, '11.《JavaEE 学习笔记》JSP组成元素', 8, '## JSP 的组成元素：\n\nJSP页面就是带有JSP元素的常规Web页面，它由静态内容和动态内容构成。其中，静态内容指HTML元素，动态内容（JSP元素）包括指令元素、脚本元素、动作元素、注释等内容。\n\n## 1、指令元素\n\n指令元素主要用于为转换阶段提供JSP页面的相关信息，指令不会产生任何输出到当前的输出流中，它指定了有关页面本身的信息，这些信息在请求之间一直保持不变。指令元素语法为<%@ directive{attr=\"value\"}%>。指令元素有三种：page、include、taglib。\n\n### 1.1 page\n\n该指令用于整个页面，定义与页面相关的属性，它是JSP页面和容器的通信员，一般放在JSP页面的第一行。与page相关的属性如下：\n\n- buffer\n- 指定out对象使用缓冲区的大小\n- autoFlush\n- 控制out对象的 缓存区\n- contentType\n- 指定当前JSP页面的MIME类型和字符编码\n- errorPage\n- 指定当JSP页面发生异常时需要转向的错误处理页面\n- isErrorPage\n- 指定当前页面是否可以作为另一个JSP页面的错误处理页面\n- extends\n- 指定servlet从哪一个类继承\n- import\n- 导入要使用的Java类\n- info\n- 定义JSP页面的描述信息\n- isThreadSafe\n- 指定对JSP页面的访问是否为线程安全\n- language\n- 定义JSP页面所用的脚本语言，默认是Java\n- session\n- 指定JSP页面是否使用session\n- isELIgnored\n- 指定是否执行EL表达式\n- isScriptingEnabled\n- 确定脚本元素能否被使用\n\n**（1）page指令属性：import**\n\nimport属性用来引入JSP文件需要使用的类。\n\n```jsp\n<%@page import=\"com.company.project.model.po.BookPo\"%>\n<%@page import=\"com.company.project.biz.impl.BooksBizImpl\"%>\n```\n\n可以使用逗号同时引入多个包，也可以在一个JSP文件中多次使用import。\n\n**（2）page指令属性：pageEncoding**\n\npageEncoding属性用来设置JSP文件的页面编码格式。\n\n```jsp\n<%@page pageEncoding=“utf-8\"%>\n```\n\n**（3）page指令属性：session**\n\nsession属性用来设置JSP页面是否生成session对象。\n\n```jsp\n<%@page session=\"false\"%>\n```\n\n**（4）page指令属性：errorPage**\n\nerrorPage属性设置JSP页面的错误页面。当JSP中发生异常或错误却没有被处理时，容器将请求转发到错误页面.\n\n```jsp\n<%@page errorPage=\"error.jsp\"%>\n```\n\n**（5）page指令属性： isErrorPage**\n\nisErrorPage属性指定当前页面是否可以作为另一个JSP页面的错误处理页面.\n\n```jsp\n<%@page isErrorPage=\"true\"%>\n```\n\n在error.jsp翻译生成的Java类中的_jspService方法中将生成exception内置对象\n\n注意：即使一个页面没有设置isErrorPage=“true”，也可以作为错误页面使用，区别在是否有内置对象exception内置对象产生。\n\n### 1.2 **include**\n\n​        该指令用于在JSP页面中包含一个文件，该文件可以是JSP页面、HTML网页、文本文件或一段Java代码。\n\n​            <%@ include file=\"相对于当前文件的\" %>\n\n```jsp\n<%@include file=\"/page/common/basePath.jsp\" %>\n```\n\n### 1.3 **taglib**\n\n​        该指令允许页面使用用户定制的标签。\n\n​            <%@taglib prefix=\"前缀\" uri=\"具有唯一标识和前缀相关的标签描述符地址\" %>\n\n## 2. JSP 内置对象\n\nJSP文件中可以直接使用一些名字固定的对象，称为内置对象。内置对象由容器根据规范声明、创建，共有9个内置对象。其中exception对象在特定情况会创建。\n\n（1）内置对象request\n\nrequest是HttpServletRequest类型的对象，可以在JSP中直接通过request调用HttpServletRequest接口中的任何方法。\n\n（2）内置对象response\n\nresponse是HttpServletResponse类型的对象，可以在JSP中直接通过response调用HttpServletResponse接口中的任何方法。\n\n（3）内置对象session\n\nsession是HttpSession类型的对象，可以在JSP中通过session调用HttpSession接口中的任何方法\n\n（4）内置对象application\n\napplicaton是ServletContext类型的对象，可以在JSP中通过application调用ServletContext接口中的任何方法。\n\n（5）内置对象out\n\nout是JspWriter类型的对象，可以在JSP中调用JspWriter的方法向客户端输出内容。然而，由于<%=%>可以更为便捷地进行输出，因此在JSP文件中往往不使用out对象进行输出。\n\n（6）内置对象config\n\nconfig是ServletConfig类型的对象，在JSP中可以使用config来调用ServletConfig接口中的任何方法。在web.xml中可以像配置Servlet那样配置JSP。使用配置的url-pattern访问JSP。\n\n（7）内置对象exception\n\nexception是一个Throwable类型的对象，默认情况下不会生成这个内置对象，当JSP页面被指令<%@page isErrorPage=“true”%>指定为可以是错误页面时，才会有exception这个内置对象。\n\n（8）内置对象page\n\npage指代当前类的对象，即this。\n\n（9）内置对象pageContext\n\npageContext是所有内置对象中最重要的内置对象，是JSP的上下文对象。\n\npageContext是javax.servlet.jsp.PageContext类的对象。\n\n很多内置对象通过pageContext对象获取。\n\n## 3、**脚本元素**\n\n​    使用JSP脚本元素可以将Java代码嵌入到JSP页面里，这些Java代码将出现在由当前JSP页面生成的Servelt中，使JSP将静态内容与动态内容分离出来。脚本元素包含表达式、脚本和声明等。    **1）表达式**\n\n​        表达式是对数据的表示，系统将其作为一个值进行计算。\n\n```jsp\n<%= expression%>\n```\n\n​        例如<%= user.getName()%>在将JSP转换成Servlet后，使用out.print()将表达式的值输出。所以如果表达式是调用一个方法的话，那方法必须要有返回值，而且在方法的后面不能有分号。\n\n​     **2）脚本**        脚本是在<% ... %>里嵌入的Java代码，这里的Java代码与一般的Java代码没有什么区别，所以每一条语句同样要以分号“；”结束，这和表达式是不同的。\n\n```jsp\n<%  code  %>\n```\n\n   **3）声明**\n\n​        声明就是允许用户定义Servlet中的变量、方法。\n\n```jsp\n<%! code %>\n```\n\n**4、注释**\n\n（1）<!--...-->：HTML的注释。在客户端查看源代码时能看到的注释\n\n（2）<%-- ... --%>：JSP注释。在客户端查看源代码时无法看到的注释。\n\n（3）JSP脚本中注释：在客户端查看源代码时能看到的注释               <% //单行注释 %>               <% /*多行注释 */ %>\n\n## 5、JSP标准动作\n\n**（1）标准动作:forward**\n\nforward动作：在JSP页面中进行请求转发\n\n```jsp\n<jsp:forward page=“loginsuccess.jsp\">\n</jsp:forward>\n```\n\n**（2）标准动作：include**\n\ninclude动作：在JSP页面中，进行动态包含\n\n```jsp\n<jsp:include page=“top.jsp\">\n</jsp:include>\n```\n\ninclude标准动作与include指令都是实现包含其他页面的功能，但是include标准动作的属性是page，实现动态包含，发生在请求阶段；而include指令的属性是file，实现静态包含，发生在翻译阶段。\n\n**（3）标准动作：param**\n\nparam动作往往作为子动作使用，为forward和include动作传递参数\n\n```jsp\n<jsp:forward page=\"perInfo.jsp\">\n 	<jsp:param name=\"userName\" value=\"张三\"/>\n </jsp:forward>\n<jsp:include page=\"changePw.jsp\"> 	\n  <jsp:param name=\"userName\" value=\"张三\"/>\n</jsp:include>\n```\n\n## 6、JavaBean\n\nJavaBean是用Java语言描述的软件组件模型，实际上是一个Java SE的类。\n\n我们往往使用JavaBean封装数据，在比较简单的应用中，也可以使用JavaBean封装业务逻辑，这些类遵循一定的编码规范：\n\n- 必须是public类 ；\n- 必须有一个无参的public的构造方法；\n- 返回属性的方法为getXxxx()格式 ；\n- 设置属性的方法为setXxx(形式参数)格式。\n\n### JavaBean相关标准动作：\n\n（1）useBean\n\n语法：<jsp:useBean id=“” class=“” scope=“”>\n\nuseBean标准动作用来使用JavaBean对象，JavaBean对象是某一范围（用scope指定）的属性。 Java Bean对象名字用id指定，类型用class指定。如果对应范围没有该属性，则调用class指定类的无参构造方法，创建一个该类的对象，并将该对象存储为scope的一个属性，属性名为id。 其中scope有四种：page、request、session、application，分别为PageContext范围、HttpServletRequest范围、HttpSession范围、ServletContext范围。如果不指定scope的值，默认为page范围。\n\n```jsp\n<jsp:useBean id=\"firend\" class=\"com.company.project.model.po.UserPo\" scope=\"\">\n```\n\n（2）setProperty\n\n语法：<jsp:setProperty name=“” property=“” param|value=“”/>\n\n```jsp\n<jsp:setUserName name=\"firend\" property=\"userName\" value=\"张三\"/>\n```\n\n（3）getProperty\n\n语法：<jsp:getProperty name=”” property=””/>\n\n```jsp\n<jsp:getProperty name=\"firend\" property=\"userName\"/>\n```\n\n**每日心语：**\n\n> 要得到必须要付出 要付出你还要学会坚持 如果你觉得真的很难 那你就放弃 但放弃你就不要抱怨', 0, 0, '2020-08-07 14:23:19', 2, 0, 1, 'JSP 的组成元素：JSP页面就是带有JSP元素的常规Web页面，它由静态内容和动态内容构成。其中，静态内容指HTML元素，动态内容（JSP元素）包括指令元素、脚本元素、动作元素、注释等内容。\n1、指令元素指令元素主要用于为转换阶段提供JSP页面的相关信息，指令不会产生任何输出到当前的输出流中，它指定了有关页面本身的信息，这些信息在请求之间一直保持不变。指令元素语法为<%@ directive{attr=”value”}%>。指令元素有三种：page、include、taglib。\n1.1 page该指令用于整个页面，定义与页面相关的属性，它是JSP页面和容器的通信员，一般放在JSP页面的第一行。与page相关的属性如下：\n\nbuffer指定out对象使用缓冲区的大小autoFlush控制out对象的 缓存区contentType指定当前JSP页面的MIME类型和字符编码errorPage指定当JSP页面发生异常时需要转向的错误处理页面isErrorPage指定当前页面是否可以作为另一个JSP页面的错误处理页面extends指定servlet从哪一个类继承import导入要使用的Java类info定义JSP页面的描述信息isThreadSafe指定对JSP页面的访问是否为线程安全language定义JSP页面所用的脚本语言，默认是Javasession指定JSP页面是否使用sessionisELIgnored指定是否执行EL表达式isScriptingEnabled确定脚本元素能否被使用\n（1）page指令属性：import\nimport属性用来引入JSP文件需要使用的类。\n<%@page import=\"com.company.project.model.po.BookPo\"%><%@page import=\"com.company.project.biz.impl.BooksBizImpl\"%>\n可以使用逗号同时引入多个包，也可以在一个JSP文件中多次使用import。\n（2）page指令属性：pageEncoding\npageEncoding属性用来设置JSP文件的页面编码格式。\n<%@page pageEncoding=“utf-8\"%>\n（3）page指令属性：session\nsession属性用来设置JSP页面是否生成session对象。\n<%@page session=\"false\"%>\n（4）page指令属性：errorPage\nerrorPage属性设置JSP页面的错误页面。当JSP中发生异常或错误却没有被处理时，容器将请求转发到错误页面.\n<%@page errorPage=\"error.jsp\"%>\n（5）page指令属性： isErrorPage\nisErrorPage属性指定当前页面是否可以作为另一个JSP页面的错误处理页面.\n<%@page isErrorPage=\"true\"%>\n在error.jsp翻译生成的Java类中的_jspService方法中将生成exception内置对象\n注意：即使一个页面没有设置isErrorPage=“true”，也可以作为错误页面使用，区别在是否有内置对象exception内置对象产生。\n1.2 include​        该指令用于在JSP页面中包含一个文件，该文件可以是JSP页面、HTML网页、文本文件或一段Java代码。\n​            <%@ include file=”相对于当前文件的” %>\n<%@include file=\"/page/common/basePath.jsp\" %>\n1.3 taglib​        该指令允许页面使用用户定制的标签。\n​            <%@taglib prefix=”前缀” uri=”具有唯一标识和前缀相关的标签描述符地址” %>\n2. JSP 内置对象JSP文件中可以直接使用一些名字固定的对象，称为内置对象。内置对象由容器根据规范声明、创建，共有9个内置对象。其中exception对象在特定情况会创建。\n（1）内置对象request\nrequest是HttpServletRequest类型的对象，可以在JSP中直接通过request调用HttpServletRequest接口中的任何方法。\n（2）内置对象response\nresponse是HttpServletResponse类型的对象，可以在JSP中直接通过response调用HttpServletResponse接口中的任何方法。\n（3）内置对象session\nsession是HttpSession类型的对象，可以在JSP中通过session调用HttpSession接口中的任何方法\n（4）内置对象application\napplicaton是ServletContext类型的对象，可以在JSP中通过application调用ServletContext接口中的任何方法。\n（5）内置对象out\nout是JspWriter类型的对象，可以在JSP中调用JspWriter的方法向客户端输出内容。然而，由于<%=%>可以更为便捷地进行输出，因此在JSP文件中往往不使用out对象进行输出。\n（6）内置对象config\nconfig是ServletConfig类型的对象，在JSP中可以使用config来调用ServletConfig接口中的任何方法。在web.xml中可以像配置Servlet那样配置JSP。使用配置的url-pattern访问JSP。\n（7）内置对象exception\nexception是一个Throwable类型的对象，默认情况下不会生成这个内置对象，当JSP页面被指令<%@page isErrorPage=“true”%>指定为可以是错误页面时，才会有exception这个内置对象。\n（8）内置对象page\npage指代当前类的对象，即this。\n（9）内置对象pageContext\npageContext是所有内置对象中最重要的内置对象，是JSP的上下文对象。\npageContext是javax.servlet.jsp.PageContext类的对象。\n很多内置对象通过pageContext对象获取。\n3、脚本元素​    使用JSP脚本元素可以将Java代码嵌入到JSP页面里，这些Java代码将出现在由当前JSP页面生成的Servelt中，使JSP将静态内容与动态内容分离出来。脚本元素包含表达式、脚本和声明等。    1）表达式\n​        表达式是对数据的表示，系统将其作为一个值进行计算。\n<%= expression%>\n​        例如<%= user.getName()%>在将JSP转换成Servlet后，使用out.print()将表达式的值输出。所以如果表达式是调用一个方法的话，那方法必须要有返回值，而且在方法的后面不能有分号。\n​     2）脚本        脚本是在<% … %>里嵌入的Java代码，这里的Java代码与一般的Java代码没有什么区别，所以每一条语句同样要以分号“；”结束，这和表达式是不同的。\n<%  code  %>\n   3）声明\n​        声明就是允许用户定义Servlet中的变量、方法。\n<%! code %>\n4、注释\n（1）<!--...-->：HTML的注释。在客户端查看源代码时能看到的注释\n（2）<%— … —%>：JSP注释。在客户端查看源代码时无法看到的注释。\n（3）JSP脚本中注释：在客户端查看源代码时能看到的注释               <% //单行注释 %>               <% /多行注释 / %>\n5、JSP标准动作（1）标准动作:forward\nforward动作：在JSP页面中进行请求转发\n<jsp:forward page=“loginsuccess.jsp\"></jsp:forward>\n（2）标准动作：include\ninclude动作：在JSP页面中，进行动态包含\n<jsp:include page=“top.jsp\"></jsp:include>\ninclude标准动作与include指令都是实现包含其他页面的功能，但是include标准动作的属性是page，实现动态包含，发生在请求阶段；而include指令的属性是file，实现静态包含，发生在翻译阶段。\n（3）标准动作：param\nparam动作往往作为子动作使用，为forward和include动作传递参数\n<jsp:forward page=\"perInfo.jsp\">     <jsp:param name=\"userName\" value=\"张三\"/> </jsp:forward><jsp:include page=\"changePw.jsp\">       <jsp:param name=\"userName\" value=\"张三\"/></jsp:include>\n6、JavaBeanJavaBean是用Java语言描述的软件组件模型，实际上是一个Java SE的类。\n我们往往使用JavaBean封装数据，在比较简单的应用中，也可以使用JavaBean封装业务逻辑，这些类遵循一定的编码规范：\n\n必须是public类 ；必须有一个无参的public的构造方法；返回属性的方法为getXxxx()格式 ；设置属性的方法为setXxx(形式参数)格式。\nJavaBean相关标准动作：（1）useBean\n语法：<jsp:useBean id=“” class=“” scope=“”>\nuseBean标准动作用来使用JavaBean对象，JavaBean对象是某一范围（用scope指定）的属性。 Java Bean对象名字用id指定，类型用class指定。如果对应范围没有该属性，则调用class指定类的无参构造方法，创建一个该类的对象，并将该对象存储为scope的一个属性，属性名为id。 其中scope有四种：page、request、session、application，分别为PageContext范围、HttpServletRequest范围、HttpSession范围、ServletContext范围。如果不指定scope的值，默认为page范围。\n<jsp:useBean id=\"firend\" class=\"com.company.project.model.po.UserPo\" scope=\"\">\n（2）setProperty\n语法：<jsp:setProperty name=“” property=“” param|value=“”/>\n<jsp:setUserName name=\"firend\" property=\"userName\" value=\"张三\"/>\n（3）getProperty\n语法：<jsp:getProperty name=”” property=””/>\n<jsp:getProperty name=\"firend\" property=\"userName\"/>\n每日心语：\n\n要得到必须要付出 要付出你还要学会坚持 如果你觉得真的很难 那你就放弃 但放弃你就不要抱怨\n\n', 0, 1);
INSERT INTO `t_article` VALUES (165, '12.《JavaEE 学习笔记》自定义标签库', 8, '> 参考链接：https://blog.csdn.net/goldentec/article/details/105349954\n\n## 1、定义\n\n自定义标签是用户定义的JSP语言元素。当JSP页面包含一个自定义标签时将被转化为servlet，标签转化为对被 称为tag handler的对象的操作，即当servlet执行时Web container调用那些操作。\n\nJSP标签扩展可以让你创建新的标签并且可以直接插入到一个JSP页面。\n\n**标记库**（Tag Library）通过定义一种专门化子语言来抽象JSP页面中使用的功能，并支持在JSP页面中更自然地反复使用它。\n\n- 标记库通过**标记库描述符**(Tag Library Descriptor，TLD)来定义功能的抽象语义，它其实是一个XML文档。\n- 标记库通过**标记处理类**来定义功能的操作语义，并在运行时根据抽象语义由JSP页面将其实例化。\n\n## 2、标记的组成\n\n自定义标记由两部分组成：\n\n- *.tld文件：是一个XML文件，用来定义标记名称、属性、标记处理类、标记体等。\n- *.class文件：每一个标记，都对应一个标记处理器类，这个类遵守一定规范，即需要继承或实现API中的特定类或接口，覆盖其中方法。也是自定义标记的主要工作。\n\n可见，自定义标记的功能依然还是用Java类实现的，不过是Java代码不再写在JSP中，而是用独立的Java类实现，并使用标记调用它，以便达到复用性。\n\n## 3、 创建自定义标签\n\n### 3.1 创建tld文件\n\n在WEB-INF目录下创建taglib.tld文件，该文件的格式可以查找相关模板进行修改。\n\n代码案例：创建user标签，将用户名和手机号写入会话当中。\n\ntaglib.tld文件：\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE taglib\n        PUBLIC \"-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN\"        \n        \"http://java.sun.com/j2ee/dtds/web-jsptaglibrary_1_2.dtd\">\n\n\n<taglib>\n	<tlib-version>1.0</tlib-version>\n	<jsp-version>2.1</jsp-version>\n	\n	<short-name>t</short-name>\n	\n	<uri>http://www.company.com/tablib</uri>\n	<description>这是我的第一个标记库</description>\n	\n	\n	<tag>\n		<name>user</name>\n		<tag-class>com.company.taglib.UserHandler</tag-class>\n		<body-content>empty</body-content>\n		\n		<attribute>\n			<name>userName</name>\n			<required>true</required>\n			<rtexprvalue>true</rtexprvalue>\n		</attribute>\n		\n		<attribute>\n			<name>phoneNum</name>\n			<required>true</required>\n			<rtexprvalue>true</rtexprvalue>\n		</attribute>	\n	</tag>\n	\n	<tag>\n		<name>printUser</name>\n		<tag-class>com.company.taglib.PrintUser</tag-class>\n		<body-content>empty</body-content>\n		\n	</tag>\n\n</taglib>\n```\n\n**tld文件解析**：\n\nuri:是这个tld文件的唯一标记，可以自定义，不一定是真实存在的URL。使用自定义标记时将根据该值寻找tld文件。 tag：tld文件中将定义多个tag元素，描述多个标签。\n\n- name:标签的名字\n- tag-class:实现该标签功能的类，是之后主要的工作\n- attribute:标签的属性，可以定义多个\n- name:属性名字\n- required:属性是否必须，true为必须\n- rtexprvalue：属性是否能使用运行期表达式传值，true表示必须\n\n### 3.2 创建标记处理类\n\n本章的标签处理器类使用继承TagSupport类实现，覆盖其中的doStartTag方法。\n\n标签处理器类首先必须声明与tld文件中对tag定义的属性对应的属性变量，例如，本例中的处理器类必须声明 attr，并提供setXXX方法，容器在运行时将自动调用setXXX方法赋值。\n\nUserHandler.java代码：\n\n```java\npackage com.company.taglib;\n\nimport javax.servlet.http.HttpSession;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.tagext.TagSupport;\n\npublic class UserHandler extends TagSupport {\n	private String userName;\n	private long phoneNum;\n	\n	@Override\n	public int doStartTag() throws JspException {\n		HttpSession session = pageContext.getSession();\n		session.setAttribute(\"userName\", userName);\n		session.setAttribute(\"phoneNum\", phoneNum);\n		\n		return super.doStartTag();\n	}\n\n	public String getUserName() {\n		return userName;\n	}\n\n	public long getPhoneNum() {\n		return phoneNum;\n	}\n\n	public void setUserName(String userName) {\n		this.userName = userName;\n	}\n\n	public void setPhoneNum(long phoneNum) {\n		this.phoneNum = phoneNum;\n	}	\n}\n```\n\nPrintUser.java代码：\n\n```java\npackage com.company.taglib;\n\nimport java.io.IOException;\n\nimport javax.servlet.http.HttpSession;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspWriter;\nimport javax.servlet.jsp.tagext.TagSupport;\n\npublic class PrintUser extends TagSupport{\n	private String userName;\n	private long phoneNum;\n	\n	@Override\n	public int doStartTag() throws JspException {\n		HttpSession session = pageContext.getSession();\n		this.userName = (String) session.getAttribute(\"userName\");\n		this.phoneNum = (long) session.getAttribute(\"phoneNum\");\n		JspWriter out = pageContext.getOut();\n		try {\n			out.println(\"userName:\"+userName);\n			out.println(\"phoneNum:\"+phoneNum);\n		} catch (IOException e) {\n			// TODO Auto-generated catch block\n			e.printStackTrace();\n		}	\n		return super.doStartTag();\n	}\n\n	public String getUserName() {\n		return userName;\n	}\n\n	public long getPhoneNum() {\n		return phoneNum;\n	}\n\n	public void setUserName(String userName) {\n		this.userName = userName;\n	}\n\n	public void setPhoneNum(long phoneNum) {\n		this.phoneNum = phoneNum;\n	}\n}\n```\n\n### 3.3 Jsp中使用自定义标签\n\n测试类：test1.jsp\n\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n    \n<%@taglib uri=\"http://www.company.com/tablib\" prefix=\"t\" %>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n<t:user phoneNum=\"86_god\" userName=\"15592233822\"/>\n<t:printUser/>\n</body>\n</html>\n```\n\n**每日心语：**\n\n> 有毒的草，开迷人的花 害你的人，说你爱听的话 在这个无比现实残酷的世界里 人与人之间 什么人说什么话', 0, 0, '2020-08-07 14:23:46', 2, 0, 1, '\n参考链接：https://blog.csdn.net/goldentec/article/details/105349954\n\n1、定义自定义标签是用户定义的JSP语言元素。当JSP页面包含一个自定义标签时将被转化为servlet，标签转化为对被 称为tag handler的对象的操作，即当servlet执行时Web container调用那些操作。\nJSP标签扩展可以让你创建新的标签并且可以直接插入到一个JSP页面。\n标记库（Tag Library）通过定义一种专门化子语言来抽象JSP页面中使用的功能，并支持在JSP页面中更自然地反复使用它。\n\n标记库通过标记库描述符(Tag Library Descriptor，TLD)来定义功能的抽象语义，它其实是一个XML文档。标记库通过标记处理类来定义功能的操作语义，并在运行时根据抽象语义由JSP页面将其实例化。\n2、标记的组成自定义标记由两部分组成：\n\n*.tld文件：是一个XML文件，用来定义标记名称、属性、标记处理类、标记体等。*.class文件：每一个标记，都对应一个标记处理器类，这个类遵守一定规范，即需要继承或实现API中的特定类或接口，覆盖其中方法。也是自定义标记的主要工作。\n可见，自定义标记的功能依然还是用Java类实现的，不过是Java代码不再写在JSP中，而是用独立的Java类实现，并使用标记调用它，以便达到复用性。\n3、 创建自定义标签3.1 创建tld文件在WEB-INF目录下创建taglib.tld文件，该文件的格式可以查找相关模板进行修改。\n代码案例：创建user标签，将用户名和手机号写入会话当中。\ntaglib.tld文件：\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?><!DOCTYPE taglib        PUBLIC \"-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN\"                \"http://java.sun.com/j2ee/dtds/web-jsptaglibrary_1_2.dtd\"><taglib>    <tlib-version>1.0</tlib-version>    <jsp-version>2.1</jsp-version>    <short-name>t</short-name>    <uri>http://www.company.com/tablib</uri>    <description>这是我的第一个标记库</description>    <tag>        <name>user</name>        <tag-class>com.company.taglib.UserHandler</tag-class>        <body-content>empty</body-content>        <attribute>            <name>userName</name>            <required>true</required>            <rtexprvalue>true</rtexprvalue>        </attribute>        <attribute>            <name>phoneNum</name>            <required>true</required>            <rtexprvalue>true</rtexprvalue>        </attribute>        </tag>    <tag>        <name>printUser</name>        <tag-class>com.company.taglib.PrintUser</tag-class>        <body-content>empty</body-content>    </tag></taglib>\ntld文件解析：\nuri:是这个tld文件的唯一标记，可以自定义，不一定是真实存在的URL。使用自定义标记时将根据该值寻找tld文件。 tag：tld文件中将定义多个tag元素，描述多个标签。\n\nname:标签的名字tag-class:实现该标签功能的类，是之后主要的工作attribute:标签的属性，可以定义多个name:属性名字required:属性是否必须，true为必须rtexprvalue：属性是否能使用运行期表达式传值，true表示必须\n3.2 创建标记处理类本章的标签处理器类使用继承TagSupport类实现，覆盖其中的doStartTag方法。\n标签处理器类首先必须声明与tld文件中对tag定义的属性对应的属性变量，例如，本例中的处理器类必须声明 attr，并提供setXXX方法，容器在运行时将自动调用setXXX方法赋值。\nUserHandler.java代码：\npackage com.company.taglib;import javax.servlet.http.HttpSession;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.TagSupport;public class UserHandler extends TagSupport {    private String userName;    private long phoneNum;    @Override    public int doStartTag() throws JspException {        HttpSession session = pageContext.getSession();        session.setAttribute(\"userName\", userName);        session.setAttribute(\"phoneNum\", phoneNum);        return super.doStartTag();    }    public String getUserName() {        return userName;    }    public long getPhoneNum() {        return phoneNum;    }    public void setUserName(String userName) {        this.userName = userName;    }    public void setPhoneNum(long phoneNum) {        this.phoneNum = phoneNum;    }    }\nPrintUser.java代码：\npackage com.company.taglib;import java.io.IOException;import javax.servlet.http.HttpSession;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.TagSupport;public class PrintUser extends TagSupport{    private String userName;    private long phoneNum;    @Override    public int doStartTag() throws JspException {        HttpSession session = pageContext.getSession();        this.userName = (String) session.getAttribute(\"userName\");        this.phoneNum = (long) session.getAttribute(\"phoneNum\");        JspWriter out = pageContext.getOut();        try {            out.println(\"userName:\"+userName);            out.println(\"phoneNum:\"+phoneNum);        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }            return super.doStartTag();    }    public String getUserName() {        return userName;    }    public long getPhoneNum() {        return phoneNum;    }    public void setUserName(String userName) {        this.userName = userName;    }    public void setPhoneNum(long phoneNum) {        this.phoneNum = phoneNum;    }}\n3.3 Jsp中使用自定义标签测试类：test1.jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><%@taglib uri=\"http://www.company.com/tablib\" prefix=\"t\" %><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>Insert title here</title></head><body><t:user phoneNum=\"86_god\" userName=\"15592233822\"/><t:printUser/></body></html>\n每日心语：\n\n有毒的草，开迷人的花 害你的人，说你爱听的话 在这个无比现实残酷的世界里 人与人之间 什么人说什么话\n\n', 0, 1);
INSERT INTO `t_article` VALUES (166, '13.《JavaEE 学习笔记》EL表达式', 8, '> 参考链接：[https://baike.baidu.com/item/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/1190845?fr=aladdin](https://baike.baidu.com/item/EL表达式/1190845?fr=aladdin) https://blog.csdn.net/goldentec/article/details/105350669\n\n## 1、内容简介\n\n**表达式语言**（Expression Language，简称EL），最初设计为一种简单的语言，以满足web应用程序中表示层的需要。\n\n在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以“${}”表示。例如，${ userinfo}代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：${ pageScope. userinfo}表示访问page范围中的userinfo 变量。\n\n## 2、EL内置对象\n\nEL 提供了11个内置对象：\n\n- 2个内置对象为了方便输出请求参数；\n- 4个内置对象为了方便输出各个范围的属性；\n- 2个与请求头有关的内置对象；\n- 2个其他内置对象cookie和initParam；\n- 1个特殊的内置对象pageContext；\n\n### 2.1 与请求参数有关的内置对象\n\nEL中有两个与请求参数有关的内置对象：\n\n**2.1.1 param**\n\n将请求参数名称映射到单个字符串参数值（通过调用 ServletRequest.getParameter (String name) 获得）。getParameter (String) 方法返回带有特定名称的参数。表达式 ${param . name}相当于 request.getParameter (name)。\n\n用来输出请求参数的值，格式为${param.请求参数名字}。\n\n表达式：\n\n```jsp\n<%= request.getParameter(\"userName\") %>\n```\n\nEL表达式：\n\n```jsp\n${ param.userName }\n```\n\n**2.1.2 paramValues**\n\n将请求参数名称映射到一个数值数组（通过调用 ServletRequest.getParameter (String name) 获得）。它与 param 隐式对象非常类似，但它检索一个字符串数组而不是单个值。表达式 ${paramvalues. name} 相当于 request.getParamterValues(name)。\n\n用来获取一对多的参数值，返回一个数组。比如请求参数为一个多选框传来的数据，可以用paramValues.array[0]来取出第一个值。其中array为参数的名称。\n\n表达式：\n\n```jsp\n<%= request.getParameterValues(\"array\")[0] %>\n```\n\nEL表达式：\n\n```jsp\n${ paramValues.array[0] }\n```\n\n### 2.2 与属性有关的内置对象\n\n与属性有关的内置对象有四个：\n\n- pageScope 页面范围，即pageContext范围。\n- requestScope 请求范围。\n- sessionScope 会话范围。\n- applicationScope 上下文范围。\n\n表达式：\n\n```jsp\n<%= request.getAttribute(\"userPo\").getUserName %>\n```\n\nEL表达式：\n\n```jsp\n${ requestScope.userPo.userName }\n```\n\n在全局找userPo.userName，El表达式：\n\n```jsp\n${ userPo.userName }\n```\n\n当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。\n\n### 2.3 与请求头有关的内置对象\n\n与请求头有关的内置对象有两个：\n\n**2.3.1 header**\n\n将请求头名称映射到单个字符串头值（通过调用 ServletRequest.getHeader(String name) 获得）。表达式 ${header. name} 相当于 request.getHeader(name)。\n\n拿出请求头中Host的信息\n\n```jsp\n${header.Host} \n```\n\n拿出请求头中Accept-Language的信息\n\n```jsp\n${header[\"Accept-Language\"]}\n```\n\n**2.3.2 headerValues**\n\n将请求头名称映射到一个数值数组（通过调用 ServletRequest.getHeaders(String) 获得）。它与头隐式对象非常类似。表达式 ${headerValues. name} 相当于 request.getHeaderValues(name)。\n\n如果某个请求头的值有多个，则使用headerValues返回一个数组。\n\n```jsp\n${headerValues.cookie[0]}\n```\n\n### 2.4 其他内置对象cookie和initParam\n\n2.4.1 cookie\n\n将 cookie 名称映射到单个 cookie 对象。向服务器发出的客户端请求可以获得一个或多个 cookie。表达式 ${cookie. name .value} 返回带有特定名称的第一个 cookie 值。如果请求包含多个同名的 cookie，则应该使用 ${headerValues. name} 表达式。\n\n用来获取cookie的值。\n\n```jsp\n${ cookie.JSESSIONID.value } \n```\n\n2.4.2 initParam\n\n将上下文初始化参数名称映射到单个值（通过调用 ServletContext.getInitparameter(String name) 获得）。\n\n用来输出上下文参数的值。\n\n在web.xml中配置上下文参数:\n\n```jsp\n<context-param>\n	<param-name>author</param-name>\n	<param-value>86_god</param-value>\n</context-param>\n```\n\n在JSP中使用EL输出path的值:\n\n```jsp\n${ initParam.author}\n```\n\n### 2.5 最特殊的内置对象pageContext\n\nJSP 页的上下文。它可以用于访问 JSP 隐式对象，如请求、响应、会话、输出、servletContext 等。例如，${pageContext.response} 为页面的响应对象赋值。\n\nEL中的pageContext对象可以调用PageContext\n\n类中所有符合规范的getXxx方法，如PageContext类中有如下方法：\n\n通过pageContext获取getRequest，再调用request 的getRemoteAddr()方法：\n\n```jsp\n ${ pageContext.request.remoteAddr }\n```\n\n## 3、EL运算符\n\n### 3.1 算术运算符\n\nEL中支持五种算术运算符：\n\n- +实现加法运算；\n- -实现减法运算；\n- \\* 实现乘法运算；\n- /或div实现除法运算；\n- %或mod实现求模运算。\n\n### 3.2 等式和关系运算符\n\nEL中有6种比较运算符：\n\n- = = 或eq表示等于。\n- != 或ne表示不等于。\n- < 或lt表示小于。\n- \\> 或gt表示大于。\n- <= 或le表示小于等于。\n- \\>= 或ge表示大于等于。\n\n### 3.3 条件运算符\n\nEL中提供了3个逻辑运算符：\n\n- &&或and表示交集，两个值都是true才返回true。\n- ||或or表示并集，两个值只要有一个是true，即返回true。\n- !或not表示非\n\n### 3.4 其他运算符\n\n- empty运算符 判断值是否为null，如果是null，返回true，否则返回false。\n- ? :关系运算符 ${A?B:C}如果A为true，则执行B，如果A为false，则执行C。\n- ()运算符 通过()可改变优先级。\n\n### 3.5 符号.与[] \n\nEL 提供“.“和“[ ]“两种运算符来存取数据。\n\n当要存取的属性名称中包含一些特殊字符，如 . 或 - 等并非字母或数字的符号，就一定要使用“[ ]“。例如：\n\n${ user. My-Name}应当改为${user[\"My-Name\"]}\n\n如果要动态取值时，就可以用“[ ]“来做，而“.“无法做到动态取值。例如：\n\n${sessionScope.user[data]}中data 是一个变量', 0, 0, '2020-08-07 14:24:20', 2, 0, 1, '\n参考链接：https://baike.baidu.com/item/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/1190845?fr=aladdin https://blog.csdn.net/goldentec/article/details/105350669\n\n1、内容简介表达式语言（Expression Language，简称EL），最初设计为一种简单的语言，以满足web应用程序中表示层的需要。\n在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以“${}”表示。例如，${ userinfo}代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：${ pageScope. userinfo}表示访问page范围中的userinfo 变量。\n2、EL内置对象EL 提供了11个内置对象：\n\n2个内置对象为了方便输出请求参数；4个内置对象为了方便输出各个范围的属性；2个与请求头有关的内置对象；2个其他内置对象cookie和initParam；1个特殊的内置对象pageContext；\n2.1 与请求参数有关的内置对象EL中有两个与请求参数有关的内置对象：\n2.1.1 param\n将请求参数名称映射到单个字符串参数值（通过调用 ServletRequest.getParameter (String name) 获得）。getParameter (String) 方法返回带有特定名称的参数。表达式 ${param . name}相当于 request.getParameter (name)。\n用来输出请求参数的值，格式为${param.请求参数名字}。\n表达式：\n<%= request.getParameter(\"userName\") %>\nEL表达式：\n${ param.userName }\n2.1.2 paramValues\n将请求参数名称映射到一个数值数组（通过调用 ServletRequest.getParameter (String name) 获得）。它与 param 隐式对象非常类似，但它检索一个字符串数组而不是单个值。表达式 ${paramvalues. name} 相当于 request.getParamterValues(name)。\n用来获取一对多的参数值，返回一个数组。比如请求参数为一个多选框传来的数据，可以用paramValues.array[0]来取出第一个值。其中array为参数的名称。\n表达式：\n<%= request.getParameterValues(\"array\")[0] %>\nEL表达式：\n${ paramValues.array[0] }\n2.2 与属性有关的内置对象与属性有关的内置对象有四个：\n\npageScope 页面范围，即pageContext范围。requestScope 请求范围。sessionScope 会话范围。applicationScope 上下文范围。\n表达式：\n<%= request.getAttribute(\"userPo\").getUserName %>\nEL表达式：\n${ requestScope.userPo.userName }\n在全局找userPo.userName，El表达式：\n${ userPo.userName }\n当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。\n2.3 与请求头有关的内置对象与请求头有关的内置对象有两个：\n2.3.1 header\n将请求头名称映射到单个字符串头值（通过调用 ServletRequest.getHeader(String name) 获得）。表达式 ${header. name} 相当于 request.getHeader(name)。\n拿出请求头中Host的信息\n${header.Host}\n拿出请求头中Accept-Language的信息\n${header[\"Accept-Language\"]}\n2.3.2 headerValues\n将请求头名称映射到一个数值数组（通过调用 ServletRequest.getHeaders(String) 获得）。它与头隐式对象非常类似。表达式 ${headerValues. name} 相当于 request.getHeaderValues(name)。\n如果某个请求头的值有多个，则使用headerValues返回一个数组。\n${headerValues.cookie[0]}\n2.4 其他内置对象cookie和initParam2.4.1 cookie\n将 cookie 名称映射到单个 cookie 对象。向服务器发出的客户端请求可以获得一个或多个 cookie。表达式 ${cookie. name .value} 返回带有特定名称的第一个 cookie 值。如果请求包含多个同名的 cookie，则应该使用 ${headerValues. name} 表达式。\n用来获取cookie的值。\n${ cookie.JSESSIONID.value }\n2.4.2 initParam\n将上下文初始化参数名称映射到单个值（通过调用 ServletContext.getInitparameter(String name) 获得）。\n用来输出上下文参数的值。\n在web.xml中配置上下文参数:\n<context-param>    <param-name>author</param-name>    <param-value>86_god</param-value></context-param>\n在JSP中使用EL输出path的值:\n${ initParam.author}\n2.5 最特殊的内置对象pageContextJSP 页的上下文。它可以用于访问 JSP 隐式对象，如请求、响应、会话、输出、servletContext 等。例如，${pageContext.response} 为页面的响应对象赋值。\nEL中的pageContext对象可以调用PageContext\n类中所有符合规范的getXxx方法，如PageContext类中有如下方法：\n通过pageContext获取getRequest，再调用request 的getRemoteAddr()方法：\n ${ pageContext.request.remoteAddr }\n3、EL运算符3.1 算术运算符EL中支持五种算术运算符：\n\n+实现加法运算；-实现减法运算；* 实现乘法运算；/或div实现除法运算；%或mod实现求模运算。\n3.2 等式和关系运算符EL中有6种比较运算符：\n\n= = 或eq表示等于。!= 或ne表示不等于。< 或lt表示小于。> 或gt表示大于。<= 或le表示小于等于。>= 或ge表示大于等于。\n3.3 条件运算符EL中提供了3个逻辑运算符：\n\n&&或and表示交集，两个值都是true才返回true。||或or表示并集，两个值只要有一个是true，即返回true。!或not表示非\n3.4 其他运算符\nempty运算符 判断值是否为null，如果是null，返回true，否则返回false。? :关系运算符 ${A?B:C}如果A为true，则执行B，如果A为false，则执行C。()运算符 通过()可改变优先级。\n3.5 符号.与[]EL 提供“.“和“[ ]“两种运算符来存取数据。\n当要存取的属性名称中包含一些特殊字符，如 . 或 - 等并非字母或数字的符号，就一定要使用“[ ]“。例如：\n${ user. My-Name}应当改为${user[“My-Name”]}\n如果要动态取值时，就可以用“[ ]“来做，而“.“无法做到动态取值。例如：\n${sessionScope.user[data]}中data 是一个变量\n', 0, 1);
INSERT INTO `t_article` VALUES (167, '14.《JavaEE 学习笔记》JSTL 标准标签库', 8, '> 参考链接：https://www.runoob.com/jsp/jsp-jstl.html\n\n## 1、JSTL——JSP标准标签库\n\nJSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。\n\nJSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。\n\n根据JSTL标签所提供的功能，可以将其分为5个类别。\n\n- **核心标签**\n- **格式化标签**\n- **SQL 标签**\n- **XML 标签**\n- **JSTL 函数**\n\n## **2、JSTL 库的安装**\n\nApache Tomcat安装JSTL 库步骤如下：\n\n从Apache的标准标签库中下载的二进包(jakarta-taglibs-standard-current.zip)。\n\n- 官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/\n\n下载 **jakarta-taglibs-standard-1.1.2.zip** 包并解压，将 **jakarta-taglibs-standard-1.1.2/lib/** 下的两个 jar 文件：**standard.jar** 和 **jstl.jar** 文件拷贝到 **/WEB-INF/lib/** 下。\n\n将 tld 文件夹复制到 WEB-INF 目录下。\n\n接下来我们在 web.xml 文件中添加以下配置：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee;http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\">\n  <display-name>JavaEEJSTL</display-name>\n  \n  <jsp-config>\n    <taglib>\n    <taglib-uri>http://java.sun.com/jsp/jstl/fmt</taglib-uri>\n    <taglib-location>/WEB-INF/tld/fmt.tld</taglib-location>\n    </taglib>\n    <taglib>\n    <taglib-uri>http://java.sun.com/jsp/jstl/fmt-rt</taglib-uri>\n    <taglib-location>/WEB-INF/tld/fmt-rt.tld</taglib-location>\n    </taglib>\n    <taglib>\n    <taglib-uri>http://java.sun.com/jsp/jstl/core</taglib-uri>\n    <taglib-location>/WEB-INF/tld/c.tld</taglib-location>\n    </taglib>\n    <taglib>\n    <taglib-uri>http://java.sun.com/jsp/jstl/core-rt</taglib-uri>\n    <taglib-location>/WEB-INF/tld/c-rt.tld</taglib-location>\n    </taglib>\n    <taglib>\n    <taglib-uri>http://java.sun.com/jsp/jstl/sql</taglib-uri>\n    <taglib-location>/WEB-INF/tld/sql.tld</taglib-location>\n    </taglib>\n    <taglib>\n    <taglib-uri>http://java.sun.com/jsp/jstl/sql-rt</taglib-uri>\n    <taglib-location>/WEB-INF/tld/sql-rt.tld</taglib-location>\n    </taglib>\n    <taglib>\n    <taglib-uri>http://java.sun.com/jsp/jstl/x</taglib-uri>\n    <taglib-location>/WEB-INF/tld/x.tld</taglib-location>\n    </taglib>\n    <taglib>\n    <taglib-uri>http://java.sun.com/jsp/jstl/x-rt</taglib-uri>\n    <taglib-location>/WEB-INF/tld/x-rt.tld</taglib-location>\n    </taglib>\n    </jsp-config>\n  \n</web-app>\n```\n\n## 3、核心标签\n\n核心标签是最常用的 JSTL标签。引用核心标签库的语法如下：\n\n```jsp\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n```\n\n**便签简介：**\n\n- <c:out>\n- 用于在JSP中显示数据，就像<%= ... > \n- <c:set>\n- 用于保存数据\n- <c:remove>\n- 用于删除数据\n- <c:catch>\n- 用来处理产生错误的异常状况，并且将错误信息储存起来\n- <c:if>\n- 与我们在一般程序中用的if一样\n- <c:choose>\n- 本身只当做<c:when>和<c:otherwise>的父标签\n- <c:when>\n- <c:choose>的子标签，用来判断条件是否成立\n- <c:otherwise>\n- <c:choose>的子标签，接在<c:when>标签后，当<c:when>标签判断为false时被执行\n- <c:import>\n- 检索一个绝对或相对 URL，然后将其内容暴露给页面\n- <c:forEach>\n- 基础迭代标签，接受多种集合类型\n- <c:forTokens>\n- 根据指定的分隔符来分隔内容并迭代输出\n- <c:param>\n- 用来给包含或重定向的页面传递参数\n- <c:redirect>\n- 重定向至一个新的URL.\n- <c:url>\n- 使用可选的查询参数来创造一个URL\n\n## 4、格式化标签\n\nJSTL格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下：\n\n```jsp\n<%@ taglib prefix=\"fmt\"  uri=\"http://java.sun.com/jsp/jstl/fmt\" %>\n```\n\n**标签简介：**\n\n- <fmt:formatNumber>	使用指定的格式或精度格式化数字\n- <fmt:parseNumber>	解析一个代表着数字，货币或百分比的字符串\n- <fmt:formatDate>	使用指定的风格或模式格式化日期和时间\n- <fmt:parseDate>	解析一个代表着日期或时间的字符串\n- <fmt:bundle>	绑定资源\n- <fmt:setLocale>	指定地区\n- <fmt:setBundle>	绑定资源\n- <fmt:timeZone>	指定时区\n- <fmt:setTimeZone>	指定时区\n- <fmt:message>	显示资源配置文件信息\n- <fmt:requestEncoding>	设置request的字符编码\n\n## 5、SQL标签\n\nJSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下：\n\n```jsp\n<%@ taglib prefix=\"sql\" \n           uri=\"http://java.sun.com/jsp/jstl/sql\" %>\n```\n\n标签简介：\n\n- <sql:setDataSource>	指定数据源\n- <sql:query>	运行SQL查询语句\n- <sql:update>	运行SQL更新语句\n- <sql:param>	将SQL语句中的参数设为指定值\n- <sql:dateParam>	 将SQL语句中的日期参数设为指定的 java.util.Date 对象值\n- <sql:transaction>	在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行.\n\n## 6、XML 标签\n\nJSTL XML标签库提供了创建和操作XML文档的标签。引用XML标签库的语法如下：\n\n```jsp\n<%@ taglib prefix=\"x\" \n           uri=\"http://java.sun.com/jsp/jstl/xml\" %>\n```\n\n在使用xml标签前，你必须将XML 和 XPath 的相关包拷贝至你的<Tomcat 安装目录>\\lib下:\n\n- **XercesImpl.jar**下载地址： http://www.apache.org/dist/xerces/j/\n- **xalan.jar**下载地址： http://xml.apache.org/xalan-j/index.html\n\n**标签简介：**\n\n- <x:out>	与<%= ... >,类似，不过只用于XPath表达式\n- <x:parse>	解析 XML 数据\n- <x:set>	设置XPath表达式\n- <x:if>	判断XPath表达式，若为真，则执行本体中的内容，否则跳过本体\n- <x:forEach>	迭代XML文档中的节点\n- <x:choose>	<x:when>和<x:otherwise>的父标签\n- <x:when>	<x:choose>的子标签，用来进行条件判断\n- <x:otherwise>	<x:choose>的子标签，当<x:when>判断为false时被执行\n- <x:transform>	将XSL转换应用在XML文档中\n- <x:param>	与<x:transform>共同使用，用于设置XSL样式表\n\n## 7、JSTL函数\n\nJSTL包含一系列标准函数，大部分是通用的字符串处理函数。引用JSTL函数库的语法如下：\n\n```jsp\n<%@ taglib prefix=\"fn\" \n           uri=\"http://java.sun.com/jsp/jstl/functions\" %>\n```\n\n**标签简介：**\n\n- fn:contains()	测试输入的字符串是否包含指定的子串\n- fn:containsIgnoreCase()	测试输入的字符串是否包含指定的子串，大小写不敏感\n- fn:endsWith()	测试输入的字符串是否以指定的后缀结尾\n- fn:escapeXml()	跳过可以作为XML标记的字符\n- fn:indexOf()	返回指定字符串在输入字符串中出现的位置\n- fn:join()	将数组中的元素合成一个字符串然后输出\n- fn:length()	返回字符串长度\n- fn:replace()	将输入字符串中指定的位置替换为指定的字符串然后返回\n- fn:split()	将字符串用指定的分隔符分隔然后组成一个子字符串数组并返回\n- fn:startsWith()	测试输入字符串是否以指定的前缀开始\n- fn:substring()	返回字符串的子集\n- fn:substringAfter()	返回字符串在指定子串之后的子集\n- fn:substringBefore()	返回字符串在指定子串之前的子集\n- fn:toLowerCase()	将字符串中的字符转为小写\n- fn:toUpperCase()	将字符串中的字符转为大写\n- fn:trim()	移除首尾的空白符', 0, 0, '2020-08-07 14:25:03', 2, 0, 1, '\n参考链接：https://www.runoob.com/jsp/jsp-jstl.html\n\n1、JSTL——JSP标准标签库JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。\nJSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。\n根据JSTL标签所提供的功能，可以将其分为5个类别。\n\n核心标签格式化标签SQL 标签XML 标签JSTL 函数\n2、JSTL 库的安装Apache Tomcat安装JSTL 库步骤如下：\n从Apache的标准标签库中下载的二进包(jakarta-taglibs-standard-current.zip)。\n\n官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/\n下载 jakarta-taglibs-standard-1.1.2.zip 包并解压，将 jakarta-taglibs-standard-1.1.2/lib/ 下的两个 jar 文件：standard.jar 和 jstl.jar 文件拷贝到 /WEB-INF/lib/ 下。\n将 tld 文件夹复制到 WEB-INF 目录下。\n接下来我们在 web.xml 文件中添加以下配置：\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee;http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\">  <display-name>JavaEEJSTL</display-name>  <jsp-config>    <taglib>    <taglib-uri>http://java.sun.com/jsp/jstl/fmt</taglib-uri>    <taglib-location>/WEB-INF/tld/fmt.tld</taglib-location>    </taglib>    <taglib>    <taglib-uri>http://java.sun.com/jsp/jstl/fmt-rt</taglib-uri>    <taglib-location>/WEB-INF/tld/fmt-rt.tld</taglib-location>    </taglib>    <taglib>    <taglib-uri>http://java.sun.com/jsp/jstl/core</taglib-uri>    <taglib-location>/WEB-INF/tld/c.tld</taglib-location>    </taglib>    <taglib>    <taglib-uri>http://java.sun.com/jsp/jstl/core-rt</taglib-uri>    <taglib-location>/WEB-INF/tld/c-rt.tld</taglib-location>    </taglib>    <taglib>    <taglib-uri>http://java.sun.com/jsp/jstl/sql</taglib-uri>    <taglib-location>/WEB-INF/tld/sql.tld</taglib-location>    </taglib>    <taglib>    <taglib-uri>http://java.sun.com/jsp/jstl/sql-rt</taglib-uri>    <taglib-location>/WEB-INF/tld/sql-rt.tld</taglib-location>    </taglib>    <taglib>    <taglib-uri>http://java.sun.com/jsp/jstl/x</taglib-uri>    <taglib-location>/WEB-INF/tld/x.tld</taglib-location>    </taglib>    <taglib>    <taglib-uri>http://java.sun.com/jsp/jstl/x-rt</taglib-uri>    <taglib-location>/WEB-INF/tld/x-rt.tld</taglib-location>    </taglib>    </jsp-config></web-app>\n3、核心标签核心标签是最常用的 JSTL标签。引用核心标签库的语法如下：\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n便签简介：\n\n<c:out>\n用于在JSP中显示数据，就像<%= … > <c:set>\n用于保存数据<c:remove>\n用于删除数据<c:catch>\n用来处理产生错误的异常状况，并且将错误信息储存起来<c:if>\n与我们在一般程序中用的if一样<c:choose>\n本身只当做<c:when>和<c:otherwise>的父标签<c:when>\n<c:choose>的子标签，用来判断条件是否成立<c:otherwise>\n<c:choose>的子标签，接在<c:when>标签后，当<c:when>标签判断为false时被执行<c:import>\n检索一个绝对或相对 URL，然后将其内容暴露给页面<c:forEach>\n基础迭代标签，接受多种集合类型<c:forTokens>\n根据指定的分隔符来分隔内容并迭代输出<c:param>\n用来给包含或重定向的页面传递参数<c:redirect>\n重定向至一个新的URL.<c:url>\n使用可选的查询参数来创造一个URL\n4、格式化标签JSTL格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下：\n<%@ taglib prefix=\"fmt\"  uri=\"http://java.sun.com/jsp/jstl/fmt\" %>\n标签简介：\n\n<fmt:formatNumber>    使用指定的格式或精度格式化数字<fmt:parseNumber>    解析一个代表着数字，货币或百分比的字符串<fmt:formatDate>    使用指定的风格或模式格式化日期和时间<fmt:parseDate>    解析一个代表着日期或时间的字符串<fmt:bundle>    绑定资源<fmt:setLocale>    指定地区<fmt:setBundle>    绑定资源<fmt:timeZone>    指定时区<fmt:setTimeZone>    指定时区<fmt:message>    显示资源配置文件信息<fmt:requestEncoding>    设置request的字符编码\n5、SQL标签JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下：\n<%@ taglib prefix=\"sql\"            uri=\"http://java.sun.com/jsp/jstl/sql\" %>\n标签简介：\n\n<sql:setDataSource>    指定数据源<sql:query>    运行SQL查询语句<sql:update>    运行SQL更新语句<sql:param>    将SQL语句中的参数设为指定值<sql:dateParam>     将SQL语句中的日期参数设为指定的 java.util.Date 对象值<sql:transaction>    在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行.\n6、XML 标签JSTL XML标签库提供了创建和操作XML文档的标签。引用XML标签库的语法如下：\n<%@ taglib prefix=\"x\"            uri=\"http://java.sun.com/jsp/jstl/xml\" %>\n在使用xml标签前，你必须将XML 和 XPath 的相关包拷贝至你的<Tomcat 安装目录>\\lib下:\n\nXercesImpl.jar下载地址： http://www.apache.org/dist/xerces/j/xalan.jar下载地址： http://xml.apache.org/xalan-j/index.html\n标签简介：\n\n<x:out>    与<%= … >,类似，不过只用于XPath表达式<x:parse>    解析 XML 数据<x:set>    设置XPath表达式<x:if>    判断XPath表达式，若为真，则执行本体中的内容，否则跳过本体<x:forEach>    迭代XML文档中的节点<x:choose>    <x:when>和<x:otherwise>的父标签<x:when>    <x:choose>的子标签，用来进行条件判断<x:otherwise>    <x:choose>的子标签，当<x:when>判断为false时被执行<x:transform>    将XSL转换应用在XML文档中<x:param>    与<x:transform>共同使用，用于设置XSL样式表\n7、JSTL函数JSTL包含一系列标准函数，大部分是通用的字符串处理函数。引用JSTL函数库的语法如下：\n<%@ taglib prefix=\"fn\"            uri=\"http://java.sun.com/jsp/jstl/functions\" %>\n标签简介：\n\nfn:contains()    测试输入的字符串是否包含指定的子串fn:containsIgnoreCase()    测试输入的字符串是否包含指定的子串，大小写不敏感fn:endsWith()    测试输入的字符串是否以指定的后缀结尾fn:escapeXml()    跳过可以作为XML标记的字符fn:indexOf()    返回指定字符串在输入字符串中出现的位置fn:join()    将数组中的元素合成一个字符串然后输出fn:length()    返回字符串长度fn:replace()    将输入字符串中指定的位置替换为指定的字符串然后返回fn:split()    将字符串用指定的分隔符分隔然后组成一个子字符串数组并返回fn:startsWith()    测试输入字符串是否以指定的前缀开始fn:substring()    返回字符串的子集fn:substringAfter()    返回字符串在指定子串之后的子集fn:substringBefore()    返回字符串在指定子串之前的子集fn:toLowerCase()    将字符串中的字符转为小写fn:toUpperCase()    将字符串中的字符转为大写fn:trim()    移除首尾的空白符\n', 0, 1);
INSERT INTO `t_article` VALUES (168, '15.《JavaEE 学习笔记》Ajax', 8, '## 1、AJAX 简介\n\nAJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\n\nAJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n\nAJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n\n**AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。**\n\n## **2、AJAX的组成元素**\n\nAjax技术主要包含四个组件，即JavaScript、CSS、DOM以及XMLHttpRequest对象。\n\n### 2.1 XMLHttpRequest\n\nXMLHttpRequest是Ajax技术的核心对象，使用Ajax技术都是从XMLHttpRequest对象开始。在Ajax应用程序中，XMLHttpRequest对象负责将用户信息以异步方式发送到服务器端，并接收服务器响应的信息和数据。\n\n**创建 XMLHttpRequest 对象：**\n\n```jsp\nvar xmlhttp;\nif(window.ActiveXObject) {\n	console.log(\"操作提示：您的浏览器是IE浏览器。\");\n	xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n} else if(window.XMLHttpRequest) {\n	console.log(\"操作提示：您的浏览器不是IE浏览器。\");\n	xmlHttp = new XMLHttpRequest();\n	}\n```\n\n**XMLHttpRequest的属性：**\n\n- readyState\n- 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。\n- 0: 请求未初始化\n- 1: 服务器连接已建立\n- 2: 请求已接收\n- 3: 请求处理中\n- 4: 请求已完成，且响应已就绪\n- status\n- 200: \"OK\"\n- 404: 未找到页面\n- onreadystatechange\n- 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。\n\n### 2.2 **AJAX - 向服务器发送请求**\n\n**方法：**\n\n（1）open(*method*,*url*,*async*)\n\n规定请求的类型、URL 以及是否异步处理请求。\n\n- *method*：请求的类型；GET 或 POST\n- *url*：文件在服务器上的位置\n- *async*：true（异步）或 false（同步）\n\n（2）send(*string*)\n\n将请求发送到服务器。\n\n- *string*：仅用于 POST 请求\n\n### 2.3 **AJAX - 服务器响应**\n\n**属性：**\n\n- responseText获得字符串形式的响应数据。\n- responseXML获得 XML 形式的响应数据。\n\n（1）**responseText 属性**\n\n如果来自服务器的响应并非 XML，请使用 responseText 属性。\n\nresponseText 属性返回字符串形式的响应，因此您可以这样使用：\n\n```jsp\ndocument.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;\n```\n\n（2）**responseXML 属性**\n\n如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性：\n\n```jsp\nxmlDoc=xmlhttp.responseXML;\n```\n\n## 代码案例：\n\n模仿网站在线注册，填写完邮箱和手机号，异步请求，检测邮箱和手机号是否已经注册。\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/v2-59d7f979a089b76c2bc8a6ffed0f9969_b.png)\n\nlogin.jsp代码:\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>登录</title>\n		<script>\n			var baseUrl = \"reg-servlet\";\n			var xmlHttp;\n			var responseText;\n			var onBlurId;\n			\n			//创建创建 XMLHttp 对象\n			function createXmlHttp(name,value) {\n				if(window.ActiveXObject) {\n					console.log(\"操作提示：您的浏览器是IE浏览器。\");\n					xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n				} else if(window.XMLHttpRequest) {\n					console.log(\"操作提示：您的浏览器不是IE浏览器。\");\n					xmlHttp = new XMLHttpRequest();\n				}\n\n				//注册监听或者回调函数\n				xmlHttp.onreadystatechange = callback;\n				//1:打开状态\n				//传递参数\n				var url = baseUrl + \"?\" + name+\"=\"+value;\n				//GET方法打开,第三个参数如果为true,那么为异步请求,将不会刷新整个页面.\n				xmlHttp.open(\"GET\", url, true);\n				//2:发送状态\n				//Get方式的send()\n				xmlHttp.send(null);				\n			}\n\n			\n			//回调函数，处理响应信息\n			function callback() {\n				console.log(\"回调函数已调用\");\n				//setResponseText(xmlHttp.readyState);\n				//获取响应内容\n				if(xmlHttp.readyState == 4) {\n					if(xmlHttp.status == 200) {\n						responseText = xmlHttp.responseText;\n						//console.log(responseText);\n						if(responseText == \"true\"){\n							setResponseText(true);\n						}else{\n							setResponseText(false);\n						}					\n					}\n				}\n			}\n\n			//通过处理后的响应信息修改提醒文本\n			function setResponseText(flag) {\n				var id;\n				var responseText;\n				if(onBlurId == \"e-mail\"){\n					id = \"pText1\";\n					responseText = document.getElementById(id);\n					if(flag){\n						responseText.style.color = \"green\";\n						responseText.innerText = \"该邮箱可以注册\";\n					}else{\n						responseText.style.color = \"red\";\n						responseText.innerText = \"该邮箱已经被注册\";\n					}\n				}else{\n					id = \"pText2\";\n					responseText = document.getElementById(id);\n					if(flag){\n						responseText.style.color = \"green\";\n						responseText.innerText = \"该手机号可以注册\";\n					}else{\n						responseText.style.color = \"red\";\n						responseText.innerText = \"该手机号已经被注册\";\n					}\n				}	\n			}\n			\n			\n			//重写失去焦点事件\n			function onBlur(id) {\n				var module = document.getElementById(id);\n				var name = module.name;\n				var value = module.value;\n				//var url = baseUrl + \"?\" + name + \"=\" + value;\n				onBlurId = id;			\n				console.log(name + \"失去焦点\");\n				console.log(name+\":\"+value);\n				createXmlHttp(name,value);\n			}\n			\n		</script>\n	</head>\n\n	<body>\n		<form id=\"Login\" action=\"\" method=\"post\">\n			<table>\n				<tr>\n					<td>邮箱：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input name=\"e-mail\" id=\"e-mail\" type=\"text\" onblur=\"onBlur(id)\" /></td>\n					<td><p id=\"pText1\" style=\"color: red;\"></p></td>\n				</tr>\n				<tr>\n					<td>手机号： <input name=\"phoneNum\" type=\"text\" id=\"phoneNum\" onblur=\"onBlur(id)\" /></td>\n					<td><p id=\"pText2\" style=\"color: red;\"></p></td>\n				</tr>\n\n			</table>\n\n			<input type=\"button\" value=\"登录\"  onclick=\"setResponseText(456)\"/>\n			<input type=\"button\" value=\"注册\" />			\n		</form>\n	</body>\n\n</html>\n```\n\nregServlet.java代码：\n\n```jsp\npackage com.company.servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/reg-servlet\")\npublic class regServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n       \n\n    public regServlet() {\n        super();\n        \n    }\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		response.setContentType(\"text/html;charset=utf-8\");\n		response.setCharacterEncoding(\"utf-8\");\n		request.setCharacterEncoding(\"utf-8\");\n		Enumeration<String> names = request.getParameterNames();\n		System.out.println(\"-----------------\");\n		String responseTest = \"\";\n		while(names.hasMoreElements()) {\n			String name = names.nextElement();\n			String value = request.getParameter(name);\n			\n			//此处模拟数据库检测，查询是否已经注册\n			if(name.equals(\"e-mail\")) {\n				if(value.equals(\"2584966199@qq.com\")) {\n					System.out.println(\"该邮箱已注册\");\n					responseTest = \"false\";\n				}else {\n					System.out.println(\"该邮箱可以注册\");\n					responseTest = \"true\";\n				}	\n			}else {\n				if(value.equals(\"15592237827\")) {\n					System.out.println(\"该手机号已注册\");\n					responseTest = \"false\";\n				}else {\n					System.out.println(\"该手机号可以注册\");\n					responseTest = \"true\";\n				}\n			}\n		}\n		PrintWriter out=response.getWriter();\n		out.print(responseTest);\n	}\n\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		\n		doGet(request, response);\n	}\n\n}\n```', 0, 0, '2020-08-07 14:25:29', 2, 0, 1, '1、AJAX 简介AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\nAJAX 不是新的编程语言，而是一种使用现有标准的新方法。\nAJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\nAJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n2、AJAX的组成元素Ajax技术主要包含四个组件，即JavaScript、CSS、DOM以及XMLHttpRequest对象。\n2.1 XMLHttpRequestXMLHttpRequest是Ajax技术的核心对象，使用Ajax技术都是从XMLHttpRequest对象开始。在Ajax应用程序中，XMLHttpRequest对象负责将用户信息以异步方式发送到服务器端，并接收服务器响应的信息和数据。\n创建 XMLHttpRequest 对象：\nvar xmlhttp;if(window.ActiveXObject) {    console.log(\"操作提示：您的浏览器是IE浏览器。\");    xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\");} else if(window.XMLHttpRequest) {    console.log(\"操作提示：您的浏览器不是IE浏览器。\");    xmlHttp = new XMLHttpRequest();    }\nXMLHttpRequest的属性：\n\nreadyState存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪status200: “OK”404: 未找到页面onreadystatechange存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。\n2.2 AJAX - 向服务器发送请求方法：\n（1）open(method,url,async)\n规定请求的类型、URL 以及是否异步处理请求。\n\nmethod：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步）\n（2）send(string)\n将请求发送到服务器。\n\nstring：仅用于 POST 请求\n2.3 AJAX - 服务器响应属性：\n\nresponseText获得字符串形式的响应数据。responseXML获得 XML 形式的响应数据。\n（1）responseText 属性\n如果来自服务器的响应并非 XML，请使用 responseText 属性。\nresponseText 属性返回字符串形式的响应，因此您可以这样使用：\ndocument.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;\n（2）responseXML 属性\n如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性：\nxmlDoc=xmlhttp.responseXML;\n代码案例：模仿网站在线注册，填写完邮箱和手机号，异步请求，检测邮箱和手机号是否已经注册。\n\nlogin.jsp代码:\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>登录</title>        <script>            var baseUrl = \"reg-servlet\";            var xmlHttp;            var responseText;            var onBlurId;            //创建创建 XMLHttp 对象            function createXmlHttp(name,value) {                if(window.ActiveXObject) {                    console.log(\"操作提示：您的浏览器是IE浏览器。\");                    xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\");                } else if(window.XMLHttpRequest) {                    console.log(\"操作提示：您的浏览器不是IE浏览器。\");                    xmlHttp = new XMLHttpRequest();                }                //注册监听或者回调函数                xmlHttp.onreadystatechange = callback;                //1:打开状态                //传递参数                var url = baseUrl + \"?\" + name+\"=\"+value;                //GET方法打开,第三个参数如果为true,那么为异步请求,将不会刷新整个页面.                xmlHttp.open(\"GET\", url, true);                //2:发送状态                //Get方式的send()                xmlHttp.send(null);                            }            //回调函数，处理响应信息            function callback() {                console.log(\"回调函数已调用\");                //setResponseText(xmlHttp.readyState);                //获取响应内容                if(xmlHttp.readyState == 4) {                    if(xmlHttp.status == 200) {                        responseText = xmlHttp.responseText;                        //console.log(responseText);                        if(responseText == \"true\"){                            setResponseText(true);                        }else{                            setResponseText(false);                        }                                        }                }            }            //通过处理后的响应信息修改提醒文本            function setResponseText(flag) {                var id;                var responseText;                if(onBlurId == \"e-mail\"){                    id = \"pText1\";                    responseText = document.getElementById(id);                    if(flag){                        responseText.style.color = \"green\";                        responseText.innerText = \"该邮箱可以注册\";                    }else{                        responseText.style.color = \"red\";                        responseText.innerText = \"该邮箱已经被注册\";                    }                }else{                    id = \"pText2\";                    responseText = document.getElementById(id);                    if(flag){                        responseText.style.color = \"green\";                        responseText.innerText = \"该手机号可以注册\";                    }else{                        responseText.style.color = \"red\";                        responseText.innerText = \"该手机号已经被注册\";                    }                }                }            //重写失去焦点事件            function onBlur(id) {                var module = document.getElementById(id);                var name = module.name;                var value = module.value;                //var url = baseUrl + \"?\" + name + \"=\" + value;                onBlurId = id;                            console.log(name + \"失去焦点\");                console.log(name+\":\"+value);                createXmlHttp(name,value);            }        </script>    </head>    <body>        <form id=\"Login\" action=\"\" method=\"post\">            <table>                <tr>                    <td>邮箱：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input name=\"e-mail\" id=\"e-mail\" type=\"text\" onblur=\"onBlur(id)\" /></td>                    <td><p id=\"pText1\" style=\"color: red;\"></p></td>                </tr>                <tr>                    <td>手机号： <input name=\"phoneNum\" type=\"text\" id=\"phoneNum\" onblur=\"onBlur(id)\" /></td>                    <td><p id=\"pText2\" style=\"color: red;\"></p></td>                </tr>            </table>            <input type=\"button\" value=\"登录\"  onclick=\"setResponseText(456)\"/>            <input type=\"button\" value=\"注册\" />                    </form>    </body></html>\nregServlet.java代码：\npackage com.company.servlet;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/reg-servlet\")public class regServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    public regServlet() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        response.setContentType(\"text/html;charset=utf-8\");        response.setCharacterEncoding(\"utf-8\");        request.setCharacterEncoding(\"utf-8\");        Enumeration<String> names = request.getParameterNames();        System.out.println(\"-----------------\");        String responseTest = \"\";        while(names.hasMoreElements()) {            String name = names.nextElement();            String value = request.getParameter(name);            //此处模拟数据库检测，查询是否已经注册            if(name.equals(\"e-mail\")) {                if(value.equals(\"2584966199@qq.com\")) {                    System.out.println(\"该邮箱已注册\");                    responseTest = \"false\";                }else {                    System.out.println(\"该邮箱可以注册\");                    responseTest = \"true\";                }                }else {                if(value.equals(\"15592237827\")) {                    System.out.println(\"该手机号已注册\");                    responseTest = \"false\";                }else {                    System.out.println(\"该手机号可以注册\");                    responseTest = \"true\";                }            }        }        PrintWriter out=response.getWriter();        out.print(responseTest);    }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        doGet(request, response);    }}\n', 0, 1);
INSERT INTO `t_article` VALUES (169, '16.随机验证码的生成及使用，全编码编写', 8, '## 使用技术：\n\nJSP + Ajax\n\n随机生成验证码，动态验证。\n\n**功能：随机生成验证码，存入会话，生成验证码图片，供输入验证，**\n\n**若验证成功，提示：验证码输入成功，并且将注册按钮启用；**\n\n**若验证失败，提示：验证码输入错误，并且将注册按钮禁用，并且在会话中删除缓存的验证码数据。**\n\n**若会话中没有存储验证码数据，则提醒：验证码已失效，点击刷新。**\n\n**验证码点击可以刷新**\n\n**1、验证码输入成功**\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/v2-af4204ec04a3c59dbbff6048e2b8ac6e_b.png)\n\n**2、验证码输入失败**\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/v2-af4204ec04a3c59dbbff6048e2b8ac6e_b.png)\n\n验证码输入失败\n\n**3、验证码失效**\n\n![img](https://86god-1302471896.cos.ap-chongqing.myqcloud.com/image/v2-af4204ec04a3c59dbbff6048e2b8ac6e_b.png)\n\n验证码失效\n\n## 代码：\n\n1、 随机生成验证码代码，VerificationCodeServlet.java：\n\n```java\npackage com.company.project.servlet;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport com.sun.prism.Image;\n\n@WebServlet(\"/verification-code-servlet\")\npublic class VerificationCodeServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n	\n	//设置生成验证码的画布宽度\n	int w = 80;\n	//生成验证码的长度\n	int fontNum = 4;\n	\n	//验证码字体大小\n	int fontSize = (w - 10) / fontNum;\n	\n    //根据字体大小设置画布的高度\n	int h = (int) (fontSize * 1.5);\n	\n	//初始化字符源\n	String charSource = \"abcdefghijklmnopqrstuvwxyxABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n	\n	/**\n	 * 随机生成验证码\n	 * @param num 生成验证码的长度\n	 * @return 验证码\n	 */\n	public String randString(int num) {\n		String verCode = \"\";\n		for(int i = 0;i<num;i++) {\n			verCode += charSource.charAt((int)(Math.random()*charSource.length()));\n		}\n		System.out.println(\"verCode:\"+verCode);\n		return verCode;\n	}\n	\n	public Color randColor() {\n		int r = (int)(Math.random() * 256);\n		int g = (int)(Math.random() * 256);\n		int b = (int)(Math.random() * 256);\n		\n		Color color = new Color(r, g, b);\n		\n		System.out.println(\"color:\"+color);\n		return color;\n	}\n	\n	/**\n	 * 随机生成一条直线\n	 * @return 两点坐标(x1,y1)(x2,y2)\n	 */\n	public int[] randLine() {\n		int x1,x2,y1,y2;\n		x1 = (int)(Math.random()*w);\n		x2 = (int)(Math.random()*w);\n		y1 = (int)(Math.random()*h);\n		y2 = (int)(Math.random()*h);\n		int[] result = {x1,y1,x2,y2};\n		return result;\n	}\n	\n    public VerificationCodeServlet() {\n        super();\n    }\n\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		//初始化画布\n		BufferedImage canvas = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n		\n		//初始化画笔对象\n		Graphics pen = canvas.getGraphics();\n		\n		//设置画笔颜色\n		pen.setColor(Color.WHITE);\n		\n		//画一个填充矩形\n		pen.fillRect(0, 0, w, h);\n		\n		//设置画笔颜色\n		pen.setColor(Color.black);\n		\n		//画出边框\n		pen.drawRect(0, 0, w-1, h-1);\n		\n		//设置画笔字体样式\n		pen.setFont(new Font(\"微软雅黑\", Font.BOLD, fontSize));\n		\n		\n		//生成验证码字符串\n		String verCode = randString(fontNum);\n		\n		//将生成的验证码存入会话\n		request.getSession().setAttribute(\"verCode\", verCode);\n		\n		//绘制随机验证码\n		for(int i = 0;i<verCode.length();i++) {\n			pen.setColor(randColor());\n			pen.drawString(String.valueOf(verCode.charAt(i)), 10 + i * 15, (h + fontSize) /2);\n		}\n		\n		//绘制一条随机直线\n		int[] line = randLine();  \n		for(int i = 0;i<line.length;i++) {\n			System.out.println(line[i]);\n		}\n		\n		\n		//设置画笔字体样式\n		pen.setColor(Color.BLACK);\n		\n		//画出随机直线\n		pen.drawLine(line[0],line[1],line[2],line[3]);\n		\n		//获取输出流对象\n		ServletOutputStream out = response.getOutputStream();\n		\n		//把画好的验证码写入输出流\n		ImageIO.write(canvas, \"png\", out);\n		\n		//释放输出流\n		out.flush();\n		out.close();\n		\n	}\n\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		\n	}\n}\n```\n\n2、验证码认证，VerifyServlet.java\n\n```\npackage com.company.project.servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/verify-servlet\")\npublic class VerifyServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n       \n\n    public VerifyServlet() {\n        super();\n        \n    }\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		response.setContentType(\"text/html;charset=utf-8\");\n		response.setCharacterEncoding(\"utf-8\");\n		request.setCharacterEncoding(\"utf-8\");\n		String verCode = request.getParameter(\"verCode\");\n		System.out.println(\"-----------------\");\n		\n		String flag = null ;\n		String code = (String) request.getSession().getAttribute(\"verCode\");\n		\n		if(code==null) {\n			//验证码失效\n			flag = \"0\";\n		}\n		else if(verCode.toUpperCase().equals(code.toUpperCase())) {\n			//验证码输入正确\n			flag = \"1\";\n		}else {\n			//验证码输入失败\n			flag = \"2\";\n			request.getSession().removeAttribute(\"verCode\");\n		}		\n		PrintWriter out=response.getWriter();\n		out.print(flag);\n	}\n\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n		// TODO Auto-generated method stub\n		doGet(request, response);\n	}\n\n}\n```\n\n3、验证码页面，verCode.jsp\n\n```java\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>登录</title>\n		<script>\n			var baseUrl = \"http://localhost:8888/JavaEE17Demo/verify-servlet\";\n			var xmlHttp;\n			var responseText;\n			var onBlurId;\n			var code;		\n	\n			//创建创建 XMLHttp 对象\n			function createXmlHttp(name, value) {\n				if(window.ActiveXObject) {\n					console.log(\"操作提示：您的浏览器是IE浏览器。\");\n					xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n				} else if(window.XMLHttpRequest) {\n					console.log(\"操作提示：您的浏览器不是IE浏览器。\");\n					xmlHttp = new XMLHttpRequest();\n				}\n\n				//注册监听或者回调函数\n				xmlHttp.onreadystatechange = callback;\n				//1:打开状态\n				//传递参数\n				var url = baseUrl + \"?\" + name + \"=\" + value;\n				//GET方法打开,第三个参数如果为true,那么为异步请求,将不会刷新整个页面.\n				xmlHttp.open(\"GET\", url, true);\n				//2:发送状态\n				//Get方式的send()\n				xmlHttp.send(null);\n\n			}\n\n			//回调函数，处理响应信息\n			function callback() {\n\n				//获取响应内容\n				if(xmlHttp.readyState == 4) {\n					if(xmlHttp.status == 200) {\n						responseText = xmlHttp.responseText;\n						console.log(responseText);\n						var pText = document.getElementById(\"pText\");\n						var button = document.getElementById(\"regButton\");\n					\n						if(responseText == \"0\") {\n							pText.style.color = \"red\";\n							button.disabled = true;\n						\n							pText.innerHTML=\"验证码已失效，点击刷新\";\n						} else if(responseText == \"1\") {\n							pText.style.color = \"green\";\n							button.disabled = false;\n							pText.innerHTML=\"验证码输入成功\";\n						}else{\n							pText.style.color = \"red\";\n							button.disabled = true;\n							pText.innerHTML=\"验证码输入失败\";\n						}\n\n					}\n				}\n			}\n\n			//通过处理后的响应信息修改提醒文本\n			function setResponseText(text) {\n				var id;\n				var responseText;\n				\n			}\n\n			//重写失去焦点事件\n			function onBlur(id) {\n				var module = document.getElementById(id);\n				var name = module.name;\n				var value = module.value;\n				//var url = baseUrl + \"?\" + name + \"=\" + value;\n				onBlurId = id;\n				console.log(name + \"失去焦点\");\n				console.log(name + \":\" + value);\n				createXmlHttp(name, value);\n			}\n			\n			function onClick(){\n				var id = Math.floor(Math.random()*10);\n				code = document.getElementById(\"verCodeImg\");\n				console.log(code);\n				code.src = \"http://localhost:8888/JavaEE17Demo/verification-code-servlet\"+\"?id=\"+id;\n				console.log(code.src);\n			}\n		</script>\n	</head>\n\n	<body>\n		<form id=\"Login\" action=\"\" method=\"post\">\n			<table>\n				<tr>\n					<td>邮箱：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input name=\"e-mail\" id=\"e-mail\" type=\"text\"  /></td>\n					<td>\n						<p id=\"pText1\" style=\"color: red;\"></p>\n					</td>\n				</tr>\n				<tr>\n					<td>手机号： <input name=\"phoneNum\" type=\"text\" id=\"phoneNum\"  /></td>\n					<td>\n						<p id=\"pText2\" style=\"color: red;\"></p>\n					</td>\n				</tr>\n				<tr>\n					<td>验证码： <input type=\"text\"  id=\"verCode\" name=\"verCode\" onblur=\"onBlur(id)\"/></td>\n					<td><img id=\"verCodeImg\" alt=\"随机生成验证码\" src=\"http://localhost:8888/JavaEE17Demo/verification-code-servlet\" onclick=\"onClick()\" ></td>\n					<td>\n						<p id=\"pText\" style=\"color: red;\"></p>\n					</td>\n				</tr>\n			</table>\n			\n			<input type=\"button\" id=\"regButton\" value=\"注册\" disabled=\"true\"/>\n		</form>\n	</body>\n\n</html>\n```', 0, 0, '2020-08-07 14:25:59', 2, 0, 1, '使用技术：JSP + Ajax\n随机生成验证码，动态验证。\n功能：随机生成验证码，存入会话，生成验证码图片，供输入验证，\n若验证成功，提示：验证码输入成功，并且将注册按钮启用；\n若验证失败，提示：验证码输入错误，并且将注册按钮禁用，并且在会话中删除缓存的验证码数据。\n若会话中没有存储验证码数据，则提醒：验证码已失效，点击刷新。\n验证码点击可以刷新\n1、验证码输入成功\n\n2、验证码输入失败\n\n验证码输入失败\n3、验证码失效\n\n验证码失效\n代码：1、 随机生成验证码代码，VerificationCodeServlet.java：\npackage com.company.project.servlet;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.IOException;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.sun.prism.Image;@WebServlet(\"/verification-code-servlet\")public class VerificationCodeServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    //设置生成验证码的画布宽度    int w = 80;    //生成验证码的长度    int fontNum = 4;    //验证码字体大小    int fontSize = (w - 10) / fontNum;    //根据字体大小设置画布的高度    int h = (int) (fontSize * 1.5);    //初始化字符源    String charSource = \"abcdefghijklmnopqrstuvwxyxABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";    /**     * 随机生成验证码     * @param num 生成验证码的长度     * @return 验证码     */    public String randString(int num) {        String verCode = \"\";        for(int i = 0;i<num;i++) {            verCode += charSource.charAt((int)(Math.random()*charSource.length()));        }        System.out.println(\"verCode:\"+verCode);        return verCode;    }    public Color randColor() {        int r = (int)(Math.random() * 256);        int g = (int)(Math.random() * 256);        int b = (int)(Math.random() * 256);        Color color = new Color(r, g, b);        System.out.println(\"color:\"+color);        return color;    }    /**     * 随机生成一条直线     * @return 两点坐标(x1,y1)(x2,y2)     */    public int[] randLine() {        int x1,x2,y1,y2;        x1 = (int)(Math.random()*w);        x2 = (int)(Math.random()*w);        y1 = (int)(Math.random()*h);        y2 = (int)(Math.random()*h);        int[] result = {x1,y1,x2,y2};        return result;    }    public VerificationCodeServlet() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        //初始化画布        BufferedImage canvas = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);        //初始化画笔对象        Graphics pen = canvas.getGraphics();        //设置画笔颜色        pen.setColor(Color.WHITE);        //画一个填充矩形        pen.fillRect(0, 0, w, h);        //设置画笔颜色        pen.setColor(Color.black);        //画出边框        pen.drawRect(0, 0, w-1, h-1);        //设置画笔字体样式        pen.setFont(new Font(\"微软雅黑\", Font.BOLD, fontSize));        //生成验证码字符串        String verCode = randString(fontNum);        //将生成的验证码存入会话        request.getSession().setAttribute(\"verCode\", verCode);        //绘制随机验证码        for(int i = 0;i<verCode.length();i++) {            pen.setColor(randColor());            pen.drawString(String.valueOf(verCode.charAt(i)), 10 + i * 15, (h + fontSize) /2);        }        //绘制一条随机直线        int[] line = randLine();          for(int i = 0;i<line.length;i++) {            System.out.println(line[i]);        }        //设置画笔字体样式        pen.setColor(Color.BLACK);        //画出随机直线        pen.drawLine(line[0],line[1],line[2],line[3]);        //获取输出流对象        ServletOutputStream out = response.getOutputStream();        //把画好的验证码写入输出流        ImageIO.write(canvas, \"png\", out);        //释放输出流        out.flush();        out.close();    }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    }}\n2、验证码认证，VerifyServlet.java\npackage com.company.project.servlet;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(\"/verify-servlet\")public class VerifyServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    public VerifyServlet() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        response.setContentType(\"text/html;charset=utf-8\");        response.setCharacterEncoding(\"utf-8\");        request.setCharacterEncoding(\"utf-8\");        String verCode = request.getParameter(\"verCode\");        System.out.println(\"-----------------\");        String flag = null ;        String code = (String) request.getSession().getAttribute(\"verCode\");        if(code==null) {            //验证码失效            flag = \"0\";        }        else if(verCode.toUpperCase().equals(code.toUpperCase())) {            //验证码输入正确            flag = \"1\";        }else {            //验证码输入失败            flag = \"2\";            request.getSession().removeAttribute(\"verCode\");        }                PrintWriter out=response.getWriter();        out.print(flag);    }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // TODO Auto-generated method stub        doGet(request, response);    }}3、验证码页面，verCode.jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>登录</title>        <script>            var baseUrl = \"http://localhost:8888/JavaEE17Demo/verify-servlet\";            var xmlHttp;            var responseText;            var onBlurId;            var code;                    //创建创建 XMLHttp 对象            function createXmlHttp(name, value) {                if(window.ActiveXObject) {                    console.log(\"操作提示：您的浏览器是IE浏览器。\");                    xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\");                } else if(window.XMLHttpRequest) {                    console.log(\"操作提示：您的浏览器不是IE浏览器。\");                    xmlHttp = new XMLHttpRequest();                }                //注册监听或者回调函数                xmlHttp.onreadystatechange = callback;                //1:打开状态                //传递参数                var url = baseUrl + \"?\" + name + \"=\" + value;                //GET方法打开,第三个参数如果为true,那么为异步请求,将不会刷新整个页面.                xmlHttp.open(\"GET\", url, true);                //2:发送状态                //Get方式的send()                xmlHttp.send(null);            }            //回调函数，处理响应信息            function callback() {                //获取响应内容                if(xmlHttp.readyState == 4) {                    if(xmlHttp.status == 200) {                        responseText = xmlHttp.responseText;                        console.log(responseText);                        var pText = document.getElementById(\"pText\");                        var button = document.getElementById(\"regButton\");                        if(responseText == \"0\") {                            pText.style.color = \"red\";                            button.disabled = true;                            pText.innerHTML=\"验证码已失效，点击刷新\";                        } else if(responseText == \"1\") {                            pText.style.color = \"green\";                            button.disabled = false;                            pText.innerHTML=\"验证码输入成功\";                        }else{                            pText.style.color = \"red\";                            button.disabled = true;                            pText.innerHTML=\"验证码输入失败\";                        }                    }                }            }            //通过处理后的响应信息修改提醒文本            function setResponseText(text) {                var id;                var responseText;            }            //重写失去焦点事件            function onBlur(id) {                var module = document.getElementById(id);                var name = module.name;                var value = module.value;                //var url = baseUrl + \"?\" + name + \"=\" + value;                onBlurId = id;                console.log(name + \"失去焦点\");                console.log(name + \":\" + value);                createXmlHttp(name, value);            }            function onClick(){                var id = Math.floor(Math.random()*10);                code = document.getElementById(\"verCodeImg\");                console.log(code);                code.src = \"http://localhost:8888/JavaEE17Demo/verification-code-servlet\"+\"?id=\"+id;                console.log(code.src);            }        </script>    </head>    <body>        <form id=\"Login\" action=\"\" method=\"post\">            <table>                <tr>                    <td>邮箱：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input name=\"e-mail\" id=\"e-mail\" type=\"text\"  /></td>                    <td>                        <p id=\"pText1\" style=\"color: red;\"></p>                    </td>                </tr>                <tr>                    <td>手机号： <input name=\"phoneNum\" type=\"text\" id=\"phoneNum\"  /></td>                    <td>                        <p id=\"pText2\" style=\"color: red;\"></p>                    </td>                </tr>                <tr>                    <td>验证码： <input type=\"text\"  id=\"verCode\" name=\"verCode\" onblur=\"onBlur(id)\"/></td>                    <td><img id=\"verCodeImg\" alt=\"随机生成验证码\" src=\"http://localhost:8888/JavaEE17Demo/verification-code-servlet\" onclick=\"onClick()\" ></td>                    <td>                        <p id=\"pText\" style=\"color: red;\"></p>                    </td>                </tr>            </table>            <input type=\"button\" id=\"regButton\" value=\"注册\" disabled=\"true\"/>        </form>    </body></html>\n', 0, 1);
INSERT INTO `t_article` VALUES (170, '17.《JavaEE 学习笔记》Servlet 上传文件', 8, '> 参考链接：https://www.runoob.com/servlet/servlet-file-uploading.html\n\n## 功能介绍：\n\n利用 Servlet 和表单提交，选择本地文件上传到服务器。上传的文件可以是文本文件或图像文件或任何文档，不能是文件夹。\n\n需要引入的 jar 文件：commons-fileupload-1.3.2、commons-io-2.5.jar。\n\n**下载链接：**\n\n- **commons-fileupload.x.x.jar** 文件：http://commons.apache.org/proper/commons-fileupload/ \n- **commons-io-x.x.jar** 文件： http://commons.apache.org/proper/commons-io/ 下载。\n\n将下载好的jar包复制到项目/WebContent/WEB-INF/lib 文件夹下：\n\n![img](https://pic4.zhimg.com/v2-4bf014ec829aaf3591c43985489017b7_b.png)\n\n## 实现代码：\n\nfileUpload.jsp:文件上传的界面页\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>文件上传</title>\n</head>\n<body>\n<h1>文件上传</h1>\n<form action=\"/JavaEE17ToolDemo/file-upload-servlet\" method=\"post\" enctype=\"multipart/form-data\">\n	选择一个文件：\n	<input type=\"file\" name=\"file\" value=\"\" />\n	<br/>\n	<input type=\"submit\" value=\"上传\">\n</form>\n\n</body>\n</html>\n```\n\nFileUploadServlet.java:文件上传处理\n\n```java\npackage com.company.project.servlet.fileupload;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n@WebServlet(\"/file-upload-servlet\")\npublic class FileUploadServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n\n	// 文件上传的存储路径\n	private static final String SAVE_PATH = \"file-upload\";\n\n	// 上传配置\n	// 配置内存临界值\n	private static final int MEMORY_THRESHOLD = 1024 * 1024 * 3; // 3MB\n	// 配置最大文件大小\n	private static final int MAX_FILE_SIZE = 1024 * 1024 * 40; // 40MB\n	// 配置请求大小\n	private static final int MAX_REQUEST_SIZE = 1024 * 1024 * 50; // 50MB\n\n	public FileUploadServlet() {\n		super();\n	}\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		doPost(request, response);\n	}\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		// 检测是否为多媒体文件\n		if (!ServletFileUpload.isMultipartContent(request)) {\n			// 如果不是则停止\n			PrintWriter out = response.getWriter();\n			out.println(\"表单必须包含 enctype=multipart/form-data\");\n			out.flush();\n			out.close();\n			return;\n		}\n\n		// 配置上传参数\n		DiskFileItemFactory factory = new DiskFileItemFactory();\n\n		// 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中\n		factory.setSizeThreshold(MEMORY_THRESHOLD);\n\n		ServletFileUpload upload = new ServletFileUpload(factory);\n\n		// 设置上传文件最大值\n		upload.setFileSizeMax(MAX_FILE_SIZE);\n\n		// 设置最大请求值(包含文件和表单数据)\n		upload.setSizeMax(MAX_REQUEST_SIZE);\n\n		// 中文处理\n		upload.setHeaderEncoding(\"UTF-8\");\n\n		// 创建保存路径\n		String uploadPath = request.getServletContext().getRealPath(\"./\") + File.separator + SAVE_PATH;\n\n		// 如果路径不存在则创建\n		File uploadDir = new File(uploadPath);\n		if (!uploadDir.exists()) {\n			uploadDir.mkdir();\n		}\n\n		try {\n			@SuppressWarnings(\"unchecked\")\n			List<FileItem> formItems = upload.parseRequest(request);\n			if (formItems != null && formItems.size() > 0) {\n				//迭代表单数据\n				for (FileItem fileItem : formItems) {\n					//处理不在表单的字段\n					if(!fileItem.isFormField()) {\n						String fileName = new File(fileItem.getName()).getName();\n						String filePath = uploadPath + File.separator + fileName;\n						File storeFile = new File(filePath);\n						// 在控制台输出文件的上传路径\n                        System.out.println(filePath);\n                        // 保存文件到硬盘\n                        fileItem.write(storeFile);\n                        request.setAttribute(\"message\",\n                            \"文件上传成功!\");\n					}\n				}\n			}\n\n		} catch (FileUploadException e) {\n			// TODO Auto-generated catch block\n			e.printStackTrace();\n		} catch (Exception e) {\n			request.setAttribute(\"message\",\n                    \"错误信息: \" + e.getMessage());\n		}\n\n		//文件上传完成跳转\n		request.getServletContext().getRequestDispatcher(\"/page/UploadMes.jsp\").forward(request, response);\n	}\n}\n```\n\nUploadMes.jsp:文件传输完成跳转页\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>文件上传结果</title>\n</head>\n<body>\n<center>\n	<h2>${message }</h2>\n</center>\n\n</body>\n</html>\n```\n\n**效果图：**\n\n![img](https://pic1.zhimg.com/v2-136dad5957f706968b771e848814236c_b.png)\n\n![img](https://pic3.zhimg.com/v2-1f1f63b3b54d5ed965683f4aa7f421da_b.png)\n\n![img](https://pic4.zhimg.com/v2-3c7bba679fae4c9a62e78691906edb07_b.png)', 0, 0, '2020-08-07 14:26:33', 2, 0, 1, '\n参考链接：https://www.runoob.com/servlet/servlet-file-uploading.html\n\n功能介绍：利用 Servlet 和表单提交，选择本地文件上传到服务器。上传的文件可以是文本文件或图像文件或任何文档，不能是文件夹。\n需要引入的 jar 文件：commons-fileupload-1.3.2、commons-io-2.5.jar。\n下载链接：\n\ncommons-fileupload.x.x.jar 文件：http://commons.apache.org/proper/commons-fileupload/ commons-io-x.x.jar 文件： http://commons.apache.org/proper/commons-io/ 下载。\n将下载好的jar包复制到项目/WebContent/WEB-INF/lib 文件夹下：\n\n实现代码：fileUpload.jsp:文件上传的界面页\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>文件上传</title></head><body><h1>文件上传</h1><form action=\"/JavaEE17ToolDemo/file-upload-servlet\" method=\"post\" enctype=\"multipart/form-data\">    选择一个文件：    <input type=\"file\" name=\"file\" value=\"\" />    <br/>    <input type=\"submit\" value=\"上传\"></form></body></html>\nFileUploadServlet.java:文件上传处理\npackage com.company.project.servlet.fileupload;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;@WebServlet(\"/file-upload-servlet\")public class FileUploadServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    // 文件上传的存储路径    private static final String SAVE_PATH = \"file-upload\";    // 上传配置    // 配置内存临界值    private static final int MEMORY_THRESHOLD = 1024 * 1024 * 3; // 3MB    // 配置最大文件大小    private static final int MAX_FILE_SIZE = 1024 * 1024 * 40; // 40MB    // 配置请求大小    private static final int MAX_REQUEST_SIZE = 1024 * 1024 * 50; // 50MB    public FileUploadServlet() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        doPost(request, response);    }    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        // 检测是否为多媒体文件        if (!ServletFileUpload.isMultipartContent(request)) {            // 如果不是则停止            PrintWriter out = response.getWriter();            out.println(\"表单必须包含 enctype=multipart/form-data\");            out.flush();            out.close();            return;        }        // 配置上传参数        DiskFileItemFactory factory = new DiskFileItemFactory();        // 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中        factory.setSizeThreshold(MEMORY_THRESHOLD);        ServletFileUpload upload = new ServletFileUpload(factory);        // 设置上传文件最大值        upload.setFileSizeMax(MAX_FILE_SIZE);        // 设置最大请求值(包含文件和表单数据)        upload.setSizeMax(MAX_REQUEST_SIZE);        // 中文处理        upload.setHeaderEncoding(\"UTF-8\");        // 创建保存路径        String uploadPath = request.getServletContext().getRealPath(\"./\") + File.separator + SAVE_PATH;        // 如果路径不存在则创建        File uploadDir = new File(uploadPath);        if (!uploadDir.exists()) {            uploadDir.mkdir();        }        try {            @SuppressWarnings(\"unchecked\")            List<FileItem> formItems = upload.parseRequest(request);            if (formItems != null && formItems.size() > 0) {                //迭代表单数据                for (FileItem fileItem : formItems) {                    //处理不在表单的字段                    if(!fileItem.isFormField()) {                        String fileName = new File(fileItem.getName()).getName();                        String filePath = uploadPath + File.separator + fileName;                        File storeFile = new File(filePath);                        // 在控制台输出文件的上传路径                        System.out.println(filePath);                        // 保存文件到硬盘                        fileItem.write(storeFile);                        request.setAttribute(\"message\",                            \"文件上传成功!\");                    }                }            }        } catch (FileUploadException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } catch (Exception e) {            request.setAttribute(\"message\",                    \"错误信息: \" + e.getMessage());        }        //文件上传完成跳转        request.getServletContext().getRequestDispatcher(\"/page/UploadMes.jsp\").forward(request, response);    }}\nUploadMes.jsp:文件传输完成跳转页\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>文件上传结果</title></head><body><center>    <h2>${message }</h2></center></body></html>\n效果图：\n\n\n\n', 0, 1);
INSERT INTO `t_article` VALUES (171, '18.实现网站上选择本地图片并上传至服务器', 8, '## 功能介绍：\n\n本地选择照片上传至服务器。\n\n需要引入的 jar 文件：commons-fileupload-1.3.2、commons-io-2.5.jar。\n\n**下载链接：**\n\n- **commons-fileupload.x.x.jar** 文件：http://commons.apache.org/proper/commons-fileupload/ \n- **commons-io-x.x.jar** 文件： http://commons.apache.org/proper/commons-io/ 下载。\n\n将下载好的jar包复制到项目/WebContent/WEB-INF/lib 文件夹下：\n\n![img](https://pic4.zhimg.com/v2-4bf014ec829aaf3591c43985489017b7_b.png)\n\n##  实现代码：\n\nfileUpload2.jsp:图片上传的界面页\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n<link type=\"text/css\" rel=\"stylesheet\" href=\"../css/fileUpload2.css\" />\n</head>\n<body >\n<form action=\"/JavaEE17ToolDemo/file-upload-servlet\" method=\"post\" enctype=\"multipart/form-data\">\n<img alt=\"\" id=\"img1\" src=\"\" style=\"height:300px;width: 200px\">\n<a class=\"a-upload\">\n  <input type=\"file\" name=\"file\" id=\"fileField\" onchange=\"document.getElementById(\'img1\').src=document.getElementById(\'fileField\').value\">点击这里上传文件\n</a>\n<br/>\n	<input type=\"submit\" value=\"上传\">\n</form>\n</body>\n</html>\n```\n\nfileUpload2.css： css文件\n\n```css\n@charset \"UTF-8\";\n\nbody{\n	background-color: skyblue;\n}\n\n#img1{\n	background-color: white;\n}\n\n.a-upload {\n    padding: 4px 10px;\n    height: 20px;\n    line-height: 20px;\n    position: relative;\n    cursor: pointer;\n    color: #888;\n    background: #fafafa;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    overflow: hidden;\n    display: inline-block;\n    *display: inline;\n    *zoom: 1\n}\n\n#img1{\n	width:100px;\n	height:100px;\n}\n\n.a-upload  input {\n    position: absolute;\n    font-size: 100px;\n    right: 0;\n    top: 0;\n    opacity: 0;\n    filter: alpha(opacity=0);\n    cursor: pointer\n}\n\n.a-upload:hover {\n    color: #444;\n    background: #eee;\n    border-color: #ccc;\n    text-decoration: none\n}\n\n.file {\n    position: relative;\n    display: inline-block;\n    background: #D0EEFF;\n    border: 1px solid #99D3F5;\n    border-radius: 4px;\n    padding: 4px 12px;\n    overflow: hidden;\n    color: #1E88C7;\n    text-decoration: none;\n    text-indent: 0;\n    line-height: 20px;\n}\n.file input {\n    position: absolute;\n    font-size: 100px;\n    right: 0;\n    top: 0;\n    opacity: 0;\n}\n.file:hover {\n    background: #AADFFD;\n    border-color: #78C3F3;\n    color: #004974;\n    text-decoration: none;\n}\n```\n\nFileUploadServlet.java:文件上传处理\n\n```java\npackage com.company.project.servlet.fileupload;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n@WebServlet(\"/file-upload-servlet\")\npublic class FileUploadServlet extends HttpServlet {\n	private static final long serialVersionUID = 1L;\n\n	// 文件上传的存储路径\n	private static final String SAVE_PATH = \"imag\";\n\n	// 上传配置\n	// 配置内存临界值\n	private static final int MEMORY_THRESHOLD = 1024 * 1024 * 3; // 3MB\n	// 配置最大文件大小\n	private static final int MAX_FILE_SIZE = 1024 * 1024 * 40; // 40MB\n	// 配置请求大小\n	private static final int MAX_REQUEST_SIZE = 1024 * 1024 * 50; // 50MB\n\n	public FileUploadServlet() {\n		super();\n	}\n\n	protected void doGet(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		doPost(request, response);\n	}\n\n	protected void doPost(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		// 检测是否为多媒体文件\n		if (!ServletFileUpload.isMultipartContent(request)) {\n			// 如果不是则停止\n			PrintWriter out = response.getWriter();\n			out.println(\"表单必须包含 enctype=multipart/form-data\");\n			out.flush();\n			out.close();\n			return;\n		}\n\n		// 配置上传参数\n		DiskFileItemFactory factory = new DiskFileItemFactory();\n\n		// 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中\n		factory.setSizeThreshold(MEMORY_THRESHOLD);\n\n		ServletFileUpload upload = new ServletFileUpload(factory);\n\n		// 设置上传文件最大值\n		upload.setFileSizeMax(MAX_FILE_SIZE);\n\n		// 设置最大请求值(包含文件和表单数据)\n		upload.setSizeMax(MAX_REQUEST_SIZE);\n\n		// 中文处理\n		upload.setHeaderEncoding(\"UTF-8\");\n\n		// 创建保存路径\n		String uploadPath = request.getServletContext().getRealPath(\"./\") + File.separator + SAVE_PATH;\n\n		// 如果路径不存在则创建\n		File uploadDir = new File(uploadPath);\n		if (!uploadDir.exists()) {\n			uploadDir.mkdir();\n		}\n\n		try {\n			@SuppressWarnings(\"unchecked\")\n			List<FileItem> formItems = upload.parseRequest(request);\n			if (formItems != null && formItems.size() > 0) {\n				//迭代表单数据\n				for (FileItem fileItem : formItems) {\n					//处理不在表单的字段\n					if(!fileItem.isFormField()) {\n						String fileName = new File(fileItem.getName()).getName();\n						String filePath = uploadPath + File.separator + fileName;\n						File storeFile = new File(filePath);\n						// 在控制台输出文件的上传路径\n                        System.out.println(filePath);\n                        // 保存文件到硬盘\n                        fileItem.write(storeFile);\n                        request.setAttribute(\"message\",\n                            \"文件上传成功!\");\n					}\n				}\n			}\n\n		} catch (FileUploadException e) {\n			// TODO Auto-generated catch block\n			e.printStackTrace();\n		} catch (Exception e) {\n			request.setAttribute(\"message\",\n                    \"错误信息: \" + e.getMessage());\n		}\n\n		//文件上传完成跳转\n		request.getServletContext().getRequestDispatcher(\"/page/UploadMes.jsp\").forward(request, response);\n	}\n}\n```\n\nUploadMes.jsp:文件传输完成跳转页\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>文件上传结果</title>\n</head>\n<body>\n<center>\n	<h2>${message }</h2>\n</center>\n\n</body>\n</html>\n```\n\n', 0, 0, '2020-08-07 14:27:16', 2, 0, 1, '功能介绍：本地选择照片上传至服务器。\n需要引入的 jar 文件：commons-fileupload-1.3.2、commons-io-2.5.jar。\n下载链接：\n\ncommons-fileupload.x.x.jar 文件：http://commons.apache.org/proper/commons-fileupload/ commons-io-x.x.jar 文件： http://commons.apache.org/proper/commons-io/ 下载。\n将下载好的jar包复制到项目/WebContent/WEB-INF/lib 文件夹下：\n\n实现代码：fileUpload2.jsp:图片上传的界面页\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>Insert title here</title><link type=\"text/css\" rel=\"stylesheet\" href=\"../css/fileUpload2.css\" /></head><body ><form action=\"/JavaEE17ToolDemo/file-upload-servlet\" method=\"post\" enctype=\"multipart/form-data\"><img alt=\"\" id=\"img1\" src=\"\" style=\"height:300px;width: 200px\"><a class=\"a-upload\">  <input type=\"file\" name=\"file\" id=\"fileField\" onchange=\"document.getElementById(\'img1\').src=document.getElementById(\'fileField\').value\">点击这里上传文件</a><br/>    <input type=\"submit\" value=\"上传\"></form></body></html>\nfileUpload2.css： css文件\n@charset \"UTF-8\";body{    background-color: skyblue;}#img1{    background-color: white;}.a-upload {    padding: 4px 10px;    height: 20px;    line-height: 20px;    position: relative;    cursor: pointer;    color: #888;    background: #fafafa;    border: 1px solid #ddd;    border-radius: 4px;    overflow: hidden;    display: inline-block;    *display: inline;    *zoom: 1}#img1{    width:100px;    height:100px;}.a-upload  input {    position: absolute;    font-size: 100px;    right: 0;    top: 0;    opacity: 0;    filter: alpha(opacity=0);    cursor: pointer}.a-upload:hover {    color: #444;    background: #eee;    border-color: #ccc;    text-decoration: none}.file {    position: relative;    display: inline-block;    background: #D0EEFF;    border: 1px solid #99D3F5;    border-radius: 4px;    padding: 4px 12px;    overflow: hidden;    color: #1E88C7;    text-decoration: none;    text-indent: 0;    line-height: 20px;}.file input {    position: absolute;    font-size: 100px;    right: 0;    top: 0;    opacity: 0;}.file:hover {    background: #AADFFD;    border-color: #78C3F3;    color: #004974;    text-decoration: none;}\nFileUploadServlet.java:文件上传处理\npackage com.company.project.servlet.fileupload;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;@WebServlet(\"/file-upload-servlet\")public class FileUploadServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    // 文件上传的存储路径    private static final String SAVE_PATH = \"imag\";    // 上传配置    // 配置内存临界值    private static final int MEMORY_THRESHOLD = 1024 * 1024 * 3; // 3MB    // 配置最大文件大小    private static final int MAX_FILE_SIZE = 1024 * 1024 * 40; // 40MB    // 配置请求大小    private static final int MAX_REQUEST_SIZE = 1024 * 1024 * 50; // 50MB    public FileUploadServlet() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        doPost(request, response);    }    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        // 检测是否为多媒体文件        if (!ServletFileUpload.isMultipartContent(request)) {            // 如果不是则停止            PrintWriter out = response.getWriter();            out.println(\"表单必须包含 enctype=multipart/form-data\");            out.flush();            out.close();            return;        }        // 配置上传参数        DiskFileItemFactory factory = new DiskFileItemFactory();        // 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中        factory.setSizeThreshold(MEMORY_THRESHOLD);        ServletFileUpload upload = new ServletFileUpload(factory);        // 设置上传文件最大值        upload.setFileSizeMax(MAX_FILE_SIZE);        // 设置最大请求值(包含文件和表单数据)        upload.setSizeMax(MAX_REQUEST_SIZE);        // 中文处理        upload.setHeaderEncoding(\"UTF-8\");        // 创建保存路径        String uploadPath = request.getServletContext().getRealPath(\"./\") + File.separator + SAVE_PATH;        // 如果路径不存在则创建        File uploadDir = new File(uploadPath);        if (!uploadDir.exists()) {            uploadDir.mkdir();        }        try {            @SuppressWarnings(\"unchecked\")            List<FileItem> formItems = upload.parseRequest(request);            if (formItems != null && formItems.size() > 0) {                //迭代表单数据                for (FileItem fileItem : formItems) {                    //处理不在表单的字段                    if(!fileItem.isFormField()) {                        String fileName = new File(fileItem.getName()).getName();                        String filePath = uploadPath + File.separator + fileName;                        File storeFile = new File(filePath);                        // 在控制台输出文件的上传路径                        System.out.println(filePath);                        // 保存文件到硬盘                        fileItem.write(storeFile);                        request.setAttribute(\"message\",                            \"文件上传成功!\");                    }                }            }        } catch (FileUploadException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } catch (Exception e) {            request.setAttribute(\"message\",                    \"错误信息: \" + e.getMessage());        }        //文件上传完成跳转        request.getServletContext().getRequestDispatcher(\"/page/UploadMes.jsp\").forward(request, response);    }}\nUploadMes.jsp:文件传输完成跳转页\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%><!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title>文件上传结果</title></head><body><center>    <h2>${message }</h2></center></body></html>\n', 0, 1);
INSERT INTO `t_article` VALUES (172, '解决在eclipse上使用TomCat9.0后web.xml文件每次修改保存都会卡半天', 8, '首先，在web.xml文件中，如果保存出现卡死情况，一般有下面两种情况;\n\n1、web.xml 中TomCat的版本配置与本地的版本不符，JDK 的版本与Tomcat 版本不符，需要修改<web-app version=\"4.0\">\n\n- web.xml——version2.2——JDK1.1——Tomcat3.3\n- web.xml——version2.3——JDK1.3——Tomcat4.1\n- web.xml——version2.4——JDK1.4——Tomcat5.5\n- web.xml——version2.5——JDK5.0——Tomcat6.0\n- web.xml——version3.0——JDK6.0——Tomcat7.0\n- web.xml——version3.1——JDK7.0——Tomcat8.0,Tomcat8.5\n- web.xml——version4.0——JDK8.0——Tomcat9.0\n\n如下修改：\n\n修改前的web.xml：将version配置为相应版本\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee;http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"3.1\">\n```\n\n修改后：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee;http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\">\n```\n\n2、在使用TomCat9.0版本，上述配置正确的情况下，还是会出现卡死，研究了一下发现了一个小细节，在自动生成的web.xml 中，源代码如下：\n\n```xml\n <web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"Java EE: XML Schemas for Java EE Deployment Descriptors\" xsi:schemaLocation=\"Java EE: XML Schemas for Java EE Deployment Descriptors http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\">\n```\n\n我们只需要在xsi:schemaLocation=\"[Java EE: XML Schemas for Java EE Deployment Descriptors](http://xmlns.jcp.org/xml/ns/javaee) http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"，把两个网站中间的空格改成分号；即可解决问题。\n\n修改后的web.xml\n\n```xml\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee;http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\">\n```\n\n以上就是解决方法，希望可以帮到你！！！\n\n> 越努力，越幸运 我们亦是拾光者！！！', 0, 0, '2020-08-07 14:27:43', 2, 0, 1, '首先，在web.xml文件中，如果保存出现卡死情况，一般有下面两种情况;\n1、web.xml 中TomCat的版本配置与本地的版本不符，JDK 的版本与Tomcat 版本不符，需要修改<web-app version=\"4.0\">\n\nweb.xml——version2.2——JDK1.1——Tomcat3.3web.xml——version2.3——JDK1.3——Tomcat4.1web.xml——version2.4——JDK1.4——Tomcat5.5web.xml——version2.5——JDK5.0——Tomcat6.0web.xml——version3.0——JDK6.0——Tomcat7.0web.xml——version3.1——JDK7.0——Tomcat8.0,Tomcat8.5web.xml——version4.0——JDK8.0——Tomcat9.0\n如下修改：\n修改前的web.xml：将version配置为相应版本\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee;http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"3.1\">\n修改后：\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee;http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\">\n2、在使用TomCat9.0版本，上述配置正确的情况下，还是会出现卡死，研究了一下发现了一个小细节，在自动生成的web.xml 中，源代码如下：\n <web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"Java EE: XML Schemas for Java EE Deployment Descriptors\" xsi:schemaLocation=\"Java EE: XML Schemas for Java EE Deployment Descriptors http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\">\n我们只需要在xsi:schemaLocation=”Java EE: XML Schemas for Java EE Deployment Descriptors http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"，把两个网站中间的空格改成分号；即可解决问题。\n修改后的web.xml\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee;http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\">\n以上就是解决方法，希望可以帮到你！！！\n\n越努力，越幸运 我们亦是拾光者！！！\n\n', 0, 1);
INSERT INTO `t_article` VALUES (173, 'Servlet使用请求转发到JSP导致前端页面css样式丢失解决办法', 8, '## 1. 问题描述：\n\n在jsp中通常，第一遍运行的时候页面的css都是好的，然后再通过请求转发过来，css样式表就会丢失。\n\njsp中的加载css的代码：\n\n```jsp\n<link rel=\"stylesheet\" href=\"../css/all.css\" />\n```\n\n直接运行：css样式正常，界面也可以显示出来\n\n![img](https://pic3.zhimg.com/v2-820bd9a75186d4ce87b71d1b523c82f6_b.png)\n\n如果通过请求转发，就会出现css样式表丢失\n\n![img](https://pic1.zhimg.com/v2-e03125ca9329ff295b29f1f5cd714bc4_b.png)\n\n## 2. 分析原因：\n\n（1）我们用浏览器打开这个链接，查看样式编辑器\n\n![img](https://pic2.zhimg.com/v2-b7a1b956b7cb8d52c92c8042c4ad9bf1_b.png)\n\n（2）找到all.css，复制网址，查看一下\n\n![img](https://pic4.zhimg.com/v2-1d5673bec21fbfe04c703537eee36cc7_b.png)\n\n（3）结果发现找不到路径\n\n![img](https://pic4.zhimg.com/v2-e5c83a8d770cf7fcf2e1a2c5ff9c93e3_b.png)\n\n我们通过观察可以发现，请求转发的访问地址还是之前servlet的地址，所以，如果在http://localhost:8888/JavaEE06JDBCTest/user-register-servlet 下运行jsp界面，就会出现css丢失，原因是我们在导入css的语句 **href=\"../css/all.css\" /**  ,    ../是返回上一层文件夹，所以如果在这里再这样使用就会导致找不到路径，所以就会出现css样表丢失\n\n## 3. 解决方法：\n\n**我们可以修改jsp的css的路径，把之前的相对路径改成绝对路径，下次不管在那块调用都不会出现路径丢失。**\n\n例如：我的css的绝对路径是http://localhost:8888/JavaEE06JDBCTest/css/all.css \n\n![img](https://pic3.zhimg.com/v2-0bad0e4b91cdb705418fa879db4a4d5a_b.png)\n\n其中前面的http://localhost:8888/JavaEE06JDBCTest/都可以通过一些方法得到，我们只需要在后面添加，在WebContent文件夹下面的css文件的路径，不包括WebContent，直接添加\"css/all.css\"就可以直接绝对定位到css文件，从而解决上述问题。\n\n在jsp中添加代码获取css的绝对路径：（其中basePath 最后面的\"/css/all.css\"，根据自己项目的结构添加）\n\n```jsp\n<%\nString path = request.getContextPath();\nString basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/css/all.css\";\n%>\n\n<link rel=\"stylesheet\" href=\"<%=basePath%>\" />\n```\n\n这样我们就可以解决路径找不到的问题，举一反三，以后遇到这种路径问题，可以通过上述方法直接定位到绝对路径。\n\n送自己一句话： **千金一刻，我们亦是拾光者！！！**', 0, 0, '2020-08-07 14:28:09', 2, 0, 1, '1. 问题描述：在jsp中通常，第一遍运行的时候页面的css都是好的，然后再通过请求转发过来，css样式表就会丢失。\njsp中的加载css的代码：\n<link rel=\"stylesheet\" href=\"../css/all.css\" />\n直接运行：css样式正常，界面也可以显示出来\n\n如果通过请求转发，就会出现css样式表丢失\n\n2. 分析原因：（1）我们用浏览器打开这个链接，查看样式编辑器\n\n（2）找到all.css，复制网址，查看一下\n\n（3）结果发现找不到路径\n\n我们通过观察可以发现，请求转发的访问地址还是之前servlet的地址，所以，如果在http://localhost:8888/JavaEE06JDBCTest/user-register-servlet 下运行jsp界面，就会出现css丢失，原因是我们在导入css的语句 href=”../css/all.css” /  ,    ../是返回上一层文件夹，所以如果在这里再这样使用就会导致找不到路径，所以就会出现css样表丢失\n3. 解决方法：我们可以修改jsp的css的路径，把之前的相对路径改成绝对路径，下次不管在那块调用都不会出现路径丢失。\n例如：我的css的绝对路径是http://localhost:8888/JavaEE06JDBCTest/css/all.css \n\n其中前面的http://localhost:8888/JavaEE06JDBCTest/都可以通过一些方法得到，我们只需要在后面添加，在WebContent文件夹下面的css文件的路径，不包括WebContent，直接添加\"css/all.css\"就可以直接绝对定位到css文件，从而解决上述问题。\n在jsp中添加代码获取css的绝对路径：（其中basePath 最后面的”/css/all.css”，根据自己项目的结构添加）\n<%String path = request.getContextPath();String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/css/all.css\";%><link rel=\"stylesheet\" href=\"<%=basePath%>\" />\n这样我们就可以解决路径找不到的问题，举一反三，以后遇到这种路径问题，可以通过上述方法直接定位到绝对路径。\n送自己一句话： 千金一刻，我们亦是拾光者！！！\n', 0, 1);
INSERT INTO `t_article` VALUES (174, '01、jQuery 简介', 8, 'jQuery 是一个 JavaScript 库。\n\njQuery 极大地简化了 JavaScript 编程。\n\n**先来感受一下jQuery的魅力：**\n\n**之前的js处理：**\n\n```html\n<!DOCTYPE html>\n<!--\n	作者：2584966199@qq.com\n	时间：2020-05-28\n	描述：利用js给按钮添加事件\n-->\n<html>\n\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			div {\n				width: 200px;\n				height: 200px;\n			}\n		</style>\n		<script>\n			\n			//入口函数\n			window.onload = function() {\n				var btnOne = document.getElementById(\"btnOne\");\n				var btnTwo = document.getElementById(\"btnTwo\");\n				var divs = document.getElementsByTagName(\"div\");\n				console.log(btnOne);\n				btnOne.onclick = function() {\n					for(var i = 0; i < divs.length; i++) {\n						divs[i].style.border = \'1px solid red\';\n					}\n				}\n\n				btnTwo.onclick = function() {\n					for(var i = 0; i < divs.length; i++) {\n						divs[i].innerText = \"我是设置的文本\";\n					}\n				}\n			}\n	\n			//只能有一个入口函数	\n//			window.onload = function(){\n//				console.log(\"我又是一个入口函数\");\n//			}\n\n\n		</script>\n	</head>\n\n	<body>\n		<input type=\"button\" value=\"设置边框\" id=\"btnOne\" />\n		<input type=\"button\" value=\"设置文本\" id=\"btnTwo\" />\n		<div></div>\n		<div></div>\n		<div></div>\n	</body>\n\n</html>\n```\n\n \n\n### 原生 js 的缺点：\n\n- 只能有一个入口函数，后面的会把前面的覆盖掉\n- 原生js的api名字太长\n- 原生js有的时候代码冗余\n- 原生js的api有兼容问题\n- 原生js的容错率比较低，前面代码出问题，后面的代码执行不了\n\n\n\n**现在使用 jQuery 处理：**\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>jQuery解决上述问题</title>\n		<style>\n			div {\n				width: 200px;\n				height: 200px;\n			}\n		</style>	\n	</head>\n		<body>\n		<input type=\"button\" value=\"设置边框\" id=\"btnOne\" />\n		<input type=\"button\" value=\"设置文本\" id=\"btnTwo\" />\n		<div></div>\n		<div></div>\n		<div></div>\n	</body>\n</html>\n\n\n\n<script src=\"js/jQuery.js\"></script>\n<script>\n	//入口函数\n	$(document).ready(function(){\n		//设置边框\n		$(\'#btnOne\').click(function(){\n			$(\'div\').css(\'border\',\'1px solid red\');\n		})\n		\n		//设置文本\n		$(\'#btnTwo\').click(function(){\n			$(\'div\').text(\"我是设置的文本\");\n		})\n	});\n	\n	//入口函数\n	$(document).ready(function(){\n		console.log(\"我又是一个入口函数\");\n	})\n		\n</script>\n```\n\n\n\n### jQuery 的优点：\n\n- 是可以有多个入口函数\n- jQuery的api名字简单\n- jQuery代码简洁（隐式迭代）\n- jQuery帮我们解决浏览器兼容问题\n- 容错率较高，前面代码出现问题，后面代码不受影响', 0, 0, '2020-08-07 14:46:24', 6, 0, 1, 'jQuery 是一个 JavaScript 库。\njQuery 极大地简化了 JavaScript 编程。\n先来感受一下jQuery的魅力：\n之前的js处理：\n<!DOCTYPE html><!--    作者：2584966199@qq.com    时间：2020-05-28    描述：利用js给按钮添加事件--><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            div {                width: 200px;                height: 200px;            }        </style>        <script>            //入口函数            window.onload = function() {                var btnOne = document.getElementById(\"btnOne\");                var btnTwo = document.getElementById(\"btnTwo\");                var divs = document.getElementsByTagName(\"div\");                console.log(btnOne);                btnOne.onclick = function() {                    for(var i = 0; i < divs.length; i++) {                        divs[i].style.border = \'1px solid red\';                    }                }                btnTwo.onclick = function() {                    for(var i = 0; i < divs.length; i++) {                        divs[i].innerText = \"我是设置的文本\";                    }                }            }            //只能有一个入口函数    //            window.onload = function(){//                console.log(\"我又是一个入口函数\");//            }        </script>    </head>    <body>        <input type=\"button\" value=\"设置边框\" id=\"btnOne\" />        <input type=\"button\" value=\"设置文本\" id=\"btnTwo\" />        <div></div>        <div></div>        <div></div>    </body></html>\n原生 js 的缺点：\n只能有一个入口函数，后面的会把前面的覆盖掉原生js的api名字太长原生js有的时候代码冗余原生js的api有兼容问题原生js的容错率比较低，前面代码出问题，后面的代码执行不了\n现在使用 jQuery 处理：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>jQuery解决上述问题</title>        <style>            div {                width: 200px;                height: 200px;            }        </style>        </head>        <body>        <input type=\"button\" value=\"设置边框\" id=\"btnOne\" />        <input type=\"button\" value=\"设置文本\" id=\"btnTwo\" />        <div></div>        <div></div>        <div></div>    </body></html><script src=\"js/jQuery.js\"></script><script>    //入口函数    $(document).ready(function(){        //设置边框        $(\'#btnOne\').click(function(){            $(\'div\').css(\'border\',\'1px solid red\');        })        //设置文本        $(\'#btnTwo\').click(function(){            $(\'div\').text(\"我是设置的文本\");        })    });    //入口函数    $(document).ready(function(){        console.log(\"我又是一个入口函数\");    })</script>\njQuery 的优点：\n是可以有多个入口函数jQuery的api名字简单jQuery代码简洁（隐式迭代）jQuery帮我们解决浏览器兼容问题容错率较高，前面代码出现问题，后面代码不受影响\n', 0, 1);
INSERT INTO `t_article` VALUES (175, '02、如何使用 jQuery', 8, '### 使用步骤：\n\n1. 从 [jquery.com](http://jquery.com/download/) 下载 jQuery 库\n2. 在html文件中引入jQuery文件\n3. 先写一个入口函数\n4. 找到你要操作的元素（jQuery 选择器）\n5. 去操作他的属性，样式\n\n\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n	</head>\n	<body>\n		<div></div>\n	</body>\n</html>\n\n<script src=\"js/jQuery3.5.1.js\">	</script>\n\n<script>\n	//如何使用jQuery?\n		//1.引入jQuery文件\n		//2.先写一个入口函数\n		//3.找到你要操作的元素（jQuery 选择器）\n		//4.去操作他的属性，样式\n	\n	$(document).ready(function(){\n		//链式编程\n		$(\'div\').width(100).height(100).css(\'backgroundColor\',\'red\').text(\'呵呵\');\n	})\n	\n</script>\n```\n\n', 0, 0, '2020-08-07 15:05:11', 8, 0, 1, '使用步骤：\n从 jquery.com 下载 jQuery 库在html文件中引入jQuery文件先写一个入口函数找到你要操作的元素（jQuery 选择器）去操作他的属性，样式\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>    </head>    <body>        <div></div>    </body></html><script src=\"js/jQuery3.5.1.js\">    </script><script>    //如何使用jQuery?        //1.引入jQuery文件        //2.先写一个入口函数        //3.找到你要操作的元素（jQuery 选择器）        //4.去操作他的属性，样式    $(document).ready(function(){        //链式编程        $(\'div\').width(100).height(100).css(\'backgroundColor\',\'red\').text(\'呵呵\');    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (176, '03、jQuery 入口函数', 8, '### jQuery 入口函数有两种写法：\n\n两种写法效果是一样的\n\n（1）\n\n```js\n$(document).ready(function(){\n		\n});\n```\n\n（2）\n\n```js\n$(function(){\n		\n});\n```\n\n\n\n### jQuery入口函数与window.onload的区别\n\n(1) 可执行次数不同：\n\n- window.onload入口函数不能写多个，但是jQuery的入口函数是可以写多个的。\n- JQuery的方式相当于页面加载的事件,可以执行多次.效率比window.onload要高.\n\n(2) 执行时机不同：\n\n- windows onload方法是在网页中所有的元素（包括元素的所有关联文件）完全加载到浏览器后才执行，即JavaScript此时才可以访问网页中的任何元素。\n- jQuery中的$（document）.ready（）方法注册的时间处理程序， 在DOM完全就绪时就可以被调用。此时，网页的所有元素对jQuery而言都是可以访问的，但是，这并不意味着这些元素关联的文件都已经下载完毕。', 0, 0, '2020-08-07 15:04:47', 2, 0, 1, 'jQuery 入口函数有两种写法：两种写法效果是一样的\n（1）\n$(document).ready(function(){});\n（2）\n$(function(){});\njQuery入口函数与window.onload的区别(1) 可执行次数不同：\n\nwindow.onload入口函数不能写多个，但是jQuery的入口函数是可以写多个的。JQuery的方式相当于页面加载的事件,可以执行多次.效率比window.onload要高.\n(2) 执行时机不同：\n\nwindows onload方法是在网页中所有的元素（包括元素的所有关联文件）完全加载到浏览器后才执行，即JavaScript此时才可以访问网页中的任何元素。jQuery中的$（document）.ready（）方法注册的时间处理程序， 在DOM完全就绪时就可以被调用。此时，网页的所有元素对jQuery而言都是可以访问的，但是，这并不意味着这些元素关联的文件都已经下载完毕。\n', 0, 1);
INSERT INTO `t_article` VALUES (177, '04、$ 函数', 8, '### $ 是什么？\n\n（1）如果报了错误：$ is not defined,就说明没有引入jQuery文件\n\n（2）jQuery文件结构：\n\n- jQuery 其实是一个自执行函数\n- window.jQuery = window.$ = jQuery;\n\n（3）jQuery 的源码刨析\n\n- 引入一个js文件，是会执行这js文件中的代码的\n- jQuery文件是一个自执行函数，执行这个jQuery文件中的代码，其实就是执行这个自制行函数\n- 这个自制行文件就是给window对象添加了一个jQuery 属性和$属性\n- jQuery 其实是一个自执行函数\n\n（4）$是一个函数，参数不同效果也不同\n\n- 如果传递一个匿名函数————入口函数\n\n  ```js\n  $(function(){\n  		console.log(\'sss\');\n  		\n  })\n  ```\n\n- 如果传递的是一个字符串————选择器/创建一个标签\n\n  ```js\n  $(\'#btnOne\')\n  $(\'<div>我是一个div标签</div>\')\n  ```\n\n- 如果传递一个dom对象，那么他就会把dom对象转换成jQuery对象\n\n  ```js\n  var div1 = document.getElementById(\'divOne\');\n  var $divOne = $(div1);\n  console.log($divOne);\n  ```\n\n  ', 0, 0, '2020-08-07 15:05:47', 2, 0, 1, '$ 是什么？（1）如果报了错误：$ is not defined,就说明没有引入jQuery文件\n（2）jQuery文件结构：\n\njQuery 其实是一个自执行函数window.jQuery = window.$ = jQuery;\n（3）jQuery 的源码刨析\n\n引入一个js文件，是会执行这js文件中的代码的jQuery文件是一个自执行函数，执行这个jQuery文件中的代码，其实就是执行这个自制行函数这个自制行文件就是给window对象添加了一个jQuery 属性和$属性jQuery 其实是一个自执行函数\n（4）$是一个函数，参数不同效果也不同\n\n如果传递一个匿名函数————入口函数\n$(function(){        console.log(\'sss\');})\n如果传递的是一个字符串————选择器/创建一个标签\n$(\'#btnOne\')$(\'<div>我是一个div标签</div>\')\n如果传递一个dom对象，那么他就会把dom对象转换成jQuery对象\nvar div1 = document.getElementById(\'divOne\');var $divOne = $(div1);console.log($divOne);\n\n', 0, 1);
INSERT INTO `t_article` VALUES (178, '05、DOM 对象和 jQuery 对象', 8, '### dom对象：\n\n- 原生js选择器获取到对象\n\n  ```js\n  var div1 = document.getElementById(\"divOne\");\n  ```\n\n  \n\n- 特点：只能调用dom方法和属性，不能调用jQuery的方法和属性\n\n  ```js\n  		//dom对象是可以调用dom的属性和方法\n  		div1.style.backgroundColor = \"red\";\n  		\n  		//dom对象是不可以调用jQuery的属性和方法\n  //		div1.css(\'backgroundColor\',\'red\');\n  ```\n\n\n\n### jQuery对象\n\n- 利用jQuery选择器获取的对象\n\n  ```js\n  var $div1 = $(\'#divOne\');\n  ```\n\n- jQuery对象是可以调用jQuery的属性和方法\n\n  ```js\n  $div1.css(\'background-color\',\'green\');\n  ```\n\n- jQuery对象是不可以调用dom的属性和方法\n\n  ```js\n  //  $div1.style.backgroundColor = \"red\";\n  ```\n\n- jQuery 不是一个数组对象，jQuery是一个伪数组，jQuery对象其实就是dom对象的包装集\n\n  ```js\n  console.log($div1);\n  console.log($div1.__proto__ === Array.prototype);\n  ```\n\n\n\n### dom 对象和 jQuery 对象的相互转换\n\n- 将dom对象转换为jQuery对象\n\n  ```js\n  var div1 = document.getElementById(\'divOne\');\n  var $divOne = $(div1);\n  console.log($divOne);\n  ```\n\n- 将jQuery对象转换为dom对象\n\n  ```js\n  var $divs = $(\'div\');\n  \n  //5.1通过下标取出来\n  var div11 = $divs[0];\n  console.log(div11);\n  		\n  //5.2通过jQuery的get()\n  var div12 = $divs.get(1);\n  console.log(div12);\n  ```\n\n  ', 0, 0, '2020-08-07 15:06:27', 2, 0, 1, 'dom对象：\n原生js选择器获取到对象\nvar div1 = document.getElementById(\"divOne\");\n\n\n特点：只能调用dom方法和属性，不能调用jQuery的方法和属性\n        //dom对象是可以调用dom的属性和方法        div1.style.backgroundColor = \"red\";        //dom对象是不可以调用jQuery的属性和方法//        div1.css(\'backgroundColor\',\'red\');\n\njQuery对象\n利用jQuery选择器获取的对象\nvar $div1 = $(\'#divOne\');\njQuery对象是可以调用jQuery的属性和方法\n$div1.css(\'background-color\',\'green\');\njQuery对象是不可以调用dom的属性和方法\n//  $div1.style.backgroundColor = \"red\";\njQuery 不是一个数组对象，jQuery是一个伪数组，jQuery对象其实就是dom对象的包装集\nconsole.log($div1);console.log($div1.__proto__ === Array.prototype);\n\ndom 对象和 jQuery 对象的相互转换\n将dom对象转换为jQuery对象\nvar div1 = document.getElementById(\'divOne\');var $divOne = $(div1);console.log($divOne);\n将jQuery对象转换为dom对象\nvar $divs = $(\'div\');//5.1通过下标取出来var div11 = $divs[0];console.log(div11);//5.2通过jQuery的get()var div12 = $divs.get(1);console.log(div12);\n\n', 0, 1);
INSERT INTO `t_article` VALUES (179, '06、一个简单的案例——开关灯', 8, '```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n	</head>\n	<body>\n		<button>开灯</button>\n		<button>关灯</button>\n		<img src=\"img/1.jpg\" />\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery未压缩版.js\" ></script>\n<script>\n	var btns = $(\'button\');\n	console.log(btns);\n//	btns[0].onclick = function(){\n//		$(\'body\').css(\'background-color\',\'white\');\n//	}\n//	\n//	btns[1].onclick = function(){\n//		$(\'body\').css(\'background-color\',\'black\');\n//	}\n	\n	$(btns[0]).click(function(){\n		$(\'body\').css(\'background-color\',\'white\');\n	});\n	\n	btns[1].onclick = function(){\n		$(\'body\').css(\'background-color\',\'black\');\n	}\n	\n</script>\n\n```', 0, 0, '2020-08-07 15:08:07', 2, 0, 1, '<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>    </head>    <body>        <button>开灯</button>        <button>关灯</button>        <img src=\"img/1.jpg\" />    </body></html><script type=\"text/javascript\" src=\"js/jQuery未压缩版.js\" ></script><script>    var btns = $(\'button\');    console.log(btns);//    btns[0].onclick = function(){//        $(\'body\').css(\'background-color\',\'white\');//    }//    //    btns[1].onclick = function(){//        $(\'body\').css(\'background-color\',\'black\');//    }    $(btns[0]).click(function(){        $(\'body\').css(\'background-color\',\'white\');    });    btns[1].onclick = function(){        $(\'body\').css(\'background-color\',\'black\');    }</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (180, '07、设置和获取文本', 8, '### 获取文本：text()方法，无参数\n\n- 通过id获取div1的文本，会把div的以及子类的文本全部获取\n\n  ```js\n  $(\'#but1\').click(function(){\n  	console.log($(\'#div1\').text());\n  });\n  ```\n\n- 通过标签获取多个dom，会把所有dom标签的文本获取到\n\n  ```js\n  $(\'#but1\').click(function(){\n  	console.log($(\'div\').text());\n  });\n  ```\n\n\n\n### 设置文本：text()方法，传参数\n\n注意：设置文本会覆盖原来的内容，如果文本中用标签，是不会解析出来的\n\n- 通过id设置div1的文本，会把div1的以及子类的全部替换\n\n  ```js\n  $(\'#but2\').click(function(){\n  	console.log($(\'#div1\').text(\'我是新设置的文本<a>我的连接</a>\'));\n  });\n  ```\n\n- 通过标签设置多个dom，会把所有dom标签及其子类的文本全部替换掉\n\n```js\n$(\'#but2\').click(function(){\n	console.log($(\'div\').text(\'我是新设置的文本<a>我的连接</a>\'));\n});\n```\n\n\n\n完整案例：\n\n```js\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n	</head>\n	<body>\n		<div id=\'div1\'>\n			我的一个div1标签\n			<p>我是p标签</p>\n			<span>我是一个span标签</span>\n		</div>\n		\n		<div id=\'div3\'>\n			我的一个div2标签\n			<p>我是p标签</p>\n			<span>我是一个span标签</span>\n		</div>\n		<button id=\"but1\">获取文本</button>\n		<button id=\"but2\">设置文本</button>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery未压缩版.js\" ></script>\n<script>\n	$(function(){\n		\n		//1获取文本，text()方法\n		//1.1 通过id获取div1的文本，会把div的以及子类的文本全部获取\n//		$(\'#but1\').click(function(){\n//			console.log($(\'#div1\').text());\n//		});\n		\n		//1.2 通过标签获取多个dom，会把所有dom标签的文本获取到\n		$(\'#but1\').click(function(){\n			console.log($(\'div\').text());\n		});\n		\n		\n		\n		//2.设置文本 \n		//设置文本会覆盖原来的内容，如果文本中用标签，是不会解析出来的\n		//2.1 通过id设置div1的文本，会把div1的以及子类的全部替换\n		$(\'#but2\').click(function(){\n			console.log($(\'#div1\').text(\'我是新设置的文本<a>我的连接</a>\'));\n		});\n		\n		//2.2 通过标签设置多个dom，会把所有dom标签及其子类的文本全部替换掉\n		$(\'#but2\').click(function(){\n			console.log($(\'div\').text(\'我是新设置的文本<a>我的连接</a>\'));\n		});\n		\n	});\n</script>\n```\n\n', 0, 0, '2020-08-07 15:24:15', 2, 0, 1, '获取文本：text()方法，无参数\n通过id获取div1的文本，会把div的以及子类的文本全部获取\n$(\'#but1\').click(function(){    console.log($(\'#div1\').text());});\n通过标签获取多个dom，会把所有dom标签的文本获取到\n$(\'#but1\').click(function(){    console.log($(\'div\').text());});\n\n设置文本：text()方法，传参数注意：设置文本会覆盖原来的内容，如果文本中用标签，是不会解析出来的\n\n通过id设置div1的文本，会把div1的以及子类的全部替换\n$(\'#but2\').click(function(){    console.log($(\'#div1\').text(\'我是新设置的文本<a>我的连接</a>\'));});\n通过标签设置多个dom，会把所有dom标签及其子类的文本全部替换掉\n\n$(\'#but2\').click(function(){    console.log($(\'div\').text(\'我是新设置的文本<a>我的连接</a>\'));});\n完整案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>    </head>    <body>        <div id=\'div1\'>            我的一个div1标签            <p>我是p标签</p>            <span>我是一个span标签</span>        </div>        <div id=\'div3\'>            我的一个div2标签            <p>我是p标签</p>            <span>我是一个span标签</span>        </div>        <button id=\"but1\">获取文本</button>        <button id=\"but2\">设置文本</button>    </body></html><script type=\"text/javascript\" src=\"js/jQuery未压缩版.js\" ></script><script>    $(function(){        //1获取文本，text()方法        //1.1 通过id获取div1的文本，会把div的以及子类的文本全部获取//        $(\'#but1\').click(function(){//            console.log($(\'#div1\').text());//        });        //1.2 通过标签获取多个dom，会把所有dom标签的文本获取到        $(\'#but1\').click(function(){            console.log($(\'div\').text());        });        //2.设置文本         //设置文本会覆盖原来的内容，如果文本中用标签，是不会解析出来的        //2.1 通过id设置div1的文本，会把div1的以及子类的全部替换        $(\'#but2\').click(function(){            console.log($(\'#div1\').text(\'我是新设置的文本<a>我的连接</a>\'));        });        //2.2 通过标签设置多个dom，会把所有dom标签及其子类的文本全部替换掉        $(\'#but2\').click(function(){            console.log($(\'div\').text(\'我是新设置的文本<a>我的连接</a>\'));        });    });</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (181, '08、设置和获取样式', 8, '### 获取样式，css()方法，无参\n\n- 获取id为div1的样式\n\n  ```js\n  console.log($(\'#div1\').css(\'width\'));\n  console.log($(\'#div1\').css(\'height\'));\n  console.log($(\'#div1\').css(\'background-color\'));\n  console.log($(\'#div1\').css(\'border\'));\n  \n  //在IE浏览器中，获取边框样式，一定要给准确的属性\n  console.log($(\'#div1\').css(\'border-top-width\'));\n  ```\n\n- 通过标签获取标签为div的样式（只能获取到第一个div的样式）\n\n  ```js\n  console.log($(\'div\').css(\'width\'));\n  console.log($(\'div\').css(\'height\'));\n  console.log($(\'div\').css(\'background-color\'));\n  console.log($(\'div\').css(\'border\'));\n  \n  //在IE浏览器中，获取边框样式，一定要给准确的属性\n  console.log($(\'div\').css(\'border-top-width\'));\n  ```\n\n\n\n### 设置样式：css(样式名,样式值)\n\n- 给id为div1的元素设置样式\n\n  ```js\n  //设置单样式\n  $(\'#div1\').css(\'width\',200);\n  $(\'#div1\').css(\'height\',\'200px\');\n  $(\'#div1\').css(\'background-color\',\'red\');\n  $(\'#div1\').css(\'border\',\'10px solid green\');\n  \n  //设置多样式\n  $(\'#div1\').css({\n      width:300,\n      \'height\':300,\n      backgroundColor:\'red\',\n   //	\'background-color\':\'red\',\n      border:\'10px solid green\',\n  });\n  ```\n\n- 给标签为div的元素们设置样式\n  注意：会给所有的div元素全部设置到新样式\n\n  ```js\n  $(\'div\').css({\n  	width:300,\n  	\'height\':300,\n  	backgroundColor:\'red\',\n  //	\'background-color\':\'red\',\n  	border:\'10px solid green\',\n  });\n  ```\n\n完整案例：\n\n```js\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			div{\n				width: 100px;\n				height: 100px;\n				border: 2px solid red;\n				background-color: skyblue;\n			}\n		</style>\n	</head>\n	<body>\n		<button id=\'but1\'>获取</button>\n		<button id=\'but2\'>设置</button>\n		<div id=\'div1\'></div>\n		<div id=\'div2\'></div>\n		<div id=\'div3\'></div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery未压缩版.js\" ></script>\n<script>\n	$(function(){\n		//1.获取样式，css()方法\n		$(\'#but1\').click(function(){\n			//1.1 获取id为div1的样式\n			console.log($(\'#div1\').css(\'width\'));\n			console.log($(\'#div1\').css(\'height\'));\n			console.log($(\'#div1\').css(\'background-color\'));\n			console.log($(\'#div1\').css(\'border\'));\n//			\n//			//在IE浏览器中，获取边框样式，一定要给准确的属性\n//			console.log($(\'#div1\').css(\'border-top-width\'));\n			\n			//1.2 获取标签为div的样式（只能获取到第一个div的样式）\n			//获取包含多个dom对象的样式，只能回去到第一个元素的样式\n			console.log($(\'div\').css(\'width\'));\n			console.log($(\'div\').css(\'height\'));\n			console.log($(\'div\').css(\'background-color\'));\n			console.log($(\'div\').css(\'border\'));\n			\n			//在IE浏览器中，获取边框样式，一定要给准确的属性\n			console.log($(\'div\').css(\'border-top-width\'));\n			\n		})\n		\n		\n		//2.设置样式：css(样式名,样式值)\n		//设置的样式是行内样式\n		$(\'#but2\').click(function(){\n			//2.1 给id为div1的元素设置样式\n			//设置单样式\n//			$(\'#div1\').css(\'width\',200);\n//			$(\'#div1\').css(\'height\',\'200px\');\n//			$(\'#div1\').css(\'background-color\',\'red\');\n//			$(\'#div1\').css(\'border\',\'10px solid green\');\n			\n			//设置多样式\n			$(\'#div1\').css({\n				width:300,\n				\'height\':300,\n				backgroundColor:\'red\',\n//				\'background-color\':\'red\',\n				border:\'10px solid green\',\n				\n			});\n			\n			//2.2 给标签为div的元素们设置样式\n			//会给所有的div元素全部设置到新样式\n			\n			$(\'div\').css({\n				\n				width:300,\n				\'height\':300,\n				backgroundColor:\'red\',\n//				\'background-color\':\'red\',\n				border:\'10px solid green\',\n				\n			});\n			\n			\n		})\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:24:51', 2, 0, 1, '获取样式，css()方法，无参\n获取id为div1的样式\nconsole.log($(\'#div1\').css(\'width\'));console.log($(\'#div1\').css(\'height\'));console.log($(\'#div1\').css(\'background-color\'));console.log($(\'#div1\').css(\'border\'));//在IE浏览器中，获取边框样式，一定要给准确的属性console.log($(\'#div1\').css(\'border-top-width\'));\n通过标签获取标签为div的样式（只能获取到第一个div的样式）\nconsole.log($(\'div\').css(\'width\'));console.log($(\'div\').css(\'height\'));console.log($(\'div\').css(\'background-color\'));console.log($(\'div\').css(\'border\'));//在IE浏览器中，获取边框样式，一定要给准确的属性console.log($(\'div\').css(\'border-top-width\'));\n\n设置样式：css(样式名,样式值)\n给id为div1的元素设置样式\n//设置单样式$(\'#div1\').css(\'width\',200);$(\'#div1\').css(\'height\',\'200px\');$(\'#div1\').css(\'background-color\',\'red\');$(\'#div1\').css(\'border\',\'10px solid green\');//设置多样式$(\'#div1\').css({    width:300,    \'height\':300,    backgroundColor:\'red\', //    \'background-color\':\'red\',    border:\'10px solid green\',});\n给标签为div的元素们设置样式注意：会给所有的div元素全部设置到新样式\n$(\'div\').css({    width:300,    \'height\':300,    backgroundColor:\'red\',//    \'background-color\':\'red\',    border:\'10px solid green\',});\n\n完整案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            div{                width: 100px;                height: 100px;                border: 2px solid red;                background-color: skyblue;            }        </style>    </head>    <body>        <button id=\'but1\'>获取</button>        <button id=\'but2\'>设置</button>        <div id=\'div1\'></div>        <div id=\'div2\'></div>        <div id=\'div3\'></div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery未压缩版.js\" ></script><script>    $(function(){        //1.获取样式，css()方法        $(\'#but1\').click(function(){            //1.1 获取id为div1的样式            console.log($(\'#div1\').css(\'width\'));            console.log($(\'#div1\').css(\'height\'));            console.log($(\'#div1\').css(\'background-color\'));            console.log($(\'#div1\').css(\'border\'));//            //            //在IE浏览器中，获取边框样式，一定要给准确的属性//            console.log($(\'#div1\').css(\'border-top-width\'));            //1.2 获取标签为div的样式（只能获取到第一个div的样式）            //获取包含多个dom对象的样式，只能回去到第一个元素的样式            console.log($(\'div\').css(\'width\'));            console.log($(\'div\').css(\'height\'));            console.log($(\'div\').css(\'background-color\'));            console.log($(\'div\').css(\'border\'));            //在IE浏览器中，获取边框样式，一定要给准确的属性            console.log($(\'div\').css(\'border-top-width\'));        })        //2.设置样式：css(样式名,样式值)        //设置的样式是行内样式        $(\'#but2\').click(function(){            //2.1 给id为div1的元素设置样式            //设置单样式//            $(\'#div1\').css(\'width\',200);//            $(\'#div1\').css(\'height\',\'200px\');//            $(\'#div1\').css(\'background-color\',\'red\');//            $(\'#div1\').css(\'border\',\'10px solid green\');            //设置多样式            $(\'#div1\').css({                width:300,                \'height\':300,                backgroundColor:\'red\',//                \'background-color\':\'red\',                border:\'10px solid green\',            });            //2.2 给标签为div的元素们设置样式            //会给所有的div元素全部设置到新样式            $(\'div\').css({                width:300,                \'height\':300,                backgroundColor:\'red\',//                \'background-color\':\'red\',                border:\'10px solid green\',            });        })    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (182, '09、选择器', 8, '### jQuery 基本选择器：\n\n| 名称       | 用法              | 描述                               |\n| ---------- | ----------------- | ---------------------------------- |\n| ID选择器   | $(\'#id\');         | 获取指定ID的元素                   |\n| 类选择器   | $(\'.class\');      | 获取同一类class的元素              |\n| 标签选择器 | $(\'div\');         | 获取同一类标签的所有元素           |\n| 并集选择器 | $(\'div,p,li\');    | 使用逗号分隔，只要符合条件之一即可 |\n| 交集选择器 | $(\'div.redClass\') | 获取class为redClass的div元素       |\n\n注意：跟css的一摸一样\n\n案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>基本选择器</title>\n	</head>\n	<body>\n		<div>\n			<ul>\n				<li id=\"slg\">国公联合司令官</li>\n			</ul>\n			<ul id=\"dlt\">\n				<li class=\"tz\">独立团团长——李云龙</li>\n				<li>狙击手</li>\n				<li>士兵</li>\n				<li>士兵</li>\n				<li>士兵</li>\n				<li class=\"hf\">伙夫</li>\n				<li class=\"wsy\">卫生员</li>\n			</ul>\n			\n			<ul id=\"t358\">\n				<li class=\"tz\">358团团长——楚云飞</li>\n				<li>狙击手</li>\n				<li class=\"nj\">士兵</li>\n				<li>士兵</li>\n				<li>士兵</li>\n				<li class=\"hf\">伙夫</li>\n				<li class=\"wsy\">卫生员</li>\n			</ul>\n			<ul id=\"lbx\">\n				<li class=\"nj\">老百姓</li>\n				<li>老百姓</li>\n				<li>老百姓</li>\n				<li>老百姓</li>\n			</ul>\n		</div>		\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		/*\n		 * (1)让国公联合司令官讲话\n		 * 将国公联合司令官标签放大\n		 * 利用 元素选择器 —— $(\'#id\');\n		 */\n		$(\'#slg\').css(\"font-size\",40);\n		\n		/*\n		 * (2)让团长讲话\n		 * 将团长的标志放大\n		 * 利用 类选择器 —— $(\'.class\');\n		 */\n		$(\'.tz\').css(\"font-size\",30);\n		\n		/*\n		 * (3)全军出击\n		 * 让司令官、团长、军队标签背景色变成红色\n		 * 利用 并集选择器 —— $(\'div,p,li\');\n		 */\n		$(\'#t358,#dlt\').css(\"background-color\",\'red\');\n		\n		/*\n		 * (4)抓出内奸，不能惊动老百姓\n		 * 让内奸标签的背景色变成绿色\n		 * 利用 交集选择器 —— $(\'div.redClass\');\n		 */\n		$(\'#t358 .nj\').css(\'background-color\',\'green\');\n	});\n	\n</script>\n```\n\n\n\n### jQuery 层级选择器\n\n| 名称       | 用法          | 描述                                                         |\n| ---------- | ------------- | ------------------------------------------------------------ |\n| 子代选择器 | $(\'ul > li\'); | 使用 > 符号，获取儿子层级的元素，注意，并不会获取到孙子级别的元素 |\n| 后代选择器 | $(\'ul li\');   | 使用 空格，代表后代选择器，获取url下的所有li元素，包括子孙   |\n\n注意：跟css的一摸一样\n\n案例：\n\n```js\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>层级选择器</title>\n	</head>\n	<body>\n		<div id=\'father\'>爸爸div\n			<span>舅舅</span>\n			<span>大伯</span>\n			<p>二伯</p>\n			<p>三伯</p>	\n				\n			<div id=\'son\'>儿子div\n				<span>儿子1</span>\n				<span>儿子2</span>\n				<p>儿子3</p>\n				<div id=\'grandson\'>孙子div\n					<span>孙子1</span>\n					<span>孙子2</span>\n					<p>孙子3</p>\n				</div>\n			</div>\n			\n		</div>\n	</body>\n</html>\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){		\n		//1.子代选择器		\n		//(1)获取到id为father的直接子代div，不能获取到孙子元素		\n		console.log($(\'#father > div\'));\n				\n		//(2)获取id为father的直接子代div和span		 \n		console.log($(\'#father > div , #father > p \'))\n		\n		//2.后代选择器\n		//获取id为father的所有子代div，包括孙子代\n		console.log($(\'#father div\'));\n		\n	})\n</script>\n```\n\n\n\n### jQuery 过滤选择器\n\n该类选择器都带有冒号\n\n| 名称       | 用法          | 描述                                           |\n| ---------- | ------------- | ---------------------------------------------- |\n| :eq(index) | $(\'li:eq(2)\') | 获取到li元素中索引号为2的元素，索引是从0开始的 |\n| :odd       | $(\'li:odd\')   | 获取到li元素中索引号为奇数的元素               |\n| :even      | $(\'li:even\')  | 获取到li元素中索引号为偶数的元素               |\n\n案例:\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>过滤选择器</title>\n	</head>\n	<body>\n		<ul>\n			<li>我的第0个li标签</li>\n			<li>我的第1个li标签</li>\n			<li>我的第2个li标签</li>\n			<li>我的第3个li标签</li>\n			<li>我的第4个li标签</li>\n			<li>我的第5个li标签</li>\n			<li>我的第6个li标签</li>\n			<li>我的第7个li标签</li>\n			<li>我的第8个li标签</li>\n			<li>我的第9个li标签</li>\n			\n		</ul>\n	</body>\n</html>\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		\n		//设置索引号为奇数的li标签颜色\n		$(\'li:odd\').css(\'background-color\',\'green\');\n		\n		//设置索引号为偶数的li标签颜色\n		$(\'li:even\').css(\'background-color\',\'yellow\');\n        \n        //设置索引号为5的li标签颜色\n		$(\'li:eq(5)\').css(\'background-color\',\'red\');\n	})\n</script>\n```\n\n\n\n### jQuery 属性选择器：\n\n可以根据属性进行筛选\n\n语法：\n\n```js\n//在li标签中筛选出带有flag属性为flag的元素\n$(\'li[flag=flag]\')\n```\n\n\n\n### jQuery筛选选择器（方法）\n\n| 名称               | 用法                       | 描述                              |\n| ------------------ | -------------------------- | --------------------------------- |\n| children(selector) | $(\'ul\').children(\'li\')     | 相当于$(\'ul > li\')，子代选择器    |\n| find(selector)     | $(\'ul\').find(\'li\')         | 相当于$(\'ul li\')，后代选择器      |\n| siblings(selector) | $(\'#first\').siblings(\'li\') | 查找兄弟结点，不包括自己          |\n| parent()           | $(\'#first\').parent()       | 查找父亲                          |\n| eq(index)          | $(\'li\').eq(2)              | 相当于$(\'li:eq(2)\')，index从0开始 |\n| next()             | $(\'li\').next()             | 找下一个兄弟                      |\n| prev()             | $(\'li\').prev()             | 找上一个兄弟                      |\n\n#### 案例：下拉菜单\n\n```js\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>筛选选择器</title>\n		<style>\n			/*\n			 * 先让二级菜单隐藏\n			 */\n			.wrap ul li ul{\n				display: none;\n			}\n		</style>\n	</head>\n	<body>\n		<div class=\"wrap\">\n			<ul>\n				<li>\n					<a href=\"\">一级菜单</a>\n					<ul>\n						<li><a href=\"\">二级菜单1</a></li>\n						<li><a href=\"\">二级菜单2</a></li>\n						<li><a href=\"\">二级菜单3</a></li>\n					</ul>\n				</li>\n				\n				<li>\n					<a href=\"\">一级菜单</a>\n					<ul>\n						<li><a href=\"\">二级菜单1</a></li>\n						<li><a href=\"\">二级菜单2</a></li>\n						<li><a href=\"\">二级菜单3</a></li>\n					</ul>\n				</li>\n				<li>\n					<a href=\"\">一级菜单</a>\n					<ul>\n						<li><a href=\"\">二级菜单1</a></li>\n						<li><a href=\"\">二级菜单2</a></li>\n						<li><a href=\"\">二级菜单3</a></li>\n					</ul>\n				</li>\n			</ul>\n		</div>\n		\n		\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n\n<script>\n	$(function(){\n		\n		//给一级菜单设置鼠标移入事件\n		$(\'.wrap > ul > li\').mouseenter(function(){\n			//this是触发事件的dom对象\n//			console.log(this);\n			//让二级菜单显示\n			//让组件显示有两种方式：两种方式的本质是相同的\n			//(1)更改 display属性为block\n//			$(this).children(\'ul\').css(\'display\',\'block\');\n			\n			//(2)调用show()方法\n			$(this).children(\'ul\').stop(true,false).show(300);\n		})\n		\n		//给一级菜单设置鼠标离开事件\n		$(\'.wrap > ul > li\').mouseleave(function(){\n			//this是触发事件的dom对象\n			console.log(this);\n			//让二级菜单隐藏\n			//让组件隐藏有两种方式：两种方式的本质是相同的\n\n			//(1)更改 display属性为none\n//			$(this).children(\'ul\').css(\'display\',\'none\');\n			\n			//(2)调用hide()方法\n			$(this).children(\'ul\').hide(150);\n			\n		})\n		\n	})\n	\n</script>\n```\n\n总结：\n\n- 显示组件：调用show()方法\n- 隐藏组件：调用hide()方法\n- mouseout() 鼠标移出事件,注意：在鼠标移出该组件及其子类组件都会触发\n- mouseleave() 鼠标移出事件，只会在鼠标移出选取的元素上才会触发\n- mouseover() 鼠标移入事件，注意：在鼠标移入该组件及其子类组件都会触发\n- mouseenter() 鼠标移入事件，只会在鼠标移入选取的元素上才会触发\n\n\n\n#### 案例：高亮显示\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>高亮显示</title>\n		<style>\n			body{\n				background: #000;\n			}\n			img{\n				width: 150px ;\n				height: 150px;\n			}\n			.wrap{\n				margin: 100px auto 0;\n				width: 570px;\n				height: 350px;\n				padding: 10px 0 0 10px;\n				background: #000;\n				overflow: hidden;\n				border: 1px solid #fff;\n			}\n			.wrap li{\n				float: left;\n				margin: 0 10px 10px 0;\n			}\n			li{\n				display: list-item;\n				text-align: -webkit-match-parent;\n			}\n		</style>\n	</head>\n	<body>\n		<div class=\"wrap\">\n			<ul>\n				<li>\n					<img src=\"img/img2.jpg\" alt=\"\"/>\n				</li>\n				<li>\n					<img src=\"img/img5.jpg\" alt=\"\"/>\n				</li>\n				<li>\n					<img src=\"img/img6.jpg\" alt=\"\"/>\n				</li>\n				<li>\n					<img src=\"img/img7.jpg\" alt=\"\"/>\n				</li>\n				<li>\n					<img src=\"img/img8.jpg\" alt=\"\"/>\n				</li>\n				<li>\n					<img src=\"img/img9.jpg\" alt=\"\"/>\n				</li>\n			</ul>\n		</div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	\n	$(function(){\n		//添加鼠标移入事件，给移入的li标签透明度设为1，其他的兄弟设为0.4\n		//鼠标离开大盒子，所有li标签透明度设为1\n//		$(\'.wrap li\')   //可以的\n		$(\'.wrap\').find(\"li\").mouseenter(function(){\n			$(this).css(\'opacity\',1).siblings(\'li\').css(\'opacity\',0.4);\n		})\n		\n		$(\'.wrap\').mouseleave(function(){\n			$(this).find(\'li\').css(\'opacity\',1);\n		})\n		\n	})\n	\n</script>\n```\n\n', 0, 0, '2020-08-07 15:25:36', 2, 0, 1, 'jQuery 基本选择器：\n\n\n名称\n用法\n描述\n\n\n\n\nID选择器\n$(‘#id’);\n获取指定ID的元素\n\n\n类选择器\n$(‘.class’);\n获取同一类class的元素\n\n\n标签选择器\n$(‘div’);\n获取同一类标签的所有元素\n\n\n并集选择器\n$(‘div,p,li’);\n使用逗号分隔，只要符合条件之一即可\n\n\n交集选择器\n$(‘div.redClass’)\n获取class为redClass的div元素\n\n\n\n注意：跟css的一摸一样\n案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>基本选择器</title>    </head>    <body>        <div>            <ul>                <li id=\"slg\">国公联合司令官</li>            </ul>            <ul id=\"dlt\">                <li class=\"tz\">独立团团长——李云龙</li>                <li>狙击手</li>                <li>士兵</li>                <li>士兵</li>                <li>士兵</li>                <li class=\"hf\">伙夫</li>                <li class=\"wsy\">卫生员</li>            </ul>            <ul id=\"t358\">                <li class=\"tz\">358团团长——楚云飞</li>                <li>狙击手</li>                <li class=\"nj\">士兵</li>                <li>士兵</li>                <li>士兵</li>                <li class=\"hf\">伙夫</li>                <li class=\"wsy\">卫生员</li>            </ul>            <ul id=\"lbx\">                <li class=\"nj\">老百姓</li>                <li>老百姓</li>                <li>老百姓</li>                <li>老百姓</li>            </ul>        </div>            </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        /*         * (1)让国公联合司令官讲话         * 将国公联合司令官标签放大         * 利用 元素选择器 —— $(\'#id\');         */        $(\'#slg\').css(\"font-size\",40);        /*         * (2)让团长讲话         * 将团长的标志放大         * 利用 类选择器 —— $(\'.class\');         */        $(\'.tz\').css(\"font-size\",30);        /*         * (3)全军出击         * 让司令官、团长、军队标签背景色变成红色         * 利用 并集选择器 —— $(\'div,p,li\');         */        $(\'#t358,#dlt\').css(\"background-color\",\'red\');        /*         * (4)抓出内奸，不能惊动老百姓         * 让内奸标签的背景色变成绿色         * 利用 交集选择器 —— $(\'div.redClass\');         */        $(\'#t358 .nj\').css(\'background-color\',\'green\');    });</script>\njQuery 层级选择器\n\n\n名称\n用法\n描述\n\n\n\n\n子代选择器\n$(‘ul > li’);\n使用 > 符号，获取儿子层级的元素，注意，并不会获取到孙子级别的元素\n\n\n后代选择器\n$(‘ul li’);\n使用 空格，代表后代选择器，获取url下的所有li元素，包括子孙\n\n\n\n注意：跟css的一摸一样\n案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>层级选择器</title>    </head>    <body>        <div id=\'father\'>爸爸div            <span>舅舅</span>            <span>大伯</span>            <p>二伯</p>            <p>三伯</p>                <div id=\'son\'>儿子div                <span>儿子1</span>                <span>儿子2</span>                <p>儿子3</p>                <div id=\'grandson\'>孙子div                    <span>孙子1</span>                    <span>孙子2</span>                    <p>孙子3</p>                </div>            </div>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){                //1.子代选择器                //(1)获取到id为father的直接子代div，不能获取到孙子元素                console.log($(\'#father > div\'));        //(2)获取id为father的直接子代div和span                 console.log($(\'#father > div , #father > p \'))        //2.后代选择器        //获取id为father的所有子代div，包括孙子代        console.log($(\'#father div\'));    })</script>\njQuery 过滤选择器该类选择器都带有冒号\n\n\n\n名称\n用法\n描述\n\n\n\n\n:eq(index)\n$(‘li:eq(2)’)\n获取到li元素中索引号为2的元素，索引是从0开始的\n\n\n:odd\n$(‘li:odd’)\n获取到li元素中索引号为奇数的元素\n\n\n:even\n$(‘li:even’)\n获取到li元素中索引号为偶数的元素\n\n\n\n案例:\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>过滤选择器</title>    </head>    <body>        <ul>            <li>我的第0个li标签</li>            <li>我的第1个li标签</li>            <li>我的第2个li标签</li>            <li>我的第3个li标签</li>            <li>我的第4个li标签</li>            <li>我的第5个li标签</li>            <li>我的第6个li标签</li>            <li>我的第7个li标签</li>            <li>我的第8个li标签</li>            <li>我的第9个li标签</li>        </ul>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //设置索引号为奇数的li标签颜色        $(\'li:odd\').css(\'background-color\',\'green\');        //设置索引号为偶数的li标签颜色        $(\'li:even\').css(\'background-color\',\'yellow\');        //设置索引号为5的li标签颜色        $(\'li:eq(5)\').css(\'background-color\',\'red\');    })</script>\njQuery 属性选择器：可以根据属性进行筛选\n语法：\n//在li标签中筛选出带有flag属性为flag的元素$(\'li[flag=flag]\')\njQuery筛选选择器（方法）\n\n\n名称\n用法\n描述\n\n\n\n\nchildren(selector)\n$(‘ul’).children(‘li’)\n相当于$(‘ul > li’)，子代选择器\n\n\nfind(selector)\n$(‘ul’).find(‘li’)\n相当于$(‘ul li’)，后代选择器\n\n\nsiblings(selector)\n$(‘#first’).siblings(‘li’)\n查找兄弟结点，不包括自己\n\n\nparent()\n$(‘#first’).parent()\n查找父亲\n\n\neq(index)\n$(‘li’).eq(2)\n相当于$(‘li:eq(2)’)，index从0开始\n\n\nnext()\n$(‘li’).next()\n找下一个兄弟\n\n\nprev()\n$(‘li’).prev()\n找上一个兄弟\n\n\n\n案例：下拉菜单<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>筛选选择器</title>        <style>            /*             * 先让二级菜单隐藏             */            .wrap ul li ul{                display: none;            }        </style>    </head>    <body>        <div class=\"wrap\">            <ul>                <li>                    <a href=\"\">一级菜单</a>                    <ul>                        <li><a href=\"\">二级菜单1</a></li>                        <li><a href=\"\">二级菜单2</a></li>                        <li><a href=\"\">二级菜单3</a></li>                    </ul>                </li>                <li>                    <a href=\"\">一级菜单</a>                    <ul>                        <li><a href=\"\">二级菜单1</a></li>                        <li><a href=\"\">二级菜单2</a></li>                        <li><a href=\"\">二级菜单3</a></li>                    </ul>                </li>                <li>                    <a href=\"\">一级菜单</a>                    <ul>                        <li><a href=\"\">二级菜单1</a></li>                        <li><a href=\"\">二级菜单2</a></li>                        <li><a href=\"\">二级菜单3</a></li>                    </ul>                </li>            </ul>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //给一级菜单设置鼠标移入事件        $(\'.wrap > ul > li\').mouseenter(function(){            //this是触发事件的dom对象//            console.log(this);            //让二级菜单显示            //让组件显示有两种方式：两种方式的本质是相同的            //(1)更改 display属性为block//            $(this).children(\'ul\').css(\'display\',\'block\');            //(2)调用show()方法            $(this).children(\'ul\').stop(true,false).show(300);        })        //给一级菜单设置鼠标离开事件        $(\'.wrap > ul > li\').mouseleave(function(){            //this是触发事件的dom对象            console.log(this);            //让二级菜单隐藏            //让组件隐藏有两种方式：两种方式的本质是相同的            //(1)更改 display属性为none//            $(this).children(\'ul\').css(\'display\',\'none\');            //(2)调用hide()方法            $(this).children(\'ul\').hide(150);        })    })</script>\n总结：\n\n显示组件：调用show()方法隐藏组件：调用hide()方法mouseout() 鼠标移出事件,注意：在鼠标移出该组件及其子类组件都会触发mouseleave() 鼠标移出事件，只会在鼠标移出选取的元素上才会触发mouseover() 鼠标移入事件，注意：在鼠标移入该组件及其子类组件都会触发mouseenter() 鼠标移入事件，只会在鼠标移入选取的元素上才会触发\n案例：高亮显示<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>高亮显示</title>        <style>            body{                background: #000;            }            img{                width: 150px ;                height: 150px;            }            .wrap{                margin: 100px auto 0;                width: 570px;                height: 350px;                padding: 10px 0 0 10px;                background: #000;                overflow: hidden;                border: 1px solid #fff;            }            .wrap li{                float: left;                margin: 0 10px 10px 0;            }            li{                display: list-item;                text-align: -webkit-match-parent;            }        </style>    </head>    <body>        <div class=\"wrap\">            <ul>                <li>                    <img src=\"img/img2.jpg\" alt=\"\"/>                </li>                <li>                    <img src=\"img/img5.jpg\" alt=\"\"/>                </li>                <li>                    <img src=\"img/img6.jpg\" alt=\"\"/>                </li>                <li>                    <img src=\"img/img7.jpg\" alt=\"\"/>                </li>                <li>                    <img src=\"img/img8.jpg\" alt=\"\"/>                </li>                <li>                    <img src=\"img/img9.jpg\" alt=\"\"/>                </li>            </ul>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //添加鼠标移入事件，给移入的li标签透明度设为1，其他的兄弟设为0.4        //鼠标离开大盒子，所有li标签透明度设为1//        $(\'.wrap li\')   //可以的        $(\'.wrap\').find(\"li\").mouseenter(function(){            $(this).css(\'opacity\',1).siblings(\'li\').css(\'opacity\',0.4);        })        $(\'.wrap\').mouseleave(function(){            $(this).find(\'li\').css(\'opacity\',1);        })    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (183, '10、类操作', 8, '### 添加类：addClass(类名)\n\n```js\n//添加单个类\n$(\'#div1\').addClass(\'fontSize30\');\n\n//添加多个类\n$(\'#div1\').addClass(\'fontSize30 width200\');\n```\n\n\n\n### 移除类： removeClass(类名)\n\n```js\n//移除单个类\n$(\'#div1\').removeClass(\'fontSize30\');\n\n//移除多个类\n$(\'#div1\').removeClass(\'fontSize30 width200\');\n\n//移除所有类\n$(\'#div1\').removeClass();\n```\n\n\n\n### 判断类：hasClass(类名)\n\n```js\n//判断元素有没有某个类\nconsole.log($(\'#div1\').hasClass(\'fontSize30\'));\n```\n\n\n\n### 切换类：toggleClass(类名)\n\n```js\n//如果元素有某个类，就移除这个类；如果没有，就添加这个类\n$(\'#div1\').toggleClass(\'fontSize30\');\n```\n\n\n\n### 完整案例：\n\n```js\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>class操作</title>\n		<style>\n			div{\n				width: 100px;\n				height: 100px;\n				margin-top: 10px;\n			}\n			\n			.bgc{\n				background-color: green;\n			}\n			\n			.fontSize30{\n				font-size: 30px;\n			}\n			.width200{\n				width:200px;\n			}\n			\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"添加类\" id=\"addClass\" />\n		<input type=\"button\" value=\"移除类\" id=\"removeClass\" />\n		<input type=\"button\" value=\"判断类\" id=\"hasClass\" />\n		<input type=\"button\" value=\"切换类\" id=\"toggleClass\" />\n		<div id=\"div1\" class=\"bgc\">div</div>\n	</body>\n</html>\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//1.添加类 addClass(类名)\n		$(\'#addClass\').click(function(){\n			//添加单个类\n//			$(\'#div1\').addClass(\'fontSize30\');\n			\n			//添加多个类\n			$(\'#div1\').addClass(\'fontSize30 width200\');\n		});\n		\n		//2.移除类 removeClass(类名)\n		$(\'#removeClass\').click(function(){\n			//移除单个类\n//			$(\'#div1\').removeClass(\'fontSize30\');\n			\n			//移除多个类\n//			$(\'#div1\').removeClass(\'fontSize30 width200\');\n\n			//移除所有类\n			$(\'#div1\').removeClass();\n		});\n		\n		//3.判断类：hasClass(类名)\n		$(\'#hasClass\').click(function(){\n			//判断元素有没有某个类\n			console.log($(\'#div1\').hasClass(\'fontSize30\'));\n		})\n		\n		//4.切换类：toggleClass(类名)\n		$(\'#toggleClass\').click(function(){\n			//如果元素有某个类，就移除这个类；如果没有，就添加这个类\n			$(\'#div1\').toggleClass(\'fontSize30\');\n		})\n		\n	})\n	\n</script>\n```\n\n\n\n### 案例：tab栏切换\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>tab栏切换</title>\n		\n		\n		<style>\n			*{\n				margin: 0;\n				padding: 0;\n			}\n			\n			\n			ul{\n				list-style: none;\n			}\n			\n			.wrapper{\n				width: 1000px;\n				height: 475px;\n				margin: 0 auto;\n				margin-top:100px ;\n			}\n			\n			\n			.tab{\n				border: 1px solid #ddd;\n				border-bottom: 0;\n				height: 36px;\n				width: 320px;\n			}\n			\n			.tab li{\n				position: relative;\n				float: left;\n				width: 80px;\n				height: 34px;\n				line-height: 34px;\n				text-align: center;\n				cursor: pointer;\n				border-top: 4px solid #FFFFFF ;\n			}\n			\n			.tab span{\n				position: absolute;\n				right: 0;\n				top:10px;\n				background: #DDDDDD;\n				width: 1px;\n				height: 14px;\n				overflow: hidden;\n\n			}\n			\n			.products .main{\n				float: left;\n				display: none;\n			}\n			\n			.products .main.selected{\n				display: block;\n			}\n			\n			.tab li.active{\n				border-color: red;\n				border-bottom: 0;\n			}\n		</style>\n		\n	</head>\n	<body>\n		<div class=\"wrapper\">\n			<ul class=\"tab\">\n				<li class=\"tab-item active\">国际大牌</li>\n				<li class=\"tab-item\">国妆名牌</li>\n				<li class=\"tab-item\">清洁用品</li>\n				<li class=\"tab-item\">男士精品</li>\n			</ul>\n			<div class =\"products\">\n				<div class=\"main selected\">\n					<a href=\"\"><img src=\"img/2.jpg\" alt=\"\" /></a>\n				</div>\n				<div class=\"main \">\n					<a href=\"\"><img src=\"img/3.jpg\" alt=\"\" /></a>\n				</div>\n				<div class=\"main \">\n					<a href=\"\"><img src=\"img/4.jpg\" alt=\"\" /></a>\n				</div>\n				<div class=\"main \">\n					<a href=\"\"><img src=\"img/5.jpg\" alt=\"\" /></a>\n				</div>\n			</div>\n		</div>\n	</body>\n</html>\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n\n<script>\n	$(function(){\n		//(1)给tab栏的每一个li标签添加移入事件，当前li添加active类，其他兄弟组件移除action类	\n		//(2)找到当前tab栏索引一致的div，让他添加selected类，其他的兄弟移除selected类\n		$(\'.tab\').children().mouseenter(function(){\n			$(this).addClass(\'active\').siblings(\'li\').removeClass(\'active\');\n			var idx = $(this).index();\n			console.log(idx);\n			$(\'.products\').children(\'div\').eq(idx).addClass(\'selected\').siblings().removeClass(\'selected\');\n		})\n		\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:26:05', 2, 0, 1, '添加类：addClass(类名)//添加单个类$(\'#div1\').addClass(\'fontSize30\');//添加多个类$(\'#div1\').addClass(\'fontSize30 width200\');\n移除类： removeClass(类名)//移除单个类$(\'#div1\').removeClass(\'fontSize30\');//移除多个类$(\'#div1\').removeClass(\'fontSize30 width200\');//移除所有类$(\'#div1\').removeClass();\n判断类：hasClass(类名)//判断元素有没有某个类console.log($(\'#div1\').hasClass(\'fontSize30\'));\n切换类：toggleClass(类名)//如果元素有某个类，就移除这个类；如果没有，就添加这个类$(\'#div1\').toggleClass(\'fontSize30\');\n完整案例：<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>class操作</title>        <style>            div{                width: 100px;                height: 100px;                margin-top: 10px;            }            .bgc{                background-color: green;            }            .fontSize30{                font-size: 30px;            }            .width200{                width:200px;            }        </style>    </head>    <body>        <input type=\"button\" value=\"添加类\" id=\"addClass\" />        <input type=\"button\" value=\"移除类\" id=\"removeClass\" />        <input type=\"button\" value=\"判断类\" id=\"hasClass\" />        <input type=\"button\" value=\"切换类\" id=\"toggleClass\" />        <div id=\"div1\" class=\"bgc\">div</div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //1.添加类 addClass(类名)        $(\'#addClass\').click(function(){            //添加单个类//            $(\'#div1\').addClass(\'fontSize30\');            //添加多个类            $(\'#div1\').addClass(\'fontSize30 width200\');        });        //2.移除类 removeClass(类名)        $(\'#removeClass\').click(function(){            //移除单个类//            $(\'#div1\').removeClass(\'fontSize30\');            //移除多个类//            $(\'#div1\').removeClass(\'fontSize30 width200\');            //移除所有类            $(\'#div1\').removeClass();        });        //3.判断类：hasClass(类名)        $(\'#hasClass\').click(function(){            //判断元素有没有某个类            console.log($(\'#div1\').hasClass(\'fontSize30\'));        })        //4.切换类：toggleClass(类名)        $(\'#toggleClass\').click(function(){            //如果元素有某个类，就移除这个类；如果没有，就添加这个类            $(\'#div1\').toggleClass(\'fontSize30\');        })    })</script>\n案例：tab栏切换<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>tab栏切换</title>        <style>            *{                margin: 0;                padding: 0;            }            ul{                list-style: none;            }            .wrapper{                width: 1000px;                height: 475px;                margin: 0 auto;                margin-top:100px ;            }            .tab{                border: 1px solid #ddd;                border-bottom: 0;                height: 36px;                width: 320px;            }            .tab li{                position: relative;                float: left;                width: 80px;                height: 34px;                line-height: 34px;                text-align: center;                cursor: pointer;                border-top: 4px solid #FFFFFF ;            }            .tab span{                position: absolute;                right: 0;                top:10px;                background: #DDDDDD;                width: 1px;                height: 14px;                overflow: hidden;            }            .products .main{                float: left;                display: none;            }            .products .main.selected{                display: block;            }            .tab li.active{                border-color: red;                border-bottom: 0;            }        </style>    </head>    <body>        <div class=\"wrapper\">            <ul class=\"tab\">                <li class=\"tab-item active\">国际大牌</li>                <li class=\"tab-item\">国妆名牌</li>                <li class=\"tab-item\">清洁用品</li>                <li class=\"tab-item\">男士精品</li>            </ul>            <div class =\"products\">                <div class=\"main selected\">                    <a href=\"\"><img src=\"img/2.jpg\" alt=\"\" /></a>                </div>                <div class=\"main \">                    <a href=\"\"><img src=\"img/3.jpg\" alt=\"\" /></a>                </div>                <div class=\"main \">                    <a href=\"\"><img src=\"img/4.jpg\" alt=\"\" /></a>                </div>                <div class=\"main \">                    <a href=\"\"><img src=\"img/5.jpg\" alt=\"\" /></a>                </div>            </div>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //(1)给tab栏的每一个li标签添加移入事件，当前li添加active类，其他兄弟组件移除action类            //(2)找到当前tab栏索引一致的div，让他添加selected类，其他的兄弟移除selected类        $(\'.tab\').children().mouseenter(function(){            $(this).addClass(\'active\').siblings(\'li\').removeClass(\'active\');            var idx = $(this).index();            console.log(idx);            $(\'.products\').children(\'div\').eq(idx).addClass(\'selected\').siblings().removeClass(\'selected\');        })    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (184, '11、jQuery 动画', 8, '### 11.1 三种基本动画\n\n- 显示(show)与隐藏(hide)是一组动画；\n- 滑入(slideDown)与划出(slideUp)与切换(slideToggle)，效果与卷帘门类似\n- 淡入(fadeln)与淡出(fadeOut)与切换(fadeToggle)\n\n\n\n#### 显示与隐藏：\n\n（1）show(参数1,参数2)：显示\n\n- 参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、\n- 参数2：动画执行完毕后的回调函数\n- 无参：没有动画效果\n\n（2）show(参数1,参数2)：隐藏\n\n- 参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、\n- 参数2：动画执行完毕后的回调函数\n- 无参：没有动画效果\n\n##### 显示与隐藏案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			div{\n				height: 500px;\n				width: 500px;\n				background: red;\n				display: none;\n				\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"显示\" id=\'show\' />\n		<input type=\"button\" value=\"隐藏\" id=\'hide\' />\n		<input type=\"button\" value=\"切换\" id=\'toggle\' />\n		<br />\n		<div id =\"div1\"></div>\n	</body>\n</html>\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//(1)显示\n		//1.1 如果使用show()无参，是没有动画效果的\n		$(\'#show\').click(function(){\n			//1.1 如果使用show()无参，是没有动画效果的\n//			$(\'#div1\').show();\n			\n			//1.2 使用show(duration: String, easing: String, callback: Function)可以传入动画参数\n			//参数1：代表动画执行的时间，单位是毫秒，也可以是时长的代表字符串：fast,normal,slow\n//			$(\'#div1\').show(2000);\n//			$(\'#div1\').show(\'fast\');     	//200毫秒\n//			$(\'#div1\').show(\'normal\');		//400毫秒\n			$(\'#div1\').show(\'slow\');		//600毫秒	\n//			$(\'#div1\').show(\'sadasda\');		//如果代表时长的单词写错了，相当于写了normal\n		\n			//1.3 回调函数\n//			$(\'#div1\').show(\'slow\',function(){\n//				alert(\'动画执行完毕。。。\');\n//			});\n		\n		});\n		//(2)隐藏\n		//1.1 hide()无参，是没有动画效果的\n		$(\'#hide\').click(function(){\n			//1.1 如果使用hide()无参，是没有动画效果的\n//			$(\'#div1\').hide();\n			\n			//1.2 使用hide(duration: String, callback: Function)可以传入动画参数\n			//参数1：代表动画执行的时间，单位是毫秒，也可以是时长的代表字符串：fast,normal,slow\n			//参数2：回调函数\n//			$(\'#div1\').hide(2000);\n//			$(\'#div1\').hide(\'fast\');     	//200毫秒\n//			$(\'#div1\').hide(\'normal\');		//400毫秒\n			$(\'#div1\').hide(\'slow\');		//600毫秒	\n//			$(\'#div1\').hide(\'sadasda\');		//如果代表时长的单词写错了，相当于写了normal\n		\n			//1.3 回调函数		\n//			$(\'#div1\').hide(\'slow\',function(){\n//				alert(\'动画执行完毕。。。\');\n//			});\n		\n		});\n		\n		//3.切换\n		//将元素在隐藏和显示之间切换\n		//1.1 toggle()无参，是没有动画效果的\n		$(\'#toggle\').click(function(){\n			//1.1 toggle()无参，是没有动画效果的\n//			$(\'#div1\').toggle();\n			\n			//1.2 使用toggle(duration: String, easing: String, callback: Function)可以传入动画参数\n			//参数1：代表动画执行的时间，单位是毫秒，也可以是时长的代表字符串：fast,normal,slow\n//			$(\'#div1\').toggle(2000);\n//			$(\'#div1\').toggle(\'fast\');     	//200毫秒\n//			$(\'#div1\').toggle(\'normal\');		//400毫秒\n			$(\'#div1\').toggle(\'slow\');		//600毫秒	\n//			$(\'#div1\').toggle(\'sadasda\');		//如果代表时长的单词写错了，相当于写了normal\n		\n			//1.3  回调函数\n//			$(\'#div1\').toggle(\'slow\',function(){\n//				alert(\'动画执行完毕。。。\');\n//			});\n		\n		});\n		\n	})	\n</script>\n```\n\n\n\n#### 滑入和划出：\n\n（1）slideDown(参数1，参数2)：滑入\n\n- 参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、\n- 参数2：动画执行完毕后的回调函数\n- 无参：默认动画时长为400ms\n\n（2）slideUp(参数1，参数2)：划出\n\n- 参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、\n- 参数2：动画执行完毕后的回调函数\n- 无参：默认动画时长为400ms\n\n##### 滑入划出案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>滑入划出</title>\n		<style>\n			div{\n				height: 500px;\n				width: 500px;\n				background: red;\n				display: none;\n				\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"滑入\" id=\'slideDown\' />\n		<input type=\"button\" value=\"划出\" id=\'slideUp\' />\n		<input type=\"button\" value=\"切换\" id=\'slideToggle\' />\n		<br />\n		<div id =\"div1\"></div>\n	</body>\n</html>\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		/*\n		 * 滑入    slideDown(参数1，参数2)\n		 * 参数1：动画执行时长,可以是数字，可以是字符串\n		 * 参数2：动画执行完毕后的回调函数\n		 */\n		$(\'#slideDown\').click(function(){\n			//让id为div1的元素滑入\n//			$(\'#div1\').slideDown();    //无参，默认时长为400毫秒\n			$(\'#div1\').slideDown(2000);\n			$(\'#div1\').slideDown(2000,function(){\n				alert(\"滑入完成\");\n			});\n		});\n		\n		/*\n		 * 划出   slideUp(参数1，参数2)\n		 * 参数1：动画执行时长,可以是数字，可以是字符串\n		 * 参数2：动画执行完毕后的回调函数\n		 */\n		$(\'#slideUp\').click(function(){\n			//让id为div1的元素划出\n//			$(\'#div1\').slideUp();    //无参，默认时长为400毫秒\n//			$(\'#div1\').slideDown(2000);\n			$(\'#div1\').slideUp(2000,function(){\n				alert(\"划出完成\");\n			});\n		});\n		\n		\n		/*\n		 * 切换  \n		 * 参数1：动画执行时长,可以是数字，可以是字符串\n		 * 参数2：动画执行完毕后的回调函数\n		 */\n		$(\'#slideToggle\').click(function(){\n			//让id为div1的元素切换\n//			$(\'#div1\').slideToggle();    //无参，默认时长为400毫秒\n//			$(\'#div1\').slideToggle(2000);\n			$(\'#div1\').slideToggle(\'fast\');\n//			$(\'#div1\').slideToggle(2000,function(){\n//				alert(\"切换完成\");\n//			});\n		});\n	})	\n</script>\n```\n\n\n\n#### 淡入与淡出：\n\n（1） fadeIn(参数1，参数2)：淡入\n\n- 参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、\n- 参数2：动画执行完毕后的回调函数\n- 无参：默认动画时长为400ms\n\n（2）fadeOut(参数1，参数2)：淡出\n\n- 参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、\n- 参数2：动画执行完毕后的回调函数\n- 无参：默认动画时长为400ms\n\n（3）fadeToggle(参数1，参数2)：切换\n\n- 参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、\n- 参数2：动画执行完毕后的回调函数\n- 无参：默认动画时长为400ms\n\n（4）fadeTo(参数1，参数2，参数3)：淡入到什么程度\n\n- 参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、\n- 参数2：透明度\n- 参数3：动画执行完毕后的回调函数\n\n##### 淡入与淡出案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>淡入淡出</title>\n		<style>\n			div{\n				height: 500px;\n				width: 500px;\n				background: red;\n				display: none;				\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"淡入\" id=\'fadeIn\' />\n		<input type=\"button\" value=\"淡出\" id=\'fadeOut\' />\n		<input type=\"button\" value=\"切换\" id=\'fadeToggle\' />\n		<input type=\"button\" value=\"淡入到哪里\" id=\'fadeTo\' />\n		<br />\n		<div id =\"div1\"></div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		/*1.淡入  fadeIn(参数1，参数2)\n		 * 参数1：动画时长\n		 * 参数2：回调函数\n		 */\n		$(\'#fadeIn\').click(function(){\n			//让id为div1的元素淡入\n//			$(\'#div1\').fadeIn();    //默认的动画时长，400ms\n//			$(\'#div1\').fadeIn(2000);\n			$(\'#div1\').fadeIn(1000,function(){\n				alert(\'淡入完成\');\n			});			\n		});\n		\n		/*2.淡出  fadeOut(参数1，参数2)\n		 * 参数1：动画时长\n		 * 参数2：回调函数\n		 */\n		$(\'#fadeOut\').click(function(){\n			//让id为div1的元素淡入\n//			$(\'#div1\').fadeOut();    //默认的动画时长，400ms\n//			$(\'#div1\').fadeOut(2000);\n			$(\'#div1\').fadeOut(1000,function(){\n				alert(\'淡出完成\');\n			});			\n		});\n		\n		/*3.切换  fadeToggle(参数1，参数2)\n		 * 参数1：动画时长\n		 * 参数2：回调函数\n		 */\n		$(\'#fadeToggle\').click(function(){\n			//让id为div1的元素淡入\n			$(\'#div1\').fadeToggle(1000);    //默认的动画时长，400ms\n//			$(\'#div1\').fadeToggle(2000);\n//			$(\'#div1\').fadeToggle(1000,function(){\n//				alert(\'切换完成\');\n//			});			\n		});\n		\n		/*3.淡入到哪里  fadeTo(参数1，参数2,参数3)\n		 * 参数1：动画时长\n		 * 参数2：透明度\n		 * 参数2：回调函数\n		 */\n		$(\'#fadeTo\').click(function(){\n			//让id为div1的元素淡入\n//			$(\'#div1\').fadeTo(1000,0.5);    //默认的动画时长，400ms\n			\n			$(\'#div1\').fadeTo(1000,0.5,function(){\n				alert(\'淡入完成\');\n			});			\n		});\n	})\n</script>\n```\n\n\n\n### 11.2 自定义动画\n\n自定义动画： animate(参数1，参数2，参数3，参数4)\n\n- 参数1：必选的  对象  代表的是需要做动画的属性\n- 参数2：可选的  代表执行动画的时长\n- 参数3：可选的  代表的是缓动还是匀速   linear(匀速),swing(缓动，默认)\n- 参数4：动画执行完毕后的回调函数\n\n#### 自定义动画案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>自定义动画</title>\n		<style>\n			div{\n				height: 100px;\n				width: 100px;\n				background: red;\n				position: absolute;\n				left: 0px;\n			}\n			#div1{\n				top: 50px;\n			}\n			#div2{\n				top:300px\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"从左到右800\" id=\"lr800\" />\n		<div id=\"div1\"></div>\n		<div id=\"div2\"></div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		/*\n		* 自定义动画    animate(参数1，参数2，参数3，参数4)\n		* 参数1：必选的  对象  代表的是需要做动画的属性\n		* 参数2：可选的  代表执行动画的时长\n		* 参数3：可选的  代表的是缓动还是匀速   linear(匀速),swing(缓动，默认)\n		* 参数4：动画执行完毕后的回调函数\n		*/\n		$(\'#lr800\').click(function(){\n			//让id为lr800的元素移动到800位置\n//			$(\'#div1\').animate({\n//				left:800,\n//				width:200,\n//				height:200,\n//				opacity:0.5\n//			},2000,\'linear\',function(){\n//				alert(\'动画执行完毕\');\n//			});\n//			\n//			$(\'#div2\').animate({\n//				left:800,\n//				width:200,\n//				height:200,\n//				opacity:0.5\n//			},2000,\'swing\');\n			\n			$(\'#div1\').animate({\n				left:800,\n				width:200,\n				height:200,\n				opacity:0.5\n			},2000,\'linear\',function(){\n				//回调函数里面可以接着做动画\n				$(\'#div1\').animate({\n				left:400,\n				width:300,\n				height:300,\n				top:150,\n				opacity:0.5\n				},2000)\n			});			\n		})\n	})\n</script>\n```\n\n\n\n#### 案例：模拟开机动画\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>模拟开机动画</title>\n		<style>\n		\n			.box{\n				position: fixed;\n				bottom: 0;\n				right: 0;\n				clear: none;\n			}\n			#closeButton{\n				bottom: 200;\n				right: 0;\n\n			}\n		</style>\n	</head>\n	<body>\n		<div class=\"box\" id=\"box\">\n			<img id=\"closeButton\" src=\"img/关  闭.png\" ></img>\n			\n			<div class=\"hd\" id=\"headPart\">\n				<img src=\"img/6.jpg\" />\n			</div>\n			<div class=\"bd\" id=\"bottomPart\">\n				<img src=\"img/7.jpg\" />\n			</div>\n		</div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		$(\'#closeButton\').click(function(){\n			//让下面的部分高度变为0\n			$(\'#bottomPart\').animate({\n				height:0\n			},1000,function(){\n				//让整个大盒子的向右移动为0\n				$(\'#box\').animate({\n					width:0\n				},1000);\n			});\n		});\n		\n	})\n</script>\n```\n\n\n\n### 11.3 动画队列——stop方法\n\n**停止动画：stop(参数1，参数2)**\n\n- 参数1：是否清除动画队列\n- 参数2：是否跳转到最终结果\n\n\n\n取消动画队列案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			#div1{\n				width: 300px;\n				height: 300px;\n				background: red;\n				display: none;\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"开始动画\" id=\"start\" />\n		<input type=\"button\" value=\"停止动画\" id=\"stop\" />\n		<div id=\"div1\"></div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//1.开始动画，模拟动画队列\n		$(\'#start\').click(function(){\n			$(\'#div1\').slideDown(2000).slideUp(2000);\n		})\n		\n		//2.停止动画，执行stop()\n		/*\n		 * 停止动画：stop(参数1，参数2)\n		 * 参数1：是否清除动画队列\n		 * 参数2：是否跳转到最终结果\n		 */\n		$(\'#stop\').click(function(){\n//			$(\'#div1\').stop(true,true);\n//			$(\'#div1\').stop(true,false);\n//			$(\'#div1\').stop(false,true);\n			$(\'#div1\').stop(false,false);   //无参默认(false,false)\n			\n			\n		})\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:26:43', 2, 0, 1, '11.1 三种基本动画\n显示(show)与隐藏(hide)是一组动画；滑入(slideDown)与划出(slideUp)与切换(slideToggle)，效果与卷帘门类似淡入(fadeln)与淡出(fadeOut)与切换(fadeToggle)\n显示与隐藏：（1）show(参数1,参数2)：显示\n\n参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、参数2：动画执行完毕后的回调函数无参：没有动画效果\n（2）show(参数1,参数2)：隐藏\n\n参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、参数2：动画执行完毕后的回调函数无参：没有动画效果\n显示与隐藏案例：<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            div{                height: 500px;                width: 500px;                background: red;                display: none;            }        </style>    </head>    <body>        <input type=\"button\" value=\"显示\" id=\'show\' />        <input type=\"button\" value=\"隐藏\" id=\'hide\' />        <input type=\"button\" value=\"切换\" id=\'toggle\' />        <br />        <div id =\"div1\"></div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //(1)显示        //1.1 如果使用show()无参，是没有动画效果的        $(\'#show\').click(function(){            //1.1 如果使用show()无参，是没有动画效果的//            $(\'#div1\').show();            //1.2 使用show(duration: String, easing: String, callback: Function)可以传入动画参数            //参数1：代表动画执行的时间，单位是毫秒，也可以是时长的代表字符串：fast,normal,slow//            $(\'#div1\').show(2000);//            $(\'#div1\').show(\'fast\');         //200毫秒//            $(\'#div1\').show(\'normal\');        //400毫秒            $(\'#div1\').show(\'slow\');        //600毫秒    //            $(\'#div1\').show(\'sadasda\');        //如果代表时长的单词写错了，相当于写了normal            //1.3 回调函数//            $(\'#div1\').show(\'slow\',function(){//                alert(\'动画执行完毕。。。\');//            });        });        //(2)隐藏        //1.1 hide()无参，是没有动画效果的        $(\'#hide\').click(function(){            //1.1 如果使用hide()无参，是没有动画效果的//            $(\'#div1\').hide();            //1.2 使用hide(duration: String, callback: Function)可以传入动画参数            //参数1：代表动画执行的时间，单位是毫秒，也可以是时长的代表字符串：fast,normal,slow            //参数2：回调函数//            $(\'#div1\').hide(2000);//            $(\'#div1\').hide(\'fast\');         //200毫秒//            $(\'#div1\').hide(\'normal\');        //400毫秒            $(\'#div1\').hide(\'slow\');        //600毫秒    //            $(\'#div1\').hide(\'sadasda\');        //如果代表时长的单词写错了，相当于写了normal            //1.3 回调函数        //            $(\'#div1\').hide(\'slow\',function(){//                alert(\'动画执行完毕。。。\');//            });        });        //3.切换        //将元素在隐藏和显示之间切换        //1.1 toggle()无参，是没有动画效果的        $(\'#toggle\').click(function(){            //1.1 toggle()无参，是没有动画效果的//            $(\'#div1\').toggle();            //1.2 使用toggle(duration: String, easing: String, callback: Function)可以传入动画参数            //参数1：代表动画执行的时间，单位是毫秒，也可以是时长的代表字符串：fast,normal,slow//            $(\'#div1\').toggle(2000);//            $(\'#div1\').toggle(\'fast\');         //200毫秒//            $(\'#div1\').toggle(\'normal\');        //400毫秒            $(\'#div1\').toggle(\'slow\');        //600毫秒    //            $(\'#div1\').toggle(\'sadasda\');        //如果代表时长的单词写错了，相当于写了normal            //1.3  回调函数//            $(\'#div1\').toggle(\'slow\',function(){//                alert(\'动画执行完毕。。。\');//            });        });    })    </script>\n滑入和划出：（1）slideDown(参数1，参数2)：滑入\n\n参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、参数2：动画执行完毕后的回调函数无参：默认动画时长为400ms\n（2）slideUp(参数1，参数2)：划出\n\n参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、参数2：动画执行完毕后的回调函数无参：默认动画时长为400ms\n滑入划出案例：<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>滑入划出</title>        <style>            div{                height: 500px;                width: 500px;                background: red;                display: none;            }        </style>    </head>    <body>        <input type=\"button\" value=\"滑入\" id=\'slideDown\' />        <input type=\"button\" value=\"划出\" id=\'slideUp\' />        <input type=\"button\" value=\"切换\" id=\'slideToggle\' />        <br />        <div id =\"div1\"></div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        /*         * 滑入    slideDown(参数1，参数2)         * 参数1：动画执行时长,可以是数字，可以是字符串         * 参数2：动画执行完毕后的回调函数         */        $(\'#slideDown\').click(function(){            //让id为div1的元素滑入//            $(\'#div1\').slideDown();    //无参，默认时长为400毫秒            $(\'#div1\').slideDown(2000);            $(\'#div1\').slideDown(2000,function(){                alert(\"滑入完成\");            });        });        /*         * 划出   slideUp(参数1，参数2)         * 参数1：动画执行时长,可以是数字，可以是字符串         * 参数2：动画执行完毕后的回调函数         */        $(\'#slideUp\').click(function(){            //让id为div1的元素划出//            $(\'#div1\').slideUp();    //无参，默认时长为400毫秒//            $(\'#div1\').slideDown(2000);            $(\'#div1\').slideUp(2000,function(){                alert(\"划出完成\");            });        });        /*         * 切换           * 参数1：动画执行时长,可以是数字，可以是字符串         * 参数2：动画执行完毕后的回调函数         */        $(\'#slideToggle\').click(function(){            //让id为div1的元素切换//            $(\'#div1\').slideToggle();    //无参，默认时长为400毫秒//            $(\'#div1\').slideToggle(2000);            $(\'#div1\').slideToggle(\'fast\');//            $(\'#div1\').slideToggle(2000,function(){//                alert(\"切换完成\");//            });        });    })    </script>\n淡入与淡出：（1） fadeIn(参数1，参数2)：淡入\n\n参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、参数2：动画执行完毕后的回调函数无参：默认动画时长为400ms\n（2）fadeOut(参数1，参数2)：淡出\n\n参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、参数2：动画执行完毕后的回调函数无参：默认动画时长为400ms\n（3）fadeToggle(参数1，参数2)：切换\n\n参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、参数2：动画执行完毕后的回调函数无参：默认动画时长为400ms\n（4）fadeTo(参数1，参数2，参数3)：淡入到什么程度\n\n参数1：动画时长，可以是数值（单位毫秒）、代表时长的字符串（fast,normal,slow）、参数2：透明度参数3：动画执行完毕后的回调函数\n淡入与淡出案例：<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>淡入淡出</title>        <style>            div{                height: 500px;                width: 500px;                background: red;                display: none;                            }        </style>    </head>    <body>        <input type=\"button\" value=\"淡入\" id=\'fadeIn\' />        <input type=\"button\" value=\"淡出\" id=\'fadeOut\' />        <input type=\"button\" value=\"切换\" id=\'fadeToggle\' />        <input type=\"button\" value=\"淡入到哪里\" id=\'fadeTo\' />        <br />        <div id =\"div1\"></div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        /*1.淡入  fadeIn(参数1，参数2)         * 参数1：动画时长         * 参数2：回调函数         */        $(\'#fadeIn\').click(function(){            //让id为div1的元素淡入//            $(\'#div1\').fadeIn();    //默认的动画时长，400ms//            $(\'#div1\').fadeIn(2000);            $(\'#div1\').fadeIn(1000,function(){                alert(\'淡入完成\');            });                    });        /*2.淡出  fadeOut(参数1，参数2)         * 参数1：动画时长         * 参数2：回调函数         */        $(\'#fadeOut\').click(function(){            //让id为div1的元素淡入//            $(\'#div1\').fadeOut();    //默认的动画时长，400ms//            $(\'#div1\').fadeOut(2000);            $(\'#div1\').fadeOut(1000,function(){                alert(\'淡出完成\');            });                    });        /*3.切换  fadeToggle(参数1，参数2)         * 参数1：动画时长         * 参数2：回调函数         */        $(\'#fadeToggle\').click(function(){            //让id为div1的元素淡入            $(\'#div1\').fadeToggle(1000);    //默认的动画时长，400ms//            $(\'#div1\').fadeToggle(2000);//            $(\'#div1\').fadeToggle(1000,function(){//                alert(\'切换完成\');//            });                    });        /*3.淡入到哪里  fadeTo(参数1，参数2,参数3)         * 参数1：动画时长         * 参数2：透明度         * 参数2：回调函数         */        $(\'#fadeTo\').click(function(){            //让id为div1的元素淡入//            $(\'#div1\').fadeTo(1000,0.5);    //默认的动画时长，400ms            $(\'#div1\').fadeTo(1000,0.5,function(){                alert(\'淡入完成\');            });                    });    })</script>\n11.2 自定义动画自定义动画： animate(参数1，参数2，参数3，参数4)\n\n参数1：必选的  对象  代表的是需要做动画的属性参数2：可选的  代表执行动画的时长参数3：可选的  代表的是缓动还是匀速   linear(匀速),swing(缓动，默认)参数4：动画执行完毕后的回调函数\n自定义动画案例：<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>自定义动画</title>        <style>            div{                height: 100px;                width: 100px;                background: red;                position: absolute;                left: 0px;            }            #div1{                top: 50px;            }            #div2{                top:300px            }        </style>    </head>    <body>        <input type=\"button\" value=\"从左到右800\" id=\"lr800\" />        <div id=\"div1\"></div>        <div id=\"div2\"></div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        /*        * 自定义动画    animate(参数1，参数2，参数3，参数4)        * 参数1：必选的  对象  代表的是需要做动画的属性        * 参数2：可选的  代表执行动画的时长        * 参数3：可选的  代表的是缓动还是匀速   linear(匀速),swing(缓动，默认)        * 参数4：动画执行完毕后的回调函数        */        $(\'#lr800\').click(function(){            //让id为lr800的元素移动到800位置//            $(\'#div1\').animate({//                left:800,//                width:200,//                height:200,//                opacity:0.5//            },2000,\'linear\',function(){//                alert(\'动画执行完毕\');//            });//            //            $(\'#div2\').animate({//                left:800,//                width:200,//                height:200,//                opacity:0.5//            },2000,\'swing\');            $(\'#div1\').animate({                left:800,                width:200,                height:200,                opacity:0.5            },2000,\'linear\',function(){                //回调函数里面可以接着做动画                $(\'#div1\').animate({                left:400,                width:300,                height:300,                top:150,                opacity:0.5                },2000)            });                    })    })</script>\n案例：模拟开机动画<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>模拟开机动画</title>        <style>            .box{                position: fixed;                bottom: 0;                right: 0;                clear: none;            }            #closeButton{                bottom: 200;                right: 0;            }        </style>    </head>    <body>        <div class=\"box\" id=\"box\">            <img id=\"closeButton\" src=\"img/关  闭.png\" ></img>            <div class=\"hd\" id=\"headPart\">                <img src=\"img/6.jpg\" />            </div>            <div class=\"bd\" id=\"bottomPart\">                <img src=\"img/7.jpg\" />            </div>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        $(\'#closeButton\').click(function(){            //让下面的部分高度变为0            $(\'#bottomPart\').animate({                height:0            },1000,function(){                //让整个大盒子的向右移动为0                $(\'#box\').animate({                    width:0                },1000);            });        });    })</script>\n11.3 动画队列——stop方法停止动画：stop(参数1，参数2)\n\n参数1：是否清除动画队列参数2：是否跳转到最终结果\n取消动画队列案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            #div1{                width: 300px;                height: 300px;                background: red;                display: none;            }        </style>    </head>    <body>        <input type=\"button\" value=\"开始动画\" id=\"start\" />        <input type=\"button\" value=\"停止动画\" id=\"stop\" />        <div id=\"div1\"></div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //1.开始动画，模拟动画队列        $(\'#start\').click(function(){            $(\'#div1\').slideDown(2000).slideUp(2000);        })        //2.停止动画，执行stop()        /*         * 停止动画：stop(参数1，参数2)         * 参数1：是否清除动画队列         * 参数2：是否跳转到最终结果         */        $(\'#stop\').click(function(){//            $(\'#div1\').stop(true,true);//            $(\'#div1\').stop(true,false);//            $(\'#div1\').stop(false,true);            $(\'#div1\').stop(false,false);   //无参默认(false,false)        })    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (185, '12、动态创建元素', 8, '（1）原生js创建节点：\n\n- document.write()\n- innerHTML()\n- document.createElement()\n\n（2）jQuert创建节点：\n\n- html()\n- $()\n\n**html()：**\n\n- 获取内容：html()无参是获取内容\n- 设置内容：html()有参数，设置的内容会把原先的内容覆盖\n\n **$()：**\n\n- 能够创建元素，创建元素在内存中\n- 如果需要显示，则需要使用append()追加元素\n\n\n\n案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			#div1{\n				width: 300px;\n				height: 300px;\n				border: 1px solid red;\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"html()\" id=\"btnHtml\" />\n		<input type=\"button\" value=\"$()\" id=\"btn1\" />\n		\n		<div id=\"div1\">\n			<p>p1\n				<span>span1</span>\n			</p>\n		</div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		/*\n		 * 原生js创建节点：\n		 * (1) document.write()\n		 * (2)innerHTML()\n		 * (3)document.createElement()\n		 */\n		\n		/*\n		 * jQuert创建节点：\n		 * (1)html()\n		 * (2)$()\n		 */\n		\n		//1. html()\n		$(\'#btnHtml\').click(function(){\n			//1.1 获取内容：html()无参是获取内容\n//			console.log($(\'#div1\').html());\n			\n			//1.2设置内容：html()有参数\n			//设置的内容会把原先的内容覆盖\n			$(\'#div1\').html(\'我是设置的内容<a href=\"https://www.baidu.com\">百度一下</a>\');\n		});\n		\n		//2. $()\n		//能够创建元素，创建元素在内存中\n		$(\'#btn1\').click(function(){\n			var $link = $(\'<a href=\"https://leetcode-cn.com/problemset/all/\">我的Leetcode</a>\');\n//			console.log($link);\n			//追加元素\n			$(\'#div1\').append($link);\n		});\n		\n	})\n</script>\n```\n\n案例：表格生成案例\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>动态生成表格</title>\n		<style>\n			*{\n				padding: 0;\n				margin: 0;\n			}\n			table{\n				border-collapse:collapse ;\n				border-spacing: 0;\n			}\n			\n			thead{\n				display: table-header-group;\n				vertical-align: middle;\n				border-color:inherit ;\n			}\n			\n			tbody{\n				display: table-row-group;\n				vertical-align: middle;\n				border-color: inherit;\n			}\n			th{\n				padding: 10px 10px;\n				background-color: skyblue;\n				border: 1px solid white;\n			}\n			td{\n				padding: 10px 10px;\n				background-color: #eeeeee;\n				border: 1px solid #999999;\n			}\n			\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"获取数据\" id=\"but_get\" />\n		<table>\n			<thead>\n				<tr>\n					<th>标题</th>\n					<th>地址</th>\n					<th>说明</th>\n				</tr>\n			</thead>\n			<tbody id=\"tbDate\">\n				\n			</tbody>\n		</table>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		var data = [{\n			name:\"知乎\",\n			url:\"https://www.zhihu.com/\",\n			type:\"找到你想知道的\"\n		},{\n			name:\"CSDN\",\n			url:\"https://www.csdn.net/\",\n			type:\"个人博客\"\n		},{\n			name:\"Leetcode\",\n			url:\"https://leetcode-cn.com/problemset/all/\",\n			type:\"刷题网站\"\n		}];\n		\n		//点击获取数据按钮，将data数据添加至表格\n		$(\'#but_get\').click(function(){\n			//1.html()\n			//设置内容，内容中有标签会解析，会覆盖掉原来的内容\n//			var list= [];\n//			for(var i = 0;i<data.length;i++){\n//				//生成tr\n//				list.push(\"<tr>\");\n//				//生成td\n//				for(var key in data[i]){\n//					list.push(\"<td>\");\n//					list.push(data[i][key]);\n//					list.push(\"</td>\");\n//				}\n//				\n//				list.push(\"</tr>\");\n//			}\n//			//连接列表中的字符串\n//			console.log(list.join(\"\"));\n//			$(\'#tbDate\').html(list.join(\"\"));\n\n\n			//2.$()\n			for(var i = 0;i<data.length;i++){\n				var $tr = $(\"<tr><td>\"+data[i][\'name\'] +\"</td><td>\"+data[i][\'url\'] +\"</td><td>\"+data[i][\'type\'] +\"</td></tr>\")\n				console.log($tr);\n				//把创建出来的$tr追加tbody中 \n				$(\'#tbDate\').append($tr);\n			}\n\n			\n		});\n		\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:27:09', 2, 0, 1, '（1）原生js创建节点：\n\ndocument.write()innerHTML()document.createElement()\n（2）jQuert创建节点：\n\nhtml()$()\nhtml()：\n\n获取内容：html()无参是获取内容设置内容：html()有参数，设置的内容会把原先的内容覆盖\n$()：\n能够创建元素，创建元素在内存中\n如果需要显示，则需要使用append()追加元素\n案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            #div1{                width: 300px;                height: 300px;                border: 1px solid red;            }        </style>    </head>    <body>        <input type=\"button\" value=\"html()\" id=\"btnHtml\" />        <input type=\"button\" value=\"$()\" id=\"btn1\" />        <div id=\"div1\">            <p>p1                <span>span1</span>            </p>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        /*         * 原生js创建节点：         * (1) document.write()         * (2)innerHTML()         * (3)document.createElement()         */        /*         * jQuert创建节点：         * (1)html()         * (2)$()         */        //1. html()        $(\'#btnHtml\').click(function(){            //1.1 获取内容：html()无参是获取内容//            console.log($(\'#div1\').html());            //1.2设置内容：html()有参数            //设置的内容会把原先的内容覆盖            $(\'#div1\').html(\'我是设置的内容<a href=\"https://www.baidu.com\">百度一下</a>\');        });        //2. $()        //能够创建元素，创建元素在内存中        $(\'#btn1\').click(function(){            var $link = $(\'<a href=\"https://leetcode-cn.com/problemset/all/\">我的Leetcode</a>\');//            console.log($link);            //追加元素            $(\'#div1\').append($link);        });    })</script>\n案例：表格生成案例\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>动态生成表格</title>        <style>            *{                padding: 0;                margin: 0;            }            table{                border-collapse:collapse ;                border-spacing: 0;            }            thead{                display: table-header-group;                vertical-align: middle;                border-color:inherit ;            }            tbody{                display: table-row-group;                vertical-align: middle;                border-color: inherit;            }            th{                padding: 10px 10px;                background-color: skyblue;                border: 1px solid white;            }            td{                padding: 10px 10px;                background-color: #eeeeee;                border: 1px solid #999999;            }        </style>    </head>    <body>        <input type=\"button\" value=\"获取数据\" id=\"but_get\" />        <table>            <thead>                <tr>                    <th>标题</th>                    <th>地址</th>                    <th>说明</th>                </tr>            </thead>            <tbody id=\"tbDate\">            </tbody>        </table>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        var data = [{            name:\"知乎\",            url:\"https://www.zhihu.com/\",            type:\"找到你想知道的\"        },{            name:\"CSDN\",            url:\"https://www.csdn.net/\",            type:\"个人博客\"        },{            name:\"Leetcode\",            url:\"https://leetcode-cn.com/problemset/all/\",            type:\"刷题网站\"        }];        //点击获取数据按钮，将data数据添加至表格        $(\'#but_get\').click(function(){            //1.html()            //设置内容，内容中有标签会解析，会覆盖掉原来的内容//            var list= [];//            for(var i = 0;i<data.length;i++){//                //生成tr//                list.push(\"<tr>\");//                //生成td//                for(var key in data[i]){//                    list.push(\"<td>\");//                    list.push(data[i][key]);//                    list.push(\"</td>\");//                }//                //                list.push(\"</tr>\");//            }//            //连接列表中的字符串//            console.log(list.join(\"\"));//            $(\'#tbDate\').html(list.join(\"\"));            //2.$()            for(var i = 0;i<data.length;i++){                var $tr = $(\"<tr><td>\"+data[i][\'name\'] +\"</td><td>\"+data[i][\'url\'] +\"</td><td>\"+data[i][\'type\'] +\"</td></tr>\")                console.log($tr);                //把创建出来的$tr追加tbody中                 $(\'#tbDate\').append($tr);            }        });    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (186, '13、添加元素的几种方式', 8, '添加元素的几种方式：\n\n（1）append()\n\n- 父元素.append(子元素)，把子元素添加到父元素的末尾\n- 新创建标签，添加到父元素中，会添加到父元素的末尾\n- 将已有的标签元素，添加到父元素中，会剪贴到父元素末尾\n\n（2）prepend() \n\n- 父元素.prepend(子元素)，把子元素添加到父元素的头部\n- 新创建标签，添加到父元素中，会添加到父元素的头部\n- 将已有的标签元素，添加到父元素中，会剪贴到父元素头部\n\n（3）before()\n\n- 元素A.prepend(元素B)，把元素B添加到元素A的兄弟元素，添加到A的头部\n\n（4）after()\n\n- 元素A.after(元素B) 把元素B作为元素A的兄弟元素添加元素A的后面\n\n（5）appendTo()\n\n- 子元素.appendTo(父元素)  把子元素添加到父元素末尾\n\n**代码案例：**\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n	</head>\n	<body>\n		<input type=\"button\" value=\"append\" id=\"btnAppend\" />\n		<input type=\"button\" value=\"prepend\" id=\"btnPrepend\" />\n		<input type=\"button\" value=\"before\" id=\"btnBefore\" />\n		<input type=\"button\" value=\"after\" id=\"btnAfter\" />\n		<input type=\"button\" value=\"appendTo\" id=\"btnAppendTo\" />\n		\n		<ul id=\"ul1\">\n			<li>我是第1个li标签</li>\n			<li>我是第2个li标签</li>\n			<li id=\"li3\">我是第3个li标签</li>\n			<li>我是第4个li标签</li>\n			<li>我是第5个li标签</li>\n		</ul>\n		<ul id=\"ul2\">\n			<li>我是第1个li标签2</li>\n			<li>我是第2个li标签2</li>\n			<li id=\"li32\">我是第3个li标签2</li>\n			<li>我是第4个li标签2</li>\n			<li>我是第5个li标签2</li>\n		</ul>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//添加标签的几种方式\n		//1.append()\n		//父元素.append(子元素)，把子元素添加到父元素的末尾\n		$(\'#btnAppend\').click(function(){\n			//1.1 新创建一个li标签，添加ul中去，会添加到父元素的末尾\n//			var $liNew = $(\"<li>我是新创建的li标签</li>\");\n//			$(\'#ul1\').append($liNew);\n\n			//1.2 把ul1中已经有的元素，再次添加到url中，剪切后作为最后一个元素添加\n//			var $li3 = $(\'#li3\');\n//			$(\'#ul1\').append($li3);\n			\n			//1.3 把ul2中已经存在的标签，添加到ul1中，剪切后作为最后一个元素添加\n			var $li32 = $(\'#li32\');\n			$(\'#ul1\').append($li32);\n		});\n		\n		//2.prepend() \n		//父元素.prepend(子元素)，把子元素添加到父元素的头部\n		$(\'#btnPrepend\').click(function(){\n			//2.1 新建一个li标签，添加到ul1中，把新元素作为第一个子元素添加\n//			var $liNew = $(\"<li>我是新创建的li标签</li>\");\n//			$(\'#ul1\').prepend($liNew);\n			\n			//2.2 把ul1中已经有的元素，再次添加到url中，剪切后作为第一个元素添加\n//			var $li3 = $(\'#li3\');\n//			$(\'#ul1\').prepend($li3);\n			\n			//1.3 把ul2中已经存在的标签，添加到ul1中，剪切后作为第一个元素添加\n			var $li32 = $(\'#li32\');\n			$(\'#ul1\').prepend($li32);\n			\n		});\n		\n		//3.before()\n		//元素A.before(元素B) 把元素B作为元素A的兄弟元素添加元素A的前面\n		$(\'#btnBefore\').click(function(){\n			//新建一个div\n			var $divNew = $(\'<div>我是新建的div</div>\');\n			$(\'#ul1\').before($divNew);\n		});\n		\n		//4.after()\n		//元素A.after(元素B) 把元素B作为元素A的兄弟元素添加元素A的后面\n		$(\'#btnAfter\').click(function(){\n			//新建一个div\n			var $divNew = $(\'<div>我是新建的div</div>\');\n			$(\'#ul1\').after($divNew);\n		});\n		\n		//5.appendTo()\n		//子元素.appendTo(父元素)  把子元素添加到父元素末尾\n		$(\'#btnAppendTo\').click(function(){\n			var $liNew = $(\"<li>我是新创建的li标签</li>\");\n			$liNew.appendTo($(\'#ul1\'));\n		});\n	})\n</script>\n```\n\n\n\n**案例——城市选择**\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>城市选择</title>\n		<style type=\"text/css\">\n			select{\n				width: 200px;\n				background: teal;\n				height: 200px;\n				font-size: 20px;\n			}\n			option{\n				font-weight: normal;\n				display: block;\n				white-space: pre;\n				padding: 0px 2px 1px;\n			}\n			.btn-box{\n				width: 30px;\n				display: inline-block;\n				vertical-align: top;\n			}\n		</style>\n		\n	</head>\n	<body>\n		<h1>城市选择</h1>\n		<select id=\"src-city\" name=\"src-city\" multiple=\"multiple\">\n			<option value=\"1\">北京</option>\n			<option value=\"2\">上海</option>\n			<option value=\"3\">广州</option>\n			<option value=\"4\">杭州</option>\n		</select>\n		<div class=\"btn-box\">\n			<input type=\"button\" value=\">>\" id=\"btn-sel-all\" />\n			<input type=\"button\" value=\"<<\" id=\"btn-sel-none\" />\n			<input type=\"button\" value=\">\" id=\"btn-sel\" />\n			<input type=\"button\" value=\"<\" id=\"btn-back\" />\n		</div>\n		<select id=\"tar-city\" name=\"tar-city\" multiple=\"multiple\"></select>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//1.全部到右边\n		$(\'#btn-sel-all\').click(function(){\n			//找到左边所以的option，剪切到右边的select下\n			$(\'#src-city>option\').appendTo($(\'#tar-city\'));\n		});\n		\n		//1.全部到右边\n		$(\'#btn-sel-all\').click(function(){\n			//找到左边所有的option，剪切到右边的select下\n			$(\'#src-city>option\').appendTo($(\'#tar-city\'));\n		});\n		\n		//2.全部到左边\n		$(\'#btn-sel-none\').click(function(){\n			//找到右边所有的option，剪切到左边的select下\n			$(\'#tar-city>option\').appendTo($(\'#src-city\'));\n		});\n		\n		//3.选中的到右边\n		$(\'#btn-sel\').click(function(){\n			//找到左边选中的option，剪切到右边的select中\n//			console.log($(\'#src-city>option:selected\'));\n			$(\'#src-city>option:selected\').appendTo($(\'#tar-city\'));\n		});\n		\n		//3.选中的到左边\n		$(\'#btn-back\').click(function(){\n			//找到右边选中的option，剪切到左边的select中\n//			console.log($(\'#tar-city>option:selected\'));\n			$(\'#tar-city>option:selected\').appendTo($(\'#src-city\'));\n		});\n	})\n</script>\n```\n\n\n\n**案例——表格删除**\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>表格删除</title>\n		<style>\n			*{\n				padding: 0;\n				margin: 0;\n			}\n			table{\n				border-collapse:collapse ;\n				border-spacing: 0;\n			}\n			\n			thead{\n				display: table-header-group;\n				vertical-align: middle;\n				border-color:inherit ;\n			}\n			\n			tbody{\n				display: table-row-group;\n				vertical-align: middle;\n				border-color: inherit;\n			}\n			th{\n				padding: 10px 10px;\n				background-color: skyblue;\n				border: 1px solid white;\n			}\n			td{\n				padding: 10px 10px;\n				background-color: #eeeeee;\n				border: 1px solid #999999;\n			}\n		</style>\n	</head>\n	<body>\n		<div class=\"wrap\">\n			<input type=\"button\" value=\"清空内容\" id=\"btn\" />\n			<table>\n				<thead>\n					<tr>\n						<th>专栏名称</th>\n						<th>内容描述</th>\n						<th>操作</th>\n					</tr>\n				</thead>\n				<tbody id=\"tb\">\n					<tr>\n						<td>JavaSE 学习笔记</td>\n						<td>参考Oracle官方文档，系统学习JavaSE</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n					<tr>\n						<td>Oracle数据库笔记</td>\n						<td>参考Oracle官方文档，系统学习Oracle数据库</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n					<tr>\n						<td>LeetCode热门算法100道</td>\n						<td>刷题的必选之路</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n					<tr>\n						<td>Linux学习笔记</td>\n						<td>从零学习Linux系统</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n				</tbody>\n			</table>\n		</div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//1.清空内容\n		$(\'#btn\').click(function(){\n			$(\'#tb\').empty();\n		})\n		\n		//2.删除一行\n		$(\'#tb .del\').click(function(){\n			console.log(\"123\");\n			console.log($(this));\n			$(this).parent().parent().remove();\n		})\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:27:34', 2, 0, 1, '添加元素的几种方式：\n（1）append()\n\n父元素.append(子元素)，把子元素添加到父元素的末尾新创建标签，添加到父元素中，会添加到父元素的末尾将已有的标签元素，添加到父元素中，会剪贴到父元素末尾\n（2）prepend() \n\n父元素.prepend(子元素)，把子元素添加到父元素的头部新创建标签，添加到父元素中，会添加到父元素的头部将已有的标签元素，添加到父元素中，会剪贴到父元素头部\n（3）before()\n\n元素A.prepend(元素B)，把元素B添加到元素A的兄弟元素，添加到A的头部\n（4）after()\n\n元素A.after(元素B) 把元素B作为元素A的兄弟元素添加元素A的后面\n（5）appendTo()\n\n子元素.appendTo(父元素)  把子元素添加到父元素末尾\n代码案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>    </head>    <body>        <input type=\"button\" value=\"append\" id=\"btnAppend\" />        <input type=\"button\" value=\"prepend\" id=\"btnPrepend\" />        <input type=\"button\" value=\"before\" id=\"btnBefore\" />        <input type=\"button\" value=\"after\" id=\"btnAfter\" />        <input type=\"button\" value=\"appendTo\" id=\"btnAppendTo\" />        <ul id=\"ul1\">            <li>我是第1个li标签</li>            <li>我是第2个li标签</li>            <li id=\"li3\">我是第3个li标签</li>            <li>我是第4个li标签</li>            <li>我是第5个li标签</li>        </ul>        <ul id=\"ul2\">            <li>我是第1个li标签2</li>            <li>我是第2个li标签2</li>            <li id=\"li32\">我是第3个li标签2</li>            <li>我是第4个li标签2</li>            <li>我是第5个li标签2</li>        </ul>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //添加标签的几种方式        //1.append()        //父元素.append(子元素)，把子元素添加到父元素的末尾        $(\'#btnAppend\').click(function(){            //1.1 新创建一个li标签，添加ul中去，会添加到父元素的末尾//            var $liNew = $(\"<li>我是新创建的li标签</li>\");//            $(\'#ul1\').append($liNew);            //1.2 把ul1中已经有的元素，再次添加到url中，剪切后作为最后一个元素添加//            var $li3 = $(\'#li3\');//            $(\'#ul1\').append($li3);            //1.3 把ul2中已经存在的标签，添加到ul1中，剪切后作为最后一个元素添加            var $li32 = $(\'#li32\');            $(\'#ul1\').append($li32);        });        //2.prepend()         //父元素.prepend(子元素)，把子元素添加到父元素的头部        $(\'#btnPrepend\').click(function(){            //2.1 新建一个li标签，添加到ul1中，把新元素作为第一个子元素添加//            var $liNew = $(\"<li>我是新创建的li标签</li>\");//            $(\'#ul1\').prepend($liNew);            //2.2 把ul1中已经有的元素，再次添加到url中，剪切后作为第一个元素添加//            var $li3 = $(\'#li3\');//            $(\'#ul1\').prepend($li3);            //1.3 把ul2中已经存在的标签，添加到ul1中，剪切后作为第一个元素添加            var $li32 = $(\'#li32\');            $(\'#ul1\').prepend($li32);        });        //3.before()        //元素A.before(元素B) 把元素B作为元素A的兄弟元素添加元素A的前面        $(\'#btnBefore\').click(function(){            //新建一个div            var $divNew = $(\'<div>我是新建的div</div>\');            $(\'#ul1\').before($divNew);        });        //4.after()        //元素A.after(元素B) 把元素B作为元素A的兄弟元素添加元素A的后面        $(\'#btnAfter\').click(function(){            //新建一个div            var $divNew = $(\'<div>我是新建的div</div>\');            $(\'#ul1\').after($divNew);        });        //5.appendTo()        //子元素.appendTo(父元素)  把子元素添加到父元素末尾        $(\'#btnAppendTo\').click(function(){            var $liNew = $(\"<li>我是新创建的li标签</li>\");            $liNew.appendTo($(\'#ul1\'));        });    })</script>\n案例——城市选择\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>城市选择</title>        <style type=\"text/css\">            select{                width: 200px;                background: teal;                height: 200px;                font-size: 20px;            }            option{                font-weight: normal;                display: block;                white-space: pre;                padding: 0px 2px 1px;            }            .btn-box{                width: 30px;                display: inline-block;                vertical-align: top;            }        </style>    </head>    <body>        <h1>城市选择</h1>        <select id=\"src-city\" name=\"src-city\" multiple=\"multiple\">            <option value=\"1\">北京</option>            <option value=\"2\">上海</option>            <option value=\"3\">广州</option>            <option value=\"4\">杭州</option>        </select>        <div class=\"btn-box\">            <input type=\"button\" value=\">>\" id=\"btn-sel-all\" />            <input type=\"button\" value=\"<<\" id=\"btn-sel-none\" />            <input type=\"button\" value=\">\" id=\"btn-sel\" />            <input type=\"button\" value=\"<\" id=\"btn-back\" />        </div>        <select id=\"tar-city\" name=\"tar-city\" multiple=\"multiple\"></select>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //1.全部到右边        $(\'#btn-sel-all\').click(function(){            //找到左边所以的option，剪切到右边的select下            $(\'#src-city>option\').appendTo($(\'#tar-city\'));        });        //1.全部到右边        $(\'#btn-sel-all\').click(function(){            //找到左边所有的option，剪切到右边的select下            $(\'#src-city>option\').appendTo($(\'#tar-city\'));        });        //2.全部到左边        $(\'#btn-sel-none\').click(function(){            //找到右边所有的option，剪切到左边的select下            $(\'#tar-city>option\').appendTo($(\'#src-city\'));        });        //3.选中的到右边        $(\'#btn-sel\').click(function(){            //找到左边选中的option，剪切到右边的select中//            console.log($(\'#src-city>option:selected\'));            $(\'#src-city>option:selected\').appendTo($(\'#tar-city\'));        });        //3.选中的到左边        $(\'#btn-back\').click(function(){            //找到右边选中的option，剪切到左边的select中//            console.log($(\'#tar-city>option:selected\'));            $(\'#tar-city>option:selected\').appendTo($(\'#src-city\'));        });    })</script>\n案例——表格删除\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>表格删除</title>        <style>            *{                padding: 0;                margin: 0;            }            table{                border-collapse:collapse ;                border-spacing: 0;            }            thead{                display: table-header-group;                vertical-align: middle;                border-color:inherit ;            }            tbody{                display: table-row-group;                vertical-align: middle;                border-color: inherit;            }            th{                padding: 10px 10px;                background-color: skyblue;                border: 1px solid white;            }            td{                padding: 10px 10px;                background-color: #eeeeee;                border: 1px solid #999999;            }        </style>    </head>    <body>        <div class=\"wrap\">            <input type=\"button\" value=\"清空内容\" id=\"btn\" />            <table>                <thead>                    <tr>                        <th>专栏名称</th>                        <th>内容描述</th>                        <th>操作</th>                    </tr>                </thead>                <tbody id=\"tb\">                    <tr>                        <td>JavaSE 学习笔记</td>                        <td>参考Oracle官方文档，系统学习JavaSE</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                    <tr>                        <td>Oracle数据库笔记</td>                        <td>参考Oracle官方文档，系统学习Oracle数据库</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                    <tr>                        <td>LeetCode热门算法100道</td>                        <td>刷题的必选之路</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                    <tr>                        <td>Linux学习笔记</td>                        <td>从零学习Linux系统</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                </tbody>            </table>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //1.清空内容        $(\'#btn\').click(function(){            $(\'#tb\').empty();        })        //2.删除一行        $(\'#tb .del\').click(function(){            console.log(\"123\");            console.log($(this));            $(this).parent().parent().remove();        })    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (187, '14、克隆节点', 8, '### **click(参数1): 克隆节点**\n\n- 无参：默认为false\n- 参数：无论是true还是false都会克隆后代节点\n- 参数为true：会把事件克隆    false:不会克隆事件\n\n克隆的组件只存在于内存中，如果要显示，就要追加到页面上。\n\n案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			#div1{\n				width: 400px;\n				height: 200px;\n				border: 1px solid red;\n			}\n			#div2{\n				width: 400px;\n				height: 200px;\n				border: 1px solid blue;\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"克隆\" id=\"clone\" />\n		<div id=\"div1\">\n			<span>span1</span>\n			<p>p1\n				<b>b1</b>\n			</p>\n		</div>\n		<br />\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		$(\'#div1\').click(function(){\n			alert(\'我被点击到了\');\n		})\n		//clone(参数)：克隆\n		//无参：默认为false\n		//参数：无论是true还是false都会克隆后代节点\n		//参数为true：会把事件克隆    false:不会克隆事件\n		\n		//只存在于内存中，如果要显示，就要追加到页面上\n		$(\'#clone\').click(function(){\n		 	var $cloneDiv = $(\'#div1\').clone(false);\n		 	console.log($cloneDiv);\n		 	\n		 	//修改克隆节点的id\n		 	$cloneDiv.attr(\'id\',\'div2\');\n		 	//把克隆的节点追加到body\n		 	$(\'body\').append($cloneDiv);\n		})\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:28:07', 2, 0, 1, 'click(参数1): 克隆节点\n无参：默认为false参数：无论是true还是false都会克隆后代节点参数为true：会把事件克隆    false:不会克隆事件\n克隆的组件只存在于内存中，如果要显示，就要追加到页面上。\n案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            #div1{                width: 400px;                height: 200px;                border: 1px solid red;            }            #div2{                width: 400px;                height: 200px;                border: 1px solid blue;            }        </style>    </head>    <body>        <input type=\"button\" value=\"克隆\" id=\"clone\" />        <div id=\"div1\">            <span>span1</span>            <p>p1                <b>b1</b>            </p>        </div>        <br />    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        $(\'#div1\').click(function(){            alert(\'我被点击到了\');        })        //clone(参数)：克隆        //无参：默认为false        //参数：无论是true还是false都会克隆后代节点        //参数为true：会把事件克隆    false:不会克隆事件        //只存在于内存中，如果要显示，就要追加到页面上        $(\'#clone\').click(function(){             var $cloneDiv = $(\'#div1\').clone(false);             console.log($cloneDiv);             //修改克隆节点的id             $cloneDiv.attr(\'id\',\'div2\');             //把克隆的节点追加到body             $(\'body\').append($cloneDiv);        })    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (188, '15、获取和设置表单内容', 8, '### val()：获取和设置表单内容\n\n- 原生js是通过value属性来获取或者设置表单元素值\n- jQuery是通过 var()\n- val()，无参就是获取\n- val(设置的值)，有参就是设置\n\n\n\n案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n	</head>\n	<body>\n		<input type=\"button\" value=\"获取\" id=\"btn-get\" />\n		<input type=\"button\" value=\"设置\" id=\"btn-set\" />\n		<input type=\"text\" placeholder=\"请输入账号\" value=\"\" id=\"txt\"/>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//原生js是通过value属性来获取或者设置表单元素值\n		//jQuery是通过 var()\n		\n		//1.val()，无参就是获取\n		$(\'#btn-get\').click(function(){\n			console.log($(\'#txt\').val());\n		});\n		\n		//2.val(设置的值)，有参就是设置\n		$(\'#btn-set\').click(function(){\n			$(\'#txt\').val(\"我是设置的值\");			\n		});		\n	})\n</script>\n```\n\n\n\n### 案例：动态数据的添加和删除\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>表格删除</title>\n		<style>\n			*{\n				padding: 0;\n				margin: 0;\n			}\n			table{\n				border-collapse:collapse ;\n				border-spacing: 0;\n				\n			}\n			\n			thead{\n				display: table-header-group;\n				vertical-align: middle;\n				border-color:inherit ;\n			}\n			\n			tbody{\n				display: table-row-group;\n				vertical-align: middle;\n				border-color: inherit;\n			}\n			th{\n				padding: 10px 10px;\n				background-color: skyblue;\n				border: 1px solid white;\n			}\n			td{\n				padding: 10px 10px;\n				background-color: #eeeeee;\n				border: 1px solid #999999;\n			}\n			.mask{\n				position: absolute;\n				left: 0px;\n				top:0px;\n				background-color: #EEEEEE;\n				opacity:0.5;\n				width: 100000px;\n				height: 10000px;\n				display: none;\n			}\n			\n			.form-add{\n				width: 400px;\n	            height: 300px;\n	            background: skyblue;\n	            position:absolute;\n	            left:0;\n	            top: 0;\n	            bottom: 0;\n	            right: 0;\n	          	display: none;\n			}\n			\n			#j_hideFormAdd{\n				position:absolute;\n				top: 0px;\n				right: 0px;\n				font-size: 50px;\n			}\n			\n		\n			\n			\n		</style>\n	</head>\n	<body>\n		<div class=\"wrap\">\n			<input type=\"button\" value=\"添加数据\" id=\"btn\" />\n			<table>\n				<thead>\n					<tr>\n						<th>专栏名称</th>\n						<th>内容描述</th>\n						<th>操作</th>\n					</tr>\n				</thead>\n				<tbody id=\"tb\">\n					<tr>\n						<td>JavaSE 学习笔记</td>\n						<td>参考Oracle官方文档，系统学习JavaSE</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n					<tr>\n						<td>Oracle数据库笔记</td>\n						<td>参考Oracle官方文档，系统学习Oracle数据库</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n					<tr>\n						<td>LeetCode热门算法100道</td>\n						<td>刷题的必选之路</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n					<tr>\n						<td>Linux学习笔记</td>\n						<td>从零学习Linux系统</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n				</tbody>\n			</table>\n		</div>\n		\n		<div id=\"j_mask\" class=\"mask\"></div>\n		\n		<div id=\"j_formAdd\" class=\"form-add\">\n			<div class=\"form-add-title\">\n				<span>添加数据</span>\n				<div id = \"j_hideFormAdd\">×</div>\n			</div>\n			<div class=\"form-item\">\n				<label class=\"lb\" for=\"j_txtLesson\">专栏名称:</label>\n				<input class=\"txt\" type=\"text\" id=\"column\" placeholder=\"请输入专栏名称\" />\n			</div>\n			<div class=\"form-item\">\n				<label class=\"lb\" for=\"j_txtBelSch\">内容简述:</label>\n				<input class=\"txt\" type=\"text\" id=\"content\" placeholder=\"请输入内容描述\" />\n			</div>\n			<div class=\"form-submit\">\n				<input type=\"button\" id=\"j_btnAdd\" value=\"添加\" />\n			</div>\n		</div>\n		\n		\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){		\n		//1.删除一行\n		$(\'#tb .del\').click(function(){\n\n			console.log($(this));\n			$(this).parent().parent().remove();\n		});\n		\n		//2.设置添加数据按钮事件\n		$(\'#btn\').click(function(){\n			$(\'#j_formAdd\').show();\n			$(\'#j_mask\').show();\n		});\n		\n		//3.设置关闭按钮事件\n		$(\'#j_hideFormAdd\').click(function(){\n			$(\'#j_formAdd\').hide();\n			$(\'#j_mask\').hide();\n		});\n		\n		//4.设置添加按钮事件\n		$(\'#j_btnAdd\').click(function(){\n			//获取专栏名称和内容描述\n			var $column = $(\'#column\').val();\n			var $content = $(\'#content\').val();\n			\n			//把用户的输入专栏名称和内容描述，创建一个tr\n			var $trNew = $(\'<tr>\'+\n			\'<td>\'+$column+\'</td>\'+\n			\'<td>\'+$content+\'</td>\'+\n			\'<td><button class=\"del\">删除</button></td></tr>\');\n			\n			//把新创建的tr标签添加到tbody中\n			$(\'#tb\').append($trNew);\n			\n			//把添加数据面板和遮罩隐藏\n			$(\'#j_hideFormAdd\').click();\n			\n			 $trNew.find(\'.del\').click(function(){\n				 $trNew.remove();\n			});\n			\n		});\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:28:29', 2, 0, 1, 'val()：获取和设置表单内容\n原生js是通过value属性来获取或者设置表单元素值jQuery是通过 var()val()，无参就是获取val(设置的值)，有参就是设置\n案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>    </head>    <body>        <input type=\"button\" value=\"获取\" id=\"btn-get\" />        <input type=\"button\" value=\"设置\" id=\"btn-set\" />        <input type=\"text\" placeholder=\"请输入账号\" value=\"\" id=\"txt\"/>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //原生js是通过value属性来获取或者设置表单元素值        //jQuery是通过 var()        //1.val()，无参就是获取        $(\'#btn-get\').click(function(){            console.log($(\'#txt\').val());        });        //2.val(设置的值)，有参就是设置        $(\'#btn-set\').click(function(){            $(\'#txt\').val(\"我是设置的值\");                    });            })</script>\n案例：动态数据的添加和删除<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>表格删除</title>        <style>            *{                padding: 0;                margin: 0;            }            table{                border-collapse:collapse ;                border-spacing: 0;            }            thead{                display: table-header-group;                vertical-align: middle;                border-color:inherit ;            }            tbody{                display: table-row-group;                vertical-align: middle;                border-color: inherit;            }            th{                padding: 10px 10px;                background-color: skyblue;                border: 1px solid white;            }            td{                padding: 10px 10px;                background-color: #eeeeee;                border: 1px solid #999999;            }            .mask{                position: absolute;                left: 0px;                top:0px;                background-color: #EEEEEE;                opacity:0.5;                width: 100000px;                height: 10000px;                display: none;            }            .form-add{                width: 400px;                height: 300px;                background: skyblue;                position:absolute;                left:0;                top: 0;                bottom: 0;                right: 0;                  display: none;            }            #j_hideFormAdd{                position:absolute;                top: 0px;                right: 0px;                font-size: 50px;            }        </style>    </head>    <body>        <div class=\"wrap\">            <input type=\"button\" value=\"添加数据\" id=\"btn\" />            <table>                <thead>                    <tr>                        <th>专栏名称</th>                        <th>内容描述</th>                        <th>操作</th>                    </tr>                </thead>                <tbody id=\"tb\">                    <tr>                        <td>JavaSE 学习笔记</td>                        <td>参考Oracle官方文档，系统学习JavaSE</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                    <tr>                        <td>Oracle数据库笔记</td>                        <td>参考Oracle官方文档，系统学习Oracle数据库</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                    <tr>                        <td>LeetCode热门算法100道</td>                        <td>刷题的必选之路</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                    <tr>                        <td>Linux学习笔记</td>                        <td>从零学习Linux系统</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                </tbody>            </table>        </div>        <div id=\"j_mask\" class=\"mask\"></div>        <div id=\"j_formAdd\" class=\"form-add\">            <div class=\"form-add-title\">                <span>添加数据</span>                <div id = \"j_hideFormAdd\">×</div>            </div>            <div class=\"form-item\">                <label class=\"lb\" for=\"j_txtLesson\">专栏名称:</label>                <input class=\"txt\" type=\"text\" id=\"column\" placeholder=\"请输入专栏名称\" />            </div>            <div class=\"form-item\">                <label class=\"lb\" for=\"j_txtBelSch\">内容简述:</label>                <input class=\"txt\" type=\"text\" id=\"content\" placeholder=\"请输入内容描述\" />            </div>            <div class=\"form-submit\">                <input type=\"button\" id=\"j_btnAdd\" value=\"添加\" />            </div>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){                //1.删除一行        $(\'#tb .del\').click(function(){            console.log($(this));            $(this).parent().parent().remove();        });        //2.设置添加数据按钮事件        $(\'#btn\').click(function(){            $(\'#j_formAdd\').show();            $(\'#j_mask\').show();        });        //3.设置关闭按钮事件        $(\'#j_hideFormAdd\').click(function(){            $(\'#j_formAdd\').hide();            $(\'#j_mask\').hide();        });        //4.设置添加按钮事件        $(\'#j_btnAdd\').click(function(){            //获取专栏名称和内容描述            var $column = $(\'#column\').val();            var $content = $(\'#content\').val();            //把用户的输入专栏名称和内容描述，创建一个tr            var $trNew = $(\'<tr>\'+            \'<td>\'+$column+\'</td>\'+            \'<td>\'+$content+\'</td>\'+            \'<td><button class=\"del\">删除</button></td></tr>\');            //把新创建的tr标签添加到tbody中            $(\'#tb\').append($trNew);            //把添加数据面板和遮罩隐藏            $(\'#j_hideFormAdd\').click();             $trNew.find(\'.del\').click(function(){                 $trNew.remove();            });        });    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (189, '16、jQuery 对属性的操作', 8, '### attr()：\n\n- attr(属性名)：获取属性\n- attr(属性名，属性值)：修改或添加属性\n- removeAttr(属性名)：移除属性\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>属性的操作</title>\n	</head>\n	<body>\n		<input type=\"button\" value=\"获取属性\" id=\"btn1\" />\n		<input type=\"button\" value=\"设置属性\" id=\"btn2\" />\n		<input type=\"button\" value=\"移除属性\" id=\"btn3\" />\n		<br />\n		<img src=\"img/img5.jpg\" alt=\"穷极一生得不到的人\" title=\"小可爱\" aaa=\'aaa\' />\n	</body>\n</html>\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//jQuery中属性操作：attr()  removeAttr()\n		\n		//1.设置属性\n		$(\'#btn2\').click(function(){\n			//设置单属性\n//			$(\'img\').attr(\'src\',\'img/img2.jpg\');  	//以前有的src属性，可以更改\n//			$(\'img\').attr(\'aaa\',\'呵呵\');				//修改自定义属性\n//			$(\'img\').attr(\'bbb\',\'bbb\');				//如果没有的属性，会添加属性\n		\n			//设置多属性\n			$(\'img\').attr({\n				src:\'img/img2.jpg\',\n				aaa:\'hehe\',\n				bbb:\'bbb\'\n			});\n		});\n		\n		//2.获取属性\n		$(\'#btn1\').click(function(){\n			 console.log($(\'img\').attr(\'src\'));		//系统自带的属性可以获取\n			 console.log($(\'img\').attr(\'aaa\'));		//自定义的属性也可以获取\n			 console.log($(\'img\').attr(\'bbb\'));		//如果没有这个属性，会返回undefined\n		});\n		\n		//3.移除属性\n		$(\'#btn3\').click(function(){\n			//移除单属性\n//			$(\'img\').removeAttr(\'src\');				//系统自带的属性可以移除\n//			$(\'img\').removeAttr(\'aaa\');				//自定义的属性也可以移除\n//			$(\'img\').removeAttr(\'bbb\');				//如果没有这个属性，也不会报错\n		\n			//移除多属性\n			$(\'img\').removeAttr(\'src aaa alt\');\n		});	\n	})\n</script>\n```\n\n#### 案例：美女相册\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>美女相册</title>\n		<style>\n			body{\n				margin-left: 100px;\n			}\n			ul{\n				list-style-type: none;\n				padding: 0px;\n			}\n			li{\n				display:inline-block;\n			}\n			\n			.imgSmall{\n				width: 100px;\n				height: 100px;\n				margin-right: 10px;\n			}\n		</style>\n	</head>\n	<body>\n		<h2>美女相册</h2>\n		<ul id=\"imagellery\">\n			<li>\n				<a href=\"img/img2.jpg\" title=\"美女1\">\n					<img class=\"imgSmall\" src=\"img/img2.jpg\" />\n				</a>\n			</li>\n			<li>\n				<a href=\"img/img5.jpg\" title=\"美女2\">\n					<img class=\"imgSmall\" src=\"img/img5.jpg\" />\n				</a>\n			</li>\n			<li>\n				<a href=\"img/img6.jpg\" title=\"美女3\">\n					<img class=\"imgSmall\" src=\"img/img6.jpg\" />\n				</a>\n			</li>\n			<li>\n				<a href=\"img/img7.jpg\" title=\"美女4\">\n					<img class=\"imgSmall\" src=\"img/img7.jpg\" />\n				</a>\n			</li>\n		</ul>\n		<div style=\"clear:both\"></div>\n		<img id=\"image\" src=\"img/img2.jpg\" alt=\"\" width=\"450px\" />\n		<p id=\"des\">选择一张图片</p>\n		\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//1.给小图片的a标签添加事件\n		//让大图的src与点击的小图的href一致\n		//让id为des的p标签的值为小图title\n		$(\'#imagellery>li>a\').click(function(){\n			var scrValue = $(this).attr(\'href\');\n			var titleValue = $(this).attr(\'title\');\n			console.log(scrValue);\n			console.log(titleValue);\n			$(\'#image\').attr(\'src\',scrValue);\n			$(\'#des\').text(titleValue);\n			return false;\n		})\n	})\n</script>\n```\n\n\n\n### prop()：\n\n有一类属性：比如checked，写在元素身上表示选中，没有表示没有被选中。\n\n这一类属性jQuery 不能再用attr,要用prop方法，用attr()的话，无论选中或是没选中都是undefined\n\n案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n	</head>\n	<body>\n		<input type=\"button\" value=\"按钮\" id=\"btn1\" />\n		<input type=\"checkbox\" id=\"ckb1\" />\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//有一类属性：比如checked，写在元素身上表示选中，没有表示没有被选中\n		//js如何操作？设置属性为true或false\n//		document.getElementById(\"btn1\").onclick=function(){\n//			//设置\n////			document.getElementById(\"ckb1\").checked = true;\n//			//获取\n//			console.log(document.getElementById(\"ckb1\").checked);\n//\n//		}\n		\n		//jQuery 不能再用attr,要用prop方法\n		$(\'#btn1\').click(function(){\n			//无论选中或是没选中都是undefined\n//			console.log($(\'#ckb1\').attr(\'checked\'));\n\n			//如果多选框是选中状态返回true，未选中返回false\n			console.log($(\'#ckb1\').prop(\'checked\'));\n		})\n	})\n</script>\n```\n\n\n\n#### 案例：表格的全选反选\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>表格删除</title>\n		<style>\n			*{\n				padding: 0;\n				margin: 0;\n			}\n			table{\n				border-collapse:collapse ;\n				border-spacing: 0;\n			}\n			\n			thead{\n				display: table-header-group;\n				vertical-align: middle;\n				border-color:inherit ;\n			}\n			\n			tbody{\n				display: table-row-group;\n				vertical-align: middle;\n				border-color: inherit;\n			}\n			th{\n				padding: 10px 10px;\n				background-color: skyblue;\n				border: 1px solid white;\n			}\n			td{\n				padding: 10px 10px;\n				background-color: #eeeeee;\n				border: 1px solid #999999;\n			}\n		</style>\n	</head>\n	<body>\n		<div class=\"wrap\">\n			\n			<table>\n				<thead>\n					<tr>\n						<th><input type=\"checkbox\" id=\"ckb_all\"/></th>\n						<th>专栏</th>\n						<th>内容描述</th>\n						\n					</tr>\n				</thead>\n				<tbody id=\"tb\">\n					<tr>\n						<td><input type=\"checkbox\" id=\"ckb1\" class=\"ckb\" /></td>\n						<td>JavaSE 学习笔记</td>\n						<td>参考Oracle官方文档，系统学习JavaSE</td>\n						\n					</tr>\n					<tr>\n						<td><input type=\"checkbox\" id=\"ckb2\" class=\"ckb\"/></td>\n						<td>Oracle数据库笔记</td>\n						<td>参考Oracle官方文档，系统学习Oracle数据库</td>\n					\n					</tr>\n					<tr>\n						<td><input type=\"checkbox\" id=\"ckb3\" class=\"ckb\"/></td>\n						<td>LeetCode热门算法100道</td>\n						<td>刷题的必选之路</td>\n					\n					</tr>\n					<tr>\n						<td><input type=\"checkbox\" id=\"ckb4\" class=\"ckb\"/></td>\n						<td>Linux学习笔记</td>\n						<td>从零学习Linux系统</td>\n					\n					</tr>\n				</tbody>\n			</table>\n		</div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//(1)设置全选按钮功能\n		$(\'#ckb_all\').click(function(){\n			var ckb_all_value = $(this).prop(\'checked\');\n//			console.log(ckb_all_value);\n			$(\'#tb .ckb\').prop(\'checked\',ckb_all_value);\n		});\n		\n		//(2)如果多选框都选中了，则全选框也选中，如果有一个没选中，全选框就未选中\n		$(\'#tb .ckb\').click(function(){\n			//判断下面的多选框是否都被选中了\n			var flag = true;\n\n\n			//(1)让每个多选框的checked值求与运算\n//			for(var i = 0;i<$(\'#tb .ckb\').length;i++){\n////				console.log($($(\'#tb .ckb\')[i]).prop(\'checked\'));\n//				flag = flag && $($(\'#tb .ckb\')[i]).prop(\'checked\');	\n//			}\n			\n			//(2)统计选中的次数和总框数比较\n			var numofAll = $(\'#tb .ckb\').length;\n			var numofChecked =  $(\'#tb .ckb:checked\').length;\n			$(\'#ckb_all\').prop(\'checked\',numofAll==numofChecked);\n		});\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:29:18', 2, 0, 1, 'attr()：\nattr(属性名)：获取属性attr(属性名，属性值)：修改或添加属性removeAttr(属性名)：移除属性\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>属性的操作</title>    </head>    <body>        <input type=\"button\" value=\"获取属性\" id=\"btn1\" />        <input type=\"button\" value=\"设置属性\" id=\"btn2\" />        <input type=\"button\" value=\"移除属性\" id=\"btn3\" />        <br />        <img src=\"img/img5.jpg\" alt=\"穷极一生得不到的人\" title=\"小可爱\" aaa=\'aaa\' />    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //jQuery中属性操作：attr()  removeAttr()        //1.设置属性        $(\'#btn2\').click(function(){            //设置单属性//            $(\'img\').attr(\'src\',\'img/img2.jpg\');      //以前有的src属性，可以更改//            $(\'img\').attr(\'aaa\',\'呵呵\');                //修改自定义属性//            $(\'img\').attr(\'bbb\',\'bbb\');                //如果没有的属性，会添加属性            //设置多属性            $(\'img\').attr({                src:\'img/img2.jpg\',                aaa:\'hehe\',                bbb:\'bbb\'            });        });        //2.获取属性        $(\'#btn1\').click(function(){             console.log($(\'img\').attr(\'src\'));        //系统自带的属性可以获取             console.log($(\'img\').attr(\'aaa\'));        //自定义的属性也可以获取             console.log($(\'img\').attr(\'bbb\'));        //如果没有这个属性，会返回undefined        });        //3.移除属性        $(\'#btn3\').click(function(){            //移除单属性//            $(\'img\').removeAttr(\'src\');                //系统自带的属性可以移除//            $(\'img\').removeAttr(\'aaa\');                //自定义的属性也可以移除//            $(\'img\').removeAttr(\'bbb\');                //如果没有这个属性，也不会报错            //移除多属性            $(\'img\').removeAttr(\'src aaa alt\');        });        })</script>\n案例：美女相册<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>美女相册</title>        <style>            body{                margin-left: 100px;            }            ul{                list-style-type: none;                padding: 0px;            }            li{                display:inline-block;            }            .imgSmall{                width: 100px;                height: 100px;                margin-right: 10px;            }        </style>    </head>    <body>        <h2>美女相册</h2>        <ul id=\"imagellery\">            <li>                <a href=\"img/img2.jpg\" title=\"美女1\">                    <img class=\"imgSmall\" src=\"img/img2.jpg\" />                </a>            </li>            <li>                <a href=\"img/img5.jpg\" title=\"美女2\">                    <img class=\"imgSmall\" src=\"img/img5.jpg\" />                </a>            </li>            <li>                <a href=\"img/img6.jpg\" title=\"美女3\">                    <img class=\"imgSmall\" src=\"img/img6.jpg\" />                </a>            </li>            <li>                <a href=\"img/img7.jpg\" title=\"美女4\">                    <img class=\"imgSmall\" src=\"img/img7.jpg\" />                </a>            </li>        </ul>        <div style=\"clear:both\"></div>        <img id=\"image\" src=\"img/img2.jpg\" alt=\"\" width=\"450px\" />        <p id=\"des\">选择一张图片</p>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //1.给小图片的a标签添加事件        //让大图的src与点击的小图的href一致        //让id为des的p标签的值为小图title        $(\'#imagellery>li>a\').click(function(){            var scrValue = $(this).attr(\'href\');            var titleValue = $(this).attr(\'title\');            console.log(scrValue);            console.log(titleValue);            $(\'#image\').attr(\'src\',scrValue);            $(\'#des\').text(titleValue);            return false;        })    })</script>\nprop()：有一类属性：比如checked，写在元素身上表示选中，没有表示没有被选中。\n这一类属性jQuery 不能再用attr,要用prop方法，用attr()的话，无论选中或是没选中都是undefined\n案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>    </head>    <body>        <input type=\"button\" value=\"按钮\" id=\"btn1\" />        <input type=\"checkbox\" id=\"ckb1\" />    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //有一类属性：比如checked，写在元素身上表示选中，没有表示没有被选中        //js如何操作？设置属性为true或false//        document.getElementById(\"btn1\").onclick=function(){//            //设置////            document.getElementById(\"ckb1\").checked = true;//            //获取//            console.log(document.getElementById(\"ckb1\").checked);////        }        //jQuery 不能再用attr,要用prop方法        $(\'#btn1\').click(function(){            //无论选中或是没选中都是undefined//            console.log($(\'#ckb1\').attr(\'checked\'));            //如果多选框是选中状态返回true，未选中返回false            console.log($(\'#ckb1\').prop(\'checked\'));        })    })</script>\n案例：表格的全选反选<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>表格删除</title>        <style>            *{                padding: 0;                margin: 0;            }            table{                border-collapse:collapse ;                border-spacing: 0;            }            thead{                display: table-header-group;                vertical-align: middle;                border-color:inherit ;            }            tbody{                display: table-row-group;                vertical-align: middle;                border-color: inherit;            }            th{                padding: 10px 10px;                background-color: skyblue;                border: 1px solid white;            }            td{                padding: 10px 10px;                background-color: #eeeeee;                border: 1px solid #999999;            }        </style>    </head>    <body>        <div class=\"wrap\">            <table>                <thead>                    <tr>                        <th><input type=\"checkbox\" id=\"ckb_all\"/></th>                        <th>专栏</th>                        <th>内容描述</th>                    </tr>                </thead>                <tbody id=\"tb\">                    <tr>                        <td><input type=\"checkbox\" id=\"ckb1\" class=\"ckb\" /></td>                        <td>JavaSE 学习笔记</td>                        <td>参考Oracle官方文档，系统学习JavaSE</td>                    </tr>                    <tr>                        <td><input type=\"checkbox\" id=\"ckb2\" class=\"ckb\"/></td>                        <td>Oracle数据库笔记</td>                        <td>参考Oracle官方文档，系统学习Oracle数据库</td>                    </tr>                    <tr>                        <td><input type=\"checkbox\" id=\"ckb3\" class=\"ckb\"/></td>                        <td>LeetCode热门算法100道</td>                        <td>刷题的必选之路</td>                    </tr>                    <tr>                        <td><input type=\"checkbox\" id=\"ckb4\" class=\"ckb\"/></td>                        <td>Linux学习笔记</td>                        <td>从零学习Linux系统</td>                    </tr>                </tbody>            </table>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //(1)设置全选按钮功能        $(\'#ckb_all\').click(function(){            var ckb_all_value = $(this).prop(\'checked\');//            console.log(ckb_all_value);            $(\'#tb .ckb\').prop(\'checked\',ckb_all_value);        });        //(2)如果多选框都选中了，则全选框也选中，如果有一个没选中，全选框就未选中        $(\'#tb .ckb\').click(function(){            //判断下面的多选框是否都被选中了            var flag = true;            //(1)让每个多选框的checked值求与运算//            for(var i = 0;i<$(\'#tb .ckb\').length;i++){////                console.log($($(\'#tb .ckb\')[i]).prop(\'checked\'));//                flag = flag && $($(\'#tb .ckb\')[i]).prop(\'checked\');    //            }            //(2)统计选中的次数和总框数比较            var numofAll = $(\'#tb .ckb\').length;            var numofChecked =  $(\'#tb .ckb:checked\').length;            $(\'#ckb_all\').prop(\'checked\',numofAll==numofChecked);        });    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (190, '17、宽高', 8, '获取宽高的几种方式：\n\n- css(\'height\') / css(\'width\')\n  - 获取组件的宽高,带有px，是字符串\n- width()，height() \n  - 获取或设置宽高，不包括padding/border/margin\n- innerWidth()/innerHeight()  \n  - 方法返回元素 的宽度/高度（包括内边距padding）\n- outerWidth()/outerHeight \n  - 方法返回元素 的宽度/高度（包括内边距padding和边框border）\n- outerWidth(true)/outerHeight(true)\n  - 方法返回元素 的宽度/高度（包括内边距padding和边框border和外边框margin）\n- $(window).width()  /  $(window).height()\n  - 获取页面可视区域的宽高\n\n**案例代码：**\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			.one{\n				width:200px;\n				border: 10px solid red;\n				padding: 20px;\n				margin: 30px;\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"按钮\" id=\"btn\" />\n		<div id=\"one\" class=\"one\" style=\"height: 200px;\"></div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		$(\'#btn\').click(function(){\n			//1.1 css(\'height\'),css(\'width\')\n			//获取id为one的宽高,带有px，是字符串\n//			console.log($(\'#one\').css(\'height\'));\n//			console.log($(\'#one\').css(\'width\'));\n			\n			//1.2width()，height()  \n			//获取或设置宽高，不包括padding/border/margin\n			//(1)获取宽高\n//			console.log($(\'#one\').width());\n//			console.log($(\'#one\').height());\n			\n			//(2)设置宽高\n//			$(\'#one\').width(300);\n//			$(\'#one\').height(300);\n			\n			//1.3 innerWidth()/innerHeight()  \n			//方法返回元素 的宽度/高度（包括内边距padding）\n//			console.log($(\'#one\').innerWidth());\n//			console.log($(\'#one\').innerHeight());\n			\n			//1.4 outerWidth()/outerHeight    \n			//方法返回元素 的宽度/高度（包括内边距padding和边框border）\n//			console.log($(\'#one\').outerWidth());\n//			console.log($(\'#one\').outerHeight());\n			\n			//1.5 outerWidth(true)/outerHeight(true)    \n			//方法返回元素 的宽度/高度（包括内边距padding和边框border和外边框margin）\n//			console.log($(\'#one\').outerWidth(true));\n//			console.log($(\'#one\').outerHeight(true));\n			\n			//1.6 获取页面可视区域的宽高\n			console.log($(window).width());\n			console.log($(window).height());\n		})\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:29:51', 4, 0, 1, '获取宽高的几种方式：\n\ncss(‘height’) / css(‘width’)\n获取组件的宽高,带有px，是字符串\nwidth()，height() \n获取或设置宽高，不包括padding/border/margin\ninnerWidth()/innerHeight()  \n方法返回元素 的宽度/高度（包括内边距padding）\nouterWidth()/outerHeight \n方法返回元素 的宽度/高度（包括内边距padding和边框border）\nouterWidth(true)/outerHeight(true)\n方法返回元素 的宽度/高度（包括内边距padding和边框border和外边框margin）\n$(window).width()  /  $(window).height()\n获取页面可视区域的宽高\n\n案例代码：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            .one{                width:200px;                border: 10px solid red;                padding: 20px;                margin: 30px;            }        </style>    </head>    <body>        <input type=\"button\" value=\"按钮\" id=\"btn\" />        <div id=\"one\" class=\"one\" style=\"height: 200px;\"></div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        $(\'#btn\').click(function(){            //1.1 css(\'height\'),css(\'width\')            //获取id为one的宽高,带有px，是字符串//            console.log($(\'#one\').css(\'height\'));//            console.log($(\'#one\').css(\'width\'));            //1.2width()，height()              //获取或设置宽高，不包括padding/border/margin            //(1)获取宽高//            console.log($(\'#one\').width());//            console.log($(\'#one\').height());            //(2)设置宽高//            $(\'#one\').width(300);//            $(\'#one\').height(300);            //1.3 innerWidth()/innerHeight()              //方法返回元素 的宽度/高度（包括内边距padding）//            console.log($(\'#one\').innerWidth());//            console.log($(\'#one\').innerHeight());            //1.4 outerWidth()/outerHeight                //方法返回元素 的宽度/高度（包括内边距padding和边框border）//            console.log($(\'#one\').outerWidth());//            console.log($(\'#one\').outerHeight());            //1.5 outerWidth(true)/outerHeight(true)                //方法返回元素 的宽度/高度（包括内边距padding和边框border和外边框margin）//            console.log($(\'#one\').outerWidth(true));//            console.log($(\'#one\').outerHeight(true));            //1.6 获取页面可视区域的宽高            console.log($(window).width());            console.log($(window).height());        })    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (191, '18、位置', 8, '方法：\n\n- offset()\n  - 获取一个对象，对象里面包含top和left；offset()获取元素距离document的位置\n- position()\n  - 获取一个对象，对象里面包含top和left；position()获取元素距离定位父级(offsetParent)的位置\n\n代码案例：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			*{\n				margin: 0;\n				padding: 0;\n			}\n			.father{\n				width: 400px;\n				height: 400px;\n				border: 10px solid red;\n				position: relative;\n				top: 10px;\n				left: 10px;\n			}\n			.son{\n				width: 100px;\n				height: 100px;\n				border: 10px solid green;\n				position: absolute;\n				top: 100px;\n				left: 100px;\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" id=\"btn1\" value=\"offset()\" />\n		<input type=\"button\" id=\"btn2\" value=\"position()\" />\n		\n		<div class=\"father\" id=\"father\">\n			<div class=\"son\"  id=\"son\">\n				\n			</div>\n		</div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//1. offset()\n		//获取一个对象，对象里面包含top和left\n		//offset()获取元素距离document的位置\n		$(\'#btn1\').click(function(){\n			console.log($(\'#son\').offset());  //top:143 ,left:120\n		});\n		\n		//2.position()\n		//获取一个对象，对象里面包含top和left\n		//position()获取元素距离定位父级(offsetParent)的位置\n		$(\'#btn2\').click(function(){\n			console.log($(\'#son\').position());  //top:100,left:100\n		});\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:30:33', 2, 0, 1, '方法：\n\noffset()\n获取一个对象，对象里面包含top和left；offset()获取元素距离document的位置\nposition()\n获取一个对象，对象里面包含top和left；position()获取元素距离定位父级(offsetParent)的位置\n\n代码案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            *{                margin: 0;                padding: 0;            }            .father{                width: 400px;                height: 400px;                border: 10px solid red;                position: relative;                top: 10px;                left: 10px;            }            .son{                width: 100px;                height: 100px;                border: 10px solid green;                position: absolute;                top: 100px;                left: 100px;            }        </style>    </head>    <body>        <input type=\"button\" id=\"btn1\" value=\"offset()\" />        <input type=\"button\" id=\"btn2\" value=\"position()\" />        <div class=\"father\" id=\"father\">            <div class=\"son\"  id=\"son\">            </div>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //1. offset()        //获取一个对象，对象里面包含top和left        //offset()获取元素距离document的位置        $(\'#btn1\').click(function(){            console.log($(\'#son\').offset());  //top:143 ,left:120        });        //2.position()        //获取一个对象，对象里面包含top和left        //position()获取元素距离定位父级(offsetParent)的位置        $(\'#btn2\').click(function(){            console.log($(\'#son\').position());  //top:100,left:100        });    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (192, '19、卷曲距离(滚动条的位置)', 8, '方法：\n\n- scrollLeft()	\n  - 获取元素内容被卷曲进去的宽度\n- scrollTop()\n  - 获取元素内容被卷曲进去的高度\n- scrollLeft(数值)	\n  - 设置元素内容被卷曲进去的宽度\n- scrollTop(数值)\n  - 设置元素内容被卷曲进去的高度\n\n\n\n案例代码：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			*{\n				padding: 0;\n				margin: 0;\n			}\n			body{\n				width: 2000px;\n				height: 2000px;\n			}\n			div{\n				width: 200px;\n				height: 200px;\n				border: 1px solid red;\n				overflow: auto;\n			}\n			img{\n				vertical-align: top;\n				width: 400px;\n				height: 400px;\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"按钮\" id=\"btn\" />\n		<div>\n			<img src=\"img/1.jpg\"/>\n		</div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		$(\'#btn\').click(function(){\n			\n			//1.获取和设置元素被卷曲的距离\n			//(1)获取\n			//scrollLeft()	获取元素内容被卷曲进去的宽度\n			//scrollTop()	获取元素内容被卷曲进去的高度\n			console.log($(\'div\').scrollLeft());\n			console.log($(\'div\').scrollTop());\n			\n			//(2)设置\n			//scrollLeft(数值)	设置元素内容被卷曲进去的宽度\n			//scrollTop(数值)		设置元素内容被卷曲进去的高度\n			$(\'div\').scrollLeft(200);\n			$(\'div\').scrollTop(100);\n			\n			\n			//2.获取和设置页面被卷曲的距离\n			//(1)获取\n			//获取页面被卷曲的宽度\n			console.log($(window).scrollLeft());\n			//获取页面被卷曲的高度\n			console.log($(window).scrollTop());\n			\n			//(2)设置\n			$(window).scrollLeft(1000);\n			$(window).scrollTop(1000)\n		})\n	})\n</script>\n```\n\n### 案例：固定导航栏\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>固定导航栏</title>\n		<style>\n			body{\n				width: 1080px;\n				height: 720px;\n			}\n			.top{\n				width: 1080px;\n				height: 100px;\n				background: red;\n			}\n			.nav{\n				width: 1080px;\n				height: 100px;\n				background: navy;\n			}\n			.main{\n				margin-top: 10px;\n				width: 1080px;\n				height: 5000px;\n				background: green;\n			}\n		</style>\n	</head>\n	<body>\n		<div class=\"top\"></div>\n		<div class=\"nav\"></div>\n		<div class=\"main\"></div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//给页面设置一个滚动事件\n		\n		//计算头部的高度\n		var topHeight = $(\'.top\').height();\n		\n		//计算导航栏的高度\n		var navHeight = $(\'.nav\').height();\n		\n		$(window).scroll(function(){\n			//1.获取页面被卷曲的距离\n			var scrollTopValue = $(window).scrollTop();\n			console.log(scrollTopValue);\n			\n			//2.判断\n			if(scrollTopValue>=topHeight){\n				//固定导航栏\n				$(\'.nav\').css({\n					position:\'fixed\',\n					top:0,\n					left:0\n				});\n				//设置内容部分的margin-top的值为导航栏的高度\n				$(\'.main\').css({\n					marginTop:navHeight+10\n				});\n			}else{\n				//让导航栏的定位还原\n				$(\'.nav\').css({\n					position:\'static\',\n					top:0,\n					left:0\n				});\n				//让内容部分的margin-top的值还原\n				$(\'.main\').css({\n					marginTop:10\n				});\n			}	\n		})\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:30:58', 2, 0, 1, '方法：\n\nscrollLeft()    \n获取元素内容被卷曲进去的宽度\nscrollTop()\n获取元素内容被卷曲进去的高度\nscrollLeft(数值)    \n设置元素内容被卷曲进去的宽度\nscrollTop(数值)\n设置元素内容被卷曲进去的高度\n\n案例代码：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            *{                padding: 0;                margin: 0;            }            body{                width: 2000px;                height: 2000px;            }            div{                width: 200px;                height: 200px;                border: 1px solid red;                overflow: auto;            }            img{                vertical-align: top;                width: 400px;                height: 400px;            }        </style>    </head>    <body>        <input type=\"button\" value=\"按钮\" id=\"btn\" />        <div>            <img src=\"img/1.jpg\"/>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        $(\'#btn\').click(function(){            //1.获取和设置元素被卷曲的距离            //(1)获取            //scrollLeft()    获取元素内容被卷曲进去的宽度            //scrollTop()    获取元素内容被卷曲进去的高度            console.log($(\'div\').scrollLeft());            console.log($(\'div\').scrollTop());            //(2)设置            //scrollLeft(数值)    设置元素内容被卷曲进去的宽度            //scrollTop(数值)        设置元素内容被卷曲进去的高度            $(\'div\').scrollLeft(200);            $(\'div\').scrollTop(100);            //2.获取和设置页面被卷曲的距离            //(1)获取            //获取页面被卷曲的宽度            console.log($(window).scrollLeft());            //获取页面被卷曲的高度            console.log($(window).scrollTop());            //(2)设置            $(window).scrollLeft(1000);            $(window).scrollTop(1000)        })    })</script>\n案例：固定导航栏<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>固定导航栏</title>        <style>            body{                width: 1080px;                height: 720px;            }            .top{                width: 1080px;                height: 100px;                background: red;            }            .nav{                width: 1080px;                height: 100px;                background: navy;            }            .main{                margin-top: 10px;                width: 1080px;                height: 5000px;                background: green;            }        </style>    </head>    <body>        <div class=\"top\"></div>        <div class=\"nav\"></div>        <div class=\"main\"></div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //给页面设置一个滚动事件        //计算头部的高度        var topHeight = $(\'.top\').height();        //计算导航栏的高度        var navHeight = $(\'.nav\').height();        $(window).scroll(function(){            //1.获取页面被卷曲的距离            var scrollTopValue = $(window).scrollTop();            console.log(scrollTopValue);            //2.判断            if(scrollTopValue>=topHeight){                //固定导航栏                $(\'.nav\').css({                    position:\'fixed\',                    top:0,                    left:0                });                //设置内容部分的margin-top的值为导航栏的高度                $(\'.main\').css({                    marginTop:navHeight+10                });            }else{                //让导航栏的定位还原                $(\'.nav\').css({                    position:\'static\',                    top:0,                    left:0                });                //让内容部分的margin-top的值还原                $(\'.main\').css({                    marginTop:10                });            }            })    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (193, '20、jQuery 事件机制', 8, '\n### 原生js事件与jQuery事件：\n\n（1）用原生的js给div注册事件\n\n- 原生js注册相同的事件，后面的会把前面的覆盖\n\n```js\ndocument.getElementById(\"one\").onclick=function(){\n	alert(\"单击事件1\");\n};\n\ndocument.getElementById(\"one\").onclick=function(){\n	alert(\"单击事件2\");\n}\n```\n\n（2）jQuery注册相同的事件，不会吧前面的覆盖\n\n```js\n$(\'#one\').click(function(){\n	alert(\"单击事件1\");\n});\n$(\'#one\').click(function(){\n	alert(\"单击事件2\");\n});\n```\n\n\n\n### jQuery事件的发展历程：\n\n（1）简单的事件绑定 click()\n\n- 不支持同时注册，也不支持动态注册（新创建的组件不能自动注册应有的事件）\n\n```js\n//不支持同时注册\n$(\'div\').click(function(){\n	console.log(\"鼠标单击事件\");\n});\n\n$(\'div\').mouseenter(function(){\n	console.log(\"鼠标移入事件\");\n});\n\n//新创建的节点对click()事件不支持动态注册\n$(\'#btn\').click(function(){\n			var $divNew = $(\'<div class=\"two\"></div>\');\n			$(\'body\').append($divNew);\n});\n```\n\n\n\n（2）bind方式注册事件\n\n- 支持同时注册，也不支持动态注册（新创建的组件不能自动注册应有的事件）\n\n```js\n//支持同时注册\n$(\'div\').bind({\n	mouseenter:function(){\n		console.log(\"鼠标移入事件\");\n	},\nclick:function(){\n		console.log(\"鼠标单击事件\");\n	}\n});\n\n//新创建的节点对bind()事件不支持动态注册\n$(\'#btn\').click(function(){\n			var $divNew = $(\'<div class=\"two\"></div>\');\n			$(\'body\').append($divNew);\n});\n```\n\n\n\n（3） delegate注册委托事件\n\n- 支持同时注册，也支持动态注册（新创建的组件可以自动注册应有的事件）\n- 需要把事件注册在父亲节点上面\n- 原理是事件冒泡\n\n```js\n$(\'body\').delegate(\'div\',{\n	mouseenter:function(){\n		console.log(\"鼠标移入事件\");\n	},\n	click:function(){\n		console.log(\"鼠标单击事件\");\n	}\n});\n```\n\n（4）jQuery1.7之后，jQuery用on统一了所有事件的注册\n\n\n\n### on 注册事件：\n\n- jQuery1.7之后，jQuery用on统一了所有事件的注册\n- 最现代的方式，兼容zepto（移动端类似jQuery的一个库），强烈建议使用。\n\n（1）on简单注册事件\n\n- 不支持动态创建\n\n```js\n$(\'div\').on(\'click\',function(){\n	console.log(\"我是点击事件\");\n});\n```\n\n（2）on委托注册\n\n- 需要把事件注册到父亲节点\n\n```js\n$(\'body\').on(\'click\',\'div,span\',function(){\n	console.log(\"我是点击事件\");\n});\n```\n\n### 案例：动态数据的添加和删除\n\n```js\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>表格删除</title>\n		<style>\n			*{\n				padding: 0;\n				margin: 0;\n			}\n			table{\n				border-collapse:collapse ;\n				border-spacing: 0;\n				\n			}\n			\n			thead{\n				display: table-header-group;\n				vertical-align: middle;\n				border-color:inherit ;\n			}\n			\n			tbody{\n				display: table-row-group;\n				vertical-align: middle;\n				border-color: inherit;\n			}\n			th{\n				padding: 10px 10px;\n				background-color: skyblue;\n				border: 1px solid white;\n			}\n			td{\n				padding: 10px 10px;\n				background-color: #eeeeee;\n				border: 1px solid #999999;\n			}\n			.mask{\n				position: absolute;\n				left: 0px;\n				top:0px;\n				background-color: #EEEEEE;\n				opacity:0.5;\n				width: 100000px;\n				height: 10000px;\n				display: none;\n			}\n			\n			.form-add{\n				width: 400px;\n	            height: 300px;\n	            background: skyblue;\n	            position:absolute;\n	            left:0;\n	            top: 0;\n	            bottom: 0;\n	            right: 0;\n	          	display: none;\n			}\n			\n			#j_hideFormAdd{\n				position:absolute;\n				top: 0px;\n				right: 0px;\n				font-size: 50px;\n			}			\n		</style>\n	</head>\n	<body>\n		<div class=\"wrap\">\n			<input type=\"button\" value=\"添加数据\" id=\"btn\" />\n			<table>\n				<thead>\n					<tr>\n						<th>专栏名称</th>\n						<th>内容描述</th>\n						<th>操作</th>\n					</tr>\n				</thead>\n				<tbody id=\"tb\">\n					<tr>\n						<td>JavaSE 学习笔记</td>\n						<td>参考Oracle官方文档，系统学习JavaSE</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n					<tr>\n						<td>Oracle数据库笔记</td>\n						<td>参考Oracle官方文档，系统学习Oracle数据库</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n					<tr>\n						<td>LeetCode热门算法100道</td>\n						<td>刷题的必选之路</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n					<tr>\n						<td>Linux学习笔记</td>\n						<td>从零学习Linux系统</td>\n						<td><button class=\"del\">删除</button></td>\n					</tr>\n				</tbody>\n			</table>\n		</div>\n		\n		<div id=\"j_mask\" class=\"mask\"></div>\n		\n		<div id=\"j_formAdd\" class=\"form-add\">\n			<div class=\"form-add-title\">\n				<span>添加数据</span>\n				<div id = \"j_hideFormAdd\">×</div>\n			</div>\n			<div class=\"form-item\">\n				<label class=\"lb\" for=\"j_txtLesson\">专栏名称:</label>\n				<input class=\"txt\" type=\"text\" id=\"column\" placeholder=\"请输入专栏名称\" />\n			</div>\n			<div class=\"form-item\">\n				<label class=\"lb\" for=\"j_txtBelSch\">内容简述:</label>\n				<input class=\"txt\" type=\"text\" id=\"content\" placeholder=\"请输入内容描述\" />\n			</div>\n			<div class=\"form-submit\">\n				<input type=\"button\" id=\"j_btnAdd\" value=\"添加\" />\n			</div>\n		</div>\n		\n		\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){		\n		//1.删除一行\n		//使用on委托注册事件\n		$(\'#tb\').on(\'click\',\'.del\',function(){\n			//jQuery为了使用方便,把this修改了,为点击元素,不是父亲节点tbody\n			$(this).parent().parent().remove();\n		})\n			\n			\n		\n		//2.设置添加数据按钮事件\n		$(\'#btn\').click(function(){\n			$(\'#j_formAdd\').show();\n			$(\'#j_mask\').show();\n		});\n		\n		//3.设置关闭按钮事件\n		$(\'#j_hideFormAdd\').click(function(){\n			$(\'#j_formAdd\').hide();\n			$(\'#j_mask\').hide();\n		});\n		\n		//4.设置添加按钮事件\n		$(\'#j_btnAdd\').click(function(){\n			//获取专栏名称和内容描述\n			var $column = $(\'#column\').val();\n			var $content = $(\'#content\').val();\n			\n			//把用户的输入专栏名称和内容描述，创建一个tr\n			var $trNew = $(\'<tr>\'+\n			\'<td>\'+$column+\'</td>\'+\n			\'<td>\'+$content+\'</td>\'+\n			\'<td><button class=\"del\">删除</button></td></tr>\');\n			\n			//把新创建的tr标签添加到tbody中\n			$(\'#tb\').append($trNew);\n			\n			//把添加数据面板和遮罩隐藏\n			$(\'#j_hideFormAdd\').click();	\n		});\n	})\n</script>\n```\n\n\n\n### 事件解绑：\n\n（1）unbind方式解绑事件（不推荐使用）\n\n```js\n//解绑所有事件\n$(\'div\').unbind();\n//解绑指定事件\n$(\'div\').unbind(\'click\');\n```\n\n（2）undelegate方式解绑事件（不推荐使用）\n\n```js\n//解绑所有事件\n$(\'div\').undelegate();\n//解绑指定事件\n$(\'div\').undelegate(\'click\');\n```\n\n（3）off方式解绑事件（推荐使用）\n\n```js\n//解绑所有事件\n$(\'div\').off();\n//解绑指定事件\n$(\'div\').off(\'click\');\n```\n\n\n\n案例：\n\n```js\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			#one{\n				width: 200px;\n				height: 200px;\n				border: 2px solid red;\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"注册事件\" id=\"btn1\" />\n		<input type=\"button\" value=\"解绑事件\" id=\"btn2\" />\n		<br />\n		<div class=\"one\" id=\"one\"></div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//jQuery用on注册事件,用off来解绑\n		//off()不给参数就是解绑所有的事件\n		//off(参数)解绑指定事件\n		\n		//添加注册事件\n		$(\'#btn1\').click(function(){\n			//给div注册事件\n			$(\'#one\').on({\n				\'click\':function(){\n					console.log(\"这个单击事件\");\n				}\n			});\n			$(\'#one\').on({\n				\'mouseenter\':function(){\n					console.log(\"这个鼠标移入事件\");\n				}\n			});\n		});\n		\n		//添加解绑事件\n		$(\'#btn2\').click(function(){\n			//给div解绑事件(无参数,解绑所有参数)\n//			$(\'#one\').off();\n			\n			//解绑指定事件(有参数,解绑指定事件)\n			$(\'#one\').off(\'click\');\n		})\n		\n		//添加解绑事件(不是用on注册的也可以用off解绑)\n		$(\'#btn2\').click(function(){\n			$(\'#btn1\').off(\'click\');\n		})\n	})\n</script>\n```\n\n\n\n### 事件触发：\n\n方法：trigger()\n\n（1）代码的方式触发事件\n\n```js\n		var i = 0;\n		$(\'#btn\').on(\'click\',function(){\n			i++;\n			if(i>=3){\n				//条件满足，触发事件\n//				$(\'#one\').click();\n				$(\'#one\').trigger(\'click\');\n			}\n		});\n```\n\n（2）可以触发自定义事件\n\n```js\n		//给div注册一个自定义事件（没有触发事件）\n		$(\'#one\').on(\'kill\',function(){\n			console.log(\'我是kill事件\');\n		});\n		\n		//使用触发器触发\n		$(\'#btn2\').on(\'click\',function(){\n			var res = confirm(\'是否启动kill事件\');\n			if(res){\n				//触发自定义kill事件\n				$(\'#one\').trigger(\'kill\');\n			}\n		});\n```\n\n\n\n### jQuery事件对象：\n\n1. 什么是事件对象？\n\n   - 注册一个事件，系统会帮我们生成一个对象记录这个事件触发时候的一些信息\n   - 比如事件是按那个键触发的，触发的位置坐标。。。\n   - jQuery在事件中由参数e来获取\n   - jQuery的事件对象是对元素js的事件进行了封装，处理了兼容性\n\n2. 三个常用坐标\n\n   - screenX,screenY触发事件的点距离屏幕左上角的坐标\n\n- clientX,clientY触发事件的点距离可视区左上角的坐标（忽视滚动条）\n\n  - pageX,pageY触发事件的点距离页面左上角的坐标\n\n  \n\n  ```JS\n  //screenX,screenY触发事件的点距离屏幕左上角的坐标\n  console.log(\'ScreenX\'+\':\'+e.screenX+\'---\'+\'ScreenY\'+\':\'+e.screenY);\n  \n  //clientX,clientY触发事件的点距离可视区左上角的坐标（忽视滚动条）\n  console.log(\'ClientX\'+\':\'+e.clientX+\'---\'+\'ClientY\'+\':\'+e.clientY);\n  \n  //pageX,pageY触发事件的点距离页面左上角的坐标\n  console.log(\'pageX\'+\':\'+e.pageX+\'---\'+\'pageY\'+\':\'+e.pageY);\n  ```\n\n  \n\n3. stopPropagation()  :  阻止事件冒泡\n\n   ```JS\n   $(\'#btn\').on(\'click\',function(e){\n   	alert(\'我是按钮的点击事件\');\n   	e.stopPropagation();\n   });\n   ```\n\n4. preventDefault() : 阻止默认行为,阻止a标签跳转\n\n   ```js\n   $(\'a\').on(\'click\',function(e){\n       alert(\'我是a标签的单击事件\');\n       //stopPropagation():阻止事件冒泡\n       e.stopPropagation();\n   \n       //4.preventDefault():阻止默认行为,阻止a标签跳转\n       e.preventDefault();\n   });\n   ```\n\n5. return false 既能阻止事件冒泡，又能阻止a标签跳转\n\n   ```JS\n   $(\'a\').on(\'click\',function(e){\n   	alert(\'我是a标签的单击事件\');\n   \n   	//5.return false 既能阻止事件冒泡，又能阻止a标签跳转\n   	return false;\n   });\n   ```\n\n6. keydown 获取键盘按键\n\n   ```\n   $(document).on(\'keydown\',function(e){}\n   ```\n\n### 案例：按键变色\n\n```js\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			#bgChage{\n				height: 50px;\n				font-size: 40px;\n			}\n		</style>\n	</head>\n	<body>\n		<div class=\"wrop\">\n			<h1>按键变色</h1>\n			<div id=\"bgChage\" style=\"background-color: blue\">\n				keyCode为:\n				<span id=\"keyCodeSpan\"></span>\n			</div>\n		</div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//获取div\n		var $div = $(\'#bgChage\');\n		\n		//显示按键的span\n		var $showCode = $(\'#keyCodeSpan\');\n		\n		//给页面注册一个键盘按键事件\n		$(document).on(\'keydown\',function(e){\n			console.log(e.keyCode); // r:82   g:71   b:66    y:89  \n			switch(e.keyCode){\n				case 82:\n					$div.css(\'background-color\',\'red\');\n					$showCode.text(\'82\');\n				break;\n				case 71:\n					$div.css(\'background-color\',\'green\');\n					$showCode.text(\'71\');\n				break;\n				case 66:\n					$div.css(\'background-color\',\'blue\');\n					$showCode.text(\'66\');\n				break;\n				case 89:\n					$div.css(\'background-color\',\'yellow\');\n					$showCode.text(\'89\');\n				break;	\n				default:\n					$div.css(\'background-color\',\'pink\');\n					$showCode.text(\'没有这个键\');\n			}\n		})\n	})\n</script>\n```\n\n\n\n### 案例：五角星评分\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>五角星评分案例</title>\n		<style>\n			ul{\n				list-style: none;\n			}\n			li{\n				display: inline-block;\n			}\n			.comment{\n				font-size:40px ;\n				color: red;\n			}\n		</style>\n	</head>\n	<body>\n		<ul class=\"comment\">\n			<li>☆</li>\n			<li>☆</li>\n			<li>☆</li>\n			<li>☆</li>\n			<li>☆</li>\n		</ul>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		//需求1:鼠标移入五角星，会把当前li标签和前面的li标签显示为实心五角星，后面的显示空心五角星\n		//需求2:鼠标离开li，会把所有的li标签设为空心五角星\n		//需求3:点击li，鼠标离开后，刚才被点击的li标签及前面的li标签为实心，后面为空心\n		\n		//prev():上一个兄弟\n		//prevAll():前面所有兄弟\n		//next():下一个兄弟\n		//nextAll():后面所有兄弟\n		\n		\n		//需求1：\n		$(\'.comment>li\').on(\'mouseenter\',function(){\n//			console.log(\'鼠标进入\');\n			//需求1\n			$(this).text(\'★\').prevAll().text(\'★\');\n			$(this).nextAll().text(\'☆\');\n			\n		}).on(\'mouseleave\',function(){\n//			console.log(\'鼠标离开\');\n			//需求2\n			$(\'.comment>li\').text(\'☆\');\n			\n			//获取刚才点击的li(属性选择器)\n			$(\'.comment>li[flag]\').text(\'★\').prevAll().text(\'★\');\n			\n			$(\'.comment>li[flag]\').nextAll().text(\'☆\');\n\n		}).on(\'click\',function(){\n//			console.log(\'鼠标单击\');\n			//需求3：给当前的li添加记号\n			//给当前鼠标点击的li添加独一无二的属性\n			$(this).attr(\'flag\',\'flag\').siblings().removeAttr(\'flag\');\n		})	\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:31:46', 2, 0, 1, '原生js事件与jQuery事件：（1）用原生的js给div注册事件\n\n原生js注册相同的事件，后面的会把前面的覆盖\ndocument.getElementById(\"one\").onclick=function(){    alert(\"单击事件1\");};document.getElementById(\"one\").onclick=function(){    alert(\"单击事件2\");}\n（2）jQuery注册相同的事件，不会吧前面的覆盖\n$(\'#one\').click(function(){    alert(\"单击事件1\");});$(\'#one\').click(function(){    alert(\"单击事件2\");});\njQuery事件的发展历程：（1）简单的事件绑定 click()\n\n不支持同时注册，也不支持动态注册（新创建的组件不能自动注册应有的事件）\n//不支持同时注册$(\'div\').click(function(){    console.log(\"鼠标单击事件\");});$(\'div\').mouseenter(function(){    console.log(\"鼠标移入事件\");});//新创建的节点对click()事件不支持动态注册$(\'#btn\').click(function(){            var $divNew = $(\'<div class=\"two\"></div>\');            $(\'body\').append($divNew);});\n（2）bind方式注册事件\n\n支持同时注册，也不支持动态注册（新创建的组件不能自动注册应有的事件）\n//支持同时注册$(\'div\').bind({    mouseenter:function(){        console.log(\"鼠标移入事件\");    },click:function(){        console.log(\"鼠标单击事件\");    }});//新创建的节点对bind()事件不支持动态注册$(\'#btn\').click(function(){            var $divNew = $(\'<div class=\"two\"></div>\');            $(\'body\').append($divNew);});\n（3） delegate注册委托事件\n\n支持同时注册，也支持动态注册（新创建的组件可以自动注册应有的事件）需要把事件注册在父亲节点上面原理是事件冒泡\n$(\'body\').delegate(\'div\',{    mouseenter:function(){        console.log(\"鼠标移入事件\");    },    click:function(){        console.log(\"鼠标单击事件\");    }});\n（4）jQuery1.7之后，jQuery用on统一了所有事件的注册\non 注册事件：\njQuery1.7之后，jQuery用on统一了所有事件的注册最现代的方式，兼容zepto（移动端类似jQuery的一个库），强烈建议使用。\n（1）on简单注册事件\n\n不支持动态创建\n$(\'div\').on(\'click\',function(){    console.log(\"我是点击事件\");});\n（2）on委托注册\n\n需要把事件注册到父亲节点\n$(\'body\').on(\'click\',\'div,span\',function(){    console.log(\"我是点击事件\");});\n案例：动态数据的添加和删除<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>表格删除</title>        <style>            *{                padding: 0;                margin: 0;            }            table{                border-collapse:collapse ;                border-spacing: 0;            }            thead{                display: table-header-group;                vertical-align: middle;                border-color:inherit ;            }            tbody{                display: table-row-group;                vertical-align: middle;                border-color: inherit;            }            th{                padding: 10px 10px;                background-color: skyblue;                border: 1px solid white;            }            td{                padding: 10px 10px;                background-color: #eeeeee;                border: 1px solid #999999;            }            .mask{                position: absolute;                left: 0px;                top:0px;                background-color: #EEEEEE;                opacity:0.5;                width: 100000px;                height: 10000px;                display: none;            }            .form-add{                width: 400px;                height: 300px;                background: skyblue;                position:absolute;                left:0;                top: 0;                bottom: 0;                right: 0;                  display: none;            }            #j_hideFormAdd{                position:absolute;                top: 0px;                right: 0px;                font-size: 50px;            }                    </style>    </head>    <body>        <div class=\"wrap\">            <input type=\"button\" value=\"添加数据\" id=\"btn\" />            <table>                <thead>                    <tr>                        <th>专栏名称</th>                        <th>内容描述</th>                        <th>操作</th>                    </tr>                </thead>                <tbody id=\"tb\">                    <tr>                        <td>JavaSE 学习笔记</td>                        <td>参考Oracle官方文档，系统学习JavaSE</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                    <tr>                        <td>Oracle数据库笔记</td>                        <td>参考Oracle官方文档，系统学习Oracle数据库</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                    <tr>                        <td>LeetCode热门算法100道</td>                        <td>刷题的必选之路</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                    <tr>                        <td>Linux学习笔记</td>                        <td>从零学习Linux系统</td>                        <td><button class=\"del\">删除</button></td>                    </tr>                </tbody>            </table>        </div>        <div id=\"j_mask\" class=\"mask\"></div>        <div id=\"j_formAdd\" class=\"form-add\">            <div class=\"form-add-title\">                <span>添加数据</span>                <div id = \"j_hideFormAdd\">×</div>            </div>            <div class=\"form-item\">                <label class=\"lb\" for=\"j_txtLesson\">专栏名称:</label>                <input class=\"txt\" type=\"text\" id=\"column\" placeholder=\"请输入专栏名称\" />            </div>            <div class=\"form-item\">                <label class=\"lb\" for=\"j_txtBelSch\">内容简述:</label>                <input class=\"txt\" type=\"text\" id=\"content\" placeholder=\"请输入内容描述\" />            </div>            <div class=\"form-submit\">                <input type=\"button\" id=\"j_btnAdd\" value=\"添加\" />            </div>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){                //1.删除一行        //使用on委托注册事件        $(\'#tb\').on(\'click\',\'.del\',function(){            //jQuery为了使用方便,把this修改了,为点击元素,不是父亲节点tbody            $(this).parent().parent().remove();        })        //2.设置添加数据按钮事件        $(\'#btn\').click(function(){            $(\'#j_formAdd\').show();            $(\'#j_mask\').show();        });        //3.设置关闭按钮事件        $(\'#j_hideFormAdd\').click(function(){            $(\'#j_formAdd\').hide();            $(\'#j_mask\').hide();        });        //4.设置添加按钮事件        $(\'#j_btnAdd\').click(function(){            //获取专栏名称和内容描述            var $column = $(\'#column\').val();            var $content = $(\'#content\').val();            //把用户的输入专栏名称和内容描述，创建一个tr            var $trNew = $(\'<tr>\'+            \'<td>\'+$column+\'</td>\'+            \'<td>\'+$content+\'</td>\'+            \'<td><button class=\"del\">删除</button></td></tr>\');            //把新创建的tr标签添加到tbody中            $(\'#tb\').append($trNew);            //把添加数据面板和遮罩隐藏            $(\'#j_hideFormAdd\').click();            });    })</script>\n事件解绑：（1）unbind方式解绑事件（不推荐使用）\n//解绑所有事件$(\'div\').unbind();//解绑指定事件$(\'div\').unbind(\'click\');\n（2）undelegate方式解绑事件（不推荐使用）\n//解绑所有事件$(\'div\').undelegate();//解绑指定事件$(\'div\').undelegate(\'click\');\n（3）off方式解绑事件（推荐使用）\n//解绑所有事件$(\'div\').off();//解绑指定事件$(\'div\').off(\'click\');\n案例：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            #one{                width: 200px;                height: 200px;                border: 2px solid red;            }        </style>    </head>    <body>        <input type=\"button\" value=\"注册事件\" id=\"btn1\" />        <input type=\"button\" value=\"解绑事件\" id=\"btn2\" />        <br />        <div class=\"one\" id=\"one\"></div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //jQuery用on注册事件,用off来解绑        //off()不给参数就是解绑所有的事件        //off(参数)解绑指定事件        //添加注册事件        $(\'#btn1\').click(function(){            //给div注册事件            $(\'#one\').on({                \'click\':function(){                    console.log(\"这个单击事件\");                }            });            $(\'#one\').on({                \'mouseenter\':function(){                    console.log(\"这个鼠标移入事件\");                }            });        });        //添加解绑事件        $(\'#btn2\').click(function(){            //给div解绑事件(无参数,解绑所有参数)//            $(\'#one\').off();            //解绑指定事件(有参数,解绑指定事件)            $(\'#one\').off(\'click\');        })        //添加解绑事件(不是用on注册的也可以用off解绑)        $(\'#btn2\').click(function(){            $(\'#btn1\').off(\'click\');        })    })</script>\n事件触发：方法：trigger()\n（1）代码的方式触发事件\n        var i = 0;        $(\'#btn\').on(\'click\',function(){            i++;            if(i>=3){                //条件满足，触发事件//                $(\'#one\').click();                $(\'#one\').trigger(\'click\');            }        });\n（2）可以触发自定义事件\n        //给div注册一个自定义事件（没有触发事件）        $(\'#one\').on(\'kill\',function(){            console.log(\'我是kill事件\');        });        //使用触发器触发        $(\'#btn2\').on(\'click\',function(){            var res = confirm(\'是否启动kill事件\');            if(res){                //触发自定义kill事件                $(\'#one\').trigger(\'kill\');            }        });\njQuery事件对象：\n什么是事件对象？\n\n注册一个事件，系统会帮我们生成一个对象记录这个事件触发时候的一些信息比如事件是按那个键触发的，触发的位置坐标。。。jQuery在事件中由参数e来获取jQuery的事件对象是对元素js的事件进行了封装，处理了兼容性\n三个常用坐标\n\nscreenX,screenY触发事件的点距离屏幕左上角的坐标\n\n\nclientX,clientY触发事件的点距离可视区左上角的坐标（忽视滚动条）\n\npageX,pageY触发事件的点距离页面左上角的坐标\n\n  //screenX,screenY触发事件的点距离屏幕左上角的坐标  console.log(\'ScreenX\'+\':\'+e.screenX+\'---\'+\'ScreenY\'+\':\'+e.screenY);  //clientX,clientY触发事件的点距离可视区左上角的坐标（忽视滚动条）  console.log(\'ClientX\'+\':\'+e.clientX+\'---\'+\'ClientY\'+\':\'+e.clientY);  //pageX,pageY触发事件的点距离页面左上角的坐标  console.log(\'pageX\'+\':\'+e.pageX+\'---\'+\'pageY\'+\':\'+e.pageY);\n\nstopPropagation()  :  阻止事件冒泡\n$(\'#btn\').on(\'click\',function(e){    alert(\'我是按钮的点击事件\');    e.stopPropagation();});\npreventDefault() : 阻止默认行为,阻止a标签跳转\n$(\'a\').on(\'click\',function(e){    alert(\'我是a标签的单击事件\');    //stopPropagation():阻止事件冒泡    e.stopPropagation();    //4.preventDefault():阻止默认行为,阻止a标签跳转    e.preventDefault();});\nreturn false 既能阻止事件冒泡，又能阻止a标签跳转\n$(\'a\').on(\'click\',function(e){    alert(\'我是a标签的单击事件\');    //5.return false 既能阻止事件冒泡，又能阻止a标签跳转    return false;});\nkeydown 获取键盘按键\n$(document).on(\'keydown\',function(e){}\n案例：按键变色<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            #bgChage{                height: 50px;                font-size: 40px;            }        </style>    </head>    <body>        <div class=\"wrop\">            <h1>按键变色</h1>            <div id=\"bgChage\" style=\"background-color: blue\">                keyCode为:                <span id=\"keyCodeSpan\"></span>            </div>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //获取div        var $div = $(\'#bgChage\');        //显示按键的span        var $showCode = $(\'#keyCodeSpan\');        //给页面注册一个键盘按键事件        $(document).on(\'keydown\',function(e){            console.log(e.keyCode); // r:82   g:71   b:66    y:89              switch(e.keyCode){                case 82:                    $div.css(\'background-color\',\'red\');                    $showCode.text(\'82\');                break;                case 71:                    $div.css(\'background-color\',\'green\');                    $showCode.text(\'71\');                break;                case 66:                    $div.css(\'background-color\',\'blue\');                    $showCode.text(\'66\');                break;                case 89:                    $div.css(\'background-color\',\'yellow\');                    $showCode.text(\'89\');                break;                    default:                    $div.css(\'background-color\',\'pink\');                    $showCode.text(\'没有这个键\');            }        })    })</script>\n案例：五角星评分<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>五角星评分案例</title>        <style>            ul{                list-style: none;            }            li{                display: inline-block;            }            .comment{                font-size:40px ;                color: red;            }        </style>    </head>    <body>        <ul class=\"comment\">            <li>☆</li>            <li>☆</li>            <li>☆</li>            <li>☆</li>            <li>☆</li>        </ul>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        //需求1:鼠标移入五角星，会把当前li标签和前面的li标签显示为实心五角星，后面的显示空心五角星        //需求2:鼠标离开li，会把所有的li标签设为空心五角星        //需求3:点击li，鼠标离开后，刚才被点击的li标签及前面的li标签为实心，后面为空心        //prev():上一个兄弟        //prevAll():前面所有兄弟        //next():下一个兄弟        //nextAll():后面所有兄弟        //需求1：        $(\'.comment>li\').on(\'mouseenter\',function(){//            console.log(\'鼠标进入\');            //需求1            $(this).text(\'★\').prevAll().text(\'★\');            $(this).nextAll().text(\'☆\');        }).on(\'mouseleave\',function(){//            console.log(\'鼠标离开\');            //需求2            $(\'.comment>li\').text(\'☆\');            //获取刚才点击的li(属性选择器)            $(\'.comment>li[flag]\').text(\'★\').prevAll().text(\'★\');            $(\'.comment>li[flag]\').nextAll().text(\'☆\');        }).on(\'click\',function(){//            console.log(\'鼠标单击\');            //需求3：给当前的li添加记号            //给当前鼠标点击的li添加独一无二的属性            $(this).attr(\'flag\',\'flag\').siblings().removeAttr(\'flag\');        })        })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (194, '21、链式编程和end方法', 8, '### 1. 什么时候可以链式编程？\n\n- 如果给元素调用一个方法，返回值为一个jQuery对象，那就可以继续在点出jQuert方法\n- 如果返回值不是我们想要的，那就不要继续链式编程了\n\n```js\n$(\'div\').width(100).height(100).css(\'background-color\',\'red\');\n```\n\n### 2. end()方法会返回上一层的结果\n\n```js\n$(this).text(\'★\').prevAll().text(\'★\').end().nextAll().text(\'☆\');\n```\n\n', 0, 0, '2020-08-07 15:32:19', 2, 0, 1, '1. 什么时候可以链式编程？\n如果给元素调用一个方法，返回值为一个jQuery对象，那就可以继续在点出jQuert方法如果返回值不是我们想要的，那就不要继续链式编程了\n$(\'div\').width(100).height(100).css(\'background-color\',\'red\');\n2. end()方法会返回上一层的结果$(this).text(\'★\').prevAll().text(\'★\').end().nextAll().text(\'☆\');\n', 0, 1);
INSERT INTO `t_article` VALUES (195, '22、each方法', 8, '（1）each(function(index,element){}\n\n- index 是索引\n- element是遍历到的标签，为一个dom对象\n\n（2）each作用\n\n- 遍历jQuery对象集合，为每一个匹配的元素执行一个函数\n\n（3）什么时候使用？\n\n- 给每一个对象设置不同值的时候\n\n**案例：显示迭代**\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			ul{\n				\n				list-style: none;\n				font-size:20px ;\n				color: black;\n			}\n			li{\n				margin-top: 10px;\n				margin-left: 10px ;\n				display: inline-block;\n				width: 200px;\n				height: 200px;\n				text-align: center;\n				border: 2px solid red;\n				background-color: red;\n			}\n			\n		</style>\n	</head>\n	<body>\n		<ul id=\"ulList\">\n			<li>我是一个li标签</li>\n			<li>我是一个li标签</li>\n			<li>我是一个li标签</li>\n			<li>我是一个li标签</li>\n			<li>我是一个li标签</li>\n			<li>我是一个li标签</li>\n			<li>我是一个li标签</li>\n			<li>我是一个li标签</li>\n			<li>我是一个li标签</li>\n			<li>我是一个li标签</li>\n\n		</ul>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery.js\" ></script>\n<script>\n	$(function(){\n		var $lis = $(\'#ulList\').children();\n		\n		//给lis的每一个li设置透明度\n		//each(function(index,element){}\n		//each作用：遍历jQuery对象集合，为每一个匹配的元素执行一个函数\n		//什么时候使用？\n		//给每一个对象设置不同值的时候\n		//index 是索引，element是遍历到的标签，为一个dom对象\n		$lis.each(function(index,element){\n			$(element).css(\'opacity\',index/10);\n			console.log(index/10);\n		});\n	})\n</script>\n```\n\n## ', 0, 0, '2020-08-07 15:32:46', 2, 0, 1, '（1）each(function(index,element){}\n\nindex 是索引element是遍历到的标签，为一个dom对象\n（2）each作用\n\n遍历jQuery对象集合，为每一个匹配的元素执行一个函数\n（3）什么时候使用？\n\n给每一个对象设置不同值的时候\n案例：显示迭代\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            ul{                list-style: none;                font-size:20px ;                color: black;            }            li{                margin-top: 10px;                margin-left: 10px ;                display: inline-block;                width: 200px;                height: 200px;                text-align: center;                border: 2px solid red;                background-color: red;            }        </style>    </head>    <body>        <ul id=\"ulList\">            <li>我是一个li标签</li>            <li>我是一个li标签</li>            <li>我是一个li标签</li>            <li>我是一个li标签</li>            <li>我是一个li标签</li>            <li>我是一个li标签</li>            <li>我是一个li标签</li>            <li>我是一个li标签</li>            <li>我是一个li标签</li>            <li>我是一个li标签</li>        </ul>    </body></html><script type=\"text/javascript\" src=\"js/jQuery.js\" ></script><script>    $(function(){        var $lis = $(\'#ulList\').children();        //给lis的每一个li设置透明度        //each(function(index,element){}        //each作用：遍历jQuery对象集合，为每一个匹配的元素执行一个函数        //什么时候使用？        //给每一个对象设置不同值的时候        //index 是索引，element是遍历到的标签，为一个dom对象        $lis.each(function(index,element){            $(element).css(\'opacity\',index/10);            console.log(index/10);        });    })</script>\n ', 0, 1);
INSERT INTO `t_article` VALUES (196, '23、多库共存', 8, '查询jQuery的版本号：\n\n```js\nconsole.log(jQuery.fn.jquery);\nconsole.log(jQuery.prototype.jquery);\nconsole.log($.fn.jquery);\nconsole.log($.prototype.jquery);\n```\n\n**如果引入了多个jQuery版本，那么我们使用的$是 那个？**\n\n- 后面引入的会把前面引入的覆盖掉\n\n\n\n**如何解决多库共存？**\n\n后面加入的jQuery可以把$控制器释放，然后用替代品代替\n\n```js\nvar _$ = $.noConflict();        //1.9.1把$元素的控制权释放掉\n	console.log(_$.fn.jquery);		//1.9.1把_$作为替代品\n	console.log(jQuery.fn.jquery); 	//1.9.1自己使用jQuery来操作\n	console.log($.fn.jquery);		//3.5.1拥有$的控制权\n```\n\n\n\n**如果之前使用的1.9.1版本的$,现在$归3.5.1版本了，如何解决？**\n\n- 可以把之前的js代码使用自执行函数框起来\n\n```js\n(function($){\n		//在这个自执行函数中，可以继续使用$了\n}(_$));\n```\n\n', 0, 0, '2020-08-07 15:33:07', 2, 0, 1, '查询jQuery的版本号：\nconsole.log(jQuery.fn.jquery);console.log(jQuery.prototype.jquery);console.log($.fn.jquery);console.log($.prototype.jquery);\n如果引入了多个jQuery版本，那么我们使用的$是 那个？\n\n后面引入的会把前面引入的覆盖掉\n如何解决多库共存？\n后面加入的jQuery可以把$控制器释放，然后用替代品代替\nvar _$ = $.noConflict();        //1.9.1把$元素的控制权释放掉    console.log(_$.fn.jquery);        //1.9.1把_$作为替代品    console.log(jQuery.fn.jquery);     //1.9.1自己使用jQuery来操作    console.log($.fn.jquery);        //3.5.1拥有$的控制权\n如果之前使用的1.9.1版本的$,现在$归3.5.1版本了，如何解决？\n\n可以把之前的js代码使用自执行函数框起来\n(function($){        //在这个自执行函数中，可以继续使用$了}(_$));\n', 0, 1);
INSERT INTO `t_article` VALUES (197, '24、jQuery插件库', 8, '网址：http://www.jq22.com/\n\n案例：颜色插件\n\n```js\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			div{\n				width: 200px;\n				height: 200px;\n				background-color: red;\n				position: relative;\n				top: 0px;\n				left: 0px;\n			}\n		</style>\n	</head>\n	<body>\n		<input type=\"button\" value=\"按钮\" id=\"btn\" />\n		<div></div>\n		\n	</body>\n</html>\n<script type=\"text/javascript\" src=\"js/jQuery1.9.1.js\" ></script>\n<script src=\"http://code.jquery.com/color/jquery.color-2.2.0.js\" integrity=\"sha256-gvMJWDHjgDrVSiN6eBI9h7dRfQmsTTsGU/eTT8vpzNg=\" crossorigin=\"anonymous\"></script>\n<script>\n	$(function(){\n		//需求：点击按钮，让div做动画，left改变为800,改变背景色\n		//animate动画不能改变背景色，如果要改，就要使用插件\n		$(\'#btn\').on(\'click\',function(){\n			//让div做动画\n			$(\'div\').animate({\n				left:800,\n				width:100,\n				height:100,\n				backgroundColor:\'green\'\n			},2000);\n			\n			//什么是插件？\n			//就是用来扩展功能的\n		})\n	})\n</script>\n```\n\n\n\n### 案例：省市联动\n\n```html\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<script type=\"text/javascript\" src=\"js/pcasunzip.js\" charset=\"UTF-8\"></script>\n\n<script type=\"text/javascript\">\nfunction getValue(){ \nvar getpro=document.getElementById(\"province\").value;\nvar getcity=document.getElementById(\"city\").value;\nvar getarea=document.getElementById(\"area\").value;\nalert(getpro+\" \"+getcity+\" \"+getarea);\n }\n</script>\n</head>\n<body>\n<font size=\"5\" color=\"color<b></b>\">根据需要可进行删除，删除须知：例如如果删除出生地该行，下面script中也要做想对应的操作，如果改动，下面script中的也要做相应的改动,得到select的值需在每个省市县三级三个select中添加上id的得到，例如：\nselect name=\"user.province\" id=\"province\"；\nselect name=\"user.city\" id=\"city\"；\nselect name=\"user.area\" id=\"area\"<br>\n</font>\n</br></br></br>\n\n<form action=\"\" method=\"\">\n<fieldset style=\"padding:5px;\">\n<legend>省市地区联动</legend>\n出　　 生 　地：<select name=\"user.province\" id=\"province\"></select>\n				<select name=\"user.city\" id=\"city\"></select>\n				<select name=\"user.area\" id=\"area\"></select><br>\n <input type=\"button\" name=\"bt\" id=\"bt\" value=\"测试\" onclick=\"getValue()\">\n</fieldset>\n</form>\n<script language=\"javascript\" defer>\nnew PCAS(\"user.province\",\"user.city\",\"user.area\",\"山东省\",\"济南市\",\"济南市\");\n\n</script>\n<br>\n</body>\n```\n\n', 0, 0, '2020-08-07 15:33:34', 2, 0, 1, '网址：http://www.jq22.com/\n案例：颜色插件\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            div{                width: 200px;                height: 200px;                background-color: red;                position: relative;                top: 0px;                left: 0px;            }        </style>    </head>    <body>        <input type=\"button\" value=\"按钮\" id=\"btn\" />        <div></div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery1.9.1.js\" ></script><script src=\"http://code.jquery.com/color/jquery.color-2.2.0.js\" integrity=\"sha256-gvMJWDHjgDrVSiN6eBI9h7dRfQmsTTsGU/eTT8vpzNg=\" crossorigin=\"anonymous\"></script><script>    $(function(){        //需求：点击按钮，让div做动画，left改变为800,改变背景色        //animate动画不能改变背景色，如果要改，就要使用插件        $(\'#btn\').on(\'click\',function(){            //让div做动画            $(\'div\').animate({                left:800,                width:100,                height:100,                backgroundColor:\'green\'            },2000);            //什么是插件？            //就是用来扩展功能的        })    })</script>\n案例：省市联动<!doctype html><html><head><meta charset=\"utf-8\"><script type=\"text/javascript\" src=\"js/pcasunzip.js\" charset=\"UTF-8\"></script><script type=\"text/javascript\">function getValue(){ var getpro=document.getElementById(\"province\").value;var getcity=document.getElementById(\"city\").value;var getarea=document.getElementById(\"area\").value;alert(getpro+\" \"+getcity+\" \"+getarea); }</script></head><body><font size=\"5\" color=\"color<b></b>\">根据需要可进行删除，删除须知：例如如果删除出生地该行，下面script中也要做想对应的操作，如果改动，下面script中的也要做相应的改动,得到select的值需在每个省市县三级三个select中添加上id的得到，例如：select name=\"user.province\" id=\"province\"；select name=\"user.city\" id=\"city\"；select name=\"user.area\" id=\"area\"<br></font></br></br></br><form action=\"\" method=\"\"><fieldset style=\"padding:5px;\"><legend>省市地区联动</legend>出　　 生 　地：<select name=\"user.province\" id=\"province\"></select>                <select name=\"user.city\" id=\"city\"></select>                <select name=\"user.area\" id=\"area\"></select><br> <input type=\"button\" name=\"bt\" id=\"bt\" value=\"测试\" onclick=\"getValue()\"></fieldset></form><script language=\"javascript\" defer>new PCAS(\"user.province\",\"user.city\",\"user.area\",\"山东省\",\"济南市\",\"济南市\");</script><br></body>\n', 0, 1);
INSERT INTO `t_article` VALUES (198, '25、jQuery UI 插件的使用', 8, '**（1）下载jQuery UI 组件库**\n\n官网地址：https://jqueryui.com/\n\n将下载好的jquery-ui-1.12.1.zip进行解压，这是我用的最新的版本。\n\n**（2）把相关文件复制到项目中**\n\n打开解压好的文件夹，把jquery-ui.css 复制到自己项目的css文件夹下面，把jQuery-ui.js复制到自己项目的js文件夹下面。\n\n**（3）调用相关文件**\n\n在自己的html文件中，需要引入jquery-ui.css 和 jQuery-ui.js，当然还要有jQuery.js。\n\n```html\n<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<link rel=\"stylesheet\" href=\"css/jquery-ui.css\" />\n</head>\n<script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script>\n<script type=\"text/javascript\" src=\"js/jquery-ui.js\" ></script>	\n```\n\n\n\n**（4）找到自己心怡的组件**\n\n使用浏览器打开里面的index.html，找到心怡的组件之后，然后查看网页源代码。\n\n**（5）复制组件源代码**\n\n查看网页源代码，然后使用ctrl+f，开始搜索组件名，找到组件的html部分进行复制。粘贴到自己的html文件中。\n\n例如：\n\n```html\n<!-- Accordion -->\n    <h2 class=\"demoHeaders\">Accordion</h2>\n    <div id=\"accordion\">\n        <h3>First</h3>\n        <div>Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet.</div>\n        <h3>Second</h3>\n        <div>Phasellus mattis tincidunt nibh.</div>\n        <h3>Third</h3>\n        <div>Nam dui erat, auctor a, dignissim quis.</div>\n    </div>	\n```\n\n**（6）调用组件的对应方法**\n\n查看网页源代码，在上一次使用ctrl+f查询到的结果，在找下一个，便是该组件的调用方法。调用后，便可生效。\n\n例如：$( \"#accordion\" ).accordion();\n\n```html\n<script>\n	$(function(){\n		$( \"#accordion\" ).accordion();\n	})\n</script>\n```\n\n案例代码：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<link rel=\"stylesheet\" href=\"css/jquery-ui.css\" />\n	</head>\n	<body>\n		<!-- Accordion -->\n		<h2 class=\"demoHeaders\">Accordion</h2>\n			<div id=\"accordion\">\n				<h3>First</h3>\n				<div>Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet.</div>\n				<h3>Second</h3>\n				<div>Phasellus mattis tincidunt nibh.</div>\n				<h3>Third</h3>\n				<div>Nam dui erat, auctor a, dignissim quis.</div>\n			</div>	\n		<!-- Tabs -->\n		<h2 class=\"demoHeaders\">Tabs</h2>\n			<div id=\"tabs\">\n				<ul>\n					<li><a href=\"#tabs-1\">First</a></li>\n					<li><a href=\"#tabs-2\">Second</a></li>\n					<li><a href=\"#tabs-3\">Third</a></li>\n				</ul>\n				<div id=\"tabs-1\">Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</div>\n				<div id=\"tabs-2\">Phasellus mattis tincidunt nibh. Cras orci urna, blandit id, pretium vel, aliquet ornare, felis. Maecenas scelerisque sem non nisl. Fusce sed lorem in enim dictum bibendum.</div>\n				<div id=\"tabs-3\">Nam dui erat, auctor a, dignissim quis, sollicitudin eu, felis. Pellentesque nisi urna, interdum eget, sagittis et, consequat vestibulum, lacus. Mauris porttitor ullamcorper augue.</div>\n			</div>	\n	</body>\n</html>\n<script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script>\n<script type=\"text/javascript\" src=\"js/jquery-ui.js\" ></script>\n<script>\n	$(function(){\n		$( \"#accordion\" ).accordion();\n		$( \"#tabs\" ).tabs();\n	})\n</script>\n```\n\n', 0, 0, '2020-08-07 15:33:56', 2, 0, 1, '（1）下载jQuery UI 组件库\n官网地址：https://jqueryui.com/\n将下载好的jquery-ui-1.12.1.zip进行解压，这是我用的最新的版本。\n（2）把相关文件复制到项目中\n打开解压好的文件夹，把jquery-ui.css 复制到自己项目的css文件夹下面，把jQuery-ui.js复制到自己项目的js文件夹下面。\n（3）调用相关文件\n在自己的html文件中，需要引入jquery-ui.css 和 jQuery-ui.js，当然还要有jQuery.js。\n<head>        <meta charset=\"UTF-8\">        <title></title>        <link rel=\"stylesheet\" href=\"css/jquery-ui.css\" /></head><script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script><script type=\"text/javascript\" src=\"js/jquery-ui.js\" ></script>\n（4）找到自己心怡的组件\n使用浏览器打开里面的index.html，找到心怡的组件之后，然后查看网页源代码。\n（5）复制组件源代码\n查看网页源代码，然后使用ctrl+f，开始搜索组件名，找到组件的html部分进行复制。粘贴到自己的html文件中。\n例如：\n<!-- Accordion -->    <h2 class=\"demoHeaders\">Accordion</h2>    <div id=\"accordion\">        <h3>First</h3>        <div>Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet.</div>        <h3>Second</h3>        <div>Phasellus mattis tincidunt nibh.</div>        <h3>Third</h3>        <div>Nam dui erat, auctor a, dignissim quis.</div>    </div>\n（6）调用组件的对应方法\n查看网页源代码，在上一次使用ctrl+f查询到的结果，在找下一个，便是该组件的调用方法。调用后，便可生效。\n例如：$( “#accordion” ).accordion();\n<script>    $(function(){        $( \"#accordion\" ).accordion();    })</script>\n案例代码：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <link rel=\"stylesheet\" href=\"css/jquery-ui.css\" />    </head>    <body>        <!-- Accordion -->        <h2 class=\"demoHeaders\">Accordion</h2>            <div id=\"accordion\">                <h3>First</h3>                <div>Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet.</div>                <h3>Second</h3>                <div>Phasellus mattis tincidunt nibh.</div>                <h3>Third</h3>                <div>Nam dui erat, auctor a, dignissim quis.</div>            </div>            <!-- Tabs -->        <h2 class=\"demoHeaders\">Tabs</h2>            <div id=\"tabs\">                <ul>                    <li><a href=\"#tabs-1\">First</a></li>                    <li><a href=\"#tabs-2\">Second</a></li>                    <li><a href=\"#tabs-3\">Third</a></li>                </ul>                <div id=\"tabs-1\">Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</div>                <div id=\"tabs-2\">Phasellus mattis tincidunt nibh. Cras orci urna, blandit id, pretium vel, aliquet ornare, felis. Maecenas scelerisque sem non nisl. Fusce sed lorem in enim dictum bibendum.</div>                <div id=\"tabs-3\">Nam dui erat, auctor a, dignissim quis, sollicitudin eu, felis. Pellentesque nisi urna, interdum eget, sagittis et, consequat vestibulum, lacus. Mauris porttitor ullamcorper augue.</div>            </div>        </body></html><script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script><script type=\"text/javascript\" src=\"js/jquery-ui.js\" ></script><script>    $(function(){        $( \"#accordion\" ).accordion();        $( \"#tabs\" ).tabs();    })</script>\n', 0, 1);
INSERT INTO `t_article` VALUES (199, '26、插件封装', 8, '### 如何封装自定义插件？\n\n两种方式：\n\n```\n$.fn.method = function(){}			//实例方法\n$.method = function(){}             //静态方法\n```\n\n两种方法的区别就在于，js代码中的自启动函数中，添加方法的对象不同，实例方法是添加到 $.fn上面，而静态方法是直接添加到$上面。\n\n\n\n#### 方法一：\n\n（1）创建jQuery-bgColor.js代码\n\n```js\n(function($){\n	//需要给jQuery的原型添加方法\n	$.fn.bgColor = function(color){\n//		console.log(this); // 获取到的this是当前的调用对象div\n		this.css(\'background-color\',color);\n		//返回jQuery对象\n		return this;\n	}\n}(jQuery));\n```\n\n（2）调用\n\n```html\n<script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script>\n<script type=\"text/javascript\" src=\"js/jQuery-bgColor.js\" ></script>\n\n<script>\n	$(function(){\n		$(\'div\').width(100).height(100).bgColor(\'red\');\n	})\n</script>\n```\n\n\n\n#### 方法二：\n\n（1）创建jQuery-add.js代码\n\n```js\n(function($){\n	$.add = function(num1,num2){\n		return num1 + num2;\n	}\n}(jQuery))\n```\n\n（2）调用\n\n```html\n<script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script>\n<script type=\"text/javascript\" src=\"js/jQuery-bgColor.js\" ></script>\n<script type=\"text/javascript\" src=\"js/jQuery-add.js\" ></script>\n<script>\n	$(function(){\n		console.log($.add(10,20));\n	})\n</script>\n```\n\n\n\n### 案例：自定义表格插件\n\nhtml文件：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title></title>\n		<style>\n			table{\n				display: table;\n				border-spacing: 2px;\n				border: 1px solid hotpink;\n				width: 500px;\n				border-collapse: collapse;\n			}\n			thead{\n				display: table-header-group;\n				vertical-align: middle;\n				border-color: inherit;\n			}\n			th {\n				border: 1px solid hotpink;\n			}\n			\n			tbody{\n				text-align: center;\n			}\n			\n			td{\n				border: 1px solid hotpink;\n				\n			}\n		</style>\n	</head>\n	<body>\n		<div id=\"c\">\n			\n		</div>\n	</body>\n</html>\n\n<script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script>\n<script type=\"text/javascript\" src=\"js/jQuery-table.js\" ></script>\n<script>\n	$(\'#c\').table([\'序号\',\'姓名\',\'年龄\',\'工资\'],[\n	{n:\'xy\',age:20,s:10},\n	{n:\'wy\',age:18,s:10},\n	{n:\'zf\',age:18,s:9}\n	]);\n	\n</script>\n```\n\n\n\njQuery-table.js文件\n\n```js\n(function($){\n	/**\n	 * 给$原型添加table方法\n	 * @param {Object} arrTableHead	生成表格表头的数据\n	 * @param {Object} arrTableBody	生成表格主体的数据\n	 */\n	$.fn.table = function(arrTableHead,arrTableBody){\n//		console.log(this); //调用table方法的jQuery对象\n		var list = [];\n		list.push(\'<table>\');\n		//生成表头\n		list.push(\'<thead>\');\n		list.push(\'<tr>\');\n		for(var i = 0 ;i<arrTableHead.length;i++){\n			list.push(\'<th>\');\n			list.push(arrTableHead[i]);\n			list.push(\'</th>\');\n		}\n		list.push(\'</tr>\');\n		list.push(\'</thead>\');\n		\n		//生成表格主体\n		for(var i = 0;i<arrTableBody.length;i++){\n			list.push(\'<tr>\');\n			list.push(\'<td>\');\n			list.push(i+1);\n			list.push(\'</td>\');\n			//遍历arrTableBody数组元素\n			for(var key in arrTableBody[i]){\n				list.push(\'<td>\');\n				list.push(arrTableBody[i][key]);\n				list.push(\'</td>\');\n			}\n			list.push(\'</tr>\');\n		}\n		\n		\n		list.push(\'</table>\');\n//		console.log(list.join(\"\"));\n		this.html(list.join(\"\"));\n		\n		return this;\n	}\n}(window.jQuery));\n```\n\n\n\n### 案例：自定义tab栏插件\n\n\n\nhtml文件：\n\n```html\n<!DOCTYPE html>\n<html>\n	<head>\n		<meta charset=\"UTF-8\">\n		<title>tab栏切换</title>\n		\n		<style>\n			*{\n				margin: 0;\n				padding: 0;\n			}\n			\n			\n			ul{\n				list-style: none;\n			}\n			\n			.wrapper{\n				width: 1000px;\n				height: 475px;\n				margin: 0 auto;\n				margin-top:100px ;\n			}\n			\n			\n			.tab{\n				border: 1px solid #ddd;\n				border-bottom: 0;\n				height: 36px;\n				width: 320px;\n			}\n			\n			.tab li{\n				position: relative;\n				float: left;\n				width: 80px;\n				height: 34px;\n				line-height: 34px;\n				text-align: center;\n				cursor: pointer;\n				border-top: 4px solid #FFFFFF ;\n			}\n			\n			.tab span{\n				position: absolute;\n				right: 0;\n				top:10px;\n				background: #DDDDDD;\n				width: 1px;\n				height: 14px;\n				overflow: hidden;\n\n			}\n			\n			.products .main{\n				float: left;\n				display: none;\n			}\n			\n			.products .main.selected{\n				display: block;\n			}\n			\n			.tab li.active{\n				border-color: red;\n				border-bottom: 0;\n			}\n		</style>\n		\n	</head>\n	<body>\n		<div id=\"wrapper\">\n			<ul class=\"tab\" id=\"tab-menu\">\n				<li class=\"tab-item active\">国际大牌</li>\n				<li class=\"tab-item\">国妆名牌</li>\n				<li class=\"tab-item\">清洁用品</li>\n				<li class=\"tab-item\">男士精品</li>\n			</ul>\n			<div class =\"products\" id=\"tab-main\">\n				<div class=\"main selected\">\n					<a href=\"\"><img src=\"img/2.jpg\" alt=\"\" /></a>\n				</div>\n				<div class=\"main \">\n					<a href=\"\"><img src=\"img/3.jpg\" alt=\"\" /></a>\n				</div>\n				<div class=\"main \">\n					<a href=\"\"><img src=\"img/4.jpg\" alt=\"\" /></a>\n				</div>\n				<div class=\"main \">\n					<a href=\"\"><img src=\"img/5.jpg\" alt=\"\" /></a>\n				</div>\n			</div>\n		</div>\n	</body>\n</html>\n<script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script>\n<script type=\"text/javascript\" src=\"js/jQuery-tabs.js\" ></script>\n<script>\n	$(function(){\n		$(\'#wrapper\').tabs({\n			tabHeads:\'#tab-menu>li\',\n			tabHeadsClass:\'active\',\n			tabBodys:\'#tab-main>div\',\n			tabBodysClass:\'selected\'\n		})\n		\n	})\n</script>\n```\n\n\n\njQuery-tabs.js文件：\n\n```js\n$(function($){\n	/**\n	 * 给$原型添加tabs()方法\n	 * @param option.tabHeads		需要注册事件的页签选择器\n	 * @param option.tabHeadsClass	触发事件页签需要给页签添加的类\n	 * @param option.tabBodys		需要显示的页面选择器\n	 * @param option.tabBodysClass 	触发事件页签需要给页面添加的类\n	 * \n	 */\n	$.fn.tabs = function(option){\n		var $bigDiv = this;\n		\n		//通过参数传递过来的页签选择器，获取到页签,给这些页签注册单击事件\n		$bigDiv.find(option.tabHeads).on(\'click\',function(){\n			//给当前鼠标点击的页签添加option.tabHeadsClass类，其他的兄弟移除option.tabHeadsClass类\n			$(this).addClass(option.tabHeadsClass).siblings().removeClass(option.tabHeadsClass);\n		\n			//获取当前点击的页签的索引\n			var idx = $(this).index();\n			console.log(idx);\n			\n			//获取索引一致的页面，给他添加option.tabBodysClass类，其他兄弟页面移除option.tabBodysClass类\n			$bigDiv.find(option.tabBodys).eq(idx).addClass(option.tabBodysClass).siblings().removeClass(option.tabBodysClass);\n		});\n		\n		return $bigDiv;\n	};\n}(jQuery));\n\n```\n\n\n\n', 1, 1, '2020-08-08 20:42:01', 12, 0, 1, '如何封装自定义插件？两种方式：\n$.fn.method = function(){}            //实例方法$.method = function(){}             //静态方法两种方法的区别就在于，js代码中的自启动函数中，添加方法的对象不同，实例方法是添加到 $.fn上面，而静态方法是直接添加到$上面。\n方法一：（1）创建jQuery-bgColor.js代码\n(function($){    //需要给jQuery的原型添加方法    $.fn.bgColor = function(color){//        console.log(this); // 获取到的this是当前的调用对象div        this.css(\'background-color\',color);        //返回jQuery对象        return this;    }}(jQuery));\n（2）调用\n<script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script><script type=\"text/javascript\" src=\"js/jQuery-bgColor.js\" ></script><script>    $(function(){        $(\'div\').width(100).height(100).bgColor(\'red\');    })</script>\n方法二：（1）创建jQuery-add.js代码\n(function($){    $.add = function(num1,num2){        return num1 + num2;    }}(jQuery))\n（2）调用\n<script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script><script type=\"text/javascript\" src=\"js/jQuery-bgColor.js\" ></script><script type=\"text/javascript\" src=\"js/jQuery-add.js\" ></script><script>    $(function(){        console.log($.add(10,20));    })</script>\n案例：自定义表格插件html文件：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            table{                display: table;                border-spacing: 2px;                border: 1px solid hotpink;                width: 500px;                border-collapse: collapse;            }            thead{                display: table-header-group;                vertical-align: middle;                border-color: inherit;            }            th {                border: 1px solid hotpink;            }            tbody{                text-align: center;            }            td{                border: 1px solid hotpink;            }        </style>    </head>    <body>        <div id=\"c\">        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script><script type=\"text/javascript\" src=\"js/jQuery-table.js\" ></script><script>    $(\'#c\').table([\'序号\',\'姓名\',\'年龄\',\'工资\'],[    {n:\'xy\',age:20,s:10},    {n:\'wy\',age:18,s:10},    {n:\'zf\',age:18,s:9}    ]);</script>\njQuery-table.js文件\n(function($){    /**     * 给$原型添加table方法     * @param {Object} arrTableHead    生成表格表头的数据     * @param {Object} arrTableBody    生成表格主体的数据     */    $.fn.table = function(arrTableHead,arrTableBody){//        console.log(this); //调用table方法的jQuery对象        var list = [];        list.push(\'<table>\');        //生成表头        list.push(\'<thead>\');        list.push(\'<tr>\');        for(var i = 0 ;i<arrTableHead.length;i++){            list.push(\'<th>\');            list.push(arrTableHead[i]);            list.push(\'</th>\');        }        list.push(\'</tr>\');        list.push(\'</thead>\');        //生成表格主体        for(var i = 0;i<arrTableBody.length;i++){            list.push(\'<tr>\');            list.push(\'<td>\');            list.push(i+1);            list.push(\'</td>\');            //遍历arrTableBody数组元素            for(var key in arrTableBody[i]){                list.push(\'<td>\');                list.push(arrTableBody[i][key]);                list.push(\'</td>\');            }            list.push(\'</tr>\');        }        list.push(\'</table>\');//        console.log(list.join(\"\"));        this.html(list.join(\"\"));        return this;    }}(window.jQuery));\n案例：自定义tab栏插件html文件：\n<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title>tab栏切换</title>        <style>            *{                margin: 0;                padding: 0;            }            ul{                list-style: none;            }            .wrapper{                width: 1000px;                height: 475px;                margin: 0 auto;                margin-top:100px ;            }            .tab{                border: 1px solid #ddd;                border-bottom: 0;                height: 36px;                width: 320px;            }            .tab li{                position: relative;                float: left;                width: 80px;                height: 34px;                line-height: 34px;                text-align: center;                cursor: pointer;                border-top: 4px solid #FFFFFF ;            }            .tab span{                position: absolute;                right: 0;                top:10px;                background: #DDDDDD;                width: 1px;                height: 14px;                overflow: hidden;            }            .products .main{                float: left;                display: none;            }            .products .main.selected{                display: block;            }            .tab li.active{                border-color: red;                border-bottom: 0;            }        </style>    </head>    <body>        <div id=\"wrapper\">            <ul class=\"tab\" id=\"tab-menu\">                <li class=\"tab-item active\">国际大牌</li>                <li class=\"tab-item\">国妆名牌</li>                <li class=\"tab-item\">清洁用品</li>                <li class=\"tab-item\">男士精品</li>            </ul>            <div class =\"products\" id=\"tab-main\">                <div class=\"main selected\">                    <a href=\"\"><img src=\"img/2.jpg\" alt=\"\" /></a>                </div>                <div class=\"main \">                    <a href=\"\"><img src=\"img/3.jpg\" alt=\"\" /></a>                </div>                <div class=\"main \">                    <a href=\"\"><img src=\"img/4.jpg\" alt=\"\" /></a>                </div>                <div class=\"main \">                    <a href=\"\"><img src=\"img/5.jpg\" alt=\"\" /></a>                </div>            </div>        </div>    </body></html><script type=\"text/javascript\" src=\"js/jQuery3.5.1.js\" ></script><script type=\"text/javascript\" src=\"js/jQuery-tabs.js\" ></script><script>    $(function(){        $(\'#wrapper\').tabs({            tabHeads:\'#tab-menu>li\',            tabHeadsClass:\'active\',            tabBodys:\'#tab-main>div\',            tabBodysClass:\'selected\'        })    })</script>\njQuery-tabs.js文件：\n$(function($){    /**     * 给$原型添加tabs()方法     * @param option.tabHeads        需要注册事件的页签选择器     * @param option.tabHeadsClass    触发事件页签需要给页签添加的类     * @param option.tabBodys        需要显示的页面选择器     * @param option.tabBodysClass     触发事件页签需要给页面添加的类     *      */    $.fn.tabs = function(option){        var $bigDiv = this;        //通过参数传递过来的页签选择器，获取到页签,给这些页签注册单击事件        $bigDiv.find(option.tabHeads).on(\'click\',function(){            //给当前鼠标点击的页签添加option.tabHeadsClass类，其他的兄弟移除option.tabHeadsClass类            $(this).addClass(option.tabHeadsClass).siblings().removeClass(option.tabHeadsClass);            //获取当前点击的页签的索引            var idx = $(this).index();            console.log(idx);            //获取索引一致的页面，给他添加option.tabBodysClass类，其他兄弟页面移除option.tabBodysClass类            $bigDiv.find(option.tabBodys).eq(idx).addClass(option.tabBodysClass).siblings().removeClass(option.tabBodysClass);        });        return $bigDiv;    };}(jQuery));\n', 0, 1);
INSERT INTO `t_article` VALUES (200, '跑步', 8, '<p>跑步</p><figure class=\"image\"><img src=\"https://blog-web-1302471896.cos.ap-beijing.myqcloud.com/img/20200807225809249.jpg\"></figure>', 0, 0, '2020-08-07 23:32:01', 6, 0, 1, '跑步image widget', 1, 1);
INSERT INTO `t_article` VALUES (201, '的发射点', 8, '<p><img src=\"https://blog-web-1302471896.cos.ap-beijing.myqcloud.com/img/20200807233223706.jpg\" alt=\"20200807233223706.jpg\"></p>', 0, 0, '2020-08-08 20:41:51', 8, 0, 1, '', 2, 1);
INSERT INTO `t_article` VALUES (202, '搜索', 8, '<p><img src=\"https://blog-web-1302471896.cos.ap-beijing.myqcloud.com/img/20200808000358821.jpg\" alt=\"20200808000358821.jpg\"><br></p>', 0, 0, '2020-08-08 17:52:43', 2, 0, 1, '', 2, 1);
INSERT INTO `t_article` VALUES (203, '最大的自律就是学会享受孤独', 8, '今天首次一口气跑步超过2公里，加油~~~\n\n![图片alt](https://blog-web-1302471896.cos.ap-beijing.myqcloud.com/img/20200808235050581.jpg \'\'图片title\'\')', 0, 0, '2020-08-09 00:45:06', 6, 0, 1, '今天首次一口气跑步超过2公里，加油~~~\n\n', 0, 1);

-- ----------------------------
-- Table structure for t_collect
-- ----------------------------
DROP TABLE IF EXISTS `t_collect`;
CREATE TABLE `t_collect`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_id` int(11) NOT NULL COMMENT '收藏人ID',
  `article_id` int(11) NOT NULL COMMENT '文章ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_collect
-- ----------------------------
INSERT INTO `t_collect` VALUES (9, 8, 199);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_id` int(11) NOT NULL COMMENT '评论人ID',
  `article_id` int(11) NOT NULL COMMENT '文章ID',
  `comment_time` datetime(0) NOT NULL COMMENT '评论时间',
  `content` text CHARACTER SET utf8 COLLATE utf8_croatian_ci NOT NULL COMMENT '评论内容',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (14, 1, 12, '2020-08-06 19:16:16', '真的爱你呀');
INSERT INTO `t_comment` VALUES (15, 8, 95, '2020-08-07 15:35:21', '牛逼，爱了爱了');
INSERT INTO `t_comment` VALUES (16, 8, 110, '2020-08-08 20:02:57', '测试');

-- ----------------------------
-- Table structure for t_focus
-- ----------------------------
DROP TABLE IF EXISTS `t_focus`;
CREATE TABLE `t_focus`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_id` int(11) NOT NULL COMMENT '用户ID',
  `focus_id` int(11) NULL DEFAULT NULL COMMENT '关注人ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_focus
-- ----------------------------
INSERT INTO `t_focus` VALUES (12, 8, 2);
INSERT INTO `t_focus` VALUES (13, 8, 3);
INSERT INTO `t_focus` VALUES (14, 2, 8);

-- ----------------------------
-- Table structure for t_like
-- ----------------------------
DROP TABLE IF EXISTS `t_like`;
CREATE TABLE `t_like`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_id` int(11) NOT NULL COMMENT '点赞人ID',
  `article_id` int(11) NOT NULL COMMENT '点赞的文章ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_like
-- ----------------------------
INSERT INTO `t_like` VALUES (12, 8, 199);

-- ----------------------------
-- Table structure for t_sec_art_type
-- ----------------------------
DROP TABLE IF EXISTS `t_sec_art_type`;
CREATE TABLE `t_sec_art_type`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `type_id` int(11) NULL DEFAULT NULL COMMENT '一级类型的ID',
  `sec_type_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '二级菜单名称',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_sec_art_type
-- ----------------------------
INSERT INTO `t_sec_art_type` VALUES (1, 3, 'HTML');
INSERT INTO `t_sec_art_type` VALUES (2, 3, 'CSS');
INSERT INTO `t_sec_art_type` VALUES (3, 3, 'JavaScript');
INSERT INTO `t_sec_art_type` VALUES (4, 3, 'jQuery');
INSERT INTO `t_sec_art_type` VALUES (5, 4, 'Spring');
INSERT INTO `t_sec_art_type` VALUES (6, 4, 'Spring MVC');
INSERT INTO `t_sec_art_type` VALUES (7, 4, 'MyBatis');
INSERT INTO `t_sec_art_type` VALUES (8, 4, 'Spring Boot');
INSERT INTO `t_sec_art_type` VALUES (9, 5, 'MySql');
INSERT INTO `t_sec_art_type` VALUES (10, 5, 'Oracle');

-- ----------------------------
-- Table structure for t_specol
-- ----------------------------
DROP TABLE IF EXISTS `t_specol`;
CREATE TABLE `t_specol`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_id` int(255) NULL DEFAULT NULL COMMENT '用户ID',
  `spe_col` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '专栏名称',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `introduction` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '简介',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 37 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_specol
-- ----------------------------
INSERT INTO `t_specol` VALUES (25, 8, 'JavaSE学习笔记', '2020-08-06 21:35:02', 'Java入门，从零开始学习');
INSERT INTO `t_specol` VALUES (26, 8, 'C语言笔记', '2020-08-06 22:27:24', 'C语言的学习笔记');
INSERT INTO `t_specol` VALUES (27, 8, 'Git以及GitHub的使用', '2020-08-06 22:29:03', '关于Git以及GitHub的使用');
INSERT INTO `t_specol` VALUES (28, 8, 'JQuery学习笔记', '2020-08-06 22:36:20', '关于JQuery学习笔记，替代了传统js');
INSERT INTO `t_specol` VALUES (29, 8, 'LeedCode刷题', '2020-08-06 23:03:48', 'LeedCode热门100道刷题含题解');
INSERT INTO `t_specol` VALUES (30, 8, 'Linux 操作系统学习笔记', '2020-08-07 00:00:34', '关于Linux 操作系统学习笔记');
INSERT INTO `t_specol` VALUES (31, 8, 'SSM框架学习', '2020-08-07 00:35:03', '由MyBatis、Spring、SpringMVC组成的现代SSM框架。');
INSERT INTO `t_specol` VALUES (32, 8, '数据结构学习笔记', '2020-08-07 00:56:42', '利用Java来实习各自数据结构和常用算法');
INSERT INTO `t_specol` VALUES (33, 8, '算法与设计', '2020-08-07 01:12:13', '关于算法的一些刨析');
INSERT INTO `t_specol` VALUES (34, 8, 'MySQL数据库学习笔记', '2020-08-07 01:13:54', '关于MySQL数据库学习笔记');
INSERT INTO `t_specol` VALUES (35, 8, 'JavaEE学习笔记', '2020-08-07 14:13:56', '使用Java进行web开发，主要是JSP和servlet配合使用完成web页面和后端交互');
INSERT INTO `t_specol` VALUES (37, 8, '跑步日志', '2020-08-08 23:52:38', '最大的自律就是学会享受孤独');

-- ----------------------------
-- Table structure for t_specol_rel
-- ----------------------------
DROP TABLE IF EXISTS `t_specol_rel`;
CREATE TABLE `t_specol_rel`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `art_id` int(11) NULL DEFAULT NULL COMMENT '文章ID',
  `spe_id` int(255) NULL DEFAULT NULL COMMENT '专栏ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 271 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_specol_rel
-- ----------------------------
INSERT INTO `t_specol_rel` VALUES (90, 27, 25);
INSERT INTO `t_specol_rel` VALUES (91, 28, 25);
INSERT INTO `t_specol_rel` VALUES (92, 30, 25);
INSERT INTO `t_specol_rel` VALUES (93, 31, 25);
INSERT INTO `t_specol_rel` VALUES (94, 32, 25);
INSERT INTO `t_specol_rel` VALUES (95, 33, 25);
INSERT INTO `t_specol_rel` VALUES (96, 34, 25);
INSERT INTO `t_specol_rel` VALUES (97, 35, 25);
INSERT INTO `t_specol_rel` VALUES (98, 36, 25);
INSERT INTO `t_specol_rel` VALUES (99, 37, 25);
INSERT INTO `t_specol_rel` VALUES (100, 38, 25);
INSERT INTO `t_specol_rel` VALUES (101, 39, 25);
INSERT INTO `t_specol_rel` VALUES (102, 40, 25);
INSERT INTO `t_specol_rel` VALUES (103, 41, 25);
INSERT INTO `t_specol_rel` VALUES (104, 42, 25);
INSERT INTO `t_specol_rel` VALUES (105, 43, 25);
INSERT INTO `t_specol_rel` VALUES (106, 44, 25);
INSERT INTO `t_specol_rel` VALUES (107, 45, 25);
INSERT INTO `t_specol_rel` VALUES (108, 46, 25);
INSERT INTO `t_specol_rel` VALUES (109, 47, 25);
INSERT INTO `t_specol_rel` VALUES (110, 48, 25);
INSERT INTO `t_specol_rel` VALUES (111, 49, 25);
INSERT INTO `t_specol_rel` VALUES (112, 50, 25);
INSERT INTO `t_specol_rel` VALUES (113, 51, 25);
INSERT INTO `t_specol_rel` VALUES (114, 52, 25);
INSERT INTO `t_specol_rel` VALUES (115, 53, 25);
INSERT INTO `t_specol_rel` VALUES (116, 54, 25);
INSERT INTO `t_specol_rel` VALUES (117, 55, 26);
INSERT INTO `t_specol_rel` VALUES (118, 56, 27);
INSERT INTO `t_specol_rel` VALUES (120, 58, 29);
INSERT INTO `t_specol_rel` VALUES (121, 59, 29);
INSERT INTO `t_specol_rel` VALUES (122, 60, 29);
INSERT INTO `t_specol_rel` VALUES (124, 61, 29);
INSERT INTO `t_specol_rel` VALUES (125, 63, 29);
INSERT INTO `t_specol_rel` VALUES (126, 64, 29);
INSERT INTO `t_specol_rel` VALUES (127, 65, 29);
INSERT INTO `t_specol_rel` VALUES (128, 66, 29);
INSERT INTO `t_specol_rel` VALUES (129, 67, 29);
INSERT INTO `t_specol_rel` VALUES (130, 68, 29);
INSERT INTO `t_specol_rel` VALUES (131, 69, 29);
INSERT INTO `t_specol_rel` VALUES (132, 70, 29);
INSERT INTO `t_specol_rel` VALUES (133, 71, 29);
INSERT INTO `t_specol_rel` VALUES (134, 72, 29);
INSERT INTO `t_specol_rel` VALUES (135, 73, 29);
INSERT INTO `t_specol_rel` VALUES (136, 74, 29);
INSERT INTO `t_specol_rel` VALUES (137, 75, 29);
INSERT INTO `t_specol_rel` VALUES (139, 76, 29);
INSERT INTO `t_specol_rel` VALUES (140, 77, 29);
INSERT INTO `t_specol_rel` VALUES (141, 78, 29);
INSERT INTO `t_specol_rel` VALUES (142, 79, 29);
INSERT INTO `t_specol_rel` VALUES (143, 80, 29);
INSERT INTO `t_specol_rel` VALUES (144, 81, 29);
INSERT INTO `t_specol_rel` VALUES (145, 82, 29);
INSERT INTO `t_specol_rel` VALUES (146, 83, 29);
INSERT INTO `t_specol_rel` VALUES (147, 84, 29);
INSERT INTO `t_specol_rel` VALUES (148, 85, 29);
INSERT INTO `t_specol_rel` VALUES (149, 86, 29);
INSERT INTO `t_specol_rel` VALUES (150, 87, 29);
INSERT INTO `t_specol_rel` VALUES (151, 88, 29);
INSERT INTO `t_specol_rel` VALUES (152, 89, 29);
INSERT INTO `t_specol_rel` VALUES (153, 90, 29);
INSERT INTO `t_specol_rel` VALUES (154, 91, 29);
INSERT INTO `t_specol_rel` VALUES (155, 92, 29);
INSERT INTO `t_specol_rel` VALUES (156, 93, 29);
INSERT INTO `t_specol_rel` VALUES (157, 94, 29);
INSERT INTO `t_specol_rel` VALUES (158, 95, 29);
INSERT INTO `t_specol_rel` VALUES (160, 96, 30);
INSERT INTO `t_specol_rel` VALUES (161, 97, 30);
INSERT INTO `t_specol_rel` VALUES (162, 98, 30);
INSERT INTO `t_specol_rel` VALUES (163, 99, 30);
INSERT INTO `t_specol_rel` VALUES (164, 100, 30);
INSERT INTO `t_specol_rel` VALUES (165, 101, 30);
INSERT INTO `t_specol_rel` VALUES (167, 102, 30);
INSERT INTO `t_specol_rel` VALUES (168, 103, 31);
INSERT INTO `t_specol_rel` VALUES (169, 104, 31);
INSERT INTO `t_specol_rel` VALUES (170, 105, 31);
INSERT INTO `t_specol_rel` VALUES (171, 106, 31);
INSERT INTO `t_specol_rel` VALUES (172, 107, 31);
INSERT INTO `t_specol_rel` VALUES (173, 108, 31);
INSERT INTO `t_specol_rel` VALUES (174, 109, 31);
INSERT INTO `t_specol_rel` VALUES (175, 110, 31);
INSERT INTO `t_specol_rel` VALUES (176, 111, 31);
INSERT INTO `t_specol_rel` VALUES (177, 112, 31);
INSERT INTO `t_specol_rel` VALUES (178, 113, 31);
INSERT INTO `t_specol_rel` VALUES (179, 114, 31);
INSERT INTO `t_specol_rel` VALUES (180, 115, 31);
INSERT INTO `t_specol_rel` VALUES (181, 116, 31);
INSERT INTO `t_specol_rel` VALUES (182, 117, 31);
INSERT INTO `t_specol_rel` VALUES (183, 118, 31);
INSERT INTO `t_specol_rel` VALUES (184, 119, 31);
INSERT INTO `t_specol_rel` VALUES (185, 120, 31);
INSERT INTO `t_specol_rel` VALUES (186, 121, 31);
INSERT INTO `t_specol_rel` VALUES (187, 122, 31);
INSERT INTO `t_specol_rel` VALUES (189, 123, 31);
INSERT INTO `t_specol_rel` VALUES (190, 124, 31);
INSERT INTO `t_specol_rel` VALUES (191, 125, 31);
INSERT INTO `t_specol_rel` VALUES (192, 126, 31);
INSERT INTO `t_specol_rel` VALUES (193, 127, 31);
INSERT INTO `t_specol_rel` VALUES (194, 128, 31);
INSERT INTO `t_specol_rel` VALUES (195, 129, 31);
INSERT INTO `t_specol_rel` VALUES (196, 130, 32);
INSERT INTO `t_specol_rel` VALUES (197, 131, 32);
INSERT INTO `t_specol_rel` VALUES (198, 132, 32);
INSERT INTO `t_specol_rel` VALUES (199, 133, 32);
INSERT INTO `t_specol_rel` VALUES (200, 134, 32);
INSERT INTO `t_specol_rel` VALUES (201, 135, 32);
INSERT INTO `t_specol_rel` VALUES (202, 136, 32);
INSERT INTO `t_specol_rel` VALUES (203, 137, 33);
INSERT INTO `t_specol_rel` VALUES (204, 138, 34);
INSERT INTO `t_specol_rel` VALUES (205, 139, 34);
INSERT INTO `t_specol_rel` VALUES (206, 140, 34);
INSERT INTO `t_specol_rel` VALUES (207, 141, 34);
INSERT INTO `t_specol_rel` VALUES (208, 142, 34);
INSERT INTO `t_specol_rel` VALUES (209, 143, 34);
INSERT INTO `t_specol_rel` VALUES (210, 144, 34);
INSERT INTO `t_specol_rel` VALUES (211, 145, 34);
INSERT INTO `t_specol_rel` VALUES (212, 146, 34);
INSERT INTO `t_specol_rel` VALUES (213, 147, 34);
INSERT INTO `t_specol_rel` VALUES (214, 148, 34);
INSERT INTO `t_specol_rel` VALUES (215, 149, 34);
INSERT INTO `t_specol_rel` VALUES (216, 150, 34);
INSERT INTO `t_specol_rel` VALUES (217, 151, 34);
INSERT INTO `t_specol_rel` VALUES (218, 152, 34);
INSERT INTO `t_specol_rel` VALUES (219, 153, 34);
INSERT INTO `t_specol_rel` VALUES (220, 154, 35);
INSERT INTO `t_specol_rel` VALUES (221, 155, 35);
INSERT INTO `t_specol_rel` VALUES (222, 156, 35);
INSERT INTO `t_specol_rel` VALUES (223, 157, 35);
INSERT INTO `t_specol_rel` VALUES (224, 158, 35);
INSERT INTO `t_specol_rel` VALUES (225, 159, 35);
INSERT INTO `t_specol_rel` VALUES (226, 160, 35);
INSERT INTO `t_specol_rel` VALUES (227, 161, 35);
INSERT INTO `t_specol_rel` VALUES (228, 162, 35);
INSERT INTO `t_specol_rel` VALUES (229, 163, 35);
INSERT INTO `t_specol_rel` VALUES (230, 164, 35);
INSERT INTO `t_specol_rel` VALUES (231, 165, 35);
INSERT INTO `t_specol_rel` VALUES (232, 166, 35);
INSERT INTO `t_specol_rel` VALUES (233, 167, 35);
INSERT INTO `t_specol_rel` VALUES (234, 168, 35);
INSERT INTO `t_specol_rel` VALUES (235, 169, 35);
INSERT INTO `t_specol_rel` VALUES (236, 170, 35);
INSERT INTO `t_specol_rel` VALUES (237, 171, 35);
INSERT INTO `t_specol_rel` VALUES (238, 172, 35);
INSERT INTO `t_specol_rel` VALUES (239, 173, 35);
INSERT INTO `t_specol_rel` VALUES (240, 174, 28);
INSERT INTO `t_specol_rel` VALUES (242, 176, 28);
INSERT INTO `t_specol_rel` VALUES (243, 175, 28);
INSERT INTO `t_specol_rel` VALUES (244, 177, 28);
INSERT INTO `t_specol_rel` VALUES (245, 178, 28);
INSERT INTO `t_specol_rel` VALUES (246, 179, 28);
INSERT INTO `t_specol_rel` VALUES (247, 180, 28);
INSERT INTO `t_specol_rel` VALUES (248, 181, 28);
INSERT INTO `t_specol_rel` VALUES (249, 182, 28);
INSERT INTO `t_specol_rel` VALUES (250, 183, 28);
INSERT INTO `t_specol_rel` VALUES (251, 184, 28);
INSERT INTO `t_specol_rel` VALUES (252, 185, 28);
INSERT INTO `t_specol_rel` VALUES (253, 186, 28);
INSERT INTO `t_specol_rel` VALUES (254, 187, 28);
INSERT INTO `t_specol_rel` VALUES (255, 188, 28);
INSERT INTO `t_specol_rel` VALUES (256, 189, 28);
INSERT INTO `t_specol_rel` VALUES (257, 190, 28);
INSERT INTO `t_specol_rel` VALUES (258, 191, 28);
INSERT INTO `t_specol_rel` VALUES (259, 192, 28);
INSERT INTO `t_specol_rel` VALUES (260, 193, 28);
INSERT INTO `t_specol_rel` VALUES (261, 194, 28);
INSERT INTO `t_specol_rel` VALUES (262, 195, 28);
INSERT INTO `t_specol_rel` VALUES (263, 196, 28);
INSERT INTO `t_specol_rel` VALUES (264, 197, 28);
INSERT INTO `t_specol_rel` VALUES (265, 198, 28);
INSERT INTO `t_specol_rel` VALUES (266, 199, 28);
INSERT INTO `t_specol_rel` VALUES (267, 200, 33);
INSERT INTO `t_specol_rel` VALUES (269, 201, 33);
INSERT INTO `t_specol_rel` VALUES (270, 202, 33);
INSERT INTO `t_specol_rel` VALUES (271, 203, 37);

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `tag` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '标签',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 26 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (1, '宅男');
INSERT INTO `t_tag` VALUES (2, '程序员');
INSERT INTO `t_tag` VALUES (3, '帅锅');
INSERT INTO `t_tag` VALUES (4, 'Java全栈工程师');
INSERT INTO `t_tag` VALUES (5, '暖男');
INSERT INTO `t_tag` VALUES (6, '钢铁直男');
INSERT INTO `t_tag` VALUES (7, '理想型');
INSERT INTO `t_tag` VALUES (8, '文艺青年');
INSERT INTO `t_tag` VALUES (9, '街头麦霸');
INSERT INTO `t_tag` VALUES (10, '白领');
INSERT INTO `t_tag` VALUES (11, '上班族');
INSERT INTO `t_tag` VALUES (12, '潜力股');
INSERT INTO `t_tag` VALUES (13, '手机控');
INSERT INTO `t_tag` VALUES (14, '小清新');
INSERT INTO `t_tag` VALUES (15, '学生');
INSERT INTO `t_tag` VALUES (16, 'IT民工');
INSERT INTO `t_tag` VALUES (17, '萝莉');
INSERT INTO `t_tag` VALUES (18, '技术宅');
INSERT INTO `t_tag` VALUES (19, '自由职业');
INSERT INTO `t_tag` VALUES (20, '运动');
INSERT INTO `t_tag` VALUES (21, '游戏');
INSERT INTO `t_tag` VALUES (22, 'K歌');
INSERT INTO `t_tag` VALUES (23, '读书');
INSERT INTO `t_tag` VALUES (24, '猫奴');
INSERT INTO `t_tag` VALUES (25, '爱狗狂魔');

-- ----------------------------
-- Table structure for t_tag_record
-- ----------------------------
DROP TABLE IF EXISTS `t_tag_record`;
CREATE TABLE `t_tag_record`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_id` int(11) NULL DEFAULT NULL COMMENT '用户ID',
  `tag_id` int(11) NULL DEFAULT NULL COMMENT '标签ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 90 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_tag_record
-- ----------------------------
INSERT INTO `t_tag_record` VALUES (78, 8, 2);
INSERT INTO `t_tag_record` VALUES (79, 8, 3);
INSERT INTO `t_tag_record` VALUES (80, 8, 4);
INSERT INTO `t_tag_record` VALUES (81, 8, 5);
INSERT INTO `t_tag_record` VALUES (82, 8, 7);
INSERT INTO `t_tag_record` VALUES (83, 8, 12);
INSERT INTO `t_tag_record` VALUES (84, 8, 14);
INSERT INTO `t_tag_record` VALUES (85, 8, 15);
INSERT INTO `t_tag_record` VALUES (86, 8, 16);
INSERT INTO `t_tag_record` VALUES (87, 8, 18);
INSERT INTO `t_tag_record` VALUES (88, 8, 20);
INSERT INTO `t_tag_record` VALUES (89, 8, 21);

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NOT NULL COMMENT '用户名',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '昵称',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NOT NULL COMMENT '密码',
  `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '地址',
  `phone_num` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '手机号',
  `identity` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '身份',
  `synopsis` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '个人简介',
  `img` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '头像',
  `sex` varchar(255) CHARACTER SET utf8 COLLATE utf8_croatian_ci NULL DEFAULT NULL COMMENT '性别',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (8, '86god', '疯狂的JINX', 'e10adc3949ba59abbe56e057f20f883e', '陕西渭南', '15592237888', '在校大学生', '愿你走过一路难堪，归来依旧落落大方。\nCSDN：一直流浪~\n知乎：一直流浪\ngithub：86God\n', '20200806212842824.jpg', '男');

-- ----------------------------
-- Table structure for t_user_head_info
-- ----------------------------
DROP TABLE IF EXISTS `t_user_head_info`;
CREATE TABLE `t_user_head_info`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_id` int(11) NOT NULL COMMENT '用户ID',
  `attention` int(10) NOT NULL DEFAULT 0 COMMENT '关注量',
  `collect` int(10) NOT NULL DEFAULT 0 COMMENT '收藏量',
  `heat` int(10) NOT NULL DEFAULT 0 COMMENT '热度',
  `article_num` int(11) NOT NULL DEFAULT 0 COMMENT '帖子数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user_head_info
-- ----------------------------
INSERT INTO `t_user_head_info` VALUES (3, 8, 2, 1, 420, 174);

-- ----------------------------
-- Table structure for t_visit
-- ----------------------------
DROP TABLE IF EXISTS `t_visit`;
CREATE TABLE `t_visit`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_id` int(11) NOT NULL COMMENT '用户ID',
  `article_id` int(11) NOT NULL COMMENT '文章ID',
  `time` datetime(0) NOT NULL COMMENT '访问时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 552 CHARACTER SET = utf8 COLLATE = utf8_croatian_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_visit
-- ----------------------------
INSERT INTO `t_visit` VALUES (153, 8, 32, '2020-08-06 21:56:44');
INSERT INTO `t_visit` VALUES (154, 8, 32, '2020-08-06 21:56:44');
INSERT INTO `t_visit` VALUES (155, 8, 33, '2020-08-06 21:57:51');
INSERT INTO `t_visit` VALUES (156, 8, 33, '2020-08-06 21:57:51');
INSERT INTO `t_visit` VALUES (157, 8, 34, '2020-08-06 21:58:29');
INSERT INTO `t_visit` VALUES (158, 8, 34, '2020-08-06 21:58:30');
INSERT INTO `t_visit` VALUES (159, 8, 35, '2020-08-06 21:59:02');
INSERT INTO `t_visit` VALUES (160, 8, 35, '2020-08-06 21:59:02');
INSERT INTO `t_visit` VALUES (161, 8, 36, '2020-08-06 21:59:45');
INSERT INTO `t_visit` VALUES (162, 8, 36, '2020-08-06 21:59:45');
INSERT INTO `t_visit` VALUES (163, 8, 37, '2020-08-06 22:00:17');
INSERT INTO `t_visit` VALUES (164, 8, 37, '2020-08-06 22:00:17');
INSERT INTO `t_visit` VALUES (165, 8, 38, '2020-08-06 22:00:43');
INSERT INTO `t_visit` VALUES (166, 8, 38, '2020-08-06 22:00:44');
INSERT INTO `t_visit` VALUES (167, 8, 39, '2020-08-06 22:01:15');
INSERT INTO `t_visit` VALUES (168, 8, 39, '2020-08-06 22:01:15');
INSERT INTO `t_visit` VALUES (169, 8, 40, '2020-08-06 22:07:17');
INSERT INTO `t_visit` VALUES (170, 8, 40, '2020-08-06 22:07:17');
INSERT INTO `t_visit` VALUES (171, 8, 41, '2020-08-06 22:07:49');
INSERT INTO `t_visit` VALUES (172, 8, 41, '2020-08-06 22:07:49');
INSERT INTO `t_visit` VALUES (173, 8, 42, '2020-08-06 22:08:22');
INSERT INTO `t_visit` VALUES (174, 8, 42, '2020-08-06 22:08:22');
INSERT INTO `t_visit` VALUES (175, 8, 43, '2020-08-06 22:09:17');
INSERT INTO `t_visit` VALUES (176, 8, 43, '2020-08-06 22:09:17');
INSERT INTO `t_visit` VALUES (177, 8, 44, '2020-08-06 22:09:49');
INSERT INTO `t_visit` VALUES (178, 8, 44, '2020-08-06 22:09:50');
INSERT INTO `t_visit` VALUES (179, 8, 45, '2020-08-06 22:10:15');
INSERT INTO `t_visit` VALUES (180, 8, 45, '2020-08-06 22:10:15');
INSERT INTO `t_visit` VALUES (181, 8, 46, '2020-08-06 22:11:40');
INSERT INTO `t_visit` VALUES (182, 8, 46, '2020-08-06 22:11:40');
INSERT INTO `t_visit` VALUES (183, 8, 47, '2020-08-06 22:12:18');
INSERT INTO `t_visit` VALUES (184, 8, 47, '2020-08-06 22:12:18');
INSERT INTO `t_visit` VALUES (185, 8, 48, '2020-08-06 22:12:54');
INSERT INTO `t_visit` VALUES (186, 8, 48, '2020-08-06 22:12:54');
INSERT INTO `t_visit` VALUES (187, 8, 49, '2020-08-06 22:13:35');
INSERT INTO `t_visit` VALUES (188, 8, 49, '2020-08-06 22:13:35');
INSERT INTO `t_visit` VALUES (189, 8, 50, '2020-08-06 22:23:11');
INSERT INTO `t_visit` VALUES (190, 8, 50, '2020-08-06 22:23:12');
INSERT INTO `t_visit` VALUES (191, 8, 51, '2020-08-06 22:23:43');
INSERT INTO `t_visit` VALUES (192, 8, 51, '2020-08-06 22:23:43');
INSERT INTO `t_visit` VALUES (193, 8, 52, '2020-08-06 22:24:22');
INSERT INTO `t_visit` VALUES (194, 8, 52, '2020-08-06 22:24:23');
INSERT INTO `t_visit` VALUES (195, 8, 53, '2020-08-06 22:25:26');
INSERT INTO `t_visit` VALUES (196, 8, 53, '2020-08-06 22:25:26');
INSERT INTO `t_visit` VALUES (197, 8, 54, '2020-08-06 22:26:21');
INSERT INTO `t_visit` VALUES (198, 8, 54, '2020-08-06 22:26:21');
INSERT INTO `t_visit` VALUES (199, 8, 55, '2020-08-06 22:27:38');
INSERT INTO `t_visit` VALUES (200, 8, 55, '2020-08-06 22:27:38');
INSERT INTO `t_visit` VALUES (201, 8, 56, '2020-08-06 22:29:18');
INSERT INTO `t_visit` VALUES (202, 8, 56, '2020-08-06 22:29:18');
INSERT INTO `t_visit` VALUES (203, 8, 57, '2020-08-06 22:37:13');
INSERT INTO `t_visit` VALUES (204, 8, 57, '2020-08-06 22:37:13');
INSERT INTO `t_visit` VALUES (205, 8, 56, '2020-08-06 22:41:23');
INSERT INTO `t_visit` VALUES (206, 8, 58, '2020-08-06 23:03:58');
INSERT INTO `t_visit` VALUES (207, 8, 58, '2020-08-06 23:03:59');
INSERT INTO `t_visit` VALUES (208, 8, 59, '2020-08-06 23:04:57');
INSERT INTO `t_visit` VALUES (209, 8, 59, '2020-08-06 23:04:58');
INSERT INTO `t_visit` VALUES (210, 8, 60, '2020-08-06 23:05:38');
INSERT INTO `t_visit` VALUES (211, 8, 60, '2020-08-06 23:05:38');
INSERT INTO `t_visit` VALUES (212, 8, 61, '2020-08-06 23:06:49');
INSERT INTO `t_visit` VALUES (213, 8, 61, '2020-08-06 23:06:49');
INSERT INTO `t_visit` VALUES (214, 8, 61, '2020-08-06 23:07:23');
INSERT INTO `t_visit` VALUES (215, 8, 61, '2020-08-06 23:12:58');
INSERT INTO `t_visit` VALUES (216, 8, 61, '2020-08-06 23:13:25');
INSERT INTO `t_visit` VALUES (217, 8, 61, '2020-08-06 23:15:52');
INSERT INTO `t_visit` VALUES (218, 8, 61, '2020-08-06 23:15:54');
INSERT INTO `t_visit` VALUES (219, 8, 61, '2020-08-06 23:17:34');
INSERT INTO `t_visit` VALUES (220, 8, 61, '2020-08-06 23:17:34');
INSERT INTO `t_visit` VALUES (221, 8, 64, '2020-08-06 23:22:25');
INSERT INTO `t_visit` VALUES (222, 8, 64, '2020-08-06 23:23:36');
INSERT INTO `t_visit` VALUES (223, 8, 64, '2020-08-06 23:25:01');
INSERT INTO `t_visit` VALUES (224, 8, 64, '2020-08-06 23:25:50');
INSERT INTO `t_visit` VALUES (225, 8, 64, '2020-08-06 23:25:52');
INSERT INTO `t_visit` VALUES (226, 8, 65, '2020-08-06 23:29:20');
INSERT INTO `t_visit` VALUES (227, 8, 65, '2020-08-06 23:29:20');
INSERT INTO `t_visit` VALUES (228, 8, 66, '2020-08-06 23:30:17');
INSERT INTO `t_visit` VALUES (229, 8, 66, '2020-08-06 23:30:17');
INSERT INTO `t_visit` VALUES (230, 8, 67, '2020-08-06 23:31:17');
INSERT INTO `t_visit` VALUES (231, 8, 67, '2020-08-06 23:31:18');
INSERT INTO `t_visit` VALUES (232, 8, 68, '2020-08-06 23:32:17');
INSERT INTO `t_visit` VALUES (233, 8, 68, '2020-08-06 23:32:17');
INSERT INTO `t_visit` VALUES (234, 8, 69, '2020-08-06 23:33:26');
INSERT INTO `t_visit` VALUES (235, 8, 69, '2020-08-06 23:33:26');
INSERT INTO `t_visit` VALUES (236, 8, 70, '2020-08-06 23:34:13');
INSERT INTO `t_visit` VALUES (237, 8, 70, '2020-08-06 23:34:13');
INSERT INTO `t_visit` VALUES (238, 8, 71, '2020-08-06 23:35:08');
INSERT INTO `t_visit` VALUES (239, 8, 71, '2020-08-06 23:35:08');
INSERT INTO `t_visit` VALUES (240, 8, 72, '2020-08-06 23:35:50');
INSERT INTO `t_visit` VALUES (241, 8, 72, '2020-08-06 23:35:50');
INSERT INTO `t_visit` VALUES (242, 8, 73, '2020-08-06 23:36:45');
INSERT INTO `t_visit` VALUES (243, 8, 73, '2020-08-06 23:36:45');
INSERT INTO `t_visit` VALUES (244, 8, 74, '2020-08-06 23:38:07');
INSERT INTO `t_visit` VALUES (245, 8, 74, '2020-08-06 23:38:07');
INSERT INTO `t_visit` VALUES (246, 8, 75, '2020-08-06 23:39:03');
INSERT INTO `t_visit` VALUES (247, 8, 75, '2020-08-06 23:39:03');
INSERT INTO `t_visit` VALUES (248, 8, 76, '2020-08-06 23:39:54');
INSERT INTO `t_visit` VALUES (249, 8, 76, '2020-08-06 23:39:54');
INSERT INTO `t_visit` VALUES (250, 8, 76, '2020-08-06 23:40:45');
INSERT INTO `t_visit` VALUES (251, 8, 76, '2020-08-06 23:41:12');
INSERT INTO `t_visit` VALUES (252, 8, 76, '2020-08-06 23:41:12');
INSERT INTO `t_visit` VALUES (253, 8, 76, '2020-08-06 23:41:26');
INSERT INTO `t_visit` VALUES (254, 8, 76, '2020-08-06 23:41:27');
INSERT INTO `t_visit` VALUES (255, 8, 77, '2020-08-06 23:42:03');
INSERT INTO `t_visit` VALUES (256, 8, 77, '2020-08-06 23:42:04');
INSERT INTO `t_visit` VALUES (257, 8, 77, '2020-08-06 23:42:12');
INSERT INTO `t_visit` VALUES (258, 8, 77, '2020-08-06 23:42:30');
INSERT INTO `t_visit` VALUES (259, 8, 77, '2020-08-06 23:42:30');
INSERT INTO `t_visit` VALUES (260, 8, 77, '2020-08-06 23:42:34');
INSERT INTO `t_visit` VALUES (261, 8, 77, '2020-08-06 23:42:35');
INSERT INTO `t_visit` VALUES (262, 8, 78, '2020-08-06 23:43:32');
INSERT INTO `t_visit` VALUES (263, 8, 78, '2020-08-06 23:43:32');
INSERT INTO `t_visit` VALUES (264, 8, 79, '2020-08-06 23:44:17');
INSERT INTO `t_visit` VALUES (265, 8, 79, '2020-08-06 23:44:18');
INSERT INTO `t_visit` VALUES (266, 8, 80, '2020-08-06 23:45:23');
INSERT INTO `t_visit` VALUES (267, 8, 80, '2020-08-06 23:45:23');
INSERT INTO `t_visit` VALUES (268, 8, 81, '2020-08-06 23:46:06');
INSERT INTO `t_visit` VALUES (269, 8, 81, '2020-08-06 23:46:07');
INSERT INTO `t_visit` VALUES (270, 8, 82, '2020-08-06 23:46:44');
INSERT INTO `t_visit` VALUES (271, 8, 82, '2020-08-06 23:46:44');
INSERT INTO `t_visit` VALUES (272, 8, 83, '2020-08-06 23:47:26');
INSERT INTO `t_visit` VALUES (273, 8, 83, '2020-08-06 23:47:27');
INSERT INTO `t_visit` VALUES (274, 8, 84, '2020-08-06 23:48:04');
INSERT INTO `t_visit` VALUES (275, 8, 84, '2020-08-06 23:48:04');
INSERT INTO `t_visit` VALUES (276, 8, 85, '2020-08-06 23:48:55');
INSERT INTO `t_visit` VALUES (277, 8, 85, '2020-08-06 23:48:56');
INSERT INTO `t_visit` VALUES (278, 8, 86, '2020-08-06 23:49:51');
INSERT INTO `t_visit` VALUES (279, 8, 86, '2020-08-06 23:49:52');
INSERT INTO `t_visit` VALUES (280, 8, 87, '2020-08-06 23:50:40');
INSERT INTO `t_visit` VALUES (281, 8, 87, '2020-08-06 23:50:40');
INSERT INTO `t_visit` VALUES (282, 8, 88, '2020-08-06 23:51:28');
INSERT INTO `t_visit` VALUES (283, 8, 88, '2020-08-06 23:51:28');
INSERT INTO `t_visit` VALUES (284, 8, 89, '2020-08-06 23:52:32');
INSERT INTO `t_visit` VALUES (285, 8, 89, '2020-08-06 23:52:33');
INSERT INTO `t_visit` VALUES (286, 8, 90, '2020-08-06 23:53:31');
INSERT INTO `t_visit` VALUES (287, 8, 90, '2020-08-06 23:53:31');
INSERT INTO `t_visit` VALUES (288, 8, 91, '2020-08-06 23:54:48');
INSERT INTO `t_visit` VALUES (289, 8, 91, '2020-08-06 23:54:49');
INSERT INTO `t_visit` VALUES (290, 8, 92, '2020-08-06 23:55:23');
INSERT INTO `t_visit` VALUES (291, 8, 92, '2020-08-06 23:55:24');
INSERT INTO `t_visit` VALUES (292, 8, 93, '2020-08-06 23:55:59');
INSERT INTO `t_visit` VALUES (293, 8, 93, '2020-08-06 23:56:00');
INSERT INTO `t_visit` VALUES (294, 8, 94, '2020-08-06 23:57:28');
INSERT INTO `t_visit` VALUES (295, 8, 94, '2020-08-06 23:57:29');
INSERT INTO `t_visit` VALUES (296, 8, 95, '2020-08-06 23:58:23');
INSERT INTO `t_visit` VALUES (297, 8, 95, '2020-08-06 23:58:23');
INSERT INTO `t_visit` VALUES (298, 8, 96, '2020-08-07 00:00:48');
INSERT INTO `t_visit` VALUES (299, 8, 96, '2020-08-07 00:00:49');
INSERT INTO `t_visit` VALUES (300, 8, 96, '2020-08-07 00:11:39');
INSERT INTO `t_visit` VALUES (301, 8, 96, '2020-08-07 00:11:59');
INSERT INTO `t_visit` VALUES (302, 8, 96, '2020-08-07 00:11:59');
INSERT INTO `t_visit` VALUES (303, 8, 96, '2020-08-07 00:16:49');
INSERT INTO `t_visit` VALUES (304, 8, 96, '2020-08-07 00:16:51');
INSERT INTO `t_visit` VALUES (305, 8, 97, '2020-08-07 00:17:21');
INSERT INTO `t_visit` VALUES (306, 8, 97, '2020-08-07 00:17:22');
INSERT INTO `t_visit` VALUES (307, 8, 98, '2020-08-07 00:22:24');
INSERT INTO `t_visit` VALUES (308, 8, 98, '2020-08-07 00:22:24');
INSERT INTO `t_visit` VALUES (309, 8, 99, '2020-08-07 00:27:55');
INSERT INTO `t_visit` VALUES (310, 8, 99, '2020-08-07 00:27:55');
INSERT INTO `t_visit` VALUES (311, 8, 100, '2020-08-07 00:29:29');
INSERT INTO `t_visit` VALUES (312, 8, 100, '2020-08-07 00:29:30');
INSERT INTO `t_visit` VALUES (313, 8, 101, '2020-08-07 00:30:39');
INSERT INTO `t_visit` VALUES (314, 8, 101, '2020-08-07 00:30:39');
INSERT INTO `t_visit` VALUES (315, 8, 102, '2020-08-07 00:31:33');
INSERT INTO `t_visit` VALUES (316, 8, 102, '2020-08-07 00:31:34');
INSERT INTO `t_visit` VALUES (317, 8, 102, '2020-08-07 00:31:35');
INSERT INTO `t_visit` VALUES (318, 8, 102, '2020-08-07 00:31:41');
INSERT INTO `t_visit` VALUES (319, 8, 102, '2020-08-07 00:31:41');
INSERT INTO `t_visit` VALUES (320, 8, 102, '2020-08-07 00:31:44');
INSERT INTO `t_visit` VALUES (321, 8, 103, '2020-08-07 00:35:20');
INSERT INTO `t_visit` VALUES (322, 8, 103, '2020-08-07 00:35:20');
INSERT INTO `t_visit` VALUES (323, 8, 104, '2020-08-07 00:36:02');
INSERT INTO `t_visit` VALUES (324, 8, 104, '2020-08-07 00:36:03');
INSERT INTO `t_visit` VALUES (325, 8, 105, '2020-08-07 00:37:24');
INSERT INTO `t_visit` VALUES (326, 8, 105, '2020-08-07 00:37:25');
INSERT INTO `t_visit` VALUES (327, 8, 106, '2020-08-07 00:38:03');
INSERT INTO `t_visit` VALUES (328, 8, 106, '2020-08-07 00:38:04');
INSERT INTO `t_visit` VALUES (329, 8, 107, '2020-08-07 00:38:41');
INSERT INTO `t_visit` VALUES (330, 8, 107, '2020-08-07 00:38:41');
INSERT INTO `t_visit` VALUES (331, 8, 108, '2020-08-07 00:39:36');
INSERT INTO `t_visit` VALUES (332, 8, 108, '2020-08-07 00:39:36');
INSERT INTO `t_visit` VALUES (333, 8, 109, '2020-08-07 00:40:19');
INSERT INTO `t_visit` VALUES (334, 8, 109, '2020-08-07 00:40:19');
INSERT INTO `t_visit` VALUES (335, 8, 110, '2020-08-07 00:40:54');
INSERT INTO `t_visit` VALUES (336, 8, 110, '2020-08-07 00:40:54');
INSERT INTO `t_visit` VALUES (337, 8, 111, '2020-08-07 00:42:04');
INSERT INTO `t_visit` VALUES (338, 8, 111, '2020-08-07 00:42:04');
INSERT INTO `t_visit` VALUES (339, 8, 112, '2020-08-07 00:42:36');
INSERT INTO `t_visit` VALUES (340, 8, 112, '2020-08-07 00:42:36');
INSERT INTO `t_visit` VALUES (341, 8, 113, '2020-08-07 00:43:06');
INSERT INTO `t_visit` VALUES (342, 8, 113, '2020-08-07 00:43:07');
INSERT INTO `t_visit` VALUES (343, 8, 114, '2020-08-07 00:43:57');
INSERT INTO `t_visit` VALUES (344, 8, 114, '2020-08-07 00:43:57');
INSERT INTO `t_visit` VALUES (345, 8, 115, '2020-08-07 00:44:32');
INSERT INTO `t_visit` VALUES (346, 8, 115, '2020-08-07 00:44:32');
INSERT INTO `t_visit` VALUES (347, 8, 116, '2020-08-07 00:45:08');
INSERT INTO `t_visit` VALUES (348, 8, 116, '2020-08-07 00:45:08');
INSERT INTO `t_visit` VALUES (349, 8, 117, '2020-08-07 00:45:36');
INSERT INTO `t_visit` VALUES (350, 8, 117, '2020-08-07 00:45:37');
INSERT INTO `t_visit` VALUES (351, 8, 118, '2020-08-07 00:46:04');
INSERT INTO `t_visit` VALUES (352, 8, 118, '2020-08-07 00:46:05');
INSERT INTO `t_visit` VALUES (353, 8, 119, '2020-08-07 00:46:43');
INSERT INTO `t_visit` VALUES (354, 8, 119, '2020-08-07 00:46:43');
INSERT INTO `t_visit` VALUES (355, 8, 120, '2020-08-07 00:47:22');
INSERT INTO `t_visit` VALUES (356, 8, 120, '2020-08-07 00:47:22');
INSERT INTO `t_visit` VALUES (357, 8, 121, '2020-08-07 00:48:06');
INSERT INTO `t_visit` VALUES (358, 8, 121, '2020-08-07 00:48:07');
INSERT INTO `t_visit` VALUES (359, 8, 122, '2020-08-07 00:48:51');
INSERT INTO `t_visit` VALUES (360, 8, 122, '2020-08-07 00:48:51');
INSERT INTO `t_visit` VALUES (361, 8, 123, '2020-08-07 00:49:26');
INSERT INTO `t_visit` VALUES (362, 8, 123, '2020-08-07 00:49:27');
INSERT INTO `t_visit` VALUES (363, 8, 123, '2020-08-07 00:49:28');
INSERT INTO `t_visit` VALUES (364, 8, 123, '2020-08-07 00:49:35');
INSERT INTO `t_visit` VALUES (365, 8, 123, '2020-08-07 00:49:35');
INSERT INTO `t_visit` VALUES (366, 8, 123, '2020-08-07 00:49:38');
INSERT INTO `t_visit` VALUES (367, 8, 124, '2020-08-07 00:50:09');
INSERT INTO `t_visit` VALUES (368, 8, 124, '2020-08-07 00:50:10');
INSERT INTO `t_visit` VALUES (369, 8, 125, '2020-08-07 00:50:53');
INSERT INTO `t_visit` VALUES (370, 8, 125, '2020-08-07 00:50:53');
INSERT INTO `t_visit` VALUES (371, 8, 126, '2020-08-07 00:51:49');
INSERT INTO `t_visit` VALUES (372, 8, 126, '2020-08-07 00:51:50');
INSERT INTO `t_visit` VALUES (373, 8, 127, '2020-08-07 00:52:27');
INSERT INTO `t_visit` VALUES (374, 8, 127, '2020-08-07 00:52:27');
INSERT INTO `t_visit` VALUES (375, 8, 128, '2020-08-07 00:53:12');
INSERT INTO `t_visit` VALUES (376, 8, 128, '2020-08-07 00:53:12');
INSERT INTO `t_visit` VALUES (377, 8, 128, '2020-08-07 00:53:44');
INSERT INTO `t_visit` VALUES (378, 8, 129, '2020-08-07 00:55:17');
INSERT INTO `t_visit` VALUES (379, 8, 129, '2020-08-07 00:55:18');
INSERT INTO `t_visit` VALUES (380, 8, 130, '2020-08-07 00:56:54');
INSERT INTO `t_visit` VALUES (381, 8, 130, '2020-08-07 00:56:54');
INSERT INTO `t_visit` VALUES (382, 8, 131, '2020-08-07 00:57:52');
INSERT INTO `t_visit` VALUES (383, 8, 131, '2020-08-07 00:57:52');
INSERT INTO `t_visit` VALUES (384, 8, 132, '2020-08-07 00:58:35');
INSERT INTO `t_visit` VALUES (385, 8, 132, '2020-08-07 00:58:35');
INSERT INTO `t_visit` VALUES (386, 8, 133, '2020-08-07 00:59:03');
INSERT INTO `t_visit` VALUES (387, 8, 133, '2020-08-07 00:59:03');
INSERT INTO `t_visit` VALUES (388, 8, 134, '2020-08-07 00:59:37');
INSERT INTO `t_visit` VALUES (389, 8, 134, '2020-08-07 00:59:37');
INSERT INTO `t_visit` VALUES (390, 8, 135, '2020-08-07 01:00:17');
INSERT INTO `t_visit` VALUES (391, 8, 135, '2020-08-07 01:00:18');
INSERT INTO `t_visit` VALUES (392, 8, 136, '2020-08-07 01:00:49');
INSERT INTO `t_visit` VALUES (393, 8, 136, '2020-08-07 01:00:49');
INSERT INTO `t_visit` VALUES (394, 8, 137, '2020-08-07 01:12:24');
INSERT INTO `t_visit` VALUES (395, 8, 137, '2020-08-07 01:12:25');
INSERT INTO `t_visit` VALUES (396, 8, 138, '2020-08-07 01:14:39');
INSERT INTO `t_visit` VALUES (397, 8, 138, '2020-08-07 01:14:39');
INSERT INTO `t_visit` VALUES (398, 8, 139, '2020-08-07 01:15:09');
INSERT INTO `t_visit` VALUES (399, 8, 139, '2020-08-07 01:15:09');
INSERT INTO `t_visit` VALUES (400, 8, 140, '2020-08-07 01:15:38');
INSERT INTO `t_visit` VALUES (401, 8, 140, '2020-08-07 01:15:38');
INSERT INTO `t_visit` VALUES (402, 8, 141, '2020-08-07 01:16:10');
INSERT INTO `t_visit` VALUES (403, 8, 141, '2020-08-07 01:16:10');
INSERT INTO `t_visit` VALUES (404, 8, 142, '2020-08-07 01:16:35');
INSERT INTO `t_visit` VALUES (405, 8, 142, '2020-08-07 01:16:35');
INSERT INTO `t_visit` VALUES (406, 8, 143, '2020-08-07 01:16:59');
INSERT INTO `t_visit` VALUES (407, 8, 143, '2020-08-07 01:16:59');
INSERT INTO `t_visit` VALUES (408, 8, 144, '2020-08-07 01:17:41');
INSERT INTO `t_visit` VALUES (409, 8, 144, '2020-08-07 01:17:42');
INSERT INTO `t_visit` VALUES (410, 8, 145, '2020-08-07 01:18:14');
INSERT INTO `t_visit` VALUES (411, 8, 145, '2020-08-07 01:18:14');
INSERT INTO `t_visit` VALUES (412, 8, 146, '2020-08-07 01:18:39');
INSERT INTO `t_visit` VALUES (413, 8, 146, '2020-08-07 01:18:39');
INSERT INTO `t_visit` VALUES (414, 8, 147, '2020-08-07 01:19:18');
INSERT INTO `t_visit` VALUES (415, 8, 147, '2020-08-07 01:19:18');
INSERT INTO `t_visit` VALUES (416, 8, 148, '2020-08-07 01:19:48');
INSERT INTO `t_visit` VALUES (417, 8, 148, '2020-08-07 01:19:48');
INSERT INTO `t_visit` VALUES (418, 8, 149, '2020-08-07 01:20:34');
INSERT INTO `t_visit` VALUES (419, 8, 149, '2020-08-07 01:20:34');
INSERT INTO `t_visit` VALUES (420, 8, 150, '2020-08-07 01:21:20');
INSERT INTO `t_visit` VALUES (421, 8, 150, '2020-08-07 01:21:20');
INSERT INTO `t_visit` VALUES (422, 8, 151, '2020-08-07 01:21:49');
INSERT INTO `t_visit` VALUES (423, 8, 151, '2020-08-07 01:21:49');
INSERT INTO `t_visit` VALUES (424, 8, 152, '2020-08-07 01:22:18');
INSERT INTO `t_visit` VALUES (425, 8, 152, '2020-08-07 01:22:18');
INSERT INTO `t_visit` VALUES (426, 8, 153, '2020-08-07 01:22:48');
INSERT INTO `t_visit` VALUES (427, 8, 153, '2020-08-07 01:22:48');
INSERT INTO `t_visit` VALUES (428, 8, 153, '2020-08-07 13:31:38');
INSERT INTO `t_visit` VALUES (429, 8, 154, '2020-08-07 14:14:06');
INSERT INTO `t_visit` VALUES (430, 8, 154, '2020-08-07 14:14:07');
INSERT INTO `t_visit` VALUES (431, 8, 155, '2020-08-07 14:14:45');
INSERT INTO `t_visit` VALUES (432, 8, 155, '2020-08-07 14:14:45');
INSERT INTO `t_visit` VALUES (433, 8, 156, '2020-08-07 14:15:42');
INSERT INTO `t_visit` VALUES (434, 8, 156, '2020-08-07 14:15:42');
INSERT INTO `t_visit` VALUES (435, 8, 157, '2020-08-07 14:16:33');
INSERT INTO `t_visit` VALUES (436, 8, 157, '2020-08-07 14:16:33');
INSERT INTO `t_visit` VALUES (437, 8, 158, '2020-08-07 14:17:10');
INSERT INTO `t_visit` VALUES (438, 8, 158, '2020-08-07 14:17:10');
INSERT INTO `t_visit` VALUES (439, 8, 159, '2020-08-07 14:17:41');
INSERT INTO `t_visit` VALUES (440, 8, 159, '2020-08-07 14:17:41');
INSERT INTO `t_visit` VALUES (441, 8, 159, '2020-08-07 14:17:52');
INSERT INTO `t_visit` VALUES (442, 8, 160, '2020-08-07 14:19:04');
INSERT INTO `t_visit` VALUES (443, 8, 160, '2020-08-07 14:19:04');
INSERT INTO `t_visit` VALUES (444, 8, 161, '2020-08-07 14:22:02');
INSERT INTO `t_visit` VALUES (445, 8, 161, '2020-08-07 14:22:03');
INSERT INTO `t_visit` VALUES (446, 8, 162, '2020-08-07 14:22:28');
INSERT INTO `t_visit` VALUES (447, 8, 162, '2020-08-07 14:22:28');
INSERT INTO `t_visit` VALUES (448, 8, 163, '2020-08-07 14:22:53');
INSERT INTO `t_visit` VALUES (449, 8, 163, '2020-08-07 14:22:53');
INSERT INTO `t_visit` VALUES (450, 8, 164, '2020-08-07 14:23:19');
INSERT INTO `t_visit` VALUES (451, 8, 164, '2020-08-07 14:23:19');
INSERT INTO `t_visit` VALUES (452, 8, 165, '2020-08-07 14:23:46');
INSERT INTO `t_visit` VALUES (453, 8, 165, '2020-08-07 14:23:46');
INSERT INTO `t_visit` VALUES (454, 8, 166, '2020-08-07 14:24:20');
INSERT INTO `t_visit` VALUES (455, 8, 166, '2020-08-07 14:24:20');
INSERT INTO `t_visit` VALUES (456, 8, 167, '2020-08-07 14:25:02');
INSERT INTO `t_visit` VALUES (457, 8, 167, '2020-08-07 14:25:03');
INSERT INTO `t_visit` VALUES (458, 8, 168, '2020-08-07 14:25:29');
INSERT INTO `t_visit` VALUES (459, 8, 168, '2020-08-07 14:25:29');
INSERT INTO `t_visit` VALUES (460, 8, 169, '2020-08-07 14:25:59');
INSERT INTO `t_visit` VALUES (461, 8, 169, '2020-08-07 14:25:59');
INSERT INTO `t_visit` VALUES (462, 8, 170, '2020-08-07 14:26:32');
INSERT INTO `t_visit` VALUES (463, 8, 170, '2020-08-07 14:26:33');
INSERT INTO `t_visit` VALUES (464, 8, 171, '2020-08-07 14:27:15');
INSERT INTO `t_visit` VALUES (465, 8, 171, '2020-08-07 14:27:16');
INSERT INTO `t_visit` VALUES (466, 8, 172, '2020-08-07 14:27:43');
INSERT INTO `t_visit` VALUES (467, 8, 172, '2020-08-07 14:27:43');
INSERT INTO `t_visit` VALUES (468, 8, 173, '2020-08-07 14:28:09');
INSERT INTO `t_visit` VALUES (469, 8, 173, '2020-08-07 14:28:09');
INSERT INTO `t_visit` VALUES (470, 8, 174, '2020-08-07 14:44:01');
INSERT INTO `t_visit` VALUES (471, 8, 174, '2020-08-07 14:44:02');
INSERT INTO `t_visit` VALUES (472, 8, 174, '2020-08-07 14:45:29');
INSERT INTO `t_visit` VALUES (473, 8, 174, '2020-08-07 14:46:23');
INSERT INTO `t_visit` VALUES (474, 8, 174, '2020-08-07 14:46:23');
INSERT INTO `t_visit` VALUES (475, 8, 174, '2020-08-07 14:46:24');
INSERT INTO `t_visit` VALUES (476, 8, 175, '2020-08-07 15:04:00');
INSERT INTO `t_visit` VALUES (477, 8, 175, '2020-08-07 15:04:00');
INSERT INTO `t_visit` VALUES (478, 8, 176, '2020-08-07 15:04:47');
INSERT INTO `t_visit` VALUES (479, 8, 176, '2020-08-07 15:04:47');
INSERT INTO `t_visit` VALUES (480, 8, 175, '2020-08-07 15:04:51');
INSERT INTO `t_visit` VALUES (481, 8, 175, '2020-08-07 15:04:52');
INSERT INTO `t_visit` VALUES (482, 8, 175, '2020-08-07 15:05:05');
INSERT INTO `t_visit` VALUES (483, 8, 175, '2020-08-07 15:05:06');
INSERT INTO `t_visit` VALUES (484, 8, 175, '2020-08-07 15:05:10');
INSERT INTO `t_visit` VALUES (485, 8, 175, '2020-08-07 15:05:11');
INSERT INTO `t_visit` VALUES (486, 8, 177, '2020-08-07 15:05:47');
INSERT INTO `t_visit` VALUES (487, 8, 177, '2020-08-07 15:05:47');
INSERT INTO `t_visit` VALUES (488, 8, 178, '2020-08-07 15:06:27');
INSERT INTO `t_visit` VALUES (489, 8, 178, '2020-08-07 15:06:27');
INSERT INTO `t_visit` VALUES (490, 8, 179, '2020-08-07 15:08:07');
INSERT INTO `t_visit` VALUES (491, 8, 179, '2020-08-07 15:08:07');
INSERT INTO `t_visit` VALUES (492, 8, 180, '2020-08-07 15:24:14');
INSERT INTO `t_visit` VALUES (493, 8, 180, '2020-08-07 15:24:15');
INSERT INTO `t_visit` VALUES (494, 8, 181, '2020-08-07 15:24:51');
INSERT INTO `t_visit` VALUES (495, 8, 181, '2020-08-07 15:24:51');
INSERT INTO `t_visit` VALUES (496, 8, 182, '2020-08-07 15:25:36');
INSERT INTO `t_visit` VALUES (497, 8, 182, '2020-08-07 15:25:36');
INSERT INTO `t_visit` VALUES (498, 8, 183, '2020-08-07 15:26:05');
INSERT INTO `t_visit` VALUES (499, 8, 183, '2020-08-07 15:26:05');
INSERT INTO `t_visit` VALUES (500, 8, 184, '2020-08-07 15:26:43');
INSERT INTO `t_visit` VALUES (501, 8, 184, '2020-08-07 15:26:43');
INSERT INTO `t_visit` VALUES (502, 8, 185, '2020-08-07 15:27:09');
INSERT INTO `t_visit` VALUES (503, 8, 185, '2020-08-07 15:27:09');
INSERT INTO `t_visit` VALUES (504, 8, 186, '2020-08-07 15:27:33');
INSERT INTO `t_visit` VALUES (505, 8, 186, '2020-08-07 15:27:34');
INSERT INTO `t_visit` VALUES (506, 8, 187, '2020-08-07 15:28:06');
INSERT INTO `t_visit` VALUES (507, 8, 187, '2020-08-07 15:28:07');
INSERT INTO `t_visit` VALUES (508, 8, 188, '2020-08-07 15:28:29');
INSERT INTO `t_visit` VALUES (509, 8, 188, '2020-08-07 15:28:29');
INSERT INTO `t_visit` VALUES (510, 8, 189, '2020-08-07 15:29:18');
INSERT INTO `t_visit` VALUES (511, 8, 189, '2020-08-07 15:29:18');
INSERT INTO `t_visit` VALUES (512, 8, 190, '2020-08-07 15:29:45');
INSERT INTO `t_visit` VALUES (513, 8, 190, '2020-08-07 15:29:45');
INSERT INTO `t_visit` VALUES (514, 8, 190, '2020-08-07 15:29:48');
INSERT INTO `t_visit` VALUES (515, 8, 190, '2020-08-07 15:29:51');
INSERT INTO `t_visit` VALUES (516, 8, 191, '2020-08-07 15:30:33');
INSERT INTO `t_visit` VALUES (517, 8, 191, '2020-08-07 15:30:33');
INSERT INTO `t_visit` VALUES (518, 8, 192, '2020-08-07 15:30:57');
INSERT INTO `t_visit` VALUES (519, 8, 192, '2020-08-07 15:30:58');
INSERT INTO `t_visit` VALUES (520, 8, 193, '2020-08-07 15:31:46');
INSERT INTO `t_visit` VALUES (521, 8, 193, '2020-08-07 15:31:46');
INSERT INTO `t_visit` VALUES (522, 8, 194, '2020-08-07 15:32:19');
INSERT INTO `t_visit` VALUES (523, 8, 194, '2020-08-07 15:32:19');
INSERT INTO `t_visit` VALUES (524, 8, 195, '2020-08-07 15:32:46');
INSERT INTO `t_visit` VALUES (525, 8, 195, '2020-08-07 15:32:46');
INSERT INTO `t_visit` VALUES (526, 8, 196, '2020-08-07 15:33:07');
INSERT INTO `t_visit` VALUES (527, 8, 196, '2020-08-07 15:33:07');
INSERT INTO `t_visit` VALUES (528, 8, 197, '2020-08-07 15:33:34');
INSERT INTO `t_visit` VALUES (529, 8, 197, '2020-08-07 15:33:34');
INSERT INTO `t_visit` VALUES (530, 8, 198, '2020-08-07 15:33:56');
INSERT INTO `t_visit` VALUES (531, 8, 198, '2020-08-07 15:33:56');
INSERT INTO `t_visit` VALUES (532, 8, 199, '2020-08-07 15:34:23');
INSERT INTO `t_visit` VALUES (533, 8, 199, '2020-08-07 15:34:23');
INSERT INTO `t_visit` VALUES (534, 8, 95, '2020-08-07 15:34:58');
INSERT INTO `t_visit` VALUES (535, 8, 95, '2020-08-07 15:35:22');
INSERT INTO `t_visit` VALUES (536, 8, 95, '2020-08-07 18:29:40');
INSERT INTO `t_visit` VALUES (537, 8, 95, '2020-08-07 18:37:07');
INSERT INTO `t_visit` VALUES (538, 8, 95, '2020-08-07 18:37:41');
INSERT INTO `t_visit` VALUES (539, 8, 200, '2020-08-07 22:58:31');
INSERT INTO `t_visit` VALUES (540, 8, 200, '2020-08-07 22:58:44');
INSERT INTO `t_visit` VALUES (541, 8, 201, '2020-08-07 23:31:42');
INSERT INTO `t_visit` VALUES (542, 8, 200, '2020-08-07 23:31:47');
INSERT INTO `t_visit` VALUES (543, 8, 200, '2020-08-07 23:31:53');
INSERT INTO `t_visit` VALUES (544, 8, 200, '2020-08-07 23:31:56');
INSERT INTO `t_visit` VALUES (545, 8, 200, '2020-08-07 23:32:01');
INSERT INTO `t_visit` VALUES (546, 8, 201, '2020-08-07 23:32:05');
INSERT INTO `t_visit` VALUES (547, 8, 201, '2020-08-07 23:32:07');
INSERT INTO `t_visit` VALUES (548, 8, 201, '2020-08-07 23:40:13');
INSERT INTO `t_visit` VALUES (549, 8, 201, '2020-08-07 23:40:39');
INSERT INTO `t_visit` VALUES (550, 8, 201, '2020-08-07 23:40:44');
INSERT INTO `t_visit` VALUES (551, 8, 202, '2020-08-08 00:04:55');
INSERT INTO `t_visit` VALUES (552, 8, 202, '2020-08-08 17:52:43');
INSERT INTO `t_visit` VALUES (553, 8, 201, '2020-08-08 17:52:49');
INSERT INTO `t_visit` VALUES (554, 8, 95, '2020-08-08 17:52:56');
INSERT INTO `t_visit` VALUES (555, 8, 199, '2020-08-08 17:55:34');
INSERT INTO `t_visit` VALUES (556, 8, 199, '2020-08-08 17:55:38');
INSERT INTO `t_visit` VALUES (557, 8, 199, '2020-08-08 17:55:41');
INSERT INTO `t_visit` VALUES (558, 8, 199, '2020-08-08 17:55:43');
INSERT INTO `t_visit` VALUES (559, 8, 199, '2020-08-08 19:59:13');
INSERT INTO `t_visit` VALUES (560, 8, 95, '2020-08-08 19:59:15');
INSERT INTO `t_visit` VALUES (561, 8, 95, '2020-08-08 19:59:17');
INSERT INTO `t_visit` VALUES (562, 8, 199, '2020-08-08 19:59:20');
INSERT INTO `t_visit` VALUES (563, 8, 199, '2020-08-08 19:59:24');
INSERT INTO `t_visit` VALUES (564, 8, 199, '2020-08-08 19:59:26');
INSERT INTO `t_visit` VALUES (565, 8, 199, '2020-08-08 20:41:45');
INSERT INTO `t_visit` VALUES (566, 8, 95, '2020-08-08 20:41:48');
INSERT INTO `t_visit` VALUES (567, 8, 201, '2020-08-08 20:41:51');
INSERT INTO `t_visit` VALUES (568, 8, 199, '2020-08-08 20:41:53');
INSERT INTO `t_visit` VALUES (569, 8, 203, '2020-08-08 23:52:49');
INSERT INTO `t_visit` VALUES (570, 8, 203, '2020-08-08 23:52:49');
INSERT INTO `t_visit` VALUES (571, 8, 203, '2020-08-08 23:53:02');
INSERT INTO `t_visit` VALUES (572, 8, 203, '2020-08-09 00:45:02');
INSERT INTO `t_visit` VALUES (573, 8, 203, '2020-08-09 00:45:04');
INSERT INTO `t_visit` VALUES (574, 8, 203, '2020-08-09 00:45:06');

SET FOREIGN_KEY_CHECKS = 1;
